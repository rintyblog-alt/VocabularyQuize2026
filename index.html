<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <meta name="color-scheme" content="light" />
  <!-- Public runtime config placeholders (replace on deploy; do not commit real keys). -->
  <meta name="firebase-api-key" content="AIzaSyB7DKVD4rQKekzfqzQiFzZBvonMXLOFWe0" />
  <meta name="firebase-auth-domain" content="vocabuquiz.firebaseapp.com" />
  <meta name="firebase-project-id" content="vocabuquiz" />
  <meta name="firebase-storage-bucket" content="vocabuquiz.firebasestorage.app" />
  <meta name="firebase-messaging-sender-id" content="290676646464" />
  <meta name="firebase-app-id" content="1:290676646464:web:cd3bba927ebbf71b4b35a5" />
  <meta name="emailjs-service-id" content="service_fyd3no8" />
  <meta name="emailjs-template-id" content="template_103i08s" />
  <meta name="emailjs-public-key" content="GQAs4-6iXdocFFrhE" />
  <title>VocabuQuiz</title>
  <link rel="icon" type="image/png" sizes="32x32" href="assets/favicon-32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="assets/favicon-16.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="assets/apple-touch-icon-180.png" />
  <link rel="manifest" href="manifest.webmanifest" />
  <meta name="theme-color" content="#18c77a" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,500,0,0" />
  <style>
    :root{
      --bg:#f5f5f7;
      --panel:#ffffff;
      --panel2:#f1f2f6;
      --text:#1d1d1f;
      --muted:rgba(29,29,31,.62);
      --border:rgba(17,18,20,.12);
      --shadow:0 14px 34px rgba(17,18,20,.12);
      --bar-bg:rgba(255,255,255,.82);
      --bar-text:#1d1d1f;
      --bar-border:rgba(17,18,20,.10);
      --chip-bg:rgba(17,18,20,.08);
      --chip-text:rgba(29,29,31,.92);
      --input-bg:rgba(17,18,20,.03);
      --input-text:#1d1d1f;
      --input-border:rgba(17,18,20,.14);
      --btn-bg:rgba(17,18,20,.05);
      --btn-text:#1d1d1f;
      --btn-border:rgba(17,18,20,.14);
      --inverse-text:#f5f5f7;
      --chart-grid:rgba(17,18,20,.08);
      --chart-axis:rgba(17,18,20,.10);
      --chart-label:rgba(17,18,20,.56);
      --chart-line:rgba(31,42,68,.92);
      --chart-bar:rgba(31,42,68,.88);
      --chart-bar-bg:rgba(17,18,20,.08);

      --accent:#1f2a44;
      --radius:14px;
      --radius-sm:10px;
      --fade:.26s;
      --ok:#0f5132;
      --ng:#842029;
      --okbg:rgba(15,81,50,.10);
      --ngbg:rgba(132,32,41,.10);
      --maru:#d11f2a; /* correct: red circle */
      --batsu:#1c4fd6; /* wrong: blue cross */
      --quiz-font-scale:1;
      --ui-font-scale:1;
      --base-font-size:16px;

      --hairline:var(--border);
      --glass:var(--panel);
      --glass-strong:var(--panel);
      --focus:rgba(0,113,227,.35);
    }
    :root[data-theme-mode="dark"]{
      --bg:#0b0b0f;
      --panel:#16161b;
      --panel2:#1c1c22;
      --text:#f5f5f7;
      --muted:rgba(245,245,247,.65);
      --border:rgba(255,255,255,.10);
      --shadow:0 14px 34px rgba(0,0,0,.55);
      --bar-bg:rgba(22,22,27,.82);
      --bar-text:#f5f5f7;
      --bar-border:rgba(255,255,255,.12);
      --chip-bg:rgba(255,255,255,.10);
      --chip-text:rgba(245,245,247,.92);
      --input-bg:rgba(255,255,255,.06);
      --input-text:#f5f5f7;
      --input-border:rgba(255,255,255,.14);
      --btn-bg:rgba(255,255,255,.10);
      --btn-text:#f5f5f7;
      --btn-border:rgba(255,255,255,.14);
      --inverse-text:#f5f5f7;
      --chart-grid:rgba(255,255,255,.12);
      --chart-axis:rgba(255,255,255,.18);
      --chart-label:rgba(245,245,247,.78);
      --chart-line:rgba(216,225,255,.96);
      --chart-bar:rgba(216,225,255,.88);
      --chart-bar-bg:rgba(255,255,255,.12);

      --accent:#d8e1ff;
      --ok:#4dd38f;
      --ng:#ff7d76;
      --okbg:rgba(15,81,50,.24);
      --ngbg:rgba(132,32,41,.28);
      --hairline:var(--border);
      --glass:var(--panel);
      --glass-strong:var(--panel2);
      --focus:rgba(144,202,249,.40);
    }
    :root[data-font-size="SMALL"]{
      --quiz-font-scale:.88;
      --ui-font-scale:.92;
      --base-font-size:15px;
    }
    :root[data-font-size="DEFAULT"]{
      --quiz-font-scale:1;
      --ui-font-scale:1;
      --base-font-size:16px;
    }
    :root[data-font-size="LARGE"]{
      --quiz-font-scale:1.2;
      --ui-font-scale:1.16;
      --base-font-size:18px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    html{
      font-size: var(--base-font-size);
    }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-size:1rem;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Sans", "Hiragino Kaku Gothic ProN", Meiryo, Arial, sans-serif;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    button,
    input,
    select,
    textarea{
      font-size: inherit;
    }

    :root[data-animations="off"]{
      scroll-behavior:auto !important;
    }
    :root[data-animations="off"] *,
    :root[data-animations="off"] *::before,
    :root[data-animations="off"] *::after{
      animation:none !important;
      transition:none !important;
      transition-duration:0s !important;
      animation-duration:0s !important;
      animation-delay:0s !important;
      scroll-behavior:auto !important;
    }

    .app{
      min-height:100%;
      display:flex;
      flex-direction:column;
      align-items:center;
    }

    .topbar{
      width:100%;
      max-width:980px;
      padding:14px 18px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }

    .brand{
      display:flex;
      align-items:baseline;
      gap:10px;
      min-width:0;
    }
    .brand-title{
      font-weight:650;
      letter-spacing:.02em;
      color:var(--accent);
      cursor:pointer;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .brand-sub{
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .icon-btn{
      appearance:none;
      border:1px solid var(--border);
      background:var(--panel);
      color:var(--accent);
      border-radius:999px;
      position:relative;
      width:40px;
      height:40px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      box-shadow: 0 2px 10px rgba(17,18,20,.04);
      transition: transform var(--fade) ease, opacity var(--fade) ease, background var(--fade) ease;
    }
    .icon-btn:active{ transform: translateY(1px); }
    .icon-btn[disabled]{ opacity:.45; cursor:not-allowed; }

    /* ===== Phase 1 Frame Refresh ===== */
    .topbar{
      position:sticky;
      top:0;
      display:block;
      z-index:50;
      width:100%;
      max-width:none;
      padding: 10px 14px;
      border-bottom: 1px solid var(--bar-border);
      background: var(--bar-bg);
    }
    @supports (backdrop-filter: blur(1px)){
      .topbar{ backdrop-filter: blur(10px); }
    }
    .topbar-inner{
      width:100%;
      max-width: 1040px;
      margin:0 auto;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .topbar-left{
      display:flex;
      align-items:center;
      gap:12px;
      min-width:0;
    }
    .topbar-actions{
      display:flex;
      align-items:center;
      gap:10px;
    }

    .ms{
      font-family: "Material Symbols Rounded";
      font-weight: 500;
      font-style: normal;
      font-size: 20px;
      line-height: 1;
      display:inline-block;
      letter-spacing: normal;
      text-transform: none;
      white-space: nowrap;
      word-wrap: normal;
      direction: ltr;
      -webkit-font-feature-settings: "liga";
      -webkit-font-smoothing: antialiased;
    }

    .notif-dot{
      position:absolute;
      right:10px;
      top:10px;
      width:8px;
      height:8px;
      border-radius:999px;
      background:#d11f2a;
      box-shadow: 0 0 0 2px var(--panel);
    }

    /* Start view */
    .start-wrap{
      min-height: min(72vh, 620px);
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 28px 0 6px;
    }
    .start-hero{
      width:100%;
      border:1px solid var(--border);
      background: var(--panel);
      border-radius: calc(var(--radius) + 4px);
      padding: 34px 26px 26px;
      box-shadow: var(--shadow);
      text-align:center;
    }
    .start-kicker{
      font-size:12px;
      letter-spacing:.18em;
      text-transform:uppercase;
      color:var(--muted);
      margin-bottom:10px;
    }
    .start-title{
      margin:0;
      font-size: clamp(40px, 6vw, 64px);
      font-weight: 760;
      letter-spacing: .02em;
      color: var(--accent);
      line-height:1.04;
    }
    .start-sub{
      margin: 14px auto 0;
      max-width: 52ch;
      color: var(--muted);
      font-size: 14px;
      line-height: 1.7;
    }
    .start-actions{
      margin-top: 22px;
      display:flex;
      justify-content:center;
    }
    .start-primary{
      appearance:none;
      border:1px solid rgba(31,42,68,.22);
      background: linear-gradient(180deg, rgba(31,42,68,.10), rgba(31,42,68,.06));
      color: var(--accent);
      border-radius: 999px;
      padding: 12px 18px;
      font-weight: 700;
      letter-spacing: .01em;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:10px;
      box-shadow: 0 10px 24px rgba(17,18,20,.08);
      transition: transform var(--fade) ease, box-shadow var(--fade) ease, background var(--fade) ease, border-color var(--fade) ease;
    }
    .start-primary:hover{
      border-color: rgba(31,42,68,.34);
      box-shadow: 0 12px 30px rgba(17,18,20,.10);
    }
    .start-primary:active{ transform: translateY(1px) scale(.99); }
    .start-note{
      margin-top: 18px;
      display:flex;
      gap:8px;
      justify-content:center;
      flex-wrap:wrap;
    }
    .start-chip{
      font-size:12px;
      color: var(--muted);
      border:1px solid var(--border);
      background: var(--chip-bg);
      border-radius:999px;
      padding: 6px 10px;
    }

    /* Notifications */
    .notify-sheet{ max-width: 720px; }
    .notify-body{ padding-top: 12px; }
    .notify-list{ display:flex; flex-direction:column; gap:10px; }
    .notify-pane.hidden{ display:none; }
    .notify-item{
      border:1px solid var(--border);
      border-radius: 14px;
      padding: 12px 12px;
      background: var(--panel);
      box-shadow: 0 2px 10px rgba(17,18,20,.04);
      display:grid;
      gap:8px;
    }
    .notify-item.unread{
      border-color: rgba(31,42,68,.26);
      background: rgba(31,42,68,.04);
    }
    .notify-title{
      font-weight: 720;
      letter-spacing:.01em;
      color: var(--accent);
      margin:0;
      font-size: 14px;
      line-height: 1.35;
    }
    .notify-bodytext{
      margin:6px 0 0;
      color: var(--text);
      font-size: 13px;
      line-height: 1.6;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
      word-break: break-word;
    }
    .notify-time{
      margin-top:8px;
      color: var(--muted);
      font-size: 12px;
      display:flex;
      align-items:center;
      gap:6px;
    }
    .notify-actions{
      margin-top: 4px;
      display:flex;
      justify-content:flex-end;
    }
    .notify-detail-wrap{
      display:grid;
      gap:10px;
      min-height: 160px;
    }
    .notify-detail-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap: wrap;
    }
    .notify-detail-title{
      margin:0;
      font-weight: 760;
      color: var(--accent);
      font-size: 16px;
      line-height: 1.4;
    }
    .notify-detail-meta{
      font-size: 12px;
      color: var(--muted);
      display:flex;
      flex-wrap: wrap;
      gap:8px;
    }
    .notify-detail-content{
      display:grid;
      gap:10px;
    }
    .notify-detail-content h3{
      margin: 6px 0 2px;
      font-size: 15px;
      color: var(--accent);
      letter-spacing: .01em;
    }
    .notify-detail-text{
      color: var(--text);
      font-size: 13px;
      line-height: 1.7;
      word-break: break-word;
    }
    .notify-detail-text a{
      color: var(--accent);
      text-decoration: underline;
      text-underline-offset: 2px;
    }
    .notify-invalid{
      font-size: 12px;
      color: #b42318;
      border: 1px solid rgba(180,35,24,.22);
      background: rgba(180,35,24,.06);
      border-radius: 10px;
      padding: 7px 10px;
    }
    .notify-media{
      display:grid;
      gap:6px;
    }
    .notify-media img{
      width:100%;
      max-width:100%;
      height:auto;
      border-radius: 12px;
      border:1px solid var(--border);
      display:block;
      background:var(--panel);
    }
    .notify-video{
      border:1px solid var(--border);
      border-radius: 12px;
      background: var(--panel);
      overflow: hidden;
    }
    .notify-video-screen{
      width:100%;
      display:block;
      background:var(--panel2);
    }
    .notify-video-controls{
      display:grid;
      gap:8px;
      padding:10px;
    }
    .notify-video-row{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap: wrap;
    }
    .notify-video-time{
      font-size:12px;
      color: var(--muted);
      min-width: 76px;
      text-align: right;
      font-variant-numeric: tabular-nums;
    }
    .notify-video-seek{
      width:100%;
    }
    .notify-empty{
      color: var(--muted);
      font-size: 13px;
      padding: 14px 6px;
    }

    main{
      width:100%;
      max-width:980px;
      padding: 0 18px 110px;
      display:flex;
      justify-content:center;
    }

    .stage{
      width:100%;
      max-width:720px;
    }

    .view{ display:none; }
    .view.active{ display:block; }

    /* Title view */
    .hero{
      background: linear-gradient(180deg, rgba(31,42,68,.06), rgba(31,42,68,0) 62%);
      border:1px solid var(--border);
      border-radius: var(--radius);
      padding: 22px 22px 20px;
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }
    .hero::after{
      content:"";
      position:absolute;
      inset:-40% -30%;
      background: radial-gradient(closest-side, rgba(31,42,68,.10), rgba(31,42,68,0));
      opacity:.45;
      pointer-events:none;
    }

    .h1{
      margin:0;
      font-size:26px;
      font-weight:720;
      letter-spacing:.02em;
      color:var(--accent);
    }
    .subtitle{
      margin:10px 0 0;
      color:var(--muted);
      font-size:14px;
      line-height:1.6;
    }

    .section{
      margin-top:14px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .section-title{
      font-size:12px;
      color:var(--muted);
      letter-spacing:.08em;
      text-transform:uppercase;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .section-title .right{
      font-size:12px;
      color:var(--muted);
      letter-spacing:normal;
      text-transform:none;
    }

    .actions{
      margin-top:8px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    @media (max-width:520px){
      .actions{ grid-template-columns:1fr; }
    }

    .btn{
      appearance:none;
      border:1px solid var(--border);
      background:var(--panel);
      color:var(--text);
      border-radius: var(--radius-sm);
      padding: 14px 14px;
      cursor:pointer;
      text-align:left;
      box-shadow: 0 2px 12px rgba(17,18,20,.04);
      transition: transform var(--fade) ease, border-color var(--fade) ease, opacity var(--fade) ease;
      display:flex;
      flex-direction:column;
      gap:4px;
      min-height:58px;
    }
    .btn:hover{ border-color: rgba(31,42,68,.32); }
    .btn:active{ transform: translateY(1px); }
    .btn[disabled]{ opacity:.45; cursor:not-allowed; }

    .btn .label{
      font-weight:650;
      letter-spacing:.01em;
      color:var(--accent);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .btn .desc{
      font-size:12px;
      color:var(--muted);
      line-height:1.5;
    }

    .fineprint{
      margin-top:14px;
      font-size:12px;
      color:var(--muted);
      line-height:1.6;
      display:flex;
      align-items:flex-start;
      gap:8px;
    }
    .badge{
      border:1px solid var(--border);
      background: var(--chip-bg);
      border-radius:999px;
      padding:2px 8px;
      font-size:11px;
      color:var(--muted);
      white-space:nowrap;
    }

    /* Seg (tabs) */
    .seg{
      display:inline-flex;
      border:1px solid var(--border);
      border-radius:999px;
      overflow:hidden;
      background:var(--panel);
      flex-shrink:0;
    }
    .seg button{
      appearance:none;
      border:0;
      background:transparent;
      padding:9px 12px;
      font-size:12px;
      cursor:pointer;
      color:var(--muted);
      transition: background var(--fade) ease, color var(--fade) ease;
      white-space:nowrap;
    }
    .seg button.active{
      background: rgba(31,42,68,.10);
      color: var(--accent);
      font-weight:650;
    }

    /* Quiz view */
    .quiz-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin: 4px 2px 10px;
    }
    .pill{
      border:1px solid var(--border);
      border-radius:999px;
      padding:6px 10px;
      font-size:12px;
      color:var(--muted);
      background: var(--chip-bg);
      white-space:nowrap;
    }
    .progress{
      font-size:12px;
      color:var(--muted);
      display:flex;
      align-items:center;
      gap:10px;
      min-width:0;
    }
    .progress strong{ color:var(--accent); }

    .card{
      position:relative;
      overflow:hidden;
      border:1px solid var(--border);
      border-radius: var(--radius);
      background:var(--panel);
      box-shadow: var(--shadow);
      padding: 18px 18px 16px;
      transition: opacity var(--fade) ease, transform var(--fade) ease;
    }
    .card.fade-out{
      opacity:0;
      transform: translateY(2px);
    }

    .mark-layer{
      position:absolute;
      top:10px;
      right:10px;
      width:74px;
      height:74px;
      pointer-events:none;
      opacity:0;
      transform: translateY(-2px) scale(.98);
      transition: opacity .18s ease, transform .18s ease;
      filter: drop-shadow(0 8px 18px rgba(17,18,20,.10));
    }
    .mark-layer.show{
      opacity:1;
      transform: translateY(0) scale(1);
    }
    .mark-layer svg{
      width:100%;
      height:100%;
      display:block;
    }
    .mark-layer .ring{
      fill:none;
      stroke: var(--maru);
      stroke-width:8.5;
      stroke-linecap:round;
      stroke-dasharray: 310;
      stroke-dashoffset: 310;
    }
    .mark-layer .xline{
      stroke: var(--batsu);
      stroke-width:9;
      stroke-linecap:round;
      stroke-dasharray: 120;
      stroke-dashoffset: 120;
    }
    .mark-layer.ok .ring{ animation: drawRing .55s ease forwards; }
    .mark-layer.ng .x1{ animation: drawLine .40s ease forwards; }
    .mark-layer.ng .x2{ animation: drawLine .40s .10s ease forwards; }

    @keyframes drawRing{ to{ stroke-dashoffset: 0; } }
    @keyframes drawLine{ to{ stroke-dashoffset: 0; } }

    .meta{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:10px;
      margin-bottom:10px;
    }
    .no{
      font-size:12px;
      color:var(--muted);
    }
    .dir{
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
      display:flex;
      align-items:center;
      gap:8px;
    }
    .judge{
      font-size:11px;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid rgba(31,42,68,.16);
      background: var(--chip-bg);
      color: var(--muted);
    }
    .judge.ok{
      border-color: rgba(15,81,50,.22);
      background: var(--okbg);
      color: var(--ok);
      font-weight:650;
    }
    .judge.ng{
      border-color: rgba(132,32,41,.22);
      background: var(--ngbg);
      color: var(--ng);
      font-weight:650;
    }

    .prompt{
      font-size:26px;
      font-weight:720;
      letter-spacing:.02em;
      line-height:1.2;
      color:var(--text);
      word-break:break-word;
    }

    .answer-wrap{
      margin-top:14px;
      padding-top:14px;
      border-top:1px dashed rgba(31,42,68,.18);
    }
    .answer-label{
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:.10em;
      color:var(--muted);
      margin-bottom:6px;
    }
    .answer{
      font-size:18px;
      line-height:1.55;
      color:var(--accent);
      word-break:break-word;
    }
    .prompt{
      font-size: calc(26px * var(--quiz-font-scale));
    }
    .answer{
      font-size: calc(18px * var(--quiz-font-scale));
    }
    #yourText{
      font-size: calc(13px * var(--quiz-font-scale)) !important;
    }
    #spellInput{
      font-size: calc(16px * var(--quiz-font-scale));
    }
    .hidden{ display:none !important; }

    .prompt-diagram-wrap{
      margin-bottom: 12px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--panel2);
      padding: 8px;
    }
    .prompt-diagram-wrap img{
      width: 100%;
      height: auto;
      max-height: 220px;
      object-fit: contain;
      display: block;
      border-radius: 10px;
      background: var(--panel);
      border: 1px solid var(--border);
    }

    .math-symbol-row{
      display: flex;
      gap: 8px;
      overflow-x: auto;
      padding-bottom: 2px;
      -webkit-overflow-scrolling: touch;
    }
    .math-symbol-row .textbtn{
      min-height: 34px;
      height: 34px;
      padding: 6px 10px;
      border-radius: 999px;
      white-space: nowrap;
      font-size: 12px;
      font-weight: 650;
    }
    .math-symbol-row .textbtn:focus-visible{
      outline: 2px solid color-mix(in srgb, var(--accent) 42%, transparent);
      outline-offset: 1px;
    }
    /* DRAW_EDITOR_V1 */
    .math-diagram-toolbar{
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    /* DRAW_EDITOR_V2V3 */
    .math-diagram-toolgroup{
      display: grid;
      gap: 6px;
    }
    .math-diagram-toolbar-wrap{
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      background: var(--panel);
      display: grid;
      gap: 10px;
    }
    .math-diagram-editops{
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
      padding: 8px 10px;
      border: 1px dashed var(--border);
      border-radius: 10px;
      background: var(--panel2);
    }
    .math-diagram-opts{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }
    .math-diagram-editops .textbtn{
      min-height: 34px;
      height: 34px;
      padding: 6px 10px;
      border-radius: 10px;
      font-size: 12px;
    }
    .math-diagram-toolbar .textbtn.is-active{
      border-color: color-mix(in srgb, var(--accent) 42%, var(--border));
      background: color-mix(in srgb, var(--accent) 10%, var(--panel2));
      color: var(--text);
    }
    .math-diagram-canvas-wrap{
      border: 1px solid var(--border);
      border-radius: 0;
      background: var(--panel2);
      padding: 10px;
      flex: 1 1 auto;
      min-height: 240px;
      overflow: hidden;
    }
    /* DRAW_EDITOR_V2V3 */
    .math-diagram-canvas-wrap.is-debug{
      box-shadow: inset 0 0 0 1px rgba(220,80,80,.35);
      outline: 1px dashed rgba(220,80,80,.5);
      outline-offset: -2px;
    }
    .math-diagram-backdrop{
      display: none !important;
    }
    #mathDiagramSection{
      position: fixed;
      z-index: 99995;
      inset: 0;
      transform: none;
      width: 100vw;
      height: 100dvh;
      max-height: none;
      overflow: hidden;
      box-shadow: none;
      background: var(--panel);
      border-radius: 0;
      padding: 0 !important;
      display: flex;
      flex-direction: column;
    }
    .math-diagram-header{
      position: sticky;
      top: 0;
      z-index: 2;
      display: grid;
      grid-template-columns: auto 1fr auto;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
    }
    .math-diagram-headmeta{
      min-width: 0;
      display: grid;
      gap: 2px;
    }
    .math-diagram-title{
      font-size: 16px;
      font-weight: 700;
      line-height: 1.2;
    }
    #mathDiagramStatus.ok{
      color: #198754;
    }
    #mathDiagramStatus.error{
      color: #b42318;
    }
    #mathDiagramCanvas{
      width: 100%;
      height: 100%;
      display: block;
      border-radius: 10px;
      background: #ffffff;
      border: 1px solid var(--border);
      touch-action: none;
      cursor: crosshair;
    }
    #mathDiagramCanvas.is-tool-select{ cursor: move; }
    #mathDiagramCanvas.is-tool-pan{ cursor: grab; }
    #mathDiagramCanvas.is-tool-eraser{ cursor: cell; }
    #mathDiagramCanvas.is-tool-point{ cursor: copy; }
    .math-diagram-footer{
      border-top: 1px solid var(--border);
      padding: 8px 12px calc(8px + env(safe-area-inset-bottom, 0px));
      background: var(--panel);
      min-height: 38px;
      display: flex;
      align-items: center;
    }
    body.math-diagram-open{
      overflow: hidden;
      touch-action: none;
    }
    @media (max-width: 640px){
      #mathDiagramSection{
        width: 100vw;
        height: 100dvh;
      }
      .math-diagram-toolbar-wrap{
        gap: 8px;
        padding: 8px;
      }
      .math-diagram-toolbar{
        flex-wrap: nowrap;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
      }
      .math-diagram-editops{
        padding: 8px;
      }
      .math-diagram-editops .textbtn{
        min-height: 32px;
        height: 32px;
        padding: 5px 8px;
      }
      .math-diagram-opts{
        gap: 8px;
      }
    }

    /* Preset/Auth forms: back to compact usable size */
    #presetOverlay .spell-input,
    #presetOverlay .select,
    #presetOverlay input[type="text"],
    #presetOverlay input[type="search"],
    #presetOverlay input[type="number"],
    #presetOverlay textarea,
    #presetOverlay select{
      min-height: 44px !important;
      font-size: 15px !important;
      padding: 10px 12px !important;
    }
    #presetOverlay textarea.spell-input{
      min-height: 112px !important;
    }
    #presetOverlay .navbtn,
    #presetOverlay .textbtn,
    #presetOverlay .btn{
      min-height: 44px !important;
      padding: 10px 14px !important;
      font-size: 15px;
    }
    #authGate .auth-gate-btn,
    #authGate .navbtn,
    #authGate .textbtn{
      min-height: 44px !important;
      padding-top: 10px !important;
      padding-bottom: 10px !important;
    }
    #authGate .spell-input,
    #authGate .select{
      min-height: 44px !important;
      font-size: 15px !important;
    }

    .hand-wrap{
      margin-top:12px;
      padding-top:12px;
      border-top:1px dashed rgba(31,42,68,.18);
    }
    .hand-title{
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:.10em;
      color:var(--muted);
      margin-bottom:8px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .hand-title .mini{
      font-size:11px;
      color:var(--muted);
      letter-spacing:normal;
      text-transform:none;
      white-space:nowrap;
    }
    .hand-canvas{
      width:100%;
      height:220px;
      border:1px solid var(--border);
      border-radius:12px;
      background:var(--input-bg);
      display:block;
      touch-action:none;
      box-shadow: 0 2px 10px rgba(17,18,20,.04) inset;
    }
    .hand-controls{
      margin-top:8px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
    }
    .hand-controls .left,
    .hand-controls .right{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .hand-note{
      font-size:12px;
      color:var(--muted);
      line-height:1.5;
    }

    
    .choice-wrap{
      margin-top:12px;
      padding-top:12px;
      border-top:1px dashed rgba(31,42,68,.18);
    }
    .choice-label{
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:.10em;
      color:var(--muted);
      margin-bottom:8px;
    }
    .choices{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
    }
    .choice-btn{
      appearance:none;
      border:1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      border-radius: 12px;
      padding: 12px 12px;
      cursor:pointer;
      text-align:left;
      line-height:1.45;
      transition: transform var(--fade) ease, border-color var(--fade) ease, background var(--fade) ease, opacity var(--fade) ease;
      box-shadow: 0 2px 10px rgba(17,18,20,.04);
    }
    .choice-btn:hover{ border-color: rgba(31,42,68,.32); }
    .choice-btn:active{ transform: translateY(1px); }
    .choice-btn[disabled]{ opacity:.70; cursor:not-allowed; }
    .choice-btn.correct{
      border-color: rgba(15,81,50,.24);
      background: var(--okbg);
    }
    .choice-btn.wrong{
      border-color: rgba(132,32,41,.24);
      background: var(--ngbg);
    }
    .choice-btn .k{
      font-size:12px;
      color: var(--muted);
      margin-bottom:4px;
      display:inline-block;
      min-width: 16px;
    }
.spell-wrap{
      margin-top:12px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .spell-row{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .spell-label{
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:.10em;
      color:var(--muted);
    }
    .spell-input{
      flex:1 1 240px;
      min-width:220px;
      border:1px solid var(--border);
      border-radius:12px;
      padding:12px 12px;
      font-size:16px;
      line-height:1.2;
      outline:none;
      background:var(--input-bg);
      color:var(--input-text);
      box-shadow: 0 2px 10px rgba(17,18,20,.04) inset;
    }
    .spell-input:disabled{ opacity:.65; }

    .controls{
      margin-top:12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .controls .left,
    .controls .right{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }

    .cta{
      appearance:none;
      border:1px solid rgba(31,42,68,.24);
      background: rgba(31,42,68,.06);
      color:var(--accent);
      border-radius: 999px;
      padding: 10px 14px;
      cursor:pointer;
      font-weight:650;
      letter-spacing:.01em;
      transition: transform var(--fade) ease, background var(--fade) ease, opacity var(--fade) ease;
    }
    .cta:hover{ background: rgba(31,42,68,.085); }
    .cta:active{ transform: translateY(1px); }
    .cta[disabled]{ opacity:.50; cursor:not-allowed; }

    .navbtn{
      appearance:none;
      border:1px solid var(--border);
      background:var(--panel);
      color:var(--text);
      border-radius: 999px;
      padding: 10px 14px;
      cursor:pointer;
      transition: transform var(--fade) ease, opacity var(--fade) ease, border-color var(--fade) ease;
    }
    .navbtn:hover{ border-color: rgba(31,42,68,.32); }
    .navbtn:active{ transform: translateY(1px); }
    .navbtn[disabled]{ opacity:.45; cursor:not-allowed; }

    .hint{
      margin-top:10px;
      font-size:12px;
      color:var(--muted);
      line-height:1.6;
      padding-left:2px;
    }

    .debug-bar{
      margin-top:10px;
      font-size:11px;
      color:var(--muted);
      line-height:1.5;
      padding: 10px 12px;
      border:1px dashed rgba(31,42,68,.18);
      border-radius: var(--radius-sm);
      background: var(--panel2);
    }
    .debug-bar strong{ color: var(--accent); }
    .debug-bar:empty{ display:none; }

    /* Result view */
    .result-box{
      margin-top:12px;
      border:1px solid var(--border);
      background: var(--panel);
      border-radius: var(--radius);
      padding: 14px 14px;
      box-shadow: 0 2px 10px rgba(17,18,20,.04);
    }
    .scoreline{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .scorebig{
      font-size:34px;
      font-weight:760;
      letter-spacing:.01em;
      color: var(--accent);
    }
    .scoresub{
      font-size:12px;
      color: var(--muted);
    }
    details{
      margin-top:12px;
      border:1px dashed rgba(31,42,68,.18);
      border-radius: var(--radius-sm);
      background: var(--panel2);
      padding: 10px 12px;
    }
    summary{
      cursor:pointer;
      color: var(--accent);
      font-weight:650;
      list-style:none;
    }
    summary::-webkit-details-marker{ display:none; }
    .wrong-list{
      margin:10px 0 0;
      padding:0;
      list-style:none;
      display:flex;
      flex-direction:column;
      gap:8px;
      color: var(--text);
    }
    .wrong-item{
      border:1px solid rgba(31,42,68,.10);
      border-radius: 12px;
      padding: 10px 10px;
      background: rgba(31,42,68,.03);
    }
    .wrong-item .top{
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:baseline;
      flex-wrap:wrap;
      margin-bottom:6px;
      color: var(--muted);
      font-size:12px;
    }
    .wrong-item .mid{
      font-size:14px;
      line-height:1.55;
    }
    .wrong-item code{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12.5px;
      background: var(--panel2);
      border:1px solid var(--border);
      border-radius: 8px;
      padding: 2px 6px;
    }

    /* Overlay settings */
    .overlay{
      position:fixed;
      inset:0;
      background: rgba(17,18,20,.32);
      display:flex;
      justify-content:center;
      align-items:flex-end;
      padding: 18px;
      z-index:50;
      transition: opacity var(--fade) ease;
    }
    .overlay.hidden{ display:none; }

    .sheet{
      width:100%;
      max-width:720px;
      border-radius: var(--radius);
      background: var(--panel);
      border:1px solid var(--border);
      box-shadow: 0 24px 80px rgba(17,18,20,.24);
      overflow:hidden;
      max-height: calc(100vh - 40px);
      display:flex;
      flex-direction:column;
    }
    .sheet-header{
      padding: 14px 16px;
      border-bottom:1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .sheet-title{
      font-weight:700;
      letter-spacing:.02em;
      color:var(--accent);
    }
    .sheet-body{
      padding: 14px 16px 16px;
      display:grid;
      gap:14px;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      flex:1;
      min-height:0;
    }

    .setting{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:14px;
      padding: 12px 12px;
      border:1px solid rgba(31,42,68,.12);
      border-radius: var(--radius-sm);
      background: rgba(31,42,68,.03);
    }
    .setting .text{
      min-width:0;
    }
    .setting .name{
      font-weight:650;
      color:var(--text);
      margin-bottom:3px;
    }
    .setting .note{
      font-size:12px;
      color:var(--muted);
      line-height:1.5;
    }

    .toggle{
      display:flex;
      align-items:center;
      gap:10px;
      flex-shrink:0;
      user-select:none;
    }
    .toggle input{
      width:44px;
      height:26px;
      appearance:none;
      background: var(--btn-bg);
      border:1px solid var(--btn-border);
      border-radius:999px;
      position:relative;
      outline:none;
      cursor:pointer;
      transition: background var(--fade) ease;
    }
    .toggle input::after{
      content:"";
      width:20px;
      height:20px;
      background:var(--panel);
      border:1px solid var(--btn-border);
      border-radius:999px;
      position:absolute;
      top:50%;
      left:3px;
      transform: translateY(-50%);
      box-shadow: 0 4px 14px rgba(17,18,20,.12);
      transition: left var(--fade) ease;
    }
    .toggle input:checked{
      background: var(--accent);
      border-color: var(--accent);
    }
    .toggle input:checked::after{
      left:21px;
    }

    .sheet-footer{
      padding: 12px 16px;
      border-top:1px solid var(--border);
      display:flex;
      justify-content:flex-end;
      gap:10px;
    }
    #settingsOverlay{
      padding: 0;
      align-items: stretch;
      justify-content: stretch;
      background: var(--bg);
      z-index: 110;
    }
    #settingsOverlay:not(.hidden){
      animation: none;
    }
    #settingsOverlay:not(.hidden) .settings-fullsheet{
      animation: none;
    }
    .settings-fullsheet{
      width: 100vw;
      max-width: 100vw;
      height: 100vh;
      max-height: 100vh;
      border-radius: 0;
      border: 0;
      box-shadow: none;
      background: var(--bg);
      display: flex;
      flex-direction: column;
    }
    :root[data-theme-mode="dark"] .settings-fullsheet{
      background: var(--bg);
    }
    .settings-nav{
      position: sticky;
      top: 0;
      z-index: 2;
      height: 56px;
      min-height: 56px;
      display: grid;
      grid-template-columns: 56px 1fr 56px;
      align-items: center;
      border-bottom: 1px solid var(--bar-border);
      background: var(--bar-bg);
      padding: 0 6px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    :root[data-theme-mode="dark"] .settings-nav{
      background: var(--bar-bg);
      border-bottom-color: var(--bar-border);
    }
    .settings-nav .settings-back-btn{
      width: 44px;
      height: 44px;
      border-radius: 999px;
      border: 0;
      box-shadow: none;
      background: transparent;
      color: var(--accent);
    }
    .settings-nav-title{
      text-align: center;
      font-size: 17px;
      font-weight: 700;
      letter-spacing: .01em;
      color: var(--text);
    }
    .settings-screen-wrap{
      flex: 1;
      min-height: 0;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    #settingsMainPane{
      flex: 1;
      min-height: 0;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      padding: 14px 12px 24px;
      display: grid;
      gap: 16px;
      align-content: start;
    }
    .settings-page{
      display: none;
      gap: 10px;
      align-content: start;
    }
    .settings-page.is-active{
      display: grid;
    }
    .settings-section-title{
      font-size: 12px;
      color: var(--muted);
      font-weight: 600;
      letter-spacing: .02em;
      padding: 0 6px;
    }
    .settings-group{
      border: 1px solid var(--border);
      border-radius: 14px;
      background: var(--panel);
      overflow: hidden;
      box-shadow: 0 1px 0 rgba(17,18,20,.04);
    }
    :root[data-theme-mode="dark"] .settings-group{
      background: var(--panel);
      border-color: var(--border);
    }
    .settings-group + .settings-group{
      margin-top: 8px;
    }
    .settings-row{
      width: 100%;
      min-height: 48px;
      border: 0;
      border-bottom: 1px solid var(--border);
      background: var(--panel);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 14px;
      text-align: left;
      color: var(--text);
      font-size: 15px;
    }
    :root[data-theme-mode="dark"] .settings-row{
      background: var(--panel);
      border-bottom-color: var(--border);
    }
    .settings-row:last-child{
      border-bottom: 0;
    }
    .settings-row .label{
      font-weight: 500;
      color: var(--text);
    }
    .settings-row .value{
      font-size: 13px;
      color: var(--muted);
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .settings-row:not(.is-static){
      cursor: pointer;
    }
    .settings-row:not(.is-static):active{
      background: var(--panel2);
    }
    .settings-row.danger-action .label,
    .settings-row.danger-action .value{
      color: #c1121f;
    }
    .settings-seg{
      display: inline-flex;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    .settings-seg button{
      min-height: 36px;
      border: 1px solid var(--btn-border);
      border-radius: 999px;
      background: var(--btn-bg);
      color: var(--btn-text);
      font-size: 13px;
      padding: 7px 10px;
      cursor: pointer;
    }
    .settings-seg button.active{
      background: rgba(31,42,68,.10);
      border-color: rgba(31,42,68,.25);
      color: var(--accent);
      font-weight: 700;
    }
    .settings-select{
      min-height: 36px;
      min-width: 108px;
      max-width: 55vw;
      margin-left: auto;
    }
    .settings-note{
      padding: 10px 14px 12px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.5;
      border-top: 1px solid var(--border);
      background: var(--panel2);
    }
    .settings-statusbar{
      border-top: 1px solid var(--bar-border);
      padding: 8px 12px calc(10px + env(safe-area-inset-bottom, 0px));
      background: var(--bar-bg);
      min-height: 44px;
    }
    :root[data-theme-mode="dark"] .settings-statusbar{
      background: var(--bar-bg);
      border-top-color: var(--bar-border);
    }
    @supports (padding:max(0px)){
      .settings-statusbar{
        padding-bottom: max(10px, env(safe-area-inset-bottom));
      }
    }
    .settings-statusbar .drawer-share-status{
      margin: 0;
    }
    #settingsOverlay .textbtn{
      min-height: 44px;
      padding: 10px 14px;
    }
    #settingsOverlay .admin-notif-editor{
      margin: 12px;
      border-radius: 14px;
      background: var(--panel);
      border: 1px solid var(--border);
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      flex: 1;
      min-height: 0;
      align-content: start;
    }
    :root[data-theme-mode="dark"] #settingsOverlay .admin-notif-editor{
      background: var(--panel);
      border-color: var(--border);
    }

    .textbtn{
      appearance:none;
      border:1px solid var(--border);
      background:var(--panel);
      color:var(--text);
      border-radius:999px;
      padding:10px 14px;
      cursor:pointer;
      transition: transform var(--fade) ease, border-color var(--fade) ease;
    }
    .textbtn:hover{ border-color: rgba(31,42,68,.32); }
    .textbtn:active{ transform: translateY(1px); }

    /* corner footer */
    .corner{
      position:fixed;
      right:10px;
      bottom:10px;
      z-index:10;
      pointer-events:none;
      opacity:.70;
    }
    .version{
      font-size:11px;
      color:var(--muted);
      text-align:right;
      line-height:1.35;
      background: var(--panel2);
      border:1px solid var(--border);
      border-radius:10px;
      padding:7px 9px;
      box-shadow: 0 6px 24px rgba(17,18,20,.06);
      backdrop-filter: blur(6px);
    }

    @media (prefers-reduced-motion: reduce){
      *{ transition:none !important; }
      .mark-layer.ok .ring,
      .mark-layer.ng .x1,
      .mark-layer.ng .x2{ animation:none !important; stroke-dashoffset:0 !important; }
    }
  

/* =========================================================
   Apple Website UI Refresh (UI-only) v13
   - No logic changes
   - Pure CSS overrides + animations
   ========================================================= */

:root{
  --radius:18px;
  --radius-sm:14px;
  --fade:.32s;
  --ease: cubic-bezier(0.22, 1, 0.36, 1);
}

/* Global typography */
body{
  background: var(--bg);
  color: var(--text);
  font-family:
    -apple-system,
    BlinkMacSystemFont,
    "SF Pro Text",
    "SF Pro Display",
    system-ui,
    "Hiragino Sans",
    "Hiragino Kaku Gothic ProN",
    Meiryo,
    sans-serif;
  letter-spacing: -0.01em;
}

a{ color: inherit; }
::selection{ background: rgba(0,0,0,.10); }

/* Layout breathing room */
.topbar{
  padding:18px 18px;
}
.brand-title{
  font-weight: 650;
  letter-spacing: -0.02em;
  color: var(--text);
}
.brand-sub{
  color: var(--muted);
}

/* Apple-like icon button (glass) */
.icon-btn{
  border:1px solid var(--hairline);
  background: var(--glass-strong);
  color: var(--text);
  box-shadow: 0 10px 30px rgba(0,0,0,.10);
  transition:
    transform .25s var(--ease),
    box-shadow .35s var(--ease),
    background .35s var(--ease),
    border-color .35s var(--ease);
}
@supports ((-webkit-backdrop-filter: blur(1px)) or (backdrop-filter: blur(1px))){
  .icon-btn{
    background: var(--glass);
    -webkit-backdrop-filter: blur(14px) saturate(180%);
    backdrop-filter: blur(14px) saturate(180%);
  }
}
.icon-btn:hover{
  transform: translateY(-1px);
  box-shadow: 0 16px 46px rgba(0,0,0,.14);
  border-color: var(--border);
}
.icon-btn:active{
  transform: translateY(1px) scale(.98);
}

/* Hero (title/result) */
.hero{
  border:1px solid var(--hairline);
  background:
    radial-gradient(1200px 700px at 20% -18%, rgba(0,0,0,.06), rgba(245,245,247,0) 62%),
    radial-gradient(900px 520px at 85% -12%, rgba(0,0,0,.04), rgba(245,245,247,0) 60%),
    var(--panel);
  box-shadow: var(--shadow);
  padding: 34px 32px 28px;
}
.hero::after{ display:none !important; }

.h1{
  font-size: clamp(32px, 4.6vw, 48px);
  line-height: 1.06;
  font-weight: 780;
  letter-spacing: -0.03em;
  color: var(--text);
}
.subtitle{
  font-size: 15px;
  color: var(--muted);
  margin-top: 14px;
}
.section{ margin-top: 18px; gap:12px; }
.section-title{
  color: var(--muted);
  letter-spacing: .14em;
}

/* Mode cards */
.btn{
  border:1px solid var(--hairline);
  border-radius: 18px;
  background: var(--panel);
  box-shadow: 0 22px 60px rgba(0,0,0,.10);
  padding: 18px 18px;
  min-height: 76px;
  transition:
    transform .25s var(--ease),
    box-shadow .40s var(--ease),
    border-color .40s var(--ease),
    background .40s var(--ease);
  will-change: transform;
}
@media (hover:hover){
  .btn:hover{
    transform: translateY(-2px);
    box-shadow: 0 30px 90px rgba(0,0,0,.14);
    border-color: var(--border);
  }
}
.btn:active{
  transform: translateY(0) scale(.99);
}
.btn .label{
  font-size: 15px;
  font-weight: 760;
  letter-spacing: -0.02em;
  color: var(--text);
}
.btn .desc{
  font-size: 13px;
  color: var(--muted);
}

/* Quiz header pills */
.quiz-header{
  display:grid;
  grid-template-columns: 1fr auto 1fr;
  align-items:center;
  gap:12px;
  margin: 10px 0 18px;
}
@media (max-width:520px){
  .quiz-header{
    grid-template-columns: 1fr;
    justify-items: stretch;
    gap:10px;
    margin: 10px 0 14px;
  }
}

.progress, .pill{
  border:1px solid var(--hairline);
  background: var(--glass-strong);
  box-shadow: 0 10px 30px rgba(0,0,0,.10);
}
@supports ((-webkit-backdrop-filter: blur(1px)) or (backdrop-filter: blur(1px))){
  .progress, .pill{
    background: var(--glass);
    -webkit-backdrop-filter: blur(14px) saturate(180%);
    backdrop-filter: blur(14px) saturate(180%);
  }
}
.progress{
  justify-self:start;
  padding: 10px 12px;
  border-radius: 999px;
}
#modePill{
  justify-self:end;
}
#timerPill{
  justify-self:center;
  padding: 12px 18px;
  font-size: clamp(26px, 4.8vw, 46px);
  font-weight: 800;
  letter-spacing: -0.03em;
  border-radius: 999px;
  box-shadow: 0 22px 70px rgba(0,0,0,.16);
}

/* Card */
.card{
  border:1px solid var(--hairline);
  border-radius: var(--radius);
  background: var(--panel);
  box-shadow: 0 30px 90px rgba(0,0,0,.12);
  padding: 26px 24px 22px;
  transition:
    opacity .55s var(--ease),
    transform .55s var(--ease),
    filter .55s var(--ease),
    box-shadow .55s var(--ease);
}
.card.fade-out{
  opacity:0;
  transform: translateY(14px) scale(.985);
  filter: blur(2px);
}
@media (max-width:520px){
  .card{ padding: 22px 18px 18px; }
}

.meta .no{
  font-weight: 650;
  letter-spacing: -0.01em;
}
.prompt{
  font-size: calc(clamp(22px, 4.4vw, 34px) * var(--quiz-font-scale));
  font-weight: 760;
  letter-spacing: -0.03em;
  line-height: 1.18;
}

/* Controls */
.controls{ margin-top: 16px; }
.cta{
  border:1px solid var(--btn-border);
  background: var(--btn-bg);
  color: var(--text);
  box-shadow: 0 16px 46px rgba(0,0,0,.10);
  transition:
    transform .22s var(--ease),
    box-shadow .35s var(--ease),
    background .35s var(--ease),
    border-color .35s var(--ease);
}
@supports ((-webkit-backdrop-filter: blur(1px)) or (backdrop-filter: blur(1px))){
  .cta{
    background: var(--glass);
    -webkit-backdrop-filter: blur(14px) saturate(180%);
    backdrop-filter: blur(14px) saturate(180%);
  }
}
@media (hover:hover){
  .cta:hover{
    transform: translateY(-1px);
    box-shadow: 0 22px 64px rgba(0,0,0,.14);
    border-color: var(--border);
  }
}
.cta:active{ transform: translateY(1px) scale(.99); }

.navbtn{
  border:1px solid var(--hairline);
  background: var(--glass-strong);
  box-shadow: 0 12px 34px rgba(0,0,0,.10);
  transition:
    transform .22s var(--ease),
    box-shadow .35s var(--ease),
    background .35s var(--ease),
    border-color .35s var(--ease);
}
@supports ((-webkit-backdrop-filter: blur(1px)) or (backdrop-filter: blur(1px))){
  .navbtn{
    background: var(--glass);
    -webkit-backdrop-filter: blur(14px) saturate(180%);
    backdrop-filter: blur(14px) saturate(180%);
  }
}
@media (hover:hover){
  .navbtn:hover{
    transform: translateY(-1px);
    box-shadow: 0 18px 56px rgba(0,0,0,.14);
    border-color: var(--border);
  }
}
.navbtn:active{ transform: translateY(1px) scale(.99); }

/* Choices */
.choice-wrap{
  border-top:1px solid var(--border);
}
.choice-label{
  letter-spacing: .14em;
}
.choice-btn{
  border:1px solid var(--hairline);
  border-radius: 16px;
  background: var(--panel);
  box-shadow: 0 18px 50px rgba(0,0,0,.10);
  padding: 14px 14px;
  transition:
    transform .22s var(--ease),
    box-shadow .35s var(--ease),
    border-color .35s var(--ease),
    background .35s var(--ease),
    opacity .35s var(--ease);
}
@media (hover:hover){
  .choice-btn:hover{
    transform: translateY(-1px);
    box-shadow: 0 24px 76px rgba(0,0,0,.14);
    border-color: var(--border);
  }
}
.choice-btn:active{ transform: translateY(1px) scale(.99); }
.choice-btn.correct{
  background: rgba(209,31,42,.06);
  border-color: rgba(209,31,42,.20);
  animation: choicePop .42s var(--ease) both;
}
.choice-btn.wrong{
  background: rgba(28,79,214,.06);
  border-color: rgba(28,79,214,.20);
  animation: choicePop .42s var(--ease) both;
}

@keyframes choicePop{
  0%{ transform: translateY(0) scale(1); }
  45%{ transform: translateY(-2px) scale(1.015); }
  100%{ transform: translateY(0) scale(1); }
}

/* Mark layer (maru/batsu) */
.mark-layer{
  width:84px;
  height:84px;
  top:12px;
  right:12px;
  filter: drop-shadow(0 18px 46px rgba(0,0,0,.16));
  transition: opacity .35s var(--ease), transform .35s var(--ease);
}
.mark-layer.show{
  transform: translateY(0) scale(1);
  animation: markPop .55s var(--ease) both;
}
@keyframes markPop{
  0%{ opacity:0; transform: translateY(-6px) scale(.92); }
  55%{ opacity:1; transform: translateY(0) scale(1.06); }
  100%{ opacity:1; transform: translateY(0) scale(1); }
}

/* Overlays (settings / time select) */
.overlay{
  background: rgba(0,0,0,.40);
}
@supports ((-webkit-backdrop-filter: blur(1px)) or (backdrop-filter: blur(1px))){
  .overlay{
    -webkit-backdrop-filter: blur(10px) saturate(160%);
    backdrop-filter: blur(10px) saturate(160%);
  }
}
.overlay:not(.hidden){
  animation: overlayIn .45s var(--ease) both;
}
@keyframes overlayIn{
  from{ opacity:0; }
  to{ opacity:1; }
}
.overlay:not(.hidden) .sheet{
  animation: sheetIn .55s var(--ease) both;
}
@keyframes sheetIn{
  from{ transform: translateY(24px) scale(.985); opacity:0; }
  to{ transform: translateY(0) scale(1); opacity:1; }
}
.sheet{
  border:1px solid var(--border);
  box-shadow: 0 40px 120px rgba(0,0,0,.35);
}

/* Result view */
.result-box{
  border:1px solid var(--hairline);
  background: var(--glass-strong);
  box-shadow: 0 20px 70px rgba(0,0,0,.12);
}
@supports ((-webkit-backdrop-filter: blur(1px)) or (backdrop-filter: blur(1px))){
  .result-box{
    background: var(--glass);
    -webkit-backdrop-filter: blur(14px) saturate(180%);
    backdrop-filter: blur(14px) saturate(180%);
  }
}
.wrong-item{
  border:1px solid var(--border);
  background: var(--panel);
  box-shadow: 0 14px 40px rgba(0,0,0,.08);
}

/* Focus rings (Apple-like) */
:focus-visible{
  outline: 3px solid var(--focus);
  outline-offset: 3px;
}

/* View entrance animation */
.view.active{
  animation: viewIn .70s var(--ease) both;
}
@keyframes viewIn{
  from{ opacity:0; transform: translateY(14px) scale(.985); }
  to{ opacity:1; transform: translateY(0) scale(1); }
}

/* Stagger inside title view */
#viewTitle.active .hero{ animation: riseIn .85s var(--ease) both; }
#viewTitle.active .actions .btn{
  animation: riseIn .75s var(--ease) both;
}
#viewTitle.active .actions .btn:nth-child(1){ animation-delay: .06s; }
#viewTitle.active .actions .btn:nth-child(2){ animation-delay: .12s; }
#viewTitle.active .actions .btn:nth-child(3){ animation-delay: .18s; }
#viewTitle.active .actions .btn:nth-child(4){ animation-delay: .24s; }

@keyframes riseIn{
  from{ opacity:0; transform: translateY(16px); }
  to{ opacity:1; transform: translateY(0); }
}

/* Stagger inside result view */
#viewResult.active .hero{ animation: riseIn .85s var(--ease) both; }
#viewResult.active .wrong-item{ animation: riseIn .65s var(--ease) both; }
#viewResult.active .wrong-item:nth-child(1){ animation-delay:.06s; }
#viewResult.active .wrong-item:nth-child(2){ animation-delay:.12s; }
#viewResult.active .wrong-item:nth-child(3){ animation-delay:.18s; }
#viewResult.active .wrong-item:nth-child(4){ animation-delay:.24s; }
#viewResult.active .wrong-item:nth-child(5){ animation-delay:.30s; }
#viewResult.active .wrong-item:nth-child(6){ animation-delay:.36s; }
#viewResult.active .wrong-item:nth-child(7){ animation-delay:.42s; }
#viewResult.active .wrong-item:nth-child(8){ animation-delay:.48s; }
#viewResult.active .wrong-item:nth-child(9){ animation-delay:.54s; }
#viewResult.active .wrong-item:nth-child(10){ animation-delay:.60s; }

/* Reduced motion */
@media (prefers-reduced-motion: reduce){
  *{
    animation-duration: 0.001ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.001ms !important;
    scroll-behavior: auto !important;
  }
  .card.fade-out{ filter:none !important; }
}


    /* Preset UI */
    .select{
      appearance:none;
      background: var(--panel);
      border:1px solid var(--border);
      border-radius: 12px;
      padding: 10px 36px 10px 12px;
      font-size: 14px;
      line-height: 1;
      color: var(--text);
      box-shadow: 0 8px 18px rgba(17,18,20,.05);
      background-image: linear-gradient(45deg, transparent 50%, var(--muted) 50%),
                        linear-gradient(135deg, var(--muted) 50%, transparent 50%);
      background-position: calc(100% - 18px) calc(50% - 3px), calc(100% - 12px) calc(50% - 3px);
      background-size: 6px 6px, 6px 6px;
      background-repeat: no-repeat;
      min-width: 220px;
    }
    .select:focus{ outline:none; border-color: rgba(31,42,68,.55); }

    /* Custom Select (non-native UI) */
    .xselect{
      position: relative;
      display: inline-block;
      vertical-align: middle;
      min-width: 220px;
      max-width: min(100%, 460px);
    }
    .xselect.settings-select{
      min-width: 108px;
      max-width: min(55vw, 260px);
    }
    .settings-row .xselect{
      margin-left: auto;
    }
    .xselect-native{
      position: absolute !important;
      width: 1px !important;
      height: 1px !important;
      padding: 0 !important;
      margin: 0 !important;
      border: 0 !important;
      opacity: 0 !important;
      pointer-events: none !important;
      clip: rect(0 0 0 0) !important;
      clip-path: inset(50%) !important;
      overflow: hidden !important;
      white-space: nowrap !important;
    }
    .xselect-trigger{
      appearance: none;
      width: 100%;
      min-height: 42px;
      border: 0;
      border-radius: 14px;
      background: var(--input-bg);
      color: var(--input-text);
      padding: 10px 38px 10px 12px;
      text-align: left;
      font-size: 14px;
      line-height: 1.25;
      cursor: pointer;
      transition: border-color var(--fade) ease, filter var(--fade) ease;
      box-sizing: border-box;
      position: relative;
    }
    .xselect-trigger::after{
      content: "";
      position: absolute;
      right: 13px;
      top: 50%;
      width: 8px;
      height: 8px;
      border-right: 2px solid currentColor;
      border-bottom: 2px solid currentColor;
      transform: translateY(-62%) rotate(45deg);
      opacity: .68;
      pointer-events: none;
      transition: transform var(--fade) ease;
    }
    .xselect.is-open .xselect-trigger::after{
      transform: translateY(-40%) rotate(-135deg);
    }
    .xselect-trigger:hover{
      filter: brightness(1.03);
    }
    .xselect-trigger:focus-visible{
      outline: none;
      border-color: transparent;
      box-shadow: 0 0 0 3px rgba(31,42,68,.14);
    }
    .xselect-label{
      display: block;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      color: var(--input-text);
    }
    .xselect.is-disabled .xselect-trigger{
      opacity: .62;
      cursor: not-allowed;
      filter: none;
    }
    .xselect-portal{
      position: fixed;
      inset: 0;
      z-index: 1900;
      background: transparent;
    }
    .xselect-portal[hidden]{
      display: none !important;
    }
    .xselect-menu{
      position: absolute;
      border: 0;
      border-radius: 14px;
      background: var(--panel);
      box-shadow: 0 10px 22px rgba(17,18,20,.08);
      padding: 0;
      max-height: 280px;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
    }
    .xselect-group{
      font-size: 11px;
      color: var(--muted);
      padding: 8px 8px 4px;
      font-weight: 600;
      letter-spacing: .02em;
    }
    .xselect-option{
      appearance: none;
      width: 100%;
      min-height: 40px;
      border: 0;
      border-radius: 0;
      background: transparent;
      color: var(--text);
      text-align: left;
      padding: 8px 10px;
      font-size: 13px;
      line-height: 1.35;
      cursor: pointer;
    }
    .xselect-option:hover{
      background: var(--panel2);
    }
    .xselect-option.is-selected{
      background: rgba(31,42,68,.12);
      border-color: transparent;
      color: var(--accent);
      font-weight: 600;
    }
    .xselect-option[disabled]{
      opacity: .45;
      cursor: not-allowed;
    }

    .preset-item{
      border:1px solid rgba(31,42,68,.10);
      border-radius: 12px;
      background: rgba(31,42,68,.03);
      padding: 10px 10px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
    }
    .preset-item .left{ min-width:0; }
    .preset-item .title{
      font-weight:650;
      color: var(--accent);
      margin-bottom:4px;
      word-break: break-word;
    }
    .preset-item .meta{
      font-size:12px;
      color: var(--muted);
      margin:0;
      word-break: break-word;
    }
    .preset-meta-row{
      margin-top: 6px;
      display:flex;
      gap:6px;
      flex-wrap:wrap;
      align-items:center;
    }
    .subject-badge{
      display:inline-flex;
      align-items:center;
      gap:6px;
      border:1px solid var(--border);
      background: var(--panel2);
      color: var(--text);
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 11px;
      line-height: 1;
      white-space: nowrap;
    }
    .tag-chip-row{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .tag-chip{
      border:1px solid var(--border);
      background: var(--panel2);
      color: var(--text);
      border-radius: 999px;
      padding: 5px 10px;
      font-size: 12px;
      line-height: 1;
      cursor: pointer;
      min-height: 28px;
      display:inline-flex;
      align-items:center;
      user-select: none;
    }
    .tag-chip.is-selected{
      border-color: var(--btn-border);
      background: var(--btn-bg);
      color: var(--btn-text);
    }
    .tag-chip.is-muted{
      opacity: .7;
    }
    .app-library-filters{
      display:grid;
      gap:10px;
    }
    .app-library-tags-wrap{
      border:1px solid var(--border);
      background: var(--panel2);
      border-radius: 12px;
      padding: 10px;
      display:grid;
      gap:8px;
    }


    /* ===== Preset empty state ===== */
    .empty-state{
      margin-top:18px;
      padding: 28px 18px;
      text-align:center;
      border-radius: var(--radius);
      background: var(--panel);
      box-shadow: inset 0 0 0 1px rgba(17,18,20,.06);
      min-height: 180px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
    }
    .empty-state.hidden{ display:none; }
    .empty-title{
      font-size:18px;
      font-weight:700;
      letter-spacing:.02em;
      color:var(--text);
    }
    .empty-desc{
      margin-top:8px;
      font-size:13px;
      color:var(--muted);
      line-height:1.55;
    }

    /* Keep preset editor actions reachable even with many words */
    .preset-edit-toolbar{
      position: sticky;
      top: 0;
      z-index: 6;
      background: var(--panel);
      padding: 10px 0 12px;
      margin: -6px 0 10px;
      border-bottom: 1px solid rgba(17,18,20,.06);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    /* ===== Scan Generator ===== */
    .scan-gen-overlay{
      position: fixed;
      inset: 0;
      z-index: 2300;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity .26s ease;
    }
    .scan-gen-overlay.hidden{
      display: none !important;
    }
    .scan-gen-overlay.is-open{
      opacity: 1;
      pointer-events: auto;
    }
    .scan-gen-backdrop{
      position: absolute;
      inset: 0;
      border: 0;
      background: rgba(12,14,18,.34);
      cursor: pointer;
      padding: 0;
    }
    @supports ((-webkit-backdrop-filter: blur(1px)) or (backdrop-filter: blur(1px))){
      .scan-gen-backdrop{
        -webkit-backdrop-filter: blur(6px);
        backdrop-filter: blur(6px);
      }
    }
    .scan-gen-sheet{
      position: relative;
      width: min(960px, 100vw);
      height: 92vh;
      max-height: 92vh;
      border: 1px solid var(--border);
      border-bottom: 0;
      border-radius: 18px 18px 0 0;
      background: var(--panel);
      box-shadow: 0 -18px 54px rgba(0,0,0,.16);
      transform: translateY(28px);
      transition: transform .26s ease;
      overflow: hidden;
      display: grid;
      grid-template-rows: auto 1fr auto;
    }
    .scan-gen-overlay.is-open .scan-gen-sheet{
      transform: translateY(0);
    }
    .scan-gen-head{
      position: sticky;
      top: 0;
      z-index: 2;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 14px 16px;
      border-bottom: 1px solid var(--border);
      background: color-mix(in srgb, var(--panel) 94%, #fff 6%);
    }
    .scan-gen-title{
      font-weight: 700;
      color: var(--text);
      font-size: 15px;
      letter-spacing: .01em;
    }
    .scan-gen-body{
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      padding: 14px 16px 16px;
      display: grid;
      gap: 12px;
      align-content: start;
    }
    .scan-gen-foot{
      border-top: 1px solid var(--border);
      background: color-mix(in srgb, var(--panel) 96%, #fff 4%);
      padding: 10px 16px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: flex-end;
    }
    .scan-card{
      border: 1px solid var(--border);
      border-radius: 14px;
      background: var(--panel2);
      padding: 12px;
      display: grid;
      gap: 10px;
    }
    .scan-card h4{
      margin: 0;
      font-size: 13px;
      color: var(--text);
      letter-spacing: .01em;
    }
    .scan-sub{
      margin: 0;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.5;
    }
    .scan-row{
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    .scan-type-chip{
      border: 1px solid var(--border);
      background: var(--panel);
      border-radius: 999px;
      min-height: 34px;
      padding: 6px 12px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--text);
    }
    .scan-file-btn{
      position: relative;
      overflow: hidden;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .scan-file-btn input[type="file"]{
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
    }
    .scan-thumb-list{
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .scan-thumb{
      position: relative;
      width: 112px;
      height: 112px;
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid var(--border);
      background: var(--panel);
      box-shadow: inset 0 0 0 1px rgba(17,18,20,.03);
    }
    .scan-thumb img{
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }
    .scan-thumb button{
      position: absolute;
      top: 6px;
      right: 6px;
      width: 26px;
      height: 26px;
      border: 1px solid rgba(255,255,255,.8);
      border-radius: 999px;
      background: rgba(0,0,0,.55);
      color: #fff;
      cursor: pointer;
      line-height: 1;
      font-size: 13px;
    }
    .scan-grid{
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }
    .scan-grid .scan-field{
      display: grid;
      gap: 6px;
    }
    .scan-grid label{
      font-size: 12px;
      color: var(--muted);
    }
    .scan-grid .spell-input,
    .scan-grid .select{
      min-width: 0;
      width: 100%;
    }
    .scan-formats{
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .scan-format-chip{
      border: 1px solid var(--border);
      background: var(--panel);
      border-radius: 999px;
      min-height: 34px;
      padding: 6px 12px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--text);
    }
    .scan-status{
      min-height: 18px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.5;
    }
    .scan-status.error{
      color: #b42318;
    }
    .scan-status.ok{
      color: #198754;
    }
    .scan-steps{
      margin: 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 6px;
    }
    .scan-step{
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--muted);
    }
    .scan-step .dot{
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: rgba(31,42,68,.2);
      flex-shrink: 0;
    }
    .scan-step.is-active{
      color: var(--text);
    }
    .scan-step.is-active .dot{
      background: rgba(31,42,68,.55);
      animation: scanPulse 1s ease infinite;
    }
    .scan-step.is-done{
      color: var(--text);
    }
    .scan-step.is-done .dot{
      background: rgba(25,135,84,.56);
      animation: none;
    }
    @keyframes scanPulse{
      0%{ transform: scale(1); opacity: .95; }
      50%{ transform: scale(1.22); opacity: .55; }
      100%{ transform: scale(1); opacity: .95; }
    }
    .scan-result{
      display: grid;
      gap: 10px;
    }
    .scan-result-meta{
      font-size: 12px;
      color: var(--muted);
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .scan-reconstructed{
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--panel);
      padding: 12px;
      max-height: 260px;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      line-height: 1.65;
      font-size: 14px;
    }
    .scan-reconstructed h1,
    .scan-reconstructed h3{
      margin: 0 0 8px;
      line-height: 1.4;
    }
    .scan-reconstructed p{
      margin: 0 0 9px;
    }
    .scan-reconstructed .author{
      margin: 0 0 10px;
      color: var(--muted);
      font-size: 13px;
    }
    .scan-reconstructed .m{
      border-radius: 4px;
      padding: 0 1px;
    }
    .scan-reconstructed .m.u{
      text-decoration: underline 2px;
      text-underline-offset: 2px;
      text-decoration-color: rgba(31,42,68,.45);
      background: rgba(31,42,68,.06);
    }
    .scan-reconstructed .m.box{
      border: 1px solid rgba(31,42,68,.32);
      background: rgba(31,42,68,.05);
      padding: 0 3px;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    .scan-reconstructed .m.box .badge{
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 16px;
      height: 16px;
      border-radius: 999px;
      font-size: 10px;
      line-height: 1;
      background: rgba(31,42,68,.75);
      color: #fff;
    }
    .scan-reconstructed .m.blank{
      border-bottom: 2px solid rgba(31,42,68,.45);
      min-width: 32px;
      display: inline-flex;
      justify-content: center;
      color: var(--muted);
    }
    .scan-question-list{
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--panel);
      overflow: hidden;
    }
    .scan-question-item{
      padding: 10px 12px;
      border-top: 1px solid var(--border);
      display: grid;
      gap: 6px;
    }
    .scan-question-item:first-child{
      border-top: 0;
    }
    .scan-question-q{
      font-size: 13px;
      color: var(--text);
      line-height: 1.55;
    }
    .scan-question-a{
      font-size: 12px;
      color: var(--muted);
      line-height: 1.5;
    }
    .scan-question-type{
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: var(--muted);
    }
    .scan-question-rest{
      margin: 8px 0 0;
      border-top: 1px solid var(--border);
      padding: 10px 12px;
      font-size: 12px;
      color: var(--muted);
    }
    .scan-result-actions{
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .scan-debug{
      border: 1px solid var(--border);
      border-radius: 10px;
      background: var(--panel);
      padding: 8px 10px;
      font-size: 11px;
      color: var(--muted);
    }
    .scan-debug > summary{
      cursor: pointer;
      user-select: none;
      color: var(--text);
      font-size: 12px;
      font-weight: 600;
      list-style: none;
    }
    .scan-debug > summary::-webkit-details-marker{ display: none; }
    .scan-debug pre{
      margin: 8px 0 0;
      white-space: pre-wrap;
      word-break: break-word;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      line-height: 1.5;
    }
    @media (max-width: 760px){
      .scan-grid{
        grid-template-columns: 1fr;
      }
      .scan-gen-body{
        padding: 12px 12px 14px;
      }
      .scan-gen-foot{
        padding: 10px 12px;
      }
    }

    .math-preview{
      min-height: 28px;
      line-height: 1.5;
      color: var(--text);
      word-break: break-word;
    }
    .math-preview .katex{
      font-size: 1.02em;
      color: var(--text);
      max-width: 100%;
      overflow-x: auto;
      overflow-y: hidden;
      padding-bottom: 2px;
    }
    .math-rendered{
      display: inline-flex;
      align-items: center;
      max-width: 100%;
      overflow-x: auto;
      overflow-y: hidden;
      vertical-align: middle;
    }

    /* ===== In-app alert / confirm modal ===== */
    .ui-modal{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:120;
      pointer-events:none;
      opacity:0;
      transition: opacity .28s cubic-bezier(0.22, 1, 0.36, 1);
    }
    .ui-modal.is-open{
      opacity:1;
      pointer-events:auto;
    }
    .ui-modal-backdrop{
      position:absolute;
      inset:0;
      background: rgba(17,18,20,.38);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      opacity:0;
      transition: opacity .28s cubic-bezier(0.22, 1, 0.36, 1);
    }
    .ui-modal.is-open .ui-modal-backdrop{ opacity:1; }
    .ui-modal-card{
      position:relative;
      width: min(520px, calc(100vw - 44px));
      background: var(--panel);
      border: 1px solid rgba(17,18,20,.08);
      border-radius: 18px;
      box-shadow: 0 24px 90px rgba(0,0,0,.22);
      padding: 18px 18px 16px;
      transform: translateY(18px) scale(.98);
      opacity:0;
      transition:
        transform .42s cubic-bezier(0.22, 1, 0.36, 1),
        opacity .32s cubic-bezier(0.22, 1, 0.36, 1);
    }
    .ui-modal.is-open .ui-modal-card{
      transform: translateY(0) scale(1);
      opacity:1;
    }
    .ui-modal-title{
      font-weight:700;
      font-size:16px;
      color:var(--text);
      letter-spacing:.01em;
    }
    .ui-modal-message{
      margin-top:10px;
      font-size:14px;
      color:var(--text);
      line-height:1.6;
      white-space:pre-wrap;
      word-break:break-word;
    }
    .ui-modal-actions{
      margin-top:16px;
      display:flex;
      gap:10px;
      justify-content:flex-end;
      flex-wrap:wrap;
    }
    .ui-modal-actions .textbtn,
    .ui-modal-actions .navbtn{ min-width: 118px; }
    .ui-modal-card.is-danger .navbtn{
      background: var(--maru);
      border-color: transparent;
      color:var(--inverse-text);
    }
    .ui-modal-card.is-danger .navbtn:hover{ filter: brightness(0.98); }
    .ui-toast{
      position: fixed;
      left: 50%;
      bottom: 24px;
      transform: translateX(-50%) translateY(10px);
      background: rgba(17,18,20,0.92);
      color: var(--inverse-text);
      border-radius: 999px;
      padding: 10px 14px;
      font-size: 12px;
      z-index: 2400;
      opacity: 0;
      pointer-events: none;
      transition: opacity .2s ease, transform .2s ease;
    }
    .ui-toast.show{
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    @media (prefers-reduced-motion: reduce){
      .ui-modal,
      .ui-modal-backdrop,
      .ui-modal-card{
        transition:none !important;
      }
      .ui-modal-card{ transform:none !important; }
    }


    /* =========================
       Update Notes
       ========================= */
    .update-sheet .sheet-body{
      max-height: min(68vh, 520px);
      overflow: auto;
      -webkit-overflow-scrolling: touch;
    }
    .update-article{
      padding: 4px 2px 8px;
    }
    .update-headline{
      margin: 0 0 6px;
      font-size: 18px;
      font-weight: 800;
      letter-spacing: -0.02em;
    }
    .update-date{
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 14px;
    }
    .update-content{
      font-size: 13px;
      color: var(--text);
      line-height: 1.65;
    }
    .update-content p{
      margin: 0 0 10px;
    }
    .update-content ul{
      margin: 10px 0 10px 18px;
      padding: 0;
    }
    .update-content li{
      margin: 6px 0;
    }
    .update-note{
      color: var(--muted);
      font-size: 12px;
      margin-top: 10px;
    }
    .update-footer{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
    }
    .checkrow{
      display:flex;
      align-items:center;
      gap: 8px;
      font-size: 12px;
      color: var(--muted);
      user-select: none;
    }
    .checkrow input{
      width: 16px;
      height: 16px;
      accent-color: var(--accent);
    }

    /* =========================
       Insights
       ========================= */
    .icon-btn.insights-btn{
      padding: 0 12px;
      font-size: 12px;
      font-weight: 700;
      letter-spacing: .02em;
    }
    .sheet-sub{
      margin-top: 4px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.4;
    }
    .insights-sheet{
      width: min(1000px, 94vw);
      max-height: min(86vh, 780px);
      display:flex;
      flex-direction: column;
    }
    .insights-body{
      max-height: none;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      display:flex;
      flex-direction: column;
      gap: 14px;
    }
    .insights-filters{
      position: sticky;
      top: 0;
      z-index: 2;
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: flex-end;
      padding: 12px;
      border-radius: 12px;
      background: var(--panel2);
      backdrop-filter: blur(10px);
      border: 1px solid var(--border);
      box-shadow: 0 10px 26px rgba(17,18,20,.04);
    }
    .filter-item{ min-width: 160px; flex: 1; }
    .filter-label{
      font-size: 11px;
      letter-spacing: .08em;
      text-transform: uppercase;
      color: var(--muted);
      margin: 0 0 6px;
    }

    .insights-summary{
      display:grid;
      gap: 10px;
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }
    @media (min-width: 820px){
      .insights-summary{ grid-template-columns: repeat(5, minmax(0, 1fr)); }
    }
    .summary-card{
      border: 1px solid var(--border);
      border-radius: 14px;
      background: var(--panel);
      padding: 12px 12px;
      box-shadow: 0 10px 26px rgba(17,18,20,.04);
      min-width: 0;
    }
    .summary-k{
      font-size: 11px;
      color: var(--muted);
      letter-spacing: .06em;
      text-transform: uppercase;
      margin-bottom: 6px;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .summary-v{
      font-size: 16px;
      font-weight: 800;
      color: var(--text);
      letter-spacing: -0.01em;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }

    .insights-grid{
      display:grid;
      gap: 14px;
      grid-template-columns: 1fr;
      padding-bottom: 6px;
    }
    @media (min-width: 900px){
      .insights-grid{ grid-template-columns: 1fr 1fr; }
      .insights-grid .insight-card:nth-child(3){ grid-column: 1 / -1; }
      .insights-grid .insight-card:nth-child(4){ grid-column: 1 / -1; }
    }
    .insight-card{
      border: 1px solid var(--border);
      border-radius: 16px;
      background: var(--panel);
      box-shadow: 0 10px 26px rgba(17,18,20,.04);
      padding: 12px 12px;
      min-width: 0;
    }
    .insight-head{
      display:flex;
      align-items:baseline;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 10px;
    }
    .insight-title{
      font-size: 13px;
      font-weight: 800;
      color: var(--text);
      letter-spacing: -0.01em;
    }
    .insight-note{
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .chart{
      width: 100%;
      min-height: 220px;
    }
    .chart svg{ width: 100%; height: 220px; display:block; }
    .chart .grid{ stroke: var(--chart-grid); stroke-width: 1; }
    .chart .axis{ stroke: var(--chart-axis); stroke-width: 1; }
    .chart .label{ fill: var(--chart-label); font-size: 11px; }
    .chart .line{ stroke: var(--chart-line); stroke-width: 2.2; fill: none; }
    .chart .dot{ fill: var(--chart-line); }
    .chart .bar{ fill: var(--chart-bar); }
    .chart .barBg{ fill: var(--chart-bar-bg); }

    .weak-list{
      display:flex;
      flex-direction: column;
      gap: 10px;
    }
    .weak-item{
      display:grid;
      grid-template-columns: 1fr 52px;
      gap: 10px;
      align-items:center;
    }
    .weak-left{ min-width: 0; }
    .weak-top{
      display:flex;
      justify-content: space-between;
      gap: 10px;
      align-items: baseline;
      margin-bottom: 6px;
    }
    .weak-word{
      font-weight: 800;
      color: var(--text);
      font-size: 13px;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .weak-no{
      font-size: 11px;
      color: var(--muted);
      white-space: nowrap;
    }
    .weak-bar{
      height: 8px;
      border-radius: 999px;
      background: var(--chart-bar-bg);
      overflow:hidden;
    }
    .weak-bar > i{
      display:block;
      height: 100%;
      width: 0%;
      background: var(--chart-bar);
      border-radius: 999px;
      transform-origin: left center;
      transition: width .45s cubic-bezier(0.22, 1, 0.36, 1);
    }
    .weak-count{
      text-align:right;
      font-weight: 800;
      color: var(--text);
    }

    .insights-actions{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .table-wrap{
      overflow:auto;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--panel);
      box-shadow: inset 0 1px 0 var(--border);
    }
    .insight-table{
      width:100%;
      border-collapse: collapse;
      font-size: 12.5px;
      line-height: 1.45;
    }
    .insight-table th,
    .insight-table td{
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      text-align: left;
      white-space: nowrap;
    }
    .insight-table th{
      position: sticky;
      top: 0;
      z-index: 1;
    }
    .insight-table th:not(:first-child),
    .insight-table td:not(:first-child){
      text-align: right;
      font-variant-numeric: tabular-nums;
    }
    .insight-table th{
      font-weight: 800;
      background: rgba(17,18,20,0.06);
      color: var(--muted);
      letter-spacing: .04em;
    }
    .insight-table tbody tr:nth-child(even){
      background: rgba(17,18,20,0.022);
    }
    .insight-table tbody tr:hover{
      background: rgba(31,42,68,0.045);
    }
    .insight-table td.is-delta{
      font-weight: 800;
    }
    .insight-table td.delta-pos{
      color: #198754;
    }
    .insight-table td.delta-neg{
      color: #c92a2a;
    }
    .insight-table td.delta-zero{
      color: var(--muted);
    }
    .insight-table tr:last-child td{ border-bottom: 0; }
    .insight-empty{
      font-size: 12px;
      color: var(--muted);
      line-height: 1.7;
      padding: 10px;
    }
    .memo-check{
      display:flex;
      flex-direction: column;
      gap: 14px;
    }
    .memo-calendar{
      border: 1px solid var(--border);
      border-radius: 14px;
      background: var(--panel);
      padding: 12px;
    }
    .memo-cal-head{
      display:flex;
      align-items:center;
      justify-content: space-between;
      margin-bottom: 10px;
      gap: 10px;
    }
    .memo-cal-grid{
      display:grid;
      grid-template-columns: repeat(7, minmax(0,1fr));
      gap: 6px;
    }
    .memo-cal-week{
      font-size: 11px;
      color: var(--muted);
      text-align:center;
      padding: 4px 0;
    }
    .memo-day{
      border: 1px solid var(--border);
      border-radius: 10px;
      min-height: 52px;
      padding: 6px;
      background: var(--panel2);
      cursor: pointer;
      display:flex;
      flex-direction: column;
      justify-content: space-between;
      gap: 6px;
    }
    .memo-day.is-out{ opacity:.4; }
    .memo-day .d{
      font-size: 12px;
      font-weight: 700;
      color: var(--text);
    }
    .memo-day .dot{
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: var(--accent);
      margin-left: auto;
    }
    .memo-block-pool,.memo-slots{
      display:grid;
      gap: 8px;
    }
    .memo-block-pool{
      grid-template-columns: repeat(auto-fill, minmax(140px,1fr));
    }
    .memo-block{
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 8px 10px;
      font-size: 12px;
      background: var(--panel);
      text-align: left;
    }
    .memo-block.is-selected{
      border-color: rgba(31,42,68,0.45);
      background: rgba(31,42,68,0.06);
    }
    .memo-slot{
      border: 1px dashed rgba(17,18,20,0.24);
      border-radius: 12px;
      padding: 10px;
      background: var(--panel2);
    }
    .memo-slot label{
      display:block;
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 6px;
      font-weight: 700;
    }
    .memo-slot textarea{
      width: 100%;
      min-height: 66px;
      border: 1px solid var(--input-border);
      border-radius: 10px;
      padding: 8px;
      resize: vertical;
      font-size: 13px;
      background: var(--input-bg);
      color: var(--input-text);
    }
    .memo-picked{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      margin-top: 8px;
    }
    .memo-tag{
      border: 1px solid rgba(31,42,68,0.22);
      background: rgba(31,42,68,0.06);
      color: var(--text);
      border-radius: 999px;
      font-size: 11px;
      padding: 4px 8px;
    }
    .memo-reco-list{
      display:flex;
      flex-direction: column;
      gap: 8px;
      max-height: 260px;
      overflow:auto;
    }
    .memo-reco-item{
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px;
      background: var(--panel);
      font-size: 12px;
    }

    @keyframes insightsFadeIn{
      from{ opacity: 0; transform: translateY(8px) scale(.99); }
      to{ opacity: 1; transform: translateY(0) scale(1); }
    }
    .overlay:not(.hidden) .insights-sheet{
      animation: insightsFadeIn .48s cubic-bezier(0.22, 1, 0.36, 1) both;
    }
    .draw-line{
      stroke-dasharray: var(--dash, 1000);
      stroke-dashoffset: var(--dash, 1000);
      animation: lineDraw .6s cubic-bezier(0.22, 1, 0.36, 1) forwards;
    }
    @keyframes lineDraw{ to{ stroke-dashoffset: 0; } }

    @media (prefers-reduced-motion: reduce){
      .overlay:not(.hidden) .insights-sheet{ animation:none !important; }
      .draw-line{ animation:none !important; stroke-dasharray:none !important; stroke-dashoffset:0 !important; }
      .weak-bar > i{ transition:none !important; }
    }



/* =========================
   Topbar labels + Notify dropdown
   ========================= */

/* Icon hover labels */
.icon-btn{ position: relative; overflow: visible; }
.icon-btn .icon-label{
  position: absolute;
  top: calc(100% + 8px);
  left: 50%;
  transform: translate(-50%, -4px);
  opacity: 0;
  pointer-events: none;
  white-space: nowrap;
  font-size: 12px;
  letter-spacing: .02em;
  padding: 6px 10px;
  border-radius: 999px;
  background: var(--panel2);
  color: var(--text);
  border: 1px solid var(--border);
  box-shadow: 0 10px 26px rgba(0,0,0,.10);
  transition: opacity .22s cubic-bezier(0.22, 1, 0.36, 1), transform .22s cubic-bezier(0.22, 1, 0.36, 1);
  z-index: 50;
}
@media (hover:hover) and (pointer:fine){
  .icon-btn:hover .icon-label,
  .icon-btn:focus-visible .icon-label{
    opacity: 1;
    transform: translate(-50%, 0);
  }
}
@media (hover:none), (pointer:coarse){
  .icon-btn .icon-label{ display:none; }
}

/* Notifications dropdown: show as topbar popover */
#notifyOverlay{
  background: transparent !important;
  align-items: flex-start !important;
  justify-content: flex-end !important;
  padding: calc(var(--topbar-h, 56px) + 10px) 16px 16px !important;
}
#notifyOverlay .notify-sheet{
  width: min(420px, calc(100vw - 24px));
  max-height: min(70vh, 560px);
  border-radius: 18px;
  box-shadow: 0 18px 45px rgba(0,0,0,.18);
  border: 1px solid var(--border);
  overflow: hidden;
  transform-origin: top right;
  transform: translateY(-10px) scale(.985);
  opacity: 0;
  transition: transform .26s cubic-bezier(0.22, 1, 0.36, 1), opacity .26s cubic-bezier(0.22, 1, 0.36, 1);
}
#notifyOverlay:not(.hidden) .notify-sheet{
  transform: translateY(0) scale(1);
  opacity: 1;
}
#notifyOverlay .sheet-footer{ display:none; }


/* =========================
   Search dropdown (Topbar)
   ========================= */
#searchOverlay{
  background: transparent !important;
  align-items: flex-start !important;
  justify-content: flex-end !important;
  padding: calc(var(--topbar-h, 56px) + 10px) 16px 16px !important;
}
#searchOverlay.hidden{ display:none !important; }

#searchOverlay .search-sheet{
  width: min(520px, calc(100vw - 24px));
  max-height: min(72vh, 620px);
  border-radius: 20px;
  box-shadow: 0 16px 34px rgba(15,23,42,.14);
  border: 1px solid var(--border);
  overflow: hidden;
  transform-origin: top right;
  transform: translateY(-10px) scale(.985);
  opacity: 0;
  transition: transform .26s cubic-bezier(0.22, 1, 0.36, 1), opacity .26s cubic-bezier(0.22, 1, 0.36, 1);
}
#searchOverlay:not(.hidden) .search-sheet{
  transform: translateY(0) scale(1);
  opacity: 1;
}
#searchOverlay .sheet-header{ padding: 16px 16px 10px; }
#searchOverlay .search-body{
  display: grid;
  gap: 10px;
  padding: 10px 12px 14px;
}
#searchOverlay .search-input-wrap{ padding: 0 2px 2px; }
#searchOverlay #searchInput{
  width: 100%;
  min-height: 46px;
  border-radius: 14px;
  border: 1px solid var(--input-border);
  background: var(--panel);
  color: var(--text);
  padding: 0 14px;
  box-shadow: inset 0 1px 0 rgba(255,255,255,.22);
}
#searchOverlay #searchInput::placeholder{
  color: var(--muted);
}
#searchOverlay #searchInput:focus-visible{
  outline: none;
  border-color: color-mix(in srgb, var(--accent, #2563eb) 48%, var(--input-border));
  box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent, #2563eb) 18%, transparent);
}
#searchOverlay .search-empty{
  padding: 12px 14px;
  border: 1px dashed var(--border);
  border-radius: 12px;
  background: color-mix(in srgb, var(--panel2) 72%, transparent);
  color: var(--muted);
  font-size: 13px;
  text-align: center;
}
#searchOverlay .search-list{
  display: flex;
  flex-direction: column;
  gap: 8px;
  max-height: 360px;
  overflow: auto;
  padding: 2px 2px 0;
  scrollbar-gutter: stable;
  -webkit-overflow-scrolling: touch;
}
.search-item{
  width: 100%;
  text-align: left;
  border-radius: 15px;
  padding: 12px 13px;
  border: 1px solid var(--border);
  background: color-mix(in srgb, var(--panel) 85%, var(--panel2));
  box-shadow: 0 6px 14px rgba(15,23,42,.06);
  transition: transform .18s cubic-bezier(0.22, 1, 0.36, 1), box-shadow .18s cubic-bezier(0.22, 1, 0.36, 1), border-color .18s cubic-bezier(0.22, 1, 0.36, 1), background .18s cubic-bezier(0.22, 1, 0.36, 1);
}
.search-item:focus-visible{ outline: 2px solid var(--focus); outline-offset: 2px; }
.search-item .row{
  display:flex;
  align-items:baseline;
  justify-content: space-between;
  gap: 10px;
}
.search-item .no{
  font-variant-numeric: tabular-nums;
  color: var(--muted);
  font-size: 12px;
}
.search-item .word{
  font-weight: 650;
  letter-spacing: -0.01em;
  color: var(--text);
  font-size: 14px;
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.search-item .meaning{
  margin-top: 4px;
  color: var(--muted);
  font-size: 12.5px;
  line-height: 1.35;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
}
.search-item .preset{
  margin-top: 7px;
  color: var(--muted);
  font-size: 11.5px;
  line-height: 1.35;
}
@media (hover:hover) and (pointer:fine){
  .search-item:hover{
    transform: translateY(-1px);
    border-color: color-mix(in srgb, var(--accent, #2563eb) 26%, var(--border));
    box-shadow: 0 10px 22px rgba(15,23,42,.10);
    background: var(--panel);
  }
}
.search-item:active{
  transform: translateY(0) scale(.986);
  box-shadow: 0 4px 10px rgba(15,23,42,.08);
}


/* 
   Hamburger Menu (stable navigation)
    */
#settingsBtn{ display:none !important; } /* moved into hamburger menu */
#helpBtn{ display:none !important; } /* if exists */

	.menu-overlay{
	      position: fixed;
	      inset: 0;
	      background: rgba(0,0,0,.18);
	      opacity: 0;
	      pointer-events: none;
	      transition: opacity .26s cubic-bezier(.22,1,.36,1);
	      z-index: 96;
	    }
	    .menu-overlay.open,
	    .menu-overlay.is-open{ opacity: 1; pointer-events: auto; }
	    .menu-overlay.is-closing{
	      opacity: 0;
	      pointer-events: none;
	    }

	    .menu-panel{
	      position: fixed;
	      top: 0;
	      right: 0;
      width: min(380px, 92vw);
      height: 100vh;
      max-height: 100vh;
	      background: var(--panel);
	      border-left: 1px solid var(--border);
	      box-shadow: -18px 0 45px rgba(2,8,23,.12);
	      transform: translateX(18px);
	      opacity: 0;
	      transition: transform .26s cubic-bezier(.22,1,.36,1), opacity .26s cubic-bezier(.22,1,.36,1);
	      will-change: transform, opacity;
	      pointer-events: none;
	      z-index: 97;
	      display: flex;
	      flex-direction: column;
	    }
	    .menu-panel.open,
	    .menu-panel.is-open{
	      transform: translateX(0);
	      opacity: 1;
	      pointer-events: auto;
	    }
	    .menu-panel.is-closing{
	      transform: translateX(18px);
	      opacity: 0;
	      pointer-events: none;
	    }
	    .menu-overlay.memo-full{
	      background: rgba(9,13,22,.32);
	    }
	    .menu-panel.memo-full{
	      left: 0;
      right: 0;
	      width: 100vw;
	      max-width: 100vw;
	      border-left: 0;
	      box-shadow: none;
	      transform: translateY(18px);
	    }
	    .menu-panel.memo-full.open,
	    .menu-panel.memo-full.is-open{
	      transform: translateY(0);
	    }
	    .menu-panel.memo-full.is-closing{
	      transform: translateY(18px);
	    }
    .menu-panel.memo-full .menu-header{
      padding: 14px 16px;
      border-bottom-color: rgba(17,18,20,.08);
    }
    .menu-panel.memo-full .menu-content{
      padding: 16px;
    }

    .menu-header{
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      background: var(--panel);
      position: sticky;
      top: 0;
      z-index: 1;
    }
    .menu-title{
      flex: 1;
      font-size: 12px;
      font-weight: 800;
      letter-spacing: .12em;
      text-transform: uppercase;
      color: var(--muted);
    }
    .menu-back{
      opacity: 0;
      pointer-events: none;
      transform: translateX(-6px);
      transition: opacity .18s cubic-bezier(.22,1,.36,1), transform .18s cubic-bezier(.22,1,.36,1);
    }
    .menu-panel.has-back .menu-back{
      opacity: 1;
      pointer-events: auto;
      transform: translateX(0);
    }

    .menu-content{
      flex: 1;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      padding: 14px 14px 20px;
    }
    .menu-content:focus{ outline: none; }

    .menu-list{
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .menu-item{
      display: flex;
      align-items: center;
      gap: 10px;
      width: 100%;
      text-align: left;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 14px;
      background: var(--panel);
      color: var(--text);
      cursor: pointer;
    }
    .menu-item:hover{ background: var(--panel2); }

    /* Drawer content: compact & scroll-friendly */
    .menu-article{
      line-height: 1.52;
    }
    .menu-article h2{
      margin: 14px 0 8px;
      font-size: 15px;
      letter-spacing: .02em;
    }
    .menu-article h3{
      margin: 12px 0 6px;
      font-size: 13px;
      letter-spacing: .01em;
    }
    .menu-article p{ margin: 8px 0; }
    .menu-article ul{
      margin: 8px 0 10px 18px;
      padding: 0;
    }
    .menu-article li{ margin: 4px 0; }
    .menu-article hr{
      margin: 14px 0;
      border: 0;
      border-top: 1px solid var(--border);
    }
    .menu-article .mini{ font-size: 12px; color: var(--muted); }
    .menu-article .embed{ margin: 10px 0; }
    .menu-article .faq-tools{
      margin: 10px 0 12px;
      display: grid;
      gap: 10px;
    }
    .menu-article .faq-search-wrap{
      border: 1px solid var(--input-border);
      border-radius: 12px;
      background: var(--input-bg);
      padding: 8px 12px;
    }
    .menu-article .faq-search{
      width: 100%;
      min-height: 40px;
      border: 0;
      outline: none;
      background: transparent;
      color: var(--input-text);
      font-size: 14px;
      line-height: 1.4;
    }
    .menu-article .faq-search::placeholder{
      color: var(--muted);
    }
    .menu-article .faq-chip-row{
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .menu-article .faq-chip{
      min-height: 34px;
      border: 1px solid var(--border);
      border-radius: 999px;
      background: var(--panel2);
      color: var(--text);
      font-size: 12px;
      font-weight: 600;
      padding: 6px 12px;
      cursor: pointer;
      transition: background .2s ease, border-color .2s ease, color .2s ease;
    }
    .menu-article .faq-chip.is-active{
      background: var(--btn-bg);
      border-color: var(--btn-border);
      color: var(--btn-text);
    }
    .menu-article .faq-meta{
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.4;
    }
    .menu-article .faq-empty{
      border: 1px dashed var(--border);
      border-radius: 12px;
      background: var(--panel2);
      color: var(--muted);
      font-size: 13px;
      padding: 12px;
      text-align: center;
    }
    .menu-article details.faq.is-hidden{
      display: none !important;
    }
    .menu-article .faq-list{
      display: grid;
      gap: 10px;
      margin: 10px 0 2px;
    }
    .menu-article details.faq{
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--panel);
      overflow: hidden;
      box-shadow: 0 1px 0 rgba(17,18,20,.02);
    }
    .menu-article details.faq > summary{
      list-style: none;
      cursor: pointer;
      padding: 12px 14px;
      min-height: 44px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      font-weight: 700;
      color: var(--text);
      line-height: 1.5;
      user-select: none;
    }
    .menu-article details.faq > summary::-webkit-details-marker{ display:none; }
    .menu-article details.faq > summary::after{
      content:"+";
      font-size: 15px;
      line-height: 1;
      color: var(--muted);
      flex-shrink: 0;
    }
    .menu-article details.faq[open] > summary{
      border-bottom: 1px solid var(--border);
      background: var(--panel2);
    }
    .menu-article details.faq[open] > summary::after{
      content:"-";
      color: var(--text);
    }
    .menu-article .faq-body{
      box-sizing: border-box;
      overflow: hidden;
      height: auto;
      opacity: 1;
      padding: 12px 14px 14px;
      color: var(--text);
      line-height: 1.56;
      transition: height .22s cubic-bezier(.22,1,.36,1), opacity .22s cubic-bezier(.22,1,.36,1);
    }
    .menu-article .faq-body p{
      margin: 0 0 8px;
    }
    .menu-article .faq-body p:last-child{
      margin-bottom: 0;
    }
    .menu-article .faq-body ol,
    .menu-article .faq-body ul{
      margin: 6px 0 8px 18px;
    }
    .menu-article .faq-body li{
      margin: 4px 0;
    }
    .drawer-share{
      display: grid;
      gap: 12px;
    }
    .drawer-share-tabs{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    .drawer-share-tab{
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--btn-bg);
      color: var(--text);
      padding: 9px 10px;
      font-weight: 700;
      cursor: pointer;
      text-align: center;
    }
    .drawer-share-tab.active{
      border-color: rgba(31,42,68,.35);
      background: rgba(31,42,68,.08);
    }
    .drawer-share-panel{
      border: 1px solid var(--border);
      border-radius: 14px;
      background: var(--panel);
      padding: 12px;
      display: grid;
      gap: 10px;
    }
    .drawer-share-code{
      font-size: 36px;
      font-weight: 800;
      letter-spacing: .12em;
      text-align: center;
      color: var(--text);
      font-variant-numeric: tabular-nums;
      line-height: 1.1;
    }
    .drawer-share-sub{
      text-align: center;
      font-size: 12px;
      color: var(--muted);
    }
    .drawer-share-qr{
      width: 240px;
      height: 240px;
      max-width: 100%;
      border: 1px solid var(--border);
      border-radius: 14px;
      display: none;
      margin: 0 auto;
      background: var(--panel);
    }
    .drawer-share-link{
      font-size: 12px;
      color: var(--muted);
      line-height: 1.4;
      word-break: break-all;
      text-align: center;
    }
    .drawer-share-actions{
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
    }
    .drawer-share-status{
      font-size: 12px;
      color: var(--muted);
      line-height: 1.5;
    }
    .drawer-share-status.error{
      color: #b42318;
    }
    .drawer-share-status.ok{
      color: #198754;
    }
    .drawer-share-empty{
      font-size: 12px;
      color: var(--muted);
      line-height: 1.6;
      padding: 10px 0;
    }
    .drawer-share-row{
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    .menu-article img{
      max-width: 100%;
      height: auto;
      border-radius: 12px;
      border: 1px solid var(--border);
      display: block;
    }
    .menu-article video{
      width: 100%;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: var(--panel2);
      display: block;
    }
    .menu-article label{
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin: 2px 0 6px;
    }
    .menu-article textarea.spell-input{
      min-height: 140px;
      resize: vertical;
    }
    .menu-article .row-actions{
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 12px;
    }
    .menu-article .status{
      margin-top: 10px;
      font-size: 12px;
      color: var(--muted);
    }
    .menu-article .status.error{ color: #b91c1c; }
    .menu-article .status.ok{ color: #198754; }
    .admin-settings-card{
      border:1px solid rgba(31,42,68,.14);
      border-radius: 12px;
      background: rgba(31,42,68,.03);
      padding: 12px;
      display:grid;
      gap: 10px;
    }
    .admin-settings-head{
      display:flex;
      flex-wrap: wrap;
      justify-content: space-between;
      gap: 10px;
      align-items: flex-start;
    }
    .admin-settings-actions{
      display:flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .admin-notif-editor{
      border:1px solid rgba(31,42,68,.14);
      border-radius: 12px;
      background: rgba(31,42,68,.03);
      padding: 12px;
      display:grid;
      gap: 12px;
    }
    .admin-editor-actions{
      display:flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .admin-editor-form{
      display:grid;
      gap: 10px;
    }
    .admin-editor-form textarea.spell-input{
      min-height: 120px;
      resize: vertical;
    }
    .admin-editor-grid{
      display:grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 8px;
    }
    .admin-editor-submit{
      display:flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    .admin-notif-list{
      display:grid;
      gap: 10px;
    }
    .admin-notif-item{
      border:1px solid var(--border);
      border-radius: 12px;
      background: var(--panel);
      padding: 10px;
      display:grid;
      gap: 8px;
    }
    .admin-notif-title{
      font-weight: 700;
      color: var(--text);
      line-height: 1.35;
    }
    .admin-notif-meta{
      font-size: 12px;
      color: var(--muted);
      display:flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .admin-notif-body{
      white-space: pre-wrap;
      color: var(--text);
      font-size: 13px;
      line-height: 1.55;
    }
    .admin-notif-item-actions{
      display:flex;
      justify-content: flex-end;
      gap: 8px;
      flex-wrap: wrap;
    }
    .maintenance-admin-preview{
      margin-top: 10px;
      padding: 12px;
      border: 1px solid var(--line);
      border-radius: 14px;
      background: rgba(17,18,20,.03);
      display: grid;
      gap: 6px;
      color: var(--muted);
      font-size: 12px;
    }
    .maintenance-admin-preview .now{
      color: var(--text);
      font-weight: 700;
      font-size: 13px;
    }
    .maintenance-overlay{
      position: fixed;
      inset: 0;
      z-index: 1800;
      display: grid;
      place-items: center;
      padding: 18px;
      background: rgba(15,16,18,.48);
      backdrop-filter: blur(3px);
      -webkit-backdrop-filter: blur(3px);
    }
    .maintenance-overlay.hidden{
      display: none !important;
    }
    .maintenance-card{
      width: min(560px, calc(100vw - 26px));
      border-radius: 20px;
      border: 1px solid var(--line);
      background: var(--panel);
      box-shadow: 0 20px 48px rgba(0,0,0,.24);
      padding: 18px 16px;
      display: grid;
      gap: 12px;
      color: var(--text);
    }
    .maintenance-head{
      display: flex;
      align-items: center;
      gap: 10px;
      min-height: 36px;
    }
    .maintenance-icon{
      width: 32px;
      height: 32px;
      border-radius: 999px;
      border: 1px solid var(--line);
      display: grid;
      place-items: center;
      color: var(--text);
      background: rgba(17,18,20,.03);
      flex-shrink: 0;
    }
    .maintenance-title{
      margin: 0;
      font-size: 20px;
      font-weight: 800;
      letter-spacing: .01em;
    }
    .maintenance-message{
      margin: 0;
      line-height: 1.7;
      color: var(--muted);
      white-space: pre-wrap;
      word-break: break-word;
    }
    .maintenance-meta{
      display: grid;
      gap: 8px;
    }
    .maintenance-meta-row{
      display: flex;
      justify-content: space-between;
      gap: 10px;
      font-size: 13px;
      color: var(--muted);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 9px 10px;
      background: rgba(17,18,20,.02);
    }
    .maintenance-meta-row strong{
      color: var(--text);
      font-weight: 700;
      text-align: right;
    }
    .maintenance-actions{
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: flex-end;
    }
    .maintenance-note{
      color: var(--muted);
      font-size: 12px;
      line-height: 1.6;
    }
    .maintenance-status{
      font-size: 12px;
      line-height: 1.4;
      min-height: 1.4em;
      color: var(--muted);
    }
    .maintenance-status.ok{ color: #12804b; }
    .maintenance-status.error{ color: #cf1f1f; }
    body.maintenance-open{
      overflow: hidden;
    }
    :root[data-theme-mode="dark"] .maintenance-overlay{
      background: rgba(4,5,8,.7);
    }
    :root[data-theme-mode="dark"] .maintenance-card{
      background: var(--panel);
      box-shadow: 0 20px 54px rgba(0,0,0,.55);
    }
    :root[data-theme-mode="dark"] .maintenance-icon,
    :root[data-theme-mode="dark"] .maintenance-meta-row{
      background: rgba(255,255,255,.03);
    }
    :root[data-theme-mode="dark"] .maintenance-status.ok{ color: #63d39a; }
    :root[data-theme-mode="dark"] .maintenance-status.error{ color: #ff8b8b; }
    .backup-settings-card{
      border:1px solid rgba(31,42,68,.14);
      border-radius: 12px;
      background: rgba(31,42,68,.03);
      padding: 12px;
      display:grid;
      gap: 10px;
    }
    .backup-actions{
      display:flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    @media (max-width: 720px){
      .admin-editor-grid{
        grid-template-columns: 1fr;
      }
    }

    .menu-article pre{
      white-space: pre-wrap;
      word-break: break-word;
      margin: 8px 0;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(15,23,42,.03);
      font-size: 12px;
      line-height: 1.45;
    }

    .report-done{
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      padding: 24px 8px 10px;
    }
    .report-done .check{
      width: 72px;
      height: 72px;
      margin-bottom: 12px;
    }
    .report-done h2{
      margin: 6px 0 4px;
      font-size: 18px;
      letter-spacing: .01em;
    }
    .report-done p{
      margin: 0;
      color: var(--muted);
      font-size: 13px;
    }

    @media (prefers-reduced-motion: reduce){
  .menu-overlay, .menu-panel{
    transition:none !important;
  }
  /* Help/Tutorial (menu-article) polish */
.menu-article{
  max-width: 820px;
  margin: 0 auto;
  padding: 6px 2px 18px;
  color: #1d1d1f;
  line-height: 1.55;
}

.menu-article h2{
  font-size: 20px;
  letter-spacing: -0.01em;
  margin: 0 0 6px;
}

.menu-article h3{
  font-size: 16px;
  margin: 18px 0 8px;
  letter-spacing: -0.01em;
}

.menu-article h4{
  font-size: 14px;
  margin: 14px 0 6px;
  opacity: .95;
}

.menu-article p{
  margin: 8px 0;
}

.menu-article .mini{
  font-size: 12.5px;
  opacity: .78;
  margin-top: 6px;
}

.menu-article ul, .menu-article ol{
  padding-left: 18px;
  margin: 8px 0 10px;
}

.menu-article li{
  margin: 6px 0;
}

.menu-article hr{
  border: none;
  border-top: 1px solid var(--border);
  margin: 16px 0;
}

.menu-article .embed{
  margin: 10px 0 12px;
  border-radius: 14px;
  overflow: hidden;
  background: var(--panel2);
  box-shadow: 0 10px 24px rgba(0,0,0,.10);
}

.menu-article .embed img,
.menu-article .embed video{
  display: block;
  width: 100%;
  height: auto;
}

.menu-article .codeblock{
  white-space: pre-wrap;
  background: var(--panel2);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 12px;
  margin: 10px 0 12px;
  font-size: 12.5px;
  line-height: 1.55;
}

}
/* =========================================================
   Theme Normalization Layer
   ========================================================= */
:root{
  color-scheme: light;
}
:root[data-theme-mode="dark"]{
  color-scheme: dark;
}

html, body, .app, main{
  background: var(--bg);
  color: var(--text);
}

.topbar{
  background: var(--bar-bg) !important;
  border-bottom: 1px solid var(--bar-border) !important;
}
.topbar .brand-title,
.topbar .brand-sub{
  color: var(--bar-text) !important;
}
.topbar .icon-btn{
  background: var(--btn-bg) !important;
  color: var(--bar-text) !important;
  border-color: var(--btn-border) !important;
  box-shadow: var(--shadow) !important;
}
.topbar .icon-btn .ms{
  color: currentColor !important;
}

.overlay{
  background: rgba(0,0,0,.42);
}

.sheet,
.menu-panel,
.menu-header,
.menu-content,
.result-box,
.wrong-item,
.notify-item,
.notify-video,
.search-item,
.insight-card,
.summary-card,
.drawer-share-panel,
.admin-notif-item,
.admin-notif-editor,
.settings-group{
  background: var(--panel) !important;
  color: var(--text) !important;
  border-color: var(--border) !important;
  box-shadow: var(--shadow);
}

.card,
.ui-modal-card{
  background: var(--panel) !important;
  color: var(--text) !important;
  border-color: var(--border) !important;
}

.settings-nav,
.settings-statusbar,
.sheet-header,
.sheet-footer,
.menu-header,
.table-wrap th{
  background: var(--panel2) !important;
  color: var(--text) !important;
  border-color: var(--border) !important;
}

.settings-row,
.menu-item{
  background: var(--panel) !important;
  color: var(--text) !important;
  border-color: var(--border) !important;
}

.settings-row .value,
.menu-item .meta,
.sheet-sub,
.note,
.mini,
.notify-time,
.drawer-share-sub,
.drawer-share-link,
.drawer-share-status,
.insight-note,
.summary-k,
.admin-notif-meta,
.menu-article .mini{
  color: var(--muted) !important;
}

.btn,
.navbtn,
.textbtn,
.icon-btn{
  background: var(--btn-bg) !important;
  color: var(--btn-text) !important;
  border-color: var(--btn-border) !important;
}
/* Quiz control buttons should stay readable in both light/dark themes */
#viewQuiz .controls .navbtn{
  background: var(--panel2) !important;
  color: var(--text) !important;
  border-color: var(--border) !important;
}
#viewQuiz .controls .navbtn[disabled]{
  background: var(--panel2) !important;
  color: var(--muted) !important;
  opacity: .72;
}
.btn:hover,
.navbtn:hover,
.textbtn:hover,
.icon-btn:hover{
  filter: brightness(1.04);
}
.btn[disabled],
.navbtn[disabled],
.textbtn[disabled],
.icon-btn[disabled]{
  opacity: .62;
  color: var(--muted) !important;
}

.spell-input,
.select,
input[type="text"],
input[type="email"],
input[type="number"],
input[type="datetime-local"],
textarea,
select{
  background: var(--input-bg) !important;
  color: var(--input-text) !important;
  border-color: var(--input-border) !important;
}
input::placeholder,
textarea::placeholder{
  color: var(--muted) !important;
}
input,
textarea,
select{
  caret-color: var(--text);
}

.start-chip,
.badge,
.fineprint .badge,
.deck-tab,
.pill{
  background: var(--chip-bg) !important;
  color: var(--chip-text) !important;
  border-color: var(--border) !important;
}

#notifyOverlay .notify-sheet,
#searchOverlay .search-sheet,
#menuPanel,
#insightsPanel,
#settingsOverlay .settings-fullsheet{
  background: var(--panel) !important;
  border-color: var(--border) !important;
}

.notify-bodytext,
.notify-detail-text,
.menu-article,
.admin-notif-body,
.update-content,
.result-box,
.wrong-item .mid{
  color: var(--text) !important;
}

.menu-article,
.menu-article h2,
.menu-article h3,
.menu-article h4{
  color: var(--text) !important;
}
.menu-article hr{
  border-top-color: var(--border) !important;
}
.menu-article .embed,
.menu-article .codeblock{
  background: var(--panel2) !important;
  border-color: var(--border) !important;
  color: var(--text) !important;
}

.table-wrap{
  border-color: var(--border) !important;
  background: var(--panel) !important;
}
.table-wrap table{
  width: 100%;
  border-collapse: collapse;
  background: var(--panel) !important;
  color: var(--text) !important;
}
.table-wrap th,
.table-wrap td{
  border-color: var(--border) !important;
  color: var(--text) !important;
}
.table-wrap td .muted,
.table-wrap .muted{
  color: var(--muted) !important;
}

.version{
  background: var(--panel2) !important;
  color: var(--muted) !important;
  border-color: var(--border) !important;
}

:root[data-theme-mode="dark"] .ui-modal-backdrop{
  background: rgba(0,0,0,.58);
}
:root[data-theme-mode="dark"] .notif-dot{
  box-shadow: 0 0 0 2px var(--panel2);
}
:root[data-theme-mode="dark"] .settings-row:not(.is-static):active,
:root[data-theme-mode="dark"] .menu-item:hover{
  background: var(--panel2) !important;
}

/* =========================
   App Tabs (Home/Library/Inbox/Insights/Settings)
   ========================= */
body{
  padding-bottom: 0;
}
body.app-tabs-visible main{
  padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 96px);
}
body:not(.app-tabs-visible) .app-tabbar{
  display: none;
}
body.app-tabs-visible #backBtn,
body.app-tabs-visible #insightsBtn,
body.app-tabs-visible #topPresetBtn,
body.app-tabs-visible #settingsBtn{
  display: none;
}

body[data-app-tab="home"] #viewTitle .hero{
  display: block;
}
body[data-app-tab="library"] #viewTitle .hero,
body[data-app-tab="inbox"] #viewTitle .hero,
body[data-app-tab="insight"] #viewTitle .hero,
body[data-app-tab="chat"] #viewTitle .hero{
  display: none;
}

.app-tab-page{
  display: none;
  padding: 6px 2px 0;
}
body[data-app-tab="library"] #appLibraryPage,
body[data-app-tab="inbox"] #appInboxPage,
body[data-app-tab="insight"] #appInsightsPage,
body[data-app-tab="chat"] #appChatPage{
  display: block;
}

.app-page-head{
  margin-bottom: 10px;
}
.app-page-head h2{
  margin: 0;
  font-size: 22px;
  color: var(--text);
}
.app-page-head p{
  margin: 6px 0 0;
  color: var(--muted);
  font-size: 13px;
}
.app-page-head-actions{
  margin-top: 10px;
  display: flex;
  justify-content: flex-end;
}
.app-page-block{
  border: 1px solid var(--border);
  background: var(--panel);
  border-radius: 16px;
  padding: 12px;
  margin: 12px 0;
}
.app-page-block-head{
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
  color: var(--muted);
  font-size: 12px;
  margin-bottom: 10px;
}

.app-preset-list{
  display: grid;
  gap: 10px;
}
.app-preset-card{
  border: 1px solid var(--border);
  background: var(--panel2);
  border-radius: 14px;
  padding: 10px;
}
.app-preset-card .title{
  color: var(--text);
  font-weight: 700;
}
.app-preset-card .meta{
  color: var(--muted);
  font-size: 12px;
  margin-top: 4px;
}
.app-preset-actions{
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  margin-top: 10px;
}

.app-inbox-list{
  display: grid;
  gap: 10px;
}
.app-inbox-item{
  border: 1px solid var(--border);
  background: var(--panel);
  border-radius: 14px;
  padding: 12px;
}
.app-inbox-item.unread{
  border-color: color-mix(in srgb, var(--accent, #1f6feb) 40%, var(--border));
}
.app-inbox-title{
  margin: 0;
  color: var(--text);
  font-size: 15px;
}
.app-inbox-preview{
  margin: 6px 0 0;
  color: var(--muted);
  font-size: 13px;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}
.app-inbox-meta{
  margin-top: 8px;
  color: var(--muted);
  font-size: 12px;
}
.app-empty{
  color: var(--muted);
  font-size: 13px;
  padding: 10px 2px;
}
.app-detail-title{
  margin: 10px 0 6px;
  color: var(--text);
}
.app-detail-meta{
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  color: var(--muted);
  font-size: 12px;
  margin-bottom: 10px;
}
.app-detail-content{
  border: 1px solid var(--border);
  background: var(--panel2);
  border-radius: 14px;
  padding: 12px;
}

.app-insights-grid{
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 10px;
}
.app-ins-card{
  border: 1px solid var(--border);
  background: var(--panel2);
  border-radius: 14px;
  padding: 10px;
}
.app-ins-k{
  color: var(--muted);
  font-size: 12px;
}
.app-ins-v{
  margin-top: 4px;
  color: var(--text);
  font-size: 20px;
  font-weight: 700;
}
.app-action-row{
  display: grid;
  gap: 10px;
}
.app-insight-filters{
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 10px;
}

.app-settings-list{
  display: grid;
  gap: 8px;
}
.app-chat-shell{
  border: 1px solid var(--border);
  border-radius: 16px;
  background: var(--panel);
  padding: 12px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  min-height: min(72dvh, 760px);
  box-sizing: border-box;
}
.app-chat-head{
  position: sticky;
  top: 0;
  z-index: 1;
  margin: -12px -12px 0;
  padding: 12px;
  border-bottom: 1px solid var(--border);
  background: var(--panel);
  background: color-mix(in oklab, var(--panel) 92%, transparent);
  backdrop-filter: saturate(135%) blur(6px);
}
.app-chat-head h2{
  margin: 0;
  font-size: 19px;
  color: var(--text);
}
.app-chat-head p{
  margin: 3px 0 0;
  font-size: 12px;
  color: var(--muted);
}
.app-chat-mode-row{
  margin-top: 8px;
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  gap: 8px;
}
.app-chat-mode-btn{
  min-height: 34px;
  border: 1px solid var(--border);
  border-radius: 999px;
  background: var(--panel2);
  color: var(--text);
  padding: 6px 12px;
  font-size: 12px;
  font-weight: 700;
  cursor: pointer;
}
.app-chat-mode-btn.is-active{
  border-color: color-mix(in oklab, var(--primary) 40%, var(--border));
  background: color-mix(in oklab, var(--primary) 14%, var(--panel));
}
.app-chat-mode-note{
  font-size: 11px;
  color: var(--muted);
}
.sr-only{
  position:absolute !important;
  width:1px !important;
  height:1px !important;
  margin:-1px !important;
  padding:0 !important;
  overflow:hidden !important;
  clip:rect(0 0 0 0) !important;
  border:0 !important;
}
.app-chat-intent-browser{
  border: 1px solid var(--border);
  border-radius: 14px;
  background: var(--panel2);
  padding: 10px;
  display: grid;
  gap: 8px;
}
.app-chat-intent-top{
  display: grid;
  grid-template-columns: minmax(0, 1fr) auto;
  gap: 8px;
  align-items: center;
}
.app-chat-intent-search{
  min-height: 38px;
  border: 1px solid var(--input-border);
  border-radius: 11px;
  background: var(--inputBg, var(--input-bg));
  color: var(--inputText, var(--input-text));
  padding: 8px 11px;
  font-size: 13px;
}
.app-chat-intent-search::placeholder{
  color: var(--muted);
}
.app-chat-intent-auto{
  min-height: 38px;
  border: 1px solid var(--border);
  border-radius: 999px;
  background: var(--btn-bg);
  color: var(--btn-text);
  padding: 6px 12px;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  white-space: nowrap;
}
.app-chat-intent-meta{
  font-size: 12px;
  color: var(--muted);
}
.app-chat-intent-groups{
  display: grid;
  gap: 8px;
  max-height: min(30dvh, 280px);
  overflow: auto;
  -webkit-overflow-scrolling: touch;
  padding-right: 2px;
}
.app-chat-intent-group{
  border: 1px solid var(--border);
  border-radius: 12px;
  background: var(--panel);
  overflow: hidden;
}
.app-chat-intent-group > summary{
  list-style: none;
  cursor: pointer;
  padding: 9px 11px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  font-size: 12px;
  font-weight: 700;
  color: var(--text);
  min-height: 40px;
}
.app-chat-intent-group > summary::-webkit-details-marker{
  display: none;
}
.app-chat-intent-group-body{
  border-top: 1px solid var(--border);
  padding: 8px;
  display: flex;
  flex-wrap: wrap;
  gap: 7px;
}
.app-chat-intent-btn{
  min-height: 34px;
  border: 1px solid var(--border);
  border-radius: 999px;
  background: var(--panel2);
  color: var(--text);
  font-size: 12px;
  padding: 6px 11px;
  cursor: pointer;
  text-align: left;
}
.app-chat-intent-btn:hover{
  border-color: color-mix(in oklab, var(--primary) 45%, var(--border));
}
.app-chat-chip-row{
  display:flex;
  gap:8px;
  flex-wrap:wrap;
}
.app-chat-chip{
  min-height:34px;
  padding:7px 12px;
  border-radius:999px;
  border:1px solid var(--border);
  background:var(--panel2);
  color:var(--text);
  font-size:12px;
  font-weight:600;
  cursor:pointer;
}
.app-chat-meta{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
  font-size:12px;
  color:var(--muted);
}
.app-chat-scroll{
  flex: 1 1 auto;
  min-height: 240px;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
  border: 1px solid var(--border);
  border-radius: 14px;
  background: var(--panel2);
  padding: 10px;
  box-sizing: border-box;
}
.app-chat-list{
  display:grid;
  gap:12px;
}
.app-chat-msg{
  display:grid;
  gap:6px;
  max-width:min(92%, 700px);
}
.app-chat-msg.is-user{
  margin-left:auto;
}
.app-chat-msg.is-ai,
.app-chat-msg.is-typing{
  margin-right:auto;
}
.app-chat-role{
  font-size:11px;
  color:var(--muted);
  letter-spacing:.02em;
}
.app-chat-bubble{
  border:1px solid var(--border);
  border-radius:14px;
  background:var(--panel);
  color:var(--text);
  padding:10px 12px;
  font-size:13px;
  line-height:1.6;
  white-space:pre-wrap;
  word-break:break-word;
}
.app-chat-msg.is-user .app-chat-bubble{
  background: var(--panel);
  background: color-mix(in oklab, var(--primary) 14%, var(--panel));
  border-color: color-mix(in oklab, var(--primary) 34%, var(--border));
}
.app-chat-msg.is-typing .app-chat-bubble{
  color:var(--muted);
}
.app-chat-time{
  font-size: 11px;
  color: var(--muted);
}
.app-chat-actions{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  margin-top:2px;
}
.app-chat-action{
  min-height:34px;
  border:1px solid var(--border);
  border-radius:999px;
  background:var(--btn-bg);
  color:var(--btn-text);
  font-size:12px;
  padding:7px 11px;
  cursor:pointer;
}
.app-chat-chart-grid{
  margin-top: 6px;
  display: grid;
  gap: 8px;
}
.app-chat-chart-card{
  border: 1px solid var(--border);
  border-radius: 12px;
  background: var(--panel2);
  padding: 8px;
}
.app-chat-chart-title{
  font-size: 12px;
  color: var(--muted);
  margin-bottom: 6px;
}
.app-chat-chart-svg{
  width: 100%;
  height: auto;
  display: block;
}
.app-chat-sources{
  margin-top: 6px;
  display: grid;
  gap: 4px;
}
.app-chat-source{
  font-size: 11px;
  color: var(--muted);
  line-height: 1.45;
}
.app-chat-meta-details{
  margin-top: 6px;
  border: 1px solid var(--border);
  border-radius: 10px;
  background: var(--panel2);
  overflow: hidden;
}
.app-chat-meta-details > summary{
  cursor: pointer;
  list-style: none;
  padding: 7px 10px;
  font-size: 11px;
  color: var(--muted);
  font-weight: 700;
}
.app-chat-meta-details > summary::-webkit-details-marker{
  display: none;
}
.app-chat-meta-grid{
  border-top: 1px solid var(--border);
  padding: 8px 10px;
  display: grid;
  gap: 4px;
  font-size: 11px;
  color: var(--muted);
  line-height: 1.45;
}
.app-chat-msg.is-ai.intent-match .app-chat-bubble{
  background: color-mix(in oklab, var(--panel2) 84%, var(--panel));
}
.app-chat-composer{
  position: sticky;
  bottom: calc(env(safe-area-inset-bottom, 0px) + 8px);
  z-index: 2;
  display: flex;
  align-items: flex-end;
  gap: 8px;
  border: 1px solid var(--border);
  border-radius: 16px;
  padding: 8px;
  background: var(--panel);
  background: color-mix(in oklab, var(--panel) 92%, transparent);
  backdrop-filter: saturate(135%) blur(6px);
}
.app-chat-input{
  flex: 1;
  min-height: 44px;
  max-height: 160px;
  border: 1px solid var(--input-border);
  border-radius: 12px;
  background: var(--inputBg, var(--input-bg));
  color: var(--inputText, var(--input-text));
  font-size: 14px;
  line-height: 1.45;
  resize: none;
  padding: 10px 12px;
  box-sizing: border-box;
}
.app-chat-input::placeholder{
  color: var(--muted);
}
.app-chat-send{
  flex: 0 0 auto;
  min-width: 78px;
  min-height: 44px;
}
.app-settings-row{
  border: 1px solid var(--border);
  background: var(--panel2);
  color: var(--text);
  border-radius: 14px;
  min-height: 44px;
  padding: 10px 12px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  cursor: pointer;
}

.app-home-quick{
  margin-top: 10px;
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}
.app-home-current{
  border: 1px solid var(--border);
  border-radius: 16px;
  background: var(--panel);
  padding: 12px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
  margin-bottom: 12px;
}
.app-home-current-main{
  min-width: 0;
}
.app-home-current-k{
  color: var(--muted);
  font-size: 12px;
}
.app-home-current-v{
  margin-top: 4px;
  color: var(--text);
  font-size: 18px;
  font-weight: 700;
}
.app-home-current-sub{
  margin-top: 4px;
  color: var(--muted);
  font-size: 12px;
}
.app-home-reco{
  margin-top: 10px;
  border: 1px solid var(--border);
  border-radius: 14px;
  background: var(--panel2);
  padding: 10px 12px;
}
.app-home-reco-title{
  color: var(--text);
  font-size: 13px;
  font-weight: 700;
}
.app-home-reco-body{
  color: var(--muted);
  font-size: 12px;
  margin-top: 4px;
}

.app-tabbar{
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 40;
  display: grid;
  grid-template-columns: repeat(5, minmax(0, 1fr));
  gap: 8px;
  padding: 8px 10px calc(env(safe-area-inset-bottom, 0px) + 10px);
  background: color-mix(in srgb, var(--bg) 84%, transparent);
  border-top: 1px solid var(--border);
  backdrop-filter: saturate(130%) blur(8px);
}
.app-tab-btn{
  border: 1px solid var(--border);
  background: var(--panel2);
  color: var(--muted);
  border-radius: 14px;
  min-height: 44px;
  padding: 6px 4px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 2px;
  font-size: 11px;
  cursor: pointer;
}
.app-tab-btn .ms{
  font-size: 18px;
  line-height: 1;
}
.app-tab-btn.is-active{
  background: var(--panel);
  color: var(--text);
  border-color: var(--btn-border);
}
@media (min-width: 880px){
  .app-tabbar{
    left: 50%;
    transform: translateX(-50%);
    max-width: 1000px;
    border-left: 1px solid var(--border);
    border-right: 1px solid var(--border);
    border-top-left-radius: 16px;
    border-top-right-radius: 16px;
  }
}
@media (max-width: 680px){
  .app-insights-grid{
    grid-template-columns: 1fr;
  }
  .app-insight-filters{
    grid-template-columns: 1fr;
  }
}

/* =========================================================
   Final Product UI Layer (visual only, no logic changes)
   ========================================================= */
:root{
  --primary:#2563eb;
  --primaryText:#ffffff;
  --danger:#d14343;
  --dangerText:#ffffff;
  --chipBg:var(--chip-bg);
  --chipText:var(--chip-text);
  --inputBg:var(--input-bg);
  --inputText:var(--input-text);
  --inputBorder:var(--input-border);
  --tabBg:rgba(245,245,247,.88);
  --tabText:var(--muted);
  --tabActiveBg:var(--panel);
  --tabActiveText:var(--text);

  --accent:var(--primary);
  --radius:16px;
  --radius-sm:12px;
  --shadow:0 12px 28px rgba(17,18,20,.12);
}
:root[data-theme-mode="dark"]{
  --primary:#8fb6ff;
  --primaryText:#0c111f;
  --danger:#ff847e;
  --dangerText:#2a1110;
  --tabBg:rgba(11,11,15,.86);
  --tabText:rgba(245,245,247,.72);
  --tabActiveBg:var(--panel2);
  --tabActiveText:var(--text);
  --shadow:0 12px 28px rgba(0,0,0,.42);
}

html, body{
  background:var(--bg);
  color:var(--text);
}
body{
  letter-spacing:-.01em;
}
main{
  width:min(1100px, 100%);
  margin:0 auto;
  padding-left:16px;
  padding-right:16px;
}

.topbar{
  background:var(--bar-bg) !important;
  border-bottom:1px solid var(--bar-border) !important;
  box-shadow:0 1px 0 rgba(127,127,127,.06);
}
.topbar-inner{
  max-width:1100px;
}
.topbar .brand-title{
  font-weight:740;
  letter-spacing:-.02em;
}
.topbar .brand-sub{
  color:var(--muted);
}

.hero,
.card,
.sheet,
.menu-panel,
.app-page-block,
.app-home-current,
.app-home-reco,
.app-preset-card,
.app-inbox-item,
.app-ins-card,
.summary-card,
.insight-card,
.notify-item,
.search-item,
.wrong-item,
.admin-notif-item,
.admin-notif-editor,
.settings-group,
.backup-settings-card,
.drawer-share-panel,
.ui-modal-card{
  background:var(--panel) !important;
  color:var(--text);
  border:1px solid var(--border) !important;
  border-radius:16px;
  box-shadow:var(--shadow);
}
.app-preset-card,
.app-ins-card,
.app-home-reco,
.app-settings-row,
.settings-row,
.app-inbox-item{
  background:var(--panel2) !important;
}

/* Settings: unify all settings pages with Sound-like card rows */
#settingsOverlay #settingsMainPane .settings-group{
  display:grid;
  gap:10px;
  padding:0;
  border:0 !important;
  background:transparent !important;
  box-shadow:none !important;
  border-radius:0 !important;
  overflow:visible !important;
}
#settingsOverlay #settingsMainPane .settings-row,
#settingsOverlay #settingsMainPane .settings-cell{
  display:flex;
  align-items:center;
  justify-content:space-between;
  min-height:52px;
  padding:0 16px;
  border-radius:18px;
  border:1px solid var(--border) !important;
  background:var(--panel) !important;
  box-sizing:border-box;
  gap:12px;
}
#settingsOverlay #settingsMainPane .settings-row .label,
#settingsOverlay #settingsMainPane .settings-cell .label{
  font-size:15px;
  font-weight:600;
  line-height:1;
}
#settingsOverlay #settingsMainPane .settings-row .right,
#settingsOverlay #settingsMainPane .settings-cell .right{
  display:flex;
  align-items:center;
  justify-content:flex-end;
  gap:10px;
  line-height:1;
  min-height:32px;
  flex-shrink:0;
  margin-left:auto;
}
#settingsOverlay #settingsMainPane .settings-row .toggle{
  display:flex;
  align-items:center;
}
#settingsOverlay #settingsMainPane .settings-row .settings-seg{
  display:inline-flex;
  align-items:center;
  justify-content:flex-end;
  gap:6px;
}
#settingsOverlay #settingsMainPane .settings-row .settings-select{
  margin-left:0;
}
#settingsOverlay #settingsMainPane .settings-row:last-child{
  border-bottom:1px solid var(--border) !important;
}

.sheet-header,
.sheet-footer,
.settings-nav,
.menu-header{
  background:var(--panel2) !important;
  border-color:var(--border) !important;
}
.menu-header{
  position:sticky;
  top:0;
  z-index:3;
}
.menu-content{
  padding-top:8px;
}
.menu-title{
  letter-spacing:.04em;
}

.btn,
.navbtn,
.textbtn,
.cta,
.icon-btn,
.choice-btn,
.search-item,
.app-chat-intent-btn,
.xselect-trigger,
.xselect-option,
.app-tab-btn,
.drawer-share-tab,
.menu-item,
.settings-row,
.app-settings-row{
  min-height:44px;
  border-radius:15px;
  border:1px solid var(--btn-border) !important;
  background:var(--btn-bg) !important;
  color:var(--btn-text) !important;
  box-shadow: 0 4px 12px rgba(15,23,42,.06);
  transition:
    transform .24s cubic-bezier(0.22, 1, 0.36, 1),
    opacity .24s cubic-bezier(0.22, 1, 0.36, 1),
    filter .24s cubic-bezier(0.22, 1, 0.36, 1),
    box-shadow .24s cubic-bezier(0.22, 1, 0.36, 1),
    border-color .24s cubic-bezier(0.22, 1, 0.36, 1),
    background .24s cubic-bezier(0.22, 1, 0.36, 1);
  transition-property: transform, opacity, filter, box-shadow, border-color, background;
}
@media (hover:hover) and (pointer:fine){
  .btn:hover,
  .navbtn:hover,
  .textbtn:hover,
  .cta:hover,
  .icon-btn:hover,
  .choice-btn:hover,
  .search-item:hover,
  .app-chat-intent-btn:hover,
  .xselect-trigger:hover,
  .xselect-option:hover,
  .app-tab-btn:hover,
  .drawer-share-tab:hover,
  .menu-item:hover,
  .settings-row:hover,
  .app-settings-row:hover{
    transform:translateY(-1px) !important;
    filter:brightness(1.01);
    box-shadow:0 10px 20px rgba(15,23,42,.10);
    border-color:var(--border);
  }
}
.xselect-trigger,
.xselect-option{
  border:0 !important;
}
.xselect-option{
  border-radius:0 !important;
  background:transparent !important;
  box-shadow:none !important;
}
.xselect-menu{
  border:0 !important;
  background:var(--panel) !important;
  box-shadow:0 10px 22px rgba(17,18,20,.08) !important;
  padding:0 !important;
}
.xselect-option.is-selected{
  border-color:transparent !important;
  box-shadow:none !important;
}
.xselect-trigger:focus-visible{
  border-color:transparent !important;
}
@media (hover:hover) and (pointer:fine){
  .xselect-trigger:hover,
  .xselect-option:hover{
    border-color:transparent !important;
    box-shadow:none !important;
  }
}
.btn:active,
.navbtn:active,
.textbtn:active,
.cta:active,
.icon-btn:active,
.app-tab-btn:active,
.drawer-share-tab:active,
.menu-item:active,
.settings-row:active,
.app-settings-row:active{
  transform:translateY(0) scale(.985);
}
.btn[disabled],
.navbtn[disabled],
.textbtn[disabled],
.cta[disabled],
.icon-btn[disabled],
.app-tab-btn[disabled],
.drawer-share-tab[disabled],
.menu-item[disabled],
.settings-row[disabled],
.app-settings-row[disabled]{
  opacity:.56;
  cursor:not-allowed;
  box-shadow:none;
}
.app-tab-btn{
  border-radius: 999px;
}

.btn.primary,
.navbtn.primary,
.textbtn.primary,
.cta.primary{
  background:var(--primary) !important;
  color:var(--primaryText) !important;
  border-color:transparent !important;
}
.btn.secondary,
.navbtn.secondary,
.textbtn.secondary,
.cta.secondary{
  background:var(--panel2) !important;
  color:var(--text) !important;
  border-color:var(--border) !important;
}
.btn.danger,
.navbtn.danger,
.textbtn.danger,
.cta.danger{
  background:var(--danger) !important;
  color:var(--dangerText) !important;
  border-color:transparent !important;
}

#viewQuiz .controls .navbtn{
  background:var(--panel2) !important;
  color:var(--text) !important;
  border-color:var(--border) !important;
}
#viewQuiz .controls .navbtn[disabled]{
  background:var(--panel2) !important;
  color:var(--muted) !important;
}

/* hover jitter fix (PC): keep hitbox stable, avoid hover on/off loops */
@media (hover:hover) and (pointer:fine){
  button:not(.btn):not(.navbtn):not(.textbtn):not(.app-tab-btn):not(.search-item):hover,
  [role="button"]:not(.btn):not(.navbtn):not(.textbtn):not(.app-tab-btn):not(.search-item):hover,
  [data-action]:hover,
  [data-rt-battle-action]:hover{
    transform:none !important;
  }
}

/* decorative overlays should not steal hover/click */
#onlineOverlay .ov-bg,
#rt3dOverlay .b3d-bg{
  pointer-events:none;
}
#onlineOverlay .ov-shell,
#rt3dOverlay .b3d-shell{
  pointer-events:auto;
}

.choice-btn{
  border-radius:14px;
  background:var(--panel) !important;
  border:1px solid var(--border) !important;
}

input[type="text"],
input[type="email"],
input[type="number"],
input[type="datetime-local"],
input[type="search"],
textarea,
select,
.select,
.spell-input{
  min-height:44px;
  border-radius:13px;
  border:1px solid var(--inputBorder) !important;
  background:var(--inputBg) !important;
  color:var(--inputText) !important;
  transition:
    border-color .22s cubic-bezier(0.22, 1, 0.36, 1),
    box-shadow .22s cubic-bezier(0.22, 1, 0.36, 1),
    background-color .22s cubic-bezier(0.22, 1, 0.36, 1);
}
textarea{
  min-height:96px;
}
input::placeholder,
textarea::placeholder{
  color:var(--muted);
}
input:focus,
textarea:focus,
select:focus{
  outline:none;
  border-color:var(--primary) !important;
  box-shadow:0 0 0 3px color-mix(in srgb, var(--primary) 24%, transparent);
}

.subject-badge,
.tag-chip,
.badge,
.pill,
.start-chip,
.deck-tab{
  background:var(--chipBg) !important;
  color:var(--chipText) !important;
  border:1px solid var(--border) !important;
}
.tag-chip.is-selected{
  background:color-mix(in srgb, var(--primary) 14%, var(--chipBg)) !important;
  color:var(--text) !important;
  border-color:color-mix(in srgb, var(--primary) 42%, var(--border)) !important;
}

.table-wrap{
  border:1px solid var(--border) !important;
  border-radius:14px;
  overflow:hidden;
  background:var(--panel) !important;
}
.table-wrap table,
table{
  width:100%;
  border-collapse:collapse;
  background:transparent;
  color:var(--text);
}
.table-wrap th,
.table-wrap td,
table th,
table td{
  border-bottom:1px solid var(--border);
  padding:10px 12px;
  text-align:left;
  vertical-align:top;
}
.table-wrap th,
table thead th{
  background:var(--panel2) !important;
  color:var(--text);
  font-weight:700;
}
.table-wrap tr:last-child td,
table tbody tr:last-child td{
  border-bottom:0;
}

.app-page-head h2{
  font-size:24px;
  letter-spacing:-.02em;
}
.app-page-head p,
.app-home-current-k,
.app-home-current-sub,
.app-home-reco-body,
.app-inbox-meta,
.app-empty,
.summary-k,
.insight-note,
.drawer-share-status,
.drawer-share-sub,
.drawer-share-link,
.menu-item .meta,
.settings-row .value,
.sheet-sub{
  color:var(--muted) !important;
}

.app-home-current-v,
.app-home-reco-title,
.app-inbox-title,
.app-detail-title,
.app-ins-v,
.summary-v,
.insight-title{
  color:var(--text) !important;
}

/* Home responsive safety: avoid clipping preset area on small screens */
body[data-app-tab="home"] main{
  padding-bottom: calc(92px + env(safe-area-inset-bottom, 0px)) !important;
}
body[data-app-tab="home"] #viewTitle{
  overflow: visible;
}
body[data-app-tab="home"] #viewTitle .hero{
  overflow: visible;
  min-height: 0;
  height: auto;
}
.home-preset-row{
  display: flex;
  gap: 10px;
  align-items: center;
  flex-wrap: wrap;
}
body[data-app-tab="home"] .home-preset-row .seg{
  display: flex;
  flex-wrap: nowrap;
  flex: 1 1 100%;
  min-width: 0;
  max-width: 100%;
  overflow-x: auto;
  overflow-y: hidden;
  -webkit-overflow-scrolling: touch;
  white-space: nowrap;
  padding-bottom: 2px;
  scrollbar-width: thin;
}
body[data-app-tab="home"] .home-preset-row .seg button{
  flex: 0 0 auto;
}
body[data-app-tab="home"] .home-preset-row .navbtn{
  flex: 0 0 auto;
}

/* Insights tab layout: strict vertical flow, no overlaying panels */
#appInsightsPage{
  display: none;
  gap: 18px;
  align-content: start;
  position: relative;
}
body[data-app-tab="insight"] #appInsightsPage{
  display: grid !important;
}
#appInsightsPage .app-page-head{
  margin-bottom: 0;
}
#appInsightsPage .app-page-block{
  margin: 0;
  padding: 16px;
  position: relative;
  z-index: 0;
  overflow: hidden;
}
#appInsightsPage .app-insight-filters{
  position: static !important;
  z-index: auto !important;
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 12px;
  background: var(--panel2);
  border: 1px solid var(--border);
  border-radius: 14px;
  padding: 12px;
  align-items: stretch;
  isolation: isolate;
}
#appInsightsPage .app-insight-filters > .settings-row{
  width: 100%;
  min-height: 0;
  padding: 10px 12px !important;
  border-radius: 12px;
  border: 1px solid var(--border);
  background: var(--panel);
  display: block !important;
  gap: 8px;
  align-content: start;
  box-sizing: border-box;
  margin: 0 !important;
  position: relative !important;
  z-index: 0 !important;
}
#appInsightsPage .app-insight-filters > .settings-row .label{
  display: block;
  font-size: 12px;
  line-height: 1.25;
  color: var(--muted);
  margin: 0 0 6px;
}
#appInsightsPage .app-insight-filters > .settings-row .settings-select,
#appInsightsPage .app-insight-filters > .settings-row select{
  width: 100%;
  min-width: 0;
  max-width: none;
  margin-left: 0 !important;
  min-height: 40px;
  display: block !important;
  position: relative !important;
  float: none !important;
}
#appInsightsPage .table-wrap,
#appInsightsPage .chart,
#appInsightsPage .app-insights-grid{
  position: relative;
  z-index: 0;
}

.app-tabbar{
  background:var(--tabBg) !important;
  border-top:1px solid var(--border) !important;
  bottom: 0 !important;
  padding:8px 10px calc(env(safe-area-inset-bottom, 0px) + 10px) !important;
  backdrop-filter:saturate(130%) blur(10px);
}
.app-tab-btn{
  min-height:44px;
  background:transparent !important;
  color:var(--tabText) !important;
  border:1px solid transparent !important;
}
.app-tab-btn.is-active{
  background:var(--tabActiveBg) !important;
  color:var(--tabActiveText) !important;
  border-color:var(--border) !important;
}

.notif-dot{
  width:8px;
  height:8px;
  background:#ef4444;
  box-shadow:0 0 0 2px var(--panel);
}

.overlay{
  background:rgba(15,18,27,.38);
}
:root[data-theme-mode="dark"] .overlay{
  background:rgba(0,0,0,.56);
}

.view.active,
.overlay:not(.hidden),
.overlay:not(.hidden) .sheet{
  animation-duration:.26s;
  animation-timing-function:cubic-bezier(0.22, 1, 0.36, 1);
}

@media (max-width: 720px){
  main{
    padding-left:12px;
    padding-right:12px;
  }
  .app-page-head h2{
    font-size:22px;
  }
  .app-home-quick{
    gap:10px;
  }
  #viewTitle .actions{
    grid-template-columns: 1fr;
  }
  .app-home-current{
    flex-direction: column;
    align-items: flex-start;
  }
  .app-home-quick{
    display: grid;
    grid-template-columns: 1fr;
  }
  .app-chat-chip-row{
    overflow-x:auto;
    overflow-y:hidden;
    -webkit-overflow-scrolling:touch;
    flex-wrap:nowrap;
    white-space:nowrap;
    padding-bottom:2px;
  }
  .app-chat-chip{
    flex:0 0 auto;
  }
  .app-chat-intent-top{
    grid-template-columns: 1fr;
  }
  .app-chat-intent-auto{
    width: 100%;
  }
  .app-chat-shell{
    min-height: min(74dvh, 820px);
    padding: 10px;
  }
  .app-chat-head{
    margin: -10px -10px 0;
    padding: 10px;
  }
  .app-chat-scroll{
    min-height: 220px;
    padding: 8px;
  }
  .app-chat-composer{
    bottom: calc(env(safe-area-inset-bottom, 0px) + 8px);
  }
  .app-chat-input{
    font-size: 16px;
  }
  .app-chat-msg{
    max-width:100%;
  }
  #appInsightsPage .app-insight-filters{
    display: flex !important;
    flex-direction: column !important;
    gap: 10px;
    padding: 10px;
  }
  #appInsightsPage .app-insight-filters > .settings-row{
    width: 100% !important;
  }
  .btn,
  .navbtn,
  .textbtn,
  .cta,
  .icon-btn,
  .app-settings-row,
  .settings-row{
    min-height:46px;
  }
}

@media (prefers-reduced-motion: reduce){
  .btn,
  .navbtn,
  .textbtn,
  .cta,
  .icon-btn,
  .app-tab-btn,
  .drawer-share-tab,
  .menu-item,
  .settings-row,
  .app-settings-row,
  input,
  textarea,
  select,
  #firstLaunchOverlay,
  .first-launch-shell,
  .first-launch-phase,
  .first-launch-welcome-text,
  .first-launch-welcome-badge,
  .view.active,
  .overlay:not(.hidden),
  .overlay:not(.hidden) .sheet{
    animation:none !important;
    transition:none !important;
    transform:none !important;
  }
}

/* =========================
   Auth Gate + Account UI
   ========================= */
body.auth-booting .app{
  display: none !important;
}
body.first-launch-open{
  overflow: hidden;
}
body.auth-gate-open{
  overflow: hidden;
}
body.auth-gate-open .app{
  display: none !important;
}
#authBootSplash{
  display: none !important;
}
#firstLaunchOverlay{
  position: fixed;
  inset: 0;
  z-index: 999999;
  display: grid;
  place-items: center;
  padding: 16px;
  background:
    radial-gradient(120% 120% at 50% 0%, color-mix(in oklab, var(--panel2) 72%, transparent), transparent 58%),
    linear-gradient(180deg, color-mix(in oklab, var(--bg) 88%, var(--panel2)) 0%, var(--bg) 70%);
  opacity: 0;
  transform: translateY(6px);
  pointer-events: none;
  transition: opacity .36s cubic-bezier(0.22, 1, 0.36, 1), transform .36s cubic-bezier(0.22, 1, 0.36, 1);
}
#firstLaunchOverlay.is-active{
  opacity: 1;
  transform: translateY(0);
  pointer-events: auto;
}
#firstLaunchOverlay.is-leaving{
  opacity: 0;
  transform: translateY(-6px) scale(.995);
  pointer-events: none;
}
#firstLaunchOverlay.hidden{
  display: none;
}
.first-launch-shell{
  width: min(560px, 94vw);
  min-height: min(440px, 78vh);
  display: grid;
  place-items: center;
  transition: opacity .34s cubic-bezier(0.22, 1, 0.36, 1), transform .34s cubic-bezier(0.22, 1, 0.36, 1);
}
#firstLaunchOverlay.is-leaving .first-launch-shell{
  opacity: 0;
  transform: translateY(-14px) scale(.985);
}
#firstLaunchStage{
  width: 100%;
  display: grid;
  place-items: center;
}
.first-launch-phase{
  display: none;
  width: 100%;
  opacity: 0;
  transform: translateY(10px) scale(.99);
}
#firstLaunchStage[data-stage="loading"] .first-launch-phase.is-loading{
  display: grid;
  place-items: center;
  opacity: 1;
  transform: translateY(0) scale(1);
  animation: firstLaunchPhaseIn .38s cubic-bezier(0.22, 1, 0.36, 1);
}
#firstLaunchStage[data-stage="welcome"] .first-launch-phase.is-welcome{
  display: grid;
  place-items: center;
  opacity: 1;
  transform: translateY(0) scale(1);
  animation: firstLaunchPhaseIn .44s cubic-bezier(0.22, 1, 0.36, 1);
}
.first-launch-loader{
  position: relative;
  width: 96px;
  height: 96px;
  border-radius: 50%;
  border: 1px solid var(--border);
  background: color-mix(in oklab, var(--panel) 86%, transparent);
  box-shadow: var(--shadow);
  display: grid;
  place-items: center;
}
.first-launch-loader .first-launch-icon{
  font-size: 42px;
  color: color-mix(in oklab, var(--text) 78%, transparent);
}
.first-launch-loader .first-launch-spinner{
  position: absolute;
  inset: 12px;
  border-radius: 50%;
  border: 2px solid color-mix(in oklab, var(--border) 70%, transparent);
  border-top-color: color-mix(in oklab, var(--text) 42%, transparent);
  animation: spin .8s linear infinite;
}
.first-launch-welcome{
  width: 100%;
  display: grid;
  place-items: center;
  padding-top: clamp(8vh, 12vh, 16vh);
}
.first-launch-welcome-badge{
  width: 84px;
  height: 84px;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: color-mix(in oklab, var(--panel2) 82%, transparent);
  box-shadow: var(--shadow);
  display: grid;
  place-items: center;
  margin-bottom: 18px;
  animation: firstLaunchBadgeFloat 2.4s ease-in-out infinite;
}
.first-launch-welcome-icon{
  font-size: 36px;
  color: color-mix(in oklab, var(--text) 76%, transparent);
}
.first-launch-welcome-text{
  margin: 0;
  font-size: clamp(20px, 6vw, 46px);
  font-weight: 760;
  letter-spacing: .02em;
  color: var(--text);
  text-align: center;
  white-space: nowrap;
  opacity: 0;
  transform: translateY(10px) scale(.985);
  filter: blur(3px);
  animation: firstLaunchWelcomeIn .72s cubic-bezier(0.22, 1, 0.36, 1) forwards;
}
#firstLaunchOverlay.is-leaving #firstLaunchStage[data-stage="welcome"] .first-launch-welcome-text{
  animation: firstLaunchWelcomeOut .34s cubic-bezier(0.4, 0, 1, 1) forwards;
}
@keyframes firstLaunchPhaseIn{
  from{ opacity: 0; transform: translateY(12px) scale(.985); }
  to{ opacity: 1; transform: translateY(0) scale(1); }
}
@keyframes firstLaunchBadgeFloat{
  0%,100%{ transform: translateY(0); }
  50%{ transform: translateY(-6px); }
}
@keyframes firstLaunchWelcomeIn{
  from{ opacity: 0; transform: translateY(10px) scale(.985); filter: blur(3px); letter-spacing: .06em; }
  to{ opacity: 1; transform: translateY(0) scale(1); filter: blur(0); letter-spacing: .02em; }
}
@keyframes firstLaunchWelcomeOut{
  from{ opacity: 1; transform: translateY(0) scale(1); filter: blur(0); }
  to{ opacity: 0; transform: translateY(-10px) scale(.98); filter: blur(2px); }
}
.auth-gate{
  position: fixed;
  inset: 0;
  z-index: 168;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: clamp(14px, 3vw, 28px);
  background:
    radial-gradient(120% 120% at 50% 0%, color-mix(in oklab, var(--panel2) 68%, transparent), transparent 58%),
    linear-gradient(180deg, color-mix(in oklab, var(--bg) 86%, var(--panel2)) 0%, var(--bg) 68%);
  opacity: 0;
  transform: translateY(8px);
  pointer-events: none;
  transition: opacity .26s cubic-bezier(0.22, 1, 0.36, 1), transform .26s cubic-bezier(0.22, 1, 0.36, 1);
}
body.auth-gate-open .auth-gate{
  opacity: 1;
  transform: translateY(0);
  pointer-events: auto;
}
.auth-gate.hidden{
  display: none;
}
.auth-gate-card{
  width: min(560px, 92vw);
  max-height: min(92dvh, 820px);
  overflow: auto;
  -webkit-overflow-scrolling: touch;
  background: transparent;
  border: 0;
  border-radius: 22px;
  box-shadow: none;
  padding: clamp(18px, 3vw, 26px);
  display: grid;
  gap: 16px;
}
.auth-gate-head{
  display: grid;
  gap: 10px;
}
.auth-gate-title{
  margin: 0;
  font-size: clamp(28px, 6vw, 44px);
  font-weight: 760;
  letter-spacing: .01em;
  color: var(--accent);
}
.auth-gate-sub{
  margin: 0;
  color: var(--muted);
  font-size: 0.92rem;
  line-height: 1.6;
}
.auth-gate-seg{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:8px;
  border:1px solid var(--border);
  border-radius:999px;
  padding:6px;
  background: color-mix(in oklab, var(--panel2) 78%, transparent);
}
.auth-gate-seg-btn{
  min-height:44px;
  border:0;
  border-radius:999px;
  background:transparent;
  color:var(--muted);
  font-size:0.94rem;
  font-weight:700;
  cursor:pointer;
}
.auth-gate-seg-btn.active{
  background:var(--panel);
  color:var(--text);
  box-shadow:0 8px 22px rgba(15,18,27,.12);
}
.auth-gate-panels{
  display: grid;
  gap: 14px;
}
.auth-gate-panel{
  display: none;
  gap: 10px;
  animation: authPanelIn .35s cubic-bezier(0.22, 1, 0.36, 1);
}
.auth-gate-panel.is-active{
  display: grid;
}
.auth-gate-panel[data-auth-panel="welcome"]{
  min-height: clamp(280px, 48vh, 420px);
  place-items: center;
  align-content: start;
  padding-top: clamp(11vh, 15vh, 19vh);
}
.auth-welcome-mark{
  font-size: clamp(24px, 5.4vw, 40px);
  font-weight: 760;
  color: var(--text);
  text-align: center;
  letter-spacing: .02em;
  opacity: 0;
  transform: translateY(8px);
  animation: authWelcomeIn .6s cubic-bezier(0.22, 1, 0.36, 1) forwards;
}
@keyframes authWelcomeIn{
  from{ opacity: 0; transform: translateY(8px); }
  to{ opacity: 1; transform: translateY(0); }
}
@keyframes authPanelIn{
  from{ opacity: 0; transform: translateY(10px) scale(.985); }
  to{ opacity: 1; transform: translateY(0) scale(1); }
}
.auth-gate-actions{
  display: grid;
  gap: 12px;
}
.auth-gate-btn{
  min-height: 52px;
  border-radius: 16px;
  justify-content: flex-start;
  text-align: left;
  padding: 14px 16px;
}
.auth-gate-btn.primary{
  border-color: rgba(31, 42, 68, .26);
  background: rgba(31, 42, 68, .08);
  color: var(--accent);
  font-weight: 700;
}
.auth-gate-btn.secondary{
  background: var(--panel2);
}
.auth-gate-btn.ghost{
  background: transparent;
}
.auth-gate-btn .label{
  font-size: 1.05rem;
  font-weight: 720;
}
.auth-gate-btn .desc{
  margin-top: 2px;
  font-size: .86rem;
  color: var(--muted);
}
.auth-gate-row{
  display: grid;
  gap: 8px;
}
.auth-gate-label{
  font-size: 12px;
  font-weight: 620;
  color: var(--muted);
}
.auth-gate .spell-input,
.auth-gate .select{
  min-height: 52px !important;
  border-radius: 14px !important;
  border-width: 1px !important;
  padding: 0 14px !important;
  font-size: 1rem !important;
}
.auth-gate .auth-line-input{
  background: transparent !important;
  border: 0 !important;
  border-bottom: 1px solid var(--input-border) !important;
  border-radius: 0 !important;
  min-height: 48px !important;
  padding: 8px 2px 10px !important;
}
.auth-gate .spell-input:focus,
.auth-gate .select:focus{
  outline: none;
  border-color: color-mix(in oklab, var(--accent) 35%, var(--input-border));
  box-shadow: 0 0 0 3px color-mix(in oklab, var(--focus) 72%, transparent);
}
.auth-gate .auth-line-input:focus{
  box-shadow: none !important;
  border-bottom-color: color-mix(in oklab, var(--accent) 45%, var(--input-border)) !important;
}
.auth-gate .auth-line-select{
  appearance: none;
  -webkit-appearance: none;
  background: transparent !important;
  border: 0 !important;
  border-bottom: 1px solid var(--input-border) !important;
  border-radius: 0 !important;
  min-height: 48px !important;
  padding: 8px 28px 10px 2px !important;
}
.auth-gate .auth-line-select:focus{
  box-shadow: none !important;
  border-bottom-color: color-mix(in oklab, var(--accent) 45%, var(--input-border)) !important;
}
.auth-gate-inline{
  display: flex;
  align-items: center;
  gap: 8px;
}
.auth-gate-inline > *{
  flex: 1 1 auto;
}
.auth-gate-grade{
  min-height: 44px;
  min-width: 120px;
}
.auth-gate-status{
  font-size: 12px;
  line-height: 1.5;
  color: var(--muted);
}
.auth-gate-panel .auth-gate-status{
  display: none;
}
.auth-gate-status-global{
  display:block;
  min-height: 20px;
  margin-top: 4px;
}
.auth-gate-status.ok{
  color: #0b6b47;
}
.auth-gate-status.error{
  color: #c1121f;
}
.auth-gate-mini{
  font-size: 12px;
  color: var(--muted);
  line-height: 1.6;
}
.auth-gate-tos-wrap{
  border: 1px solid var(--border);
  border-radius: 14px;
  background: var(--panel2);
  padding: 10px 10px 12px;
  display: grid;
  gap: 10px;
}
.auth-gate-tos-scroll{
  max-height: 260px;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
  border: 1px solid var(--border);
  border-radius: 12px;
  background: var(--panel);
  padding: 12px 12px;
  line-height: 1.65;
}
.auth-gate-tos-scroll h4{
  margin: 0 0 8px;
  font-size: 14px;
  color: var(--accent);
}
.auth-gate-tos-scroll p{
  margin: 0 0 10px;
  font-size: 13px;
  color: var(--text);
}
.auth-gate-tos-scroll p:last-child{
  margin-bottom: 0;
}
.auth-gate-checks{
  display: grid;
  gap: 8px;
}
.auth-gate-check{
  display: flex;
  align-items: center;
  gap: 8px;
  color: var(--text);
  font-size: 13px;
}
.auth-gate-check input{
  width: 18px;
  height: 18px;
}
.auth-gate-foot{
  display: flex;
  gap: 10px;
  justify-content: flex-end;
  flex-wrap: wrap;
}
.auth-gate-foot-between{
  justify-content: space-between;
}
.auth-confirm-card{
  border: 1px solid var(--border);
  border-radius: 16px;
  background: color-mix(in oklab, var(--panel2) 80%, transparent);
  padding: 12px;
  display: grid;
  gap: 12px;
}
.auth-confirm-value{
  min-height: 24px;
  color: var(--text);
  font-size: 1rem;
  font-weight: 650;
  letter-spacing: .01em;
}
.auth-like-seg{
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
}
.auth-like-btn{
  min-height: 48px;
  border: 1px solid var(--border);
  border-radius: 999px;
  background: var(--panel2);
  color: var(--text);
  font-size: .95rem;
  font-weight: 680;
  cursor: pointer;
}
.auth-like-btn.active{
  background: color-mix(in oklab, var(--accent) 12%, var(--panel));
  border-color: color-mix(in oklab, var(--accent) 45%, var(--border));
}
.auth-profile-steps{
  position: relative;
}
.auth-profile-step{
  display: none;
  gap: 10px;
}
.auth-profile-step.is-active{
  display: grid;
  animation: authQuestionIn .34s cubic-bezier(0.22, 1, 0.36, 1);
}
.auth-profile-nav-left{
  display: inline-flex;
  align-items: center;
  gap: 8px;
}
@keyframes authQuestionIn{
  from{ opacity: 0; transform: translateY(10px) scale(.99); }
  to{ opacity: 1; transform: translateY(0) scale(1); }
}
.auth-badge{
  display: inline-flex;
  align-items: center;
  gap: 6px;
  border: 1px solid var(--border);
  border-radius: 999px;
  padding: 4px 10px;
  font-size: 11px;
  color: var(--muted);
  background: var(--chip-bg);
}
#authGuestBadge.hidden{
  display: none;
}
.account-user-card{
  border: 1px solid var(--border);
  border-radius: 14px;
  background: var(--panel2);
  padding: 10px 12px;
  display: grid;
  gap: 6px;
}
.account-user-title{
  font-size: 13px;
  font-weight: 650;
  color: var(--text);
}
.account-user-meta{
  font-size: 12px;
  color: var(--muted);
  line-height: 1.5;
}
@media (max-width: 640px){
  .auth-gate{
    padding: 14px;
  }
  .auth-gate-card{
    width: min(560px, 100%);
    border-radius: 18px;
    padding: 16px;
  }
  .auth-gate-title{
    font-size: clamp(28px, 9vw, 38px);
  }
}

#globalLoadingOverlay{
  position: fixed;
  inset: 0;
  z-index: 172;
  display: grid;
  place-items: center;
  background: color-mix(in oklab, var(--bg) 72%, transparent);
  backdrop-filter: saturate(110%) blur(2px);
}
#globalLoadingOverlay.hidden{
  display: none;
}
.app-loading-card{
  position: relative;
  width: 72px;
  height: 72px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border: 1px solid var(--border);
  background: var(--panel);
  color: var(--text);
  border-radius: 50%;
  box-shadow: var(--shadow);
}
.app-loading-spinner{
  position: absolute;
  width: 60px;
  height: 60px;
  border: 2px solid color-mix(in oklab, var(--border) 70%, transparent);
  border-top-color: color-mix(in oklab, var(--text) 42%, transparent);
  border-radius: 50%;
  animation: spin .78s linear infinite;
}
.app-loading-icon{
  font-size: 30px;
  color: color-mix(in oklab, var(--text) 72%, transparent);
}
@keyframes spin{
  to{ transform: rotate(360deg); }
}

/* =========================
   Chat UI Refresh (white / ChatGPT-like)
   ========================= */
:root{
  --chat-page-bg:#f6f7fb;
  --chat-surface:#ffffff;
  --chat-surface-soft:#f3f5f9;
  --chat-bubble-user:#eaf1ff;
  --chat-bubble-ai:#ffffff;
  --chat-border:rgba(15,23,42,.10);
  --chat-muted:#667085;
  --chat-send-bg:#111827;
  --chat-send-text:#ffffff;
}
:root[data-theme-mode="dark"]{
  --chat-page-bg:#11131a;
  --chat-surface:#171b24;
  --chat-surface-soft:#1e2430;
  --chat-bubble-user:#1f2937;
  --chat-bubble-ai:#171b24;
  --chat-border:rgba(255,255,255,.14);
  --chat-muted:rgba(245,246,247,.68);
  --chat-send-bg:#8fb6ff;
  --chat-send-text:#0c111f;
}
#appChatPage{
  padding-top: 2px;
  padding-bottom: calc(220px + env(safe-area-inset-bottom, 0px));
}
.app-chat-shell{
  border: 1px solid var(--chat-border) !important;
  border-radius: 24px !important;
  background: var(--chat-page-bg) !important;
  min-height: calc(100dvh - 210px) !important;
  padding: 0 !important;
  gap: 0 !important;
  overflow: hidden;
}
.app-chat-head{
  position: sticky;
  top: 0;
  z-index: 4;
  margin: 0 !important;
  padding: 16px 16px 12px !important;
  border-bottom: 1px solid var(--chat-border) !important;
  background: var(--chat-surface) !important;
  backdrop-filter: none !important;
}
.app-chat-head h2{
  font-size: 21px;
  font-weight: 740;
}
.app-chat-head p,
.app-chat-mode-note{
  color: var(--chat-muted) !important;
}
.app-chat-mode-row{
  margin-top: 10px;
  gap: 7px;
}
.app-chat-mode-btn{
  min-height: 36px;
  border-radius: 999px;
  border: 1px solid var(--chat-border);
  background: var(--chat-surface-soft);
  color: var(--text);
}
.app-chat-mode-btn.is-active{
  background: color-mix(in srgb, var(--chat-surface) 82%, var(--accentSoft, rgba(37,99,235,.16)));
  border-color: color-mix(in srgb, var(--chat-border) 58%, var(--accent, #2563eb));
}
.app-chat-intent-browser{
  margin: 12px 14px 0;
  border: 1px solid var(--chat-border);
  background: var(--chat-surface);
  border-radius: 16px;
  padding: 10px;
}
.app-chat-intent-search{
  background: var(--chat-surface-soft);
  border-color: var(--chat-border);
  border-radius: 12px;
}
.app-chat-intent-auto{
  border-color: var(--chat-border);
  background: var(--chat-surface-soft);
  color: var(--text);
}
.app-chat-intent-groups{
  max-height: min(28dvh, 240px);
}
.app-chat-intent-group{
  background: var(--chat-surface-soft);
  border-color: var(--chat-border);
}
.app-chat-intent-group-body{
  border-top-color: var(--chat-border);
}
.app-chat-intent-btn,
.app-chat-chip,
.app-chat-action{
  border: 1px solid var(--chat-border);
  background: var(--chat-surface);
  color: var(--text);
}
.app-chat-chip-row{
  margin: 10px 14px 0;
  gap: 7px;
}
.app-chat-meta{
  margin: 8px 14px 0;
  padding: 0 2px;
  color: var(--chat-muted);
}
.app-chat-scroll{
  margin: 10px 14px 0;
  border: 1px solid var(--chat-border);
  border-radius: 18px;
  background: var(--chat-page-bg);
  padding: 14px 12px;
  min-height: 340px;
  padding-bottom: 20px;
}
.app-chat-list{
  gap: 14px;
}
.app-chat-msg{
  max-width: min(86%, 760px);
}
.app-chat-msg.is-user{
  margin-left: auto;
}
.app-chat-msg.is-ai,
.app-chat-msg.is-typing{
  margin-right: auto;
}
.app-chat-role,
.app-chat-time{
  color: var(--chat-muted);
  font-size: 11px;
}
.app-chat-bubble{
  border: 1px solid var(--chat-border);
  border-radius: 18px;
  background: var(--chat-bubble-ai);
  color: var(--text);
  padding: 11px 14px;
  line-height: 1.65;
  font-size: 14px;
  box-shadow: 0 4px 14px rgba(15,23,42,.05);
}
.app-chat-msg.is-user .app-chat-bubble{
  background: var(--chat-bubble-user);
  border-color: color-mix(in srgb, var(--chat-border) 68%, rgba(59,130,246,.35));
}
.app-chat-msg.is-typing .app-chat-bubble{
  background: var(--chat-surface-soft);
  color: var(--chat-muted);
}
.app-chat-msg.is-ai.intent-match .app-chat-bubble{
  background: var(--chat-bubble-ai);
}
.app-chat-chart-card,
.app-chat-meta-details{
  border-color: var(--chat-border);
  background: var(--chat-surface);
}
.app-chat-source,
.app-chat-meta-grid,
.app-chat-meta-details > summary{
  color: var(--chat-muted);
}
.app-chat-composer{
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  bottom: calc(env(safe-area-inset-bottom, 0px) + 80px);
  z-index: 25;
  margin: 0;
  width: min(1080px, calc(100vw - 20px));
  border: 1px solid var(--chat-border);
  border-radius: 18px;
  background: var(--chat-surface);
  backdrop-filter: none !important;
  padding: 8px;
  box-shadow: 0 8px 24px rgba(15,23,42,.08);
}
.app-chat-input{
  min-height: 44px;
  border-radius: 12px;
  border: 1px solid var(--chat-border);
  background: var(--chat-surface-soft);
  color: var(--text);
  font-size: 14px;
  line-height: 1.55;
  padding: 10px 12px;
}
.app-chat-input::placeholder{
  color: var(--chat-muted);
}
.app-chat-send,
.app-chat-send.btn.primary{
  min-height: 44px;
  min-width: 74px;
  border-radius: 12px !important;
  border: 1px solid var(--chat-send-bg) !important;
  background: var(--chat-send-bg) !important;
  color: var(--chat-send-text) !important;
  box-shadow: none !important;
}
.app-chat-send:disabled{
  opacity: .45;
  cursor: not-allowed;
}
.app-chat-send.is-locked{
  filter: grayscale(.2);
}
@media (max-width: 720px){
  .app-chat-shell{
    border-radius: 18px !important;
    min-height: calc(100dvh - 192px) !important;
  }
  .app-chat-head{
    padding: 12px 12px 10px !important;
  }
  .app-chat-intent-browser,
  .app-chat-chip-row,
  .app-chat-meta,
  .app-chat-scroll,
  .app-chat-composer{
    margin-left: 10px;
    margin-right: 10px;
  }
  .app-chat-scroll{
    min-height: 300px;
    padding: 10px 9px;
  }
  .app-chat-composer{
    width: calc(100vw - 14px);
    bottom: calc(env(safe-area-inset-bottom, 0px) + 74px);
    border-radius: 16px;
  }
  .app-chat-msg{
    max-width: 96%;
  }
}

/* Chat focused layout: keep only messages + fixed controls */
body[data-app-tab="chat"] #appChatIntentBrowser,
body[data-app-tab="chat"] #appChatQuestionRow,
body[data-app-tab="chat"] .app-chat-meta{
  display: none !important;
}
body[data-app-tab="chat"] #appChatPage{
  --chat-fixed-composer-bottom: calc(env(safe-area-inset-bottom, 0px) + 66px);
  --chat-fixed-composer-height: 74px;
  --chat-fixed-mode-gap: 10px;
  background: #ffffff;
  border-radius: 20px;
  padding-top: 8px;
  padding-bottom: 0;
  max-width: 1000px;
  min-height: calc(100dvh - (env(safe-area-inset-bottom, 0px) + 94px));
  margin-left: auto;
  margin-right: auto;
  padding-left: 0;
  padding-right: 0;
}
body[data-app-tab="chat"],
body[data-app-tab="chat"] .app{
  background: #ffffff !important;
}
body[data-app-tab="chat"] main{
  background: #ffffff;
  min-height: 100dvh;
  padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 94px) !important;
}
body[data-app-tab="chat"] #viewTitle,
body[data-app-tab="chat"] #viewTitle.active{
  animation: none !important;
  transform: none !important;
}
body[data-app-tab="chat"] .app-chat-shell{
  display: flex !important;
  flex-direction: column !important;
  background: #ffffff !important;
  border: 1px solid rgba(15, 23, 42, .08) !important;
  box-shadow: 0 14px 34px rgba(15, 23, 42, .08);
  min-height: calc(100dvh - 100px) !important;
  padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 12px) !important;
  overflow: visible !important;
}
body[data-app-tab="chat"] .app-chat-head{
  position: static !important;
  margin: 0 !important;
  padding: 0 !important;
  border: 0 !important;
  min-height: 0 !important;
  background: transparent !important;
}
body[data-app-tab="chat"] .app-chat-head h2,
body[data-app-tab="chat"] .app-chat-head p{
  display: none !important;
}
body[data-app-tab="chat"] .app-chat-mode-row{
  position: fixed !important;
  left: 50%;
  transform: translateX(-50%);
  bottom: calc(var(--chat-fixed-composer-bottom) + var(--chat-fixed-composer-height) + var(--chat-fixed-mode-gap));
  z-index: 61;
  width: min(1000px, calc(100vw - 20px));
  display: flex;
  justify-content: flex-start;
  align-items: center;
  flex-wrap: nowrap;
  gap: 8px;
  margin-top: 0 !important;
  padding: 0;
}
body[data-app-tab="chat"] .app-chat-mode-note{
  display: none !important;
}
body[data-app-tab="chat"] .app-chat-mode-btn{
  min-height: 36px;
  padding: 6px 14px;
  border-radius: 999px;
  background: #ffffff;
  border: 1px solid rgba(15, 23, 42, .12);
  box-shadow: 0 6px 16px rgba(15, 23, 42, .08);
}
body[data-app-tab="chat"] .app-chat-mode-select-wrap{
  position: relative;
  display: inline-flex;
  align-items: center;
  gap: 8px;
  min-height: 36px;
  padding: 4px 10px;
  border-radius: 999px;
  border: 1px solid rgba(15, 23, 42, .12);
  background: #ffffff;
  box-shadow: 0 6px 16px rgba(15, 23, 42, .08);
}
body[data-app-tab="chat"] .app-chat-mode-select-wrap .ms{
  font-size: 16px;
  color: #111827;
}
body[data-app-tab="chat"] .app-chat-mode-picker-btn{
  display: inline-flex;
  align-items: center;
  gap: 8px;
  min-height: 34px;
  border: 0;
  background: transparent;
  color: #111827;
  padding: 0;
  font-size: 13px;
  font-weight: 700;
  cursor: pointer;
}
body[data-app-tab="chat"] .app-chat-mode-picker-btn .ms{
  font-size: 16px;
  line-height: 1;
}
body[data-app-tab="chat"] .app-chat-mode-picker-btn .ms.chev{
  font-size: 18px;
  color: #6b7280;
}
body[data-app-tab="chat"] .app-chat-mode-menu{
  position: absolute;
  left: 0;
  top: auto;
  bottom: calc(100% + 8px);
  z-index: 72;
  display: grid;
  gap: 6px;
  min-width: 186px;
  padding: 8px;
  border-radius: 12px;
  border: 1px solid rgba(15, 23, 42, .12);
  background: #ffffff;
  box-shadow: 0 12px 26px rgba(15, 23, 42, .14);
}
body[data-app-tab="chat"] .app-chat-mode-option{
  min-height: 36px;
  border-radius: 9px;
  border: 1px solid transparent;
  background: #f3f4f6;
  color: #111827;
  font-size: 13px;
  font-weight: 700;
  text-align: left;
  padding: 0 10px;
  cursor: pointer;
}
body[data-app-tab="chat"] .app-chat-mode-option.is-active{
  background: #111827;
  color: #ffffff;
  border-color: #111827;
}
body[data-app-tab="chat"] .app-chat-mode-btn.is-active{
  background: #111827;
  color: #ffffff;
  border-color: #111827;
}
body[data-app-tab="chat"] .app-chat-scroll{
  flex: 1 1 auto !important;
  height: auto !important;
  margin: 8px 14px 0 !important;
  background: #ffffff !important;
  border: 0 !important;
  border-radius: 0 !important;
  box-shadow: none !important;
  min-height: 0 !important;
  margin-bottom: 0 !important;
  padding: 8px 4px 40px !important;
  scroll-padding-bottom: 42px;
}
body[data-app-tab="chat"] .app-chat-list::after{
  content: "";
  display: block;
  height: 32px;
}
body[data-app-tab="chat"] .app-chat-list{
  gap: 12px;
}
body[data-app-tab="chat"] .app-chat-bubble{
  box-shadow: 0 8px 20px rgba(15, 23, 42, .06);
}
body[data-app-tab="chat"] .app-chat-composer{
  position: fixed !important;
  left: 50%;
  transform: translateX(-50%);
  bottom: var(--chat-fixed-composer-bottom);
  width: min(1000px, calc(100vw - 18px));
  margin: 0 !important;
  z-index: 60 !important;
  background: #ffffff !important;
  border: 1px solid rgba(15, 23, 42, .10) !important;
  border-radius: 22px !important;
  box-shadow: 0 16px 34px rgba(15, 23, 42, .12) !important;
  padding: 10px !important;
}
body[data-app-tab="chat"] .app-chat-limit-banner{
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  bottom: calc(var(--chat-fixed-composer-bottom) + var(--chat-fixed-composer-height) + 52px);
  width: min(1000px, calc(100vw - 18px));
  z-index: 62;
  border: 1px solid rgba(15, 23, 42, .12);
  border-radius: 14px;
  background: #ffffff;
  box-shadow: 0 12px 28px rgba(15, 23, 42, .12);
  padding: 10px 12px;
  animation: chatNoticeIn .24s cubic-bezier(.22, 1, .36, 1);
}
body[data-app-tab="chat"] .app-chat-limit-banner.hidden{
  display: none !important;
}
@keyframes chatNoticeIn{
  0%{
    opacity: 0;
    transform: translateX(-50%) translateY(10px);
  }
  100%{
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }
}
body[data-app-tab="chat"] .app-chat-limit-row{
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
}
body[data-app-tab="chat"] .app-chat-limit-title,
body[data-app-tab="chat"] #appChatLimitTitle{
  font-size: 13px;
  color: #111827;
}
body[data-app-tab="chat"] .app-chat-limit-sub,
body[data-app-tab="chat"] #appChatLimitSub{
  margin-top: 5px;
  font-size: 12px;
  color: #6b7280;
}
body[data-app-tab="chat"] .app-chat-limit-close{
  flex: 0 0 auto;
  width: 28px;
  height: 28px;
  border-radius: 999px;
  border: 1px solid rgba(15, 23, 42, .12);
  background: #f5f6f8;
  color: #111827;
  font-size: 16px;
  line-height: 1;
  cursor: pointer;
}
body[data-app-tab="chat"] .app-chat-role{
  display: inline-flex;
  align-items: center;
  gap: 6px;
}
body[data-app-tab="chat"] .app-chat-role-icon{
  display: inline-grid;
  place-items: center;
  width: 20px;
  height: 20px;
  border-radius: 999px;
  background: rgba(17, 24, 39, .08);
  color: #111827;
  font-size: 14px;
  line-height: 1;
}
body[data-app-tab="chat"] .app-chat-role-label{
  line-height: 1;
}
body[data-app-tab="chat"] .app-chat-typing-dots{
  display: inline-flex;
  align-items: center;
  gap: 6px;
  min-height: 16px;
}
body[data-app-tab="chat"] .app-chat-typing-dots i{
  display: inline-block;
  width: 7px;
  height: 7px;
  border-radius: 999px;
  background: rgba(17, 24, 39, .55);
  opacity: .25;
  animation: chatTypingDot 1.1s ease-in-out infinite;
}
body[data-app-tab="chat"] .app-chat-typing-dots i:nth-child(2){
  animation-delay: .16s;
}
body[data-app-tab="chat"] .app-chat-typing-dots i:nth-child(3){
  animation-delay: .32s;
}
@keyframes chatTypingDot{
  0%, 80%, 100%{
    opacity: .24;
    transform: translateY(0) scale(.92);
  }
  40%{
    opacity: 1;
    transform: translateY(-2px) scale(1);
  }
}
body[data-app-tab="chat"] .app-chat-input{
  background: #f5f6f8 !important;
  border: 1px solid rgba(15, 23, 42, .10) !important;
  border-radius: 14px !important;
  min-height: 46px !important;
}
body[data-app-tab="chat"] .app-chat-send,
body[data-app-tab="chat"] .app-chat-send.btn.primary{
  min-width: 82px;
  min-height: 46px;
  border-radius: 14px !important;
}
@media (max-width: 720px){
  body[data-app-tab="chat"] #appChatPage{
    --chat-fixed-composer-bottom: calc(env(safe-area-inset-bottom, 0px) + 62px);
    --chat-fixed-composer-height: 70px;
    --chat-fixed-mode-gap: 8px;
    border-radius: 14px;
    padding-bottom: 0;
    max-width: none;
  }
  body[data-app-tab="chat"] main{
    padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 84px) !important;
  }
  body[data-app-tab="chat"] .app-chat-shell{
    min-height: calc(100dvh - 118px) !important;
    border-radius: 14px !important;
  }
  body[data-app-tab="chat"] .app-chat-scroll{
    margin-left: 10px !important;
    margin-right: 10px !important;
    min-height: 0 !important;
  }
  body[data-app-tab="chat"] .app-chat-mode-row{
    width: calc(100vw - 14px);
    bottom: calc(var(--chat-fixed-composer-bottom) + var(--chat-fixed-composer-height) + var(--chat-fixed-mode-gap));
    justify-content: flex-start;
    overflow-x: visible;
    overflow-y: visible;
    -webkit-overflow-scrolling: touch;
    white-space: normal;
    padding-bottom: 2px;
  }
  body[data-app-tab="chat"] .app-chat-limit-banner{
    width: calc(100vw - 14px);
    bottom: calc(var(--chat-fixed-composer-bottom) + var(--chat-fixed-composer-height) + 52px);
    padding: 9px 10px;
  }
  body[data-app-tab="chat"] .app-chat-composer{
    width: calc(100vw - 14px);
    bottom: var(--chat-fixed-composer-bottom);
    border-radius: 18px !important;
    padding: 8px !important;
  }
  body[data-app-tab="chat"] .app-chat-role-icon{
    width: 18px;
    height: 18px;
    font-size: 13px;
  }
}

/* font-size bridge: enforce setting reflection on core UI */
.brand-title,
.brand-sub,
.icon-label,
.btn,
.navbtn,
.textbtn,
.menu-item,
.settings-row .label,
.settings-row .value,
.app-settings-row,
.note,
.auth-gate-status,
.app-page-head p,
.app-page-head h2,
.app-inbox-title,
.app-inbox-preview,
.app-ins-k,
.app-ins-v,
.drawer-share-status{
  font-size: calc(1em * var(--ui-font-scale));
}

/* Inbox: chat-thread refresh */
:root{
  --inbox-thread-bg:#ffffff;
  --inbox-bubble-bg:var(--chat-bubble-ai, var(--panel));
  --inbox-bubble-border:var(--chat-border, var(--border));
  --inbox-avatar-bg:var(--chat-surface-soft, var(--panel2));
  --inbox-avatar-text:color-mix(in srgb, var(--text) 70%, transparent);
  --inbox-high-chip-bg:rgba(37,99,235,.10);
  --inbox-high-chip-border:rgba(37,99,235,.22);
}
:root[data-theme-mode="dark"]{
  --inbox-thread-bg:#171b24;
  --inbox-bubble-bg:#171b24;
  --inbox-bubble-border:rgba(255,255,255,.14);
  --inbox-avatar-bg:#1e2430;
  --inbox-avatar-text:rgba(245,246,247,.86);
  --inbox-high-chip-bg:rgba(143,182,255,.15);
  --inbox-high-chip-border:rgba(143,182,255,.26);
}

#appInboxPage{
  gap: 12px;
}
body[data-app-tab="inbox"] #appInboxPage{
  display: grid !important;
}
#appInboxPage #appInboxListPane,
#appInboxPage #appInboxDetailPane{
  border: 1px solid var(--inbox-bubble-border);
  border-radius: 20px;
  background: var(--inbox-thread-bg);
  box-shadow: 0 10px 26px rgba(15,23,42,.07);
}
#appInboxPage #appInboxListPane{
  max-height: min(74dvh, 780px);
  overflow: auto;
  -webkit-overflow-scrolling: touch;
  padding: 12px;
}
#appInboxPage #appInboxDetailPane{
  max-height: min(74dvh, 780px);
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}
#appInboxPage .app-inbox-list{
  display: grid;
  gap: 12px;
  align-content: start;
}
#appInboxPage .app-inbox-item{
  display: grid;
  grid-template-columns: 34px minmax(0, 1fr);
  gap: 10px;
  align-items: start;
  border: 0 !important;
  background: transparent !important;
  box-shadow: none !important;
  border-radius: 0 !important;
  padding: 0 !important;
  margin: 0;
  max-width: 100%;
}
#appInboxPage .app-inbox-avatar{
  width: 34px;
  height: 34px;
  border-radius: 999px;
  border: 1px solid var(--inbox-bubble-border);
  background: var(--inbox-avatar-bg);
  color: var(--inbox-avatar-text);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 11px;
  font-weight: 700;
  letter-spacing: .04em;
  flex-shrink: 0;
}
#appInboxPage .app-inbox-body{
  min-width: 0;
  display: grid;
  gap: 6px;
}
#appInboxPage .app-inbox-bubble{
  position: relative;
  border: 1px solid var(--inbox-bubble-border) !important;
  border-radius: 16px !important;
  background: var(--inbox-bubble-bg) !important;
  box-shadow: 0 6px 18px rgba(15,23,42,.05);
  padding: 10px 12px;
}
#appInboxPage .app-inbox-item.unread .app-inbox-bubble{
  border-color: color-mix(in srgb, var(--accent, #2563eb) 36%, var(--inbox-bubble-border)) !important;
}
#appInboxPage .app-inbox-unread-dot{
  position: absolute;
  left: -4px;
  top: -4px;
  width: 8px;
  height: 8px;
  border-radius: 999px;
  background: color-mix(in srgb, var(--accent, #2563eb) 78%, #ffffff);
  box-shadow: 0 0 0 2px var(--inbox-thread-bg);
}
#appInboxPage .app-inbox-item:not(.unread) .app-inbox-unread-dot{
  display: none;
}
#appInboxPage .app-inbox-bubble-head{
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 8px;
}
#appInboxPage .app-inbox-title{
  margin: 0;
  color: var(--text);
  font-size: 14px;
  line-height: 1.45;
  font-weight: 700;
}
#appInboxPage .app-inbox-category{
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 2px 8px;
  border-radius: 999px;
  border: 1px solid var(--inbox-bubble-border);
  background: var(--chat-surface-soft, var(--panel2));
  color: var(--muted);
  font-size: 11px;
  font-weight: 600;
  white-space: nowrap;
}
#appInboxPage .app-inbox-item.priority-high .app-inbox-category{
  background: var(--inbox-high-chip-bg);
  border-color: var(--inbox-high-chip-border);
}
#appInboxPage .app-inbox-preview{
  margin: 6px 0 0;
  color: var(--muted);
  font-size: 13px;
  line-height: 1.55;
  word-break: break-word;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}
#appInboxPage .app-inbox-bubble-meta{
  margin-top: 7px;
  display: flex;
  justify-content: flex-end;
}
#appInboxPage .app-inbox-time{
  font-size: 11px;
  color: var(--muted);
  font-variant-numeric: tabular-nums;
}
#appInboxPage .app-inbox-action-row{
  display: flex;
  align-items: center;
  justify-content: flex-end;
  gap: 8px;
}
#appInboxPage .app-inbox-read-state{
  font-size: 11px;
  color: var(--muted);
}
#appInboxPage .app-inbox-action-btn{
  min-height: 30px;
  border-radius: 999px;
  padding: 0 12px;
}

#appInboxPage .app-inbox-detail-shell{
  min-height: 100%;
}
#appInboxPage .app-inbox-detail-head{
  position: sticky;
  top: 0;
  z-index: 4;
  border-bottom: 1px solid var(--inbox-bubble-border);
  background: var(--inbox-thread-bg);
  padding: 12px 12px 10px;
}
#appInboxPage .app-inbox-detail-head-actions{
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
}
#appInboxPage .app-inbox-close-btn{
  appearance: none;
  border: 1px solid var(--inbox-bubble-border);
  background: var(--inbox-thread-bg);
  color: var(--text);
  width: 32px;
  height: 32px;
  border-radius: 999px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
}
#appInboxPage .app-inbox-close-btn .ms{
  font-size: 18px;
}
#appInboxPage .app-detail-title{
  margin: 10px 0 6px;
  font-size: 20px;
  line-height: 1.4;
}
#appInboxPage .app-detail-meta{
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-bottom: 0;
}
#appInboxPage .app-inbox-detail-chip{
  display: inline-flex;
  align-items: center;
  min-height: 24px;
  padding: 2px 9px;
  border-radius: 999px;
  border: 1px solid var(--inbox-bubble-border);
  background: var(--chat-surface-soft, var(--panel2));
  color: var(--muted);
  font-size: 11px;
}
#appInboxPage .app-inbox-detail-chip.is-high{
  background: var(--inbox-high-chip-bg);
  border-color: var(--inbox-high-chip-border);
}
#appInboxPage .app-detail-content{
  border: 0;
  border-radius: 0;
  background: transparent;
  box-shadow: none;
  padding: 14px 14px 18px;
}
#appInboxPage .app-detail-content .notify-detail-text{
  font-size: 14px;
  line-height: 1.72;
}
#appInboxPage .app-empty{
  padding: 14px 4px 8px;
}

</style>
</head>
<body class="app-tabs-visible auth-booting" data-app-tab="home">
  <div id="authBootSplash" role="status" aria-live="polite">
    <div class="boot-splash-inner">
      <span class="ms app-loading-icon" id="authBootIcon" aria-hidden="true">menu_book</span>
      <span class="app-loading-spinner" aria-hidden="true"></span>
    </div>
  </div>
  <div id="authGate" class="auth-gate hidden" role="dialog" aria-modal="true" aria-label="">
    <div class="auth-gate-card">
      <div class="auth-gate-head">
        <h2 class="auth-gate-title">VocabuQuiz</h2>
        <p class="auth-gate-sub"></p>
      </div>
      <div class="auth-gate-panels">
        <section class="auth-gate-panel" data-auth-panel="welcome" id="authWelcomePanel">
          <div class="auth-welcome-mark">VocabuQuiz</div>
        </section>

        <section class="auth-gate-panel is-active" data-auth-panel="entry" id="authEntryPanel">
          <div class="auth-gate-actions">
            <button class="btn auth-gate-btn primary" type="button" id="authOpenRegisterBtn">
              <div class="label"></div>
              <div class="desc"></div>
            </button>
            <button class="btn auth-gate-btn secondary" type="button" id="authOpenLoginBtn">
              <div class="label"></div>
              <div class="desc"></div>
            </button>
            <button class="btn auth-gate-btn ghost" type="button" id="authOpenGuestConfirmBtn">
              <div class="label"></div>
              <div class="desc"></div>
            </button>
          </div>
          <div id="authEntryStatus" class="auth-gate-status" aria-live="polite"></div>
        </section>

        <section class="auth-gate-panel" data-auth-panel="register" id="authRegisterPanel">
          <div class="auth-gate-seg" role="tablist" aria-label="">
            <button class="auth-gate-seg-btn" id="authSegRegisterBtn" type="button" role="tab"></button>
            <button class="auth-gate-seg-btn" id="authSegLoginBtn" type="button" role="tab"></button>
          </div>
          <div class="auth-gate-row">
            <div class="auth-gate-label"></div>
            <select id="authRegisterGrade" class="select auth-gate-grade auth-line-select">
              <option value="J1">1</option>
              <option value="J2">2</option>
              <option value="J3">3</option>
              <option value="H1">1</option>
              <option value="H2">2</option>
              <option value="H3">3</option>
            </select>
          </div>
          <div class="auth-gate-row">
            <div class="auth-gate-label"></div>
            <input id="authRegisterNickname" class="spell-input auth-line-input" type="text" maxlength="24" autocomplete="username" placeholder=": rinty" />
          </div>
          <div class="auth-gate-row">
            <div class="auth-gate-label"></div>
            <input id="authRegisterPassword" class="spell-input auth-line-input" type="password" minlength="8" maxlength="72" autocomplete="new-password" placeholder="8" />
          </div>
          <div class="auth-gate-foot">
            <button class="textbtn" type="button" id="authRegisterBackBtn"></button>
            <button class="navbtn" type="button" id="authRegisterNextBtn"></button>
          </div>
          <div id="authRegisterStatus" class="auth-gate-status" aria-live="polite"></div>
        </section>

        <section class="auth-gate-panel" data-auth-panel="registerConfirm" id="authRegisterConfirmPanel">
          <div class="auth-confirm-card">
            <div class="auth-gate-row">
              <div class="auth-gate-label"></div>
              <div id="authRegisterConfirmGrade" class="auth-confirm-value"></div>
            </div>
            <div class="auth-gate-row">
              <div class="auth-gate-label"></div>
              <div id="authRegisterConfirmNickname" class="auth-confirm-value"></div>
            </div>
            <div class="auth-gate-row">
              <div class="auth-gate-label"></div>
              <div id="authRegisterConfirmPassword" class="auth-confirm-value"></div>
            </div>
          </div>
          <div class="auth-gate-foot">
            <button class="textbtn" type="button" id="authRegisterConfirmBackBtn"></button>
            <button class="navbtn" type="button" id="authRegisterConfirmNextBtn">OK</button>
          </div>
          <div id="authRegisterConfirmStatus" class="auth-gate-status" aria-live="polite"></div>
        </section>

        <section class="auth-gate-panel" data-auth-panel="login" id="authLoginPanel">
          <div class="auth-gate-seg" role="tablist" aria-label="">
            <button class="auth-gate-seg-btn" id="authSegRegisterBtn2" type="button" role="tab"></button>
            <button class="auth-gate-seg-btn" id="authSegLoginBtn2" type="button" role="tab"></button>
          </div>
          <div class="auth-gate-row">
            <div class="auth-gate-label"></div>
            <select id="authLoginGrade" class="select auth-gate-grade auth-line-select">
              <option value="J1">1</option>
              <option value="J2">2</option>
              <option value="J3">3</option>
              <option value="H1">1</option>
              <option value="H2">2</option>
              <option value="H3">3</option>
            </select>
          </div>
          <div class="auth-gate-row">
            <div class="auth-gate-label"></div>
            <input id="authLoginNickname" class="spell-input auth-line-input" type="text" maxlength="24" autocomplete="username" placeholder=": rinty" />
          </div>
          <div class="auth-gate-row">
            <div class="auth-gate-label"></div>
            <input id="authLoginPassword" class="spell-input auth-line-input" type="password" maxlength="72" autocomplete="current-password" placeholder="" />
          </div>
          <div class="auth-gate-foot">
            <button class="textbtn" type="button" id="authLoginBackBtn"></button>
            <button class="navbtn" type="button" id="authLoginSubmitBtn"></button>
          </div>
          <div id="authLoginStatus" class="auth-gate-status" aria-live="polite"></div>
        </section>

        <section class="auth-gate-panel" data-auth-panel="tos" id="authTosPanel">
          <div class="auth-gate-tos-wrap">
            <div class="auth-gate-mini"></div>
            <div id="authTosScroll" class="auth-gate-tos-scroll" tabindex="0">
              <h4> v1</h4>
              <p><strong>1</strong><br>VocabuQuiz</p>
              <p><strong>2</strong><br></p>
              <p><strong>3</strong><br></p>
              <p><strong>4</strong><br></p>
              <p><strong>5</strong><br></p>
              <p><strong>6</strong><br></p>
              <p><strong>7</strong><br></p>
              <p><strong>8</strong><br></p>
              <p><strong>9</strong><br></p>
              <p><strong>10</strong><br></p>
            </div>
            <div id="authTosHint" class="auth-gate-mini"></div>
            <div class="auth-gate-checks">
              <label class="auth-gate-check">
                <input id="authTosAgree1" type="checkbox" disabled />
                <span></span>
              </label>
              <label class="auth-gate-check">
                <input id="authTosAgree2" type="checkbox" disabled />
                <span></span>
              </label>
            </div>
          </div>
          <div class="auth-gate-foot">
            <button class="textbtn" type="button" id="authTosBackBtn"></button>
            <button class="navbtn" type="button" id="authTosSubmitBtn" disabled></button>
          </div>
          <div id="authTosStatus" class="auth-gate-status" aria-live="polite"></div>
        </section>

        <section class="auth-gate-panel" data-auth-panel="profile" id="authProfilePanel">
          <div class="auth-profile-steps" id="authProfileSteps">
            <div class="auth-profile-step is-active" data-auth-question-step="1">
              <div class="auth-gate-row">
                <div class="auth-gate-label">Q1. </div>
                <select id="authProfileStudyTime" class="select auth-gate-grade auth-line-select">
                  <option value=""></option>
                  <option value="0-30">030</option>
                  <option value="30-60">3060</option>
                  <option value="1-2h">12</option>
                  <option value="2h+">2</option>
                </select>
              </div>
            </div>
            <div class="auth-profile-step" data-auth-question-step="2">
              <div class="auth-gate-row">
                <div class="auth-gate-label">Q2. </div>
                <input id="authProfileSubjects" class="spell-input auth-line-input" type="text" maxlength="120" placeholder=": , " />
              </div>
            </div>
            <div class="auth-profile-step" data-auth-question-step="3">
              <div class="auth-gate-row">
                <div class="auth-gate-label">Q3. </div>
                <div class="auth-like-seg" role="group" aria-label="">
                  <button class="auth-like-btn" type="button" id="authProfileLikeGoodBtn" data-value="like"></button>
                  <button class="auth-like-btn" type="button" id="authProfileLikeHardBtn" data-value="hard"></button>
                </div>
                <input type="hidden" id="authProfileLike" value="" />
              </div>
            </div>
          </div>
          <div class="auth-gate-foot auth-gate-foot-between">
            <div class="auth-profile-nav-left">
              <button class="textbtn hidden" type="button" id="authProfileBackBtn"></button>
              <button class="textbtn" type="button" id="authProfileSkipBtn"></button>
            </div>
            <button class="navbtn" type="button" id="authProfileNextBtn"></button>
          </div>
          <div id="authProfileStatus" class="auth-gate-status" aria-live="polite"></div>
        </section>

        <section class="auth-gate-panel" data-auth-panel="guestConfirm" id="authGuestConfirmPanel">
          <h3 class="auth-gate-title" style="font-size:20px;"></h3>
          <p class="auth-gate-mini">
             / 
            
          </p>
          <label class="auth-gate-check">
            <input id="authGuestAcknowledge" type="checkbox" />
            <span></span>
          </label>
          <div class="auth-gate-foot">
            <button class="textbtn" type="button" id="authGuestBackBtn"></button>
            <button class="navbtn" type="button" id="authGuestConfirmBtn" disabled></button>
          </div>
          <div id="authGuestStatus" class="auth-gate-status" aria-live="polite"></div>
        </section>
      </div>
      <div id="authGlobalStatus" class="auth-gate-status auth-gate-status-global" aria-live="polite"></div>
    </div>
  </div>
  <div id="globalLoadingOverlay" class="hidden" role="status" aria-live="polite" aria-busy="true">
    <div class="app-loading-card">
      <span class="ms app-loading-icon" id="globalLoadingIcon" aria-hidden="true">menu_book</span>
      <span class="app-loading-spinner" aria-hidden="true"></span>
    </div>
  </div>
  <div id="maintenanceOverlay" class="maintenance-overlay hidden" role="dialog" aria-modal="true" aria-label="">
    <div class="maintenance-card">
      <div class="maintenance-head">
        <div class="maintenance-icon"><span class="ms" aria-hidden="true">construction</span></div>
        <h2 id="maintenanceTitle" class="maintenance-title"></h2>
      </div>
      <p id="maintenanceMessage" class="maintenance-message"></p>
      <div class="maintenance-meta">
        <div class="maintenance-meta-row"><span></span><strong id="maintenancePeriod"></strong></div>
        <div class="maintenance-meta-row"><span></span><strong id="maintenanceRemaining"></strong></div>
      </div>
      <div class="maintenance-actions">
        <button class="textbtn" id="maintenanceReloadBtn" type="button"></button>
        <button class="textbtn hidden" id="maintenanceAdminLoginBtn" type="button"></button>
        <button class="navbtn hidden" id="maintenanceBypassBtn" type="button"></button>
      </div>
      <div id="maintenanceStatus" class="maintenance-status" aria-live="polite"></div>
      <div class="maintenance-note"></div>
    </div>
  </div>
  <div class="app" id="app">
    
    <header class="topbar" role="banner">
      <div class="topbar-inner">
        <div class="topbar-left">
      <button class="icon-btn" id="menuBtn" aria-label="Menu">
        <span class="ms">menu</span>
        <span class="icon-label"></span>
      </button>
          <button class="icon-btn" id="backBtn" aria-label="" title="" disabled>
            <span class="ms" aria-hidden="true">chevron_left</span>
          </button>

          <div class="brand" aria-label="">
            <div class="brand-title">VocabuQuiz</div>
            <div class="brand-sub">v.1 Public</div>
            <span id="authGuestBadge" class="auth-badge hidden"></span>
          </div>
        </div>

        <div class="topbar-actions" aria-label="">
          <button class="icon-btn" id="insightsBtn" aria-label="Insights" title="Insights">
            <span class="ms" aria-hidden="true">query_stats</span>
          
            <span class="icon-label" aria-hidden="true"></span>
          </button>

          <button class="icon-btn" id="topPresetBtn" aria-label="" title="">
            <span class="ms" aria-hidden="true">collections_bookmark</span>
          
            <span class="icon-label" aria-hidden="true"></span>
          </button>


          <button class="icon-btn" id="searchBtn" aria-label="" title="">
            <span class="ms" aria-hidden="true">search</span>
            <span class="icon-label" aria-hidden="true"></span>
          </button>

          <button class="icon-btn" id="notifyBtn" aria-label="" title="">
            <span class="ms" aria-hidden="true">notifications</span>
            <span class="notif-dot hidden" id="notifyDot" aria-hidden="true"></span>
          
            <span class="icon-label" aria-hidden="true"></span>
          </button>

          <button class="icon-btn" id="settingsBtn" aria-label="" title="">
            <span class="ms" aria-hidden="true">settings</span>
          
            <span class="icon-label" aria-hidden="true"></span>
          </button>
        </div>
      </div>
    </header>


  <!-- Hamburger Menu -->
  <div id="menuOverlay" class="menu-overlay" hidden aria-hidden="true"></div>
  <div id="menuPanel" class="menu-panel" hidden role="dialog" aria-label="Menu" aria-hidden="true">
    <div class="menu-header">
      <button class="icon-btn menu-back" type="button" data-menu-action="back" aria-label="Back">
        <span class="ms">arrow_back</span>
      </button>
      <div class="menu-title" id="menuTitle">MENU</div>
      <button class="icon-btn" type="button" data-menu-action="close" aria-label="Close menu">
        <span class="ms">close</span>
      </button>
    </div>
    <div id="menuContent" class="menu-content" tabindex="-1">
      <div class="menu-list" data-menu-view="root">
        <button class="menu-item" type="button" data-menu-action="help">
          <span class="ms">help</span><span></span>
        </button>
        <button class="menu-item" type="button" data-menu-action="settings">
          <span class="ms">settings</span><span></span>
        </button>
        <button class="menu-item" type="button" data-menu-action="memoCheck">
          <span class="ms">edit_calendar</span><span></span>
        </button>
        <button class="menu-item" type="button" data-menu-action="presetShare">
          <span class="ms">share</span><span></span>
        </button>
        <button class="menu-item" type="button" data-menu-action="onlineBattleRealtime">
          <span class="ms">wifi_tethering</span><span></span>
        </button>
        <button class="menu-item" type="button" data-menu-action="terms">
          <span class="ms">policy</span><span></span>
        </button>
        <button class="menu-item" type="button" data-menu-action="report">
          <span class="ms">report</span><span>/</span>
        </button>
      </div>
    </div>
  </div>

<main>
      <div class="stage">

        <!-- Start -->
        <section class="view" id="viewStart" aria-label="">
          <div class="start-wrap">
            <div class="start-hero">
              <div class="start-kicker">version 1</div>
              <h1 class="start-title">VocabuQuiz</h1>
              <p class="start-sub">
                
              </p>
              <div class="start-actions">
                <button class="start-primary" id="startAppBtn" type="button">
                  
                  <span class="ms" aria-hidden="true">arrow_forward</span>
                </button>
              </div>
              <div class="start-note">
                <span class="start-chip">Offline</span>
                <span class="start-chip">Local Save</span>
                <span class="start-chip">No Ads</span>
              </div>
            </div>
          </div>
        </section>

        <!-- Dashboard -->
        <section class="view active" id="viewTitle" aria-label="">
          <div class="hero">
            <h1 class="h1">Word Practice 11000</h1>
            <p class="subtitle">
              Vocabu
            </p>

            <div class="app-home-current">
              <div class="app-home-current-main">
                <div class="app-home-current-k"></div>
                <div class="app-home-current-v" id="homeActivePresetName"></div>
                <div class="app-home-current-sub" id="homeActivePresetMeta"></div>
              </div>
              <button class="textbtn" type="button" data-home-action="openLibrary"></button>
            </div>

            <div class="section">
              <div class="section-title">
                <span>Preset</span>
                <span class="right" id="deckStatus"></span>
              </div>
              <div class="home-preset-row" style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">

              <div class="seg" role="tablist" aria-label="Vocabu range">
                <button type="button" id="deckABtn" class="active" role="tab" aria-selected="true">0200</button>
                <button type="button" id="deckBBtn" role="tab" aria-selected="false">200400</button>
                <button type="button" id="deckCBtn" role="tab" aria-selected="false">400600</button>
                <button type="button" id="deckDBtn" role="tab" aria-selected="false">600800</button>
                <button type="button" id="deckEBtn" role="tab" aria-selected="false">80010008011000</button>
                <button type="button" id="deckAllBtn" role="tab" aria-selected="false">ALL</button>
                <button type="button" id="deckMyBtn" role="tab" aria-selected="false">My</button>
              </div>
                <button class="navbtn" id="presetManageBtn" type="button" title=""></button>
              </div>
              <div id="customPresetRow" class="hint hidden" style="margin-top:10px; display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
                <span style="color:var(--muted); font-size:12px;">My Preset</span>
                <select id="customPresetSelect" class="select" aria-label="My Preset"></select>
                <button class="textbtn" id="customPresetNewBtn" type="button"></button>
              </div>
            </div>

            <div class="section">
              <div class="section-title"><span>Practice</span><span class="right" id="practiceHint"></span></div>

	              <div class="actions" id="modeActions">
                <button class="btn" id="startSeqBtn">
                  <div class="label"><span>TURN MODE</span><span class="badge" id="badgeSeq"></span></div>
                  <div class="desc"></div>
                </button>

                <button class="btn" id="startRndBtn">
                  <div class="label"><span>RANDOM MODE</span><span class="badge" id="badgeRnd"></span></div>
                  <div class="desc"></div>
                </button>

                <button class="btn" id="startChoiceBtn">
                  <div class="label"><span>EXAM MODE</span><span class="badge" id="badgeChoice"></span></div>
                  <div class="desc">4/</div>
                </button>

	                <button class="btn" id="startHandBtn">
	                  <div class="label"><span>WRITE MODE</span><span class="badge" id="badgeHand"></span></div>
	                  <div class="desc"></div>
	                </button>
	</div>

              <div class="app-home-quick">
                <button class="textbtn" type="button" id="homeResumeBtn" data-home-action="resume"></button>
                <button class="textbtn" type="button" data-home-action="importShare"></button>
                <button class="textbtn" type="button" data-home-action="openReport">Report</button>
              </div>

              <div class="app-home-reco">
                <div class="app-home-reco-title"></div>
                <div class="app-home-reco-body"> 1020 </div>
              </div>

              
              <div class="empty-state hidden" id="emptyState" aria-live="polite">
                <div class="empty-title"></div>
                <div class="empty-desc"></div>
              </div>

	              <div class="fineprint" id="titleDebug">
	                <span class="badge">Data</span>
	                <span id="dataStatusText">loading</span>
	              </div>
	            </div>
	          </div>

          <section class="app-tab-page" id="appLibraryPage" aria-label="Library">
            <div class="app-page-head">
              <h2>Library</h2>
              <p>builtin / My Preset </p>
            </div>
            <div class="app-page-block">
              <div class="app-page-block-head">
                <span></span>
              </div>
              <div class="app-library-filters">
                <label class="settings-row is-static" for="appLibrarySubjectFilter">
                  <span class="label"></span>
                  <select id="appLibrarySubjectFilter" class="select settings-select">
                    <option value="ALL">ALL</option>
                  </select>
                </label>
                <label class="settings-row is-static" for="appLibrarySearchInput">
                  <span class="label"></span>
                  <input id="appLibrarySearchInput" class="spell-input" type="text" placeholder="" />
                </label>
                <div class="app-library-tags-wrap">
                  <div class="note"></div>
                  <div id="appLibraryTagFilters" class="tag-chip-row"></div>
                </div>
              </div>
            </div>
            <div class="app-page-block">
              <div class="app-page-block-head">
                <span>builtin</span>
              </div>
              <div class="app-preset-list" id="appLibraryBuiltinList"></div>
            </div>
            <div class="app-page-block">
              <div class="app-page-block-head">
                <span>My Preset</span>
                <button class="textbtn" type="button" data-lib-action="newPreset"></button>
              </div>
              <div class="app-preset-list" id="appLibraryMyList"></div>
            </div>
          </section>

          <section class="app-tab-page" id="appInboxPage" aria-label="Inbox">
            <div class="app-page-head">
              <h2>Inbox</h2>
              <p></p>
              <div class="app-page-head-actions">
                <button class="textbtn hidden" type="button" id="appInboxAdminBtn" data-inbox-action="openAdminEditor"></button>
              </div>
            </div>
            <div id="appInboxListPane">
              <div class="app-inbox-list" id="appInboxList"></div>
              <div class="app-empty hidden" id="appInboxEmpty"></div>
            </div>
            <div id="appInboxDetailPane" class="hidden">
              <div class="app-inbox-detail-shell">
                <div class="app-inbox-detail-head">
                  <div class="app-inbox-detail-head-actions">
                    <button class="textbtn app-inbox-back-btn" type="button" data-inbox-action="back"></button>
                    <button class="app-inbox-close-btn" type="button" data-inbox-action="back" aria-label="">
                      <span class="ms" aria-hidden="true">close</span>
                    </button>
                  </div>
                  <h3 id="appInboxDetailTitle" class="app-detail-title"></h3>
                  <div id="appInboxDetailMeta" class="app-detail-meta"></div>
                </div>
                <div id="appInboxDetailContent" class="app-detail-content"></div>
              </div>
            </div>
          </section>

          <section class="app-tab-page" id="appInsightsPage" aria-label="Insights">
            <div class="app-page-head">
              <h2>Insights</h2>
              <p></p>
            </div>
            <div class="app-page-block">
              <div class="app-insight-filters">
                <label class="settings-row is-static" for="appInsightsPresetSelect">
                  <span class="label">Preset</span>
                  <select id="appInsightsPresetSelect" class="select settings-select">
                    <option value="CURRENT">CURRENT</option>
                    <option value="ALL">ALL</option>
                  </select>
                </label>
                <label class="settings-row is-static" for="appInsightsModeSelect">
                  <span class="label">Mode</span>
                  <select id="appInsightsModeSelect" class="select settings-select">
                    <option value="ALL">ALL</option>
                    <option value="SEQ">TURN MODE</option>
                    <option value="RND">RUNDOM MODE</option>
                    <option value="CHOICE">EXAM MODE</option>
                    <option value="HAND">WRITE MODE</option>
                  </select>
                </label>
                <label class="settings-row is-static" for="appInsightsRangeSelect">
                  <span class="label"></span>
                  <select id="appInsightsRangeSelect" class="select settings-select">
                    <option value="7D">7</option>
                    <option value="30D" selected>30</option>
                    <option value="ALL">ALL</option>
                  </select>
                </label>
              </div>
            </div>
            <div class="app-insights-grid" id="appInsightsSummaryCards"></div>
            <div class="app-page-block">
              <div class="app-page-block-head"><span> </span></div>
              <div class="chart" id="appInsightsDailyVolume"></div>
            </div>
            <div class="app-page-block">
              <div class="app-page-block-head"><span> </span></div>
              <div class="chart" id="appInsightsDailyAccuracy"></div>
            </div>
            <div class="app-page-block">
              <div class="app-page-block-head"><span> </span></div>
              <div class="table-wrap" id="appInsightsModeDistribution"></div>
            </div>
            <div class="app-page-block">
              <div class="app-page-block-head"><span></span></div>
              <div class="app-action-row">
                <button class="btn" type="button" data-insights-action="openOverlay">
                  <div class="label">Insights </div>
                  <div class="desc"> / Preset / Mode </div>
                </button>
              </div>
            </div>
          </section>

          <section class="app-tab-page" id="appChatPage" aria-label="Chat">
            <div class="app-chat-shell">
              <header class="app-chat-head">
                <h2>Chat</h2>
                <p>AI assistant (Workers AI)</p>
                <div class="app-chat-mode-row" id="appChatModeRow" role="group" aria-label="AI mode">
                  <div class="app-chat-mode-select-wrap" id="appChatModePicker">
                    <button class="app-chat-mode-picker-btn" type="button" id="appChatModeToggleBtn" data-chat-action="toggleModeMenu" aria-haspopup="listbox" aria-expanded="false">
                      <span class="ms" aria-hidden="true">tune</span>
                      <span id="appChatModeToggleText">instant</span>
                      <span class="ms chev" aria-hidden="true">expand_more</span>
                    </button>
                    <div class="app-chat-mode-menu hidden" id="appChatModeMenu" role="listbox" aria-label="AI mode options">
                      <button class="app-chat-mode-option is-active" type="button" id="appChatModeOptionNormal" data-chat-action="setAiMode" data-chat-mode="normal" role="option" aria-selected="true">instant</button>
                      <button class="app-chat-mode-option" type="button" id="appChatModeOptionReason" data-chat-action="setAiMode" data-chat-mode="reason" role="option" aria-selected="false">deep</button>
                    </div>
                  </div>
                  <span class="app-chat-mode-note" id="appChatModeNote">VQ AI mini-1 instant/deep</span>
                </div>
              </header>

              <section class="app-chat-intent-browser" id="appChatIntentBrowser" aria-label="Intent Browser">
                <div class="app-chat-intent-top">
                  <label class="sr-only" for="appChatIntentSearch">Intent</label>
                  <input id="appChatIntentSearch" class="app-chat-intent-search" type="search" inputmode="search" placeholder="Intent:  /  /  / EXAM" />
                  <button class="app-chat-intent-auto" type="button" id="appChatAutoPickToggleBtn" data-chat-action="toggleAutoPick">1: ON</button>
                </div>
                <div class="app-chat-intent-meta">
                  <span id="appChatIntentCount">0 intents</span>
                </div>
                <div class="app-chat-intent-groups" id="appChatIntentGroups"></div>
              </section>

              <div class="app-chat-chip-row" id="appChatQuestionRow">
                <button class="app-chat-chip" type="button" data-chat-prompt="(7)" data-chat-intent-id="intent-trend-7d">(7)</button>
                <button class="app-chat-chip" type="button" data-chat-prompt="TOP10" data-chat-intent-id="intent-weak-top10">TOP10</button>
                <button class="app-chat-chip" type="button" data-chat-prompt="20EXAM" data-chat-intent-id="intent-reco-exam20">20EXAM</button>
                <button class="app-chat-chip" type="button" data-chat-prompt="20WRITE" data-chat-intent-id="intent-reco-write20">20WRITE</button>
                <button class="app-chat-chip" type="button" data-chat-prompt="()" data-chat-intent-id="intent-compare-week-acc">()</button>
                <button class="app-chat-chip" type="button" data-chat-prompt="()" data-chat-intent-id="intent-compare-week-volume">()</button>
                <button class="app-chat-chip" type="button" data-chat-prompt="" data-chat-intent-id="intent-share-failed"></button>
                <button class="app-chat-chip" type="button" data-chat-prompt="unauthorized-domain" data-chat-intent-id="intent-trouble-unauthorized-domain">unauthorized-domain</button>
              </div>

              <div class="app-chat-meta">
                <span id="appChatHistoryCount">0</span>
                <span id="appChatQuotaStatus">: --</span>
                <button class="textbtn" type="button" data-chat-action="clearHistory"></button>
              </div>

              <div class="app-chat-scroll" id="appChatScroll">
                <div class="app-chat-list" id="appChatList"></div>
                <div class="app-empty" id="appChatEmpty">Workers AI </div>
              </div>
              <div class="app-chat-limit-banner hidden" id="appChatLimitBanner" role="status" aria-live="polite">
                <div class="app-chat-limit-row">
                  <strong id="appChatLimitTitle">VQ AI mini-1 instant </strong>
                  <button class="app-chat-limit-close" type="button" data-chat-action="dismissQuotaNotice" aria-label=""></button>
                </div>
                <div class="app-chat-limit-sub" id="appChatLimitSub">: --</div>
              </div>

              <form class="app-chat-composer" id="appChatComposer">
                <textarea id="appChatInput" class="app-chat-input" rows="1" maxlength="1200" placeholder="Enter / Ctrl+Enter" aria-label=""></textarea>
                <button class="btn primary app-chat-send" id="appChatSendBtn" type="submit"></button>
              </form>
            </div>
          </section>

          <section class="app-tab-page" id="appSettingsPage" aria-label="Settings">
            <div class="app-page-head">
              <h2>Settings</h2>
              <p> /  / </p>
            </div>
            <div class="app-page-block">
              <div class="app-settings-list">
                <button class="app-settings-row" type="button" data-settings-shortcut="openSettings">
                  <span></span><span></span>
                </button>
                <button class="app-settings-row" type="button" data-settings-shortcut="openAdmin">
                  <span>Admin</span><span></span>
                </button>
                <button class="app-settings-row" type="button" data-settings-shortcut="openPresetShare">
                  <span></span><span></span>
                </button>
                <button class="app-settings-row" type="button" data-settings-shortcut="openReport">
                  <span>Report</span><span></span>
                </button>
                <button class="app-settings-row" type="button" data-settings-shortcut="openHelp">
                  <span>Help</span><span></span>
                </button>
                <button class="app-settings-row" type="button" data-settings-shortcut="openTerms">
                  <span>Terms</span><span></span>
                </button>
              </div>
            </div>
          </section>
	        </section>

        <!-- Quiz -->
        <section class="view" id="viewQuiz" aria-label="">
          <div class="quiz-header">
            <div class="progress" id="progressWrap">
              <span id="progressText"></span>
            </div>
            <div class="pill hidden" id="timerPill"></div>
            <div class="pill" id="modePill"></div>
          </div>

          <div class="card" id="card">
            <div class="mark-layer hidden" id="markLayer" aria-hidden="true">
              <!-- correct (red circle) -->
              <svg class="svg-ok hidden" id="svgOk" viewBox="0 0 120 120">
                <circle class="ring" cx="60" cy="60" r="44"></circle>
              </svg>
              <!-- wrong (blue cross) -->
              <svg class="svg-ng hidden" id="svgNg" viewBox="0 0 120 120">
                <line class="xline x1" x1="34" y1="34" x2="86" y2="86"></line>
                <line class="xline x2" x1="86" y1="34" x2="34" y2="86"></line>
              </svg>
            </div>

            <div class="meta">
              <div class="no" id="noText">No.</div>
              <div class="dir" id="dirText">
                <span id="dirLabel"></span>
                <span class="judge hidden" id="judgeBadge"></span>
              </div>
            </div>

            <div class="prompt-diagram-wrap hidden" id="promptDiagramWrap">
              <img id="promptDiagramImg" alt="diagram" loading="lazy" />
            </div>
            <div class="prompt" id="promptText"></div>

            <div class="choice-wrap hidden" id="choiceWrap" aria-label="4">
              <div class="choice-label">CHOICES</div>
              <div class="choices" id="choices"></div>
            </div>

            <div class="spell-wrap hidden" id="spellWrap" aria-label="">
              <div class="spell-label">SPELLING</div>
              <div class="spell-row">
                <input class="spell-input" id="spellInput" type="text"
                       inputmode="latin" autocomplete="off" autocapitalize="none" autocorrect="off" spellcheck="false"
                       placeholder="/" />
                <button class="navbtn hidden" id="readCanvasBtn" title=""></button>
              </div>
            </div>

            <div class="answer-wrap hidden" id="answerWrap">
              <div class="answer-label">ANSWER</div>
              <div class="answer" id="answerText"></div>
              <div class="answer" id="yourText" style="margin-top:6px; color: var(--muted); font-size: 13px;"></div>
            </div>

            <div class="hand-wrap hidden" id="handWrap">
              <div class="hand-title">
                <span>HANDWRITE</span>
                <span class="mini" id="handMini"></span>
              </div>
              <canvas class="hand-canvas" id="handCanvas" width="800" height="400"></canvas>
              <div class="hand-controls">
                <div class="left">
                  <button class="navbtn" id="clearCanvasBtn" title=""></button>
                </div>
                <div class="right">
                  <div class="hand-note"> or Enter </div>
                </div>
              </div>
            </div>
          </div>

          <div class="controls">
            <div class="left">
              <button class="cta" id="primaryBtn"></button>
              <button class="navbtn" id="restartBtn" title=""></button>
              <button class="navbtn hidden" id="newSetBtn" title=""></button>
            </div>

            <div class="right">
              <button class="navbtn" id="prevBtn"></button>
              <button class="navbtn" id="nextBtn"></button>
            </div>
          </div>

          <div class="hint">
            Enter /  / Esc
          </div>

          <div class="debug-bar" id="debugBar"></div>
        </section>

        <!-- Result -->
        <section class="view" id="viewResult" aria-label="">
          <div class="hero">
            <h2 class="h1" style="font-size:22px">Score</h2>
            <p class="subtitle" id="resultSub"></p>

            <div class="result-box">
              <div class="scoreline">
                <div class="scorebig" id="scoreBig"></div>
                <div class="scoresub" id="scoreSub"></div>
              </div>
            </div>

            <details id="wrongDetails">
              <summary id="wrongSummary"></summary>
              <ul class="wrong-list" id="wrongList"></ul>
            </details>

            <div class="actions" style="margin-top:12px;">
              <button class="btn" id="resultRestartBtn">
                <div class="label"></div>
                <div class="desc"></div>
              </button>
              <button class="btn" id="resultNewSetBtn">
                <div class="label"></div>
                <div class="desc"></div>
              </button>
              <button class="btn" id="resultTitleBtn">
                <div class="label"></div>
                <div class="desc"></div>
              </button>
              <button class="btn" id="resultReviewBtn">
                <div class="label"></div>
                <div class="desc"></div>
              </button>
            </div>
          </div>
        </section>
      </div>
	    </main>

    <nav class="app-tabbar" id="appTabBar" aria-label="">
      <button class="app-tab-btn is-active" type="button" data-app-tab="home" aria-selected="true">
        <span class="ms" aria-hidden="true">home</span>
        <span>Home</span>
      </button>
      <button class="app-tab-btn" type="button" data-app-tab="library" aria-selected="false">
        <span class="ms" aria-hidden="true">collections_bookmark</span>
        <span>Library</span>
      </button>
      <button class="app-tab-btn" type="button" data-app-tab="inbox" aria-selected="false">
        <span class="ms" aria-hidden="true">inbox</span>
        <span>Inbox</span>
      </button>
      <button class="app-tab-btn" type="button" data-app-tab="insight" aria-selected="false">
        <span class="ms" aria-hidden="true">query_stats</span>
        <span>Insights</span>
      </button>
      <button class="app-tab-btn" type="button" data-app-tab="chat" aria-selected="false">
        <span class="ms" aria-hidden="true">smart_toy</span>
        <span>Chat</span>
      </button>
    </nav>


	    <!-- Preset Manager -->
    <div class="overlay hidden" id="presetOverlay" role="dialog" aria-modal="true" aria-label="">
      <div class="sheet">
        <div class="sheet-header">
          <div class="sheet-title"></div>
          <button class="icon-btn" id="presetCloseBtn" aria-label="" title=""></button>
        </div>

        <div class="sheet-body" style="gap:14px">
          <div class="setting">
            <div class="text">
              <div class="name"></div>
              <div class="note">0200 / 200400 / ALL</div>
            </div>
            <div style="display:flex; gap:10px; flex-wrap:wrap;">
              <button class="textbtn" id="presetImportBtn" type="button">JSON</button>
              <button class="textbtn" id="presetShareImportBtn" type="button"></button>
              <button class="textbtn" id="presetScanBtn" type="button"></button>
              <button class="textbtn" id="presetNewBtn" type="button"></button>
            </div>
            <input id="presetImportFile" type="file" accept="application/json" style="display:none" />
          </div>

          <div class="result-box" style="padding:12px">
            <div id="presetList" style="display:flex; flex-direction:column; gap:10px;"></div>
          </div>

          <div class="setting" style="flex-direction:column; align-items:stretch;">
            <div class="preset-edit-toolbar" style="display:flex; justify-content:space-between; gap:10px; align-items:center; flex-wrap:wrap;">
              <div>
                <div class="name" style="margin:0">My Preset</div>
                <div class="note">ON/OFF</div>
              </div>
              <div style="display:flex; gap:10px; flex-wrap:wrap;">
                <button class="textbtn" id="presetExportBtn" type="button">JSON</button>
                <button class="textbtn" id="presetShareBtn" type="button"></button>
                <button class="textbtn" id="presetDeleteBtn" type="button"></button>
                <button class="textbtn" id="presetSaveBtn" type="button"></button>
              </div>
            </div>

            <div style="display:grid; gap:12px; margin-top:10px;">
              <div>
                <div class="note" style="margin-bottom:6px;"></div>
                <input class="spell-input" id="presetNameInput" type="text" placeholder=" " />
              </div>

              <div>
                <div class="note" style="margin-bottom:6px;"> / </div>
                <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
                  <select id="presetSubjectSelect" class="select" aria-label=""></select>
                  <button class="textbtn" id="presetManageSubjectsBtn" type="button"></button>
                  <button class="textbtn" id="presetManageTagsBtn" type="button"></button>
                </div>
                <div style="margin-top:10px;">
                  <div class="note" style="margin-bottom:6px;"></div>
                  <div id="presetTagPicker" class="tag-chip-row"></div>
                </div>
                <div id="presetMetaStatus" class="drawer-share-status" aria-live="polite"></div>
              </div>

              <div id="presetSubjectManager" class="result-box hidden" style="padding:12px;">
                <div class="note" style="margin-bottom:8px;"> /  / </div>
                <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
                  <input class="spell-input" id="presetSubjectNameInput" type="text" placeholder="" />
                  <input class="spell-input" id="presetSubjectColorInput" type="text" placeholder="#6aa9ff" style="max-width:150px;" />
                  <button class="navbtn" id="presetSubjectAddBtn" type="button"></button>
                </div>
                <div id="presetSubjectManagerList" style="display:flex; flex-direction:column; gap:8px; margin-top:10px;"></div>
              </div>

              <div id="presetTagManager" class="result-box hidden" style="padding:12px;">
                <div class="note" style="margin-bottom:8px;"> /  / </div>
                <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
                  <input class="spell-input" id="presetTagNameInput" type="text" placeholder="" />
                  <input class="spell-input" id="presetTagColorInput" type="text" placeholder="#8ecf8a" style="max-width:150px;" />
                  <button class="navbtn" id="presetTagAddBtn" type="button"></button>
                </div>
                <div id="presetTagManagerList" style="display:flex; flex-direction:column; gap:8px; margin-top:10px;"></div>
              </div>

              <div>
                <div class="note" style="margin-bottom:6px;"></div>
                <div style="display:flex; gap:12px; flex-wrap:wrap;">
                  <label class="toggle" style="gap:8px;">
                    <span class="note" style="min-width:90px;">TURN MODE</span>
                    <input type="checkbox" id="presetModeSeq" />
                  </label>
                  <label class="toggle" style="gap:8px;">
                    <span class="note" style="min-width:90px;">RANDOM MODE</span>
                    <input type="checkbox" id="presetModeRnd" />
                  </label>
                  <label class="toggle" style="gap:8px;">
                    <span class="note" style="min-width:90px;">WRITE MODE</span>
                    <input type="checkbox" id="presetModeHand" />
                  </label>
                  <label class="toggle" style="gap:8px;">
                    <span class="note" style="min-width:90px;">EXAM MODE</span>
                    <input type="checkbox" id="presetModeChoice" />
                  </label>
                </div>
                <div class="note" style="margin-top:8px;"> OFF</div>
              </div>

              <div class="result-box" style="padding:12px;">
                <div class="note" style="margin-bottom:6px;" id="presetSingleEditorTitle">/1</div>
                <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:flex-end;">
                  <div style="display:flex; flex-direction:column; gap:6px;">
                    <div class="note" style="margin:0;">ID</div>
                    <input class="spell-input" id="wordIdInput" inputmode="numeric" placeholder="id" style="max-width:120px;" />
                  </div>
                  <div style="display:flex; flex-direction:column; gap:6px; flex:1; min-width:170px;">
                    <div class="note" style="margin:0;" id="wordFieldLabelA"></div>
                    <input class="spell-input" id="wordWordInput" placeholder=" / " style="width:100%;" />
                  </div>
                  <div style="display:flex; flex-direction:column; gap:6px; flex:2; min-width:220px;">
                    <div class="note" style="margin:0;" id="wordFieldLabelB"></div>
                    <input class="spell-input" id="wordMeaningInput" placeholder="" style="width:100%;" />
                  </div>
                  <button class="navbtn" id="wordUpsertBtn" type="button">/</button>
                  <button class="textbtn" id="wordClearBtn" type="button"></button>
                  <button class="textbtn hidden" id="mathDiagramOpenCurrentBtn" type="button"></button>
                </div>

                <div id="mathFormatWrap" class="hidden" style="margin-top:12px; display:grid; gap:10px;">
                  <div class="note" style="margin:0;">Math  Text / LaTeX </div>
                  <div style="display:flex; gap:10px; flex-wrap:wrap;">
                    <label style="display:flex; align-items:center; gap:8px;">
                      <span class="note" style="min-width:90px;"></span>
                      <select id="wordFrontFormatSelect" class="select" style="min-width:140px;">
                        <option value="text">Text</option>
                        <option value="latex">LaTeX</option>
                      </select>
                    </label>
                    <label style="display:flex; align-items:center; gap:8px;">
                      <span class="note" style="min-width:90px;"></span>
                      <select id="wordBackFormatSelect" class="select" style="min-width:140px;">
                        <option value="text">Text</option>
                        <option value="latex">LaTeX</option>
                      </select>
                    </label>
                  </div>
                <div id="mathPreviewWrap" style="display:grid; gap:10px;">
                  <div id="mathFrontPreviewCard" class="result-box hidden" style="padding:10px;">
                    <div class="note" style="margin-bottom:6px;"></div>
                    <div id="mathFrontPreview" class="math-preview"></div>
                  </div>
                    <div id="mathBackPreviewCard" class="result-box hidden" style="padding:10px;">
                      <div class="note" style="margin-bottom:6px;"></div>
                      <div id="mathBackPreview" class="math-preview"></div>
                    </div>
                  </div>
                  <div id="mathSymbolPaletteWrap" class="hidden" style="display:grid; gap:8px;">
                    <div class="note" style="margin:0;">LaTeX</div>
                    <div id="mathSymbolPalette" class="math-symbol-row">
                      <button type="button" class="textbtn" data-math-insert="\pi"></button>
                      <button type="button" class="textbtn" data-math-insert="\theta"></button>
                      <button type="button" class="textbtn" data-math-template="sqrt"></button>
                      <button type="button" class="textbtn" data-math-insert="\sum"></button>
                      <button type="button" class="textbtn" data-math-insert="\int"></button>
                      <button type="button" class="textbtn" data-math-insert="\neq"></button>
                      <button type="button" class="textbtn" data-math-insert="\le"></button>
                      <button type="button" class="textbtn" data-math-insert="\ge"></button>
                      <button type="button" class="textbtn" data-math-insert="\pm"></button>
                      <button type="button" class="textbtn" data-math-insert="\infty"></button>
                      <button type="button" class="textbtn" data-math-insert="\to"></button>
                      <button type="button" class="textbtn" data-math-insert="\Leftrightarrow"></button>
                      <button type="button" class="textbtn" data-math-insert="\angle"></button>
                      <button type="button" class="textbtn" data-math-insert="\perp"></button>
                      <button type="button" class="textbtn" data-math-insert="\parallel"></button>
                      <button type="button" class="textbtn" data-math-insert="\in"></button>
                      <button type="button" class="textbtn" data-math-insert="\subset"></button>
                      <button type="button" class="textbtn" data-math-insert="\cup"></button>
                      <button type="button" class="textbtn" data-math-insert="\cap"></button>
                      <button type="button" class="textbtn" data-math-template="frac">fraction</button>
                      <button type="button" class="textbtn" data-math-template="power">power</button>
                      <button type="button" class="textbtn" data-math-template="subscript">subscript</button>
                    </div>
                  </div>
                </div>
                <div class="note" style="margin-top:8px;"> id</div>
              </div>

              <!-- DRAW_EDITOR_V1 -->
              <div id="mathDiagramBackdrop" class="math-diagram-backdrop hidden"></div>
              <section id="mathDiagramSection" class="hidden" aria-hidden="true">
                <header class="math-diagram-header">
                  <button class="textbtn" id="mathDiagramCloseBtn" type="button" aria-label=""></button>
                  <div class="math-diagram-headmeta">
                    <div class="math-diagram-title"></div>
                    <div id="mathDiagramTargetLabel" class="note" style="margin:0;">: </div>
                  </div>
                  <button class="navbtn" id="mathDiagramSaveBtn" type="button"></button>
                </header>

                <div class="math-diagram-toolbar-wrap">
                  <!-- DRAW_EDITOR_V2V3 -->
                  <div class="math-diagram-toolgroup">
                    <span class="note"></span>
                    <div class="math-diagram-toolbar">
                      <button type="button" class="textbtn" data-math-tool="pen"></button>
                      <button type="button" class="textbtn" data-math-tool="line"></button>
                      <button type="button" class="textbtn" data-math-tool="rect"></button>
                      <button type="button" class="textbtn" data-math-tool="circle"></button>
                      <button type="button" class="textbtn" data-math-tool="text"></button>
                      <button type="button" class="textbtn" data-math-tool="point"></button>
                    </div>
                  </div>
                  <!-- DRAW_EDITOR_V2V3 -->
                  <div class="math-diagram-toolgroup">
                    <span class="note"></span>
                    <div class="math-diagram-toolbar">
                      <button type="button" class="textbtn" data-math-tool="select"></button>
                      <button type="button" class="textbtn" data-math-tool="pan"></button>
                      <button type="button" class="textbtn" data-math-tool="eraser"></button>
                      <button type="button" class="textbtn" id="mathDiagramUndoBtn">Undo</button>
                      <button type="button" class="textbtn" id="mathDiagramRedoBtn">Redo</button>
                      <button type="button" class="textbtn" id="mathDiagramBringFrontBtn"></button>
                      <button type="button" class="textbtn" id="mathDiagramSendBackBtn"></button>
                      <button type="button" class="textbtn" id="mathDiagramDeleteBtn"></button>
                    </div>
                  </div>
                  <!-- DRAW_EDITOR_V2V3 -->
                  <div class="math-diagram-toolgroup">
                    <span class="note"></span>
                    <div class="math-diagram-toolbar">
                      <button type="button" class="textbtn" id="mathDiagramTable2Btn">2x2</button>
                      <button type="button" class="textbtn" id="mathDiagramTable3Btn">3x3</button>
                      <button type="button" class="textbtn" id="mathDiagramTable4Btn">4x4</button>
                      <button type="button" class="textbtn" id="mathDiagramTableCellEditBtn"></button>
                      <button type="button" class="textbtn" id="mathDiagramAddImageBtn"></button>
                      <button type="button" class="textbtn" id="mathDiagramZoomResetBtn"></button>
                      <button type="button" class="textbtn" id="mathDiagramClearBtn"></button>
                    </div>
                  </div>

                  <div class="math-diagram-editops">
                    <div id="mathDiagramSelectedInfo" class="note"></div>
                    <div style="display:flex; gap:6px; flex-wrap:wrap;">
                    <button type="button" class="textbtn" id="mathDiagramMoveLeftBtn"></button>
                      <button type="button" class="textbtn" id="mathDiagramMoveUpBtn"></button>
                      <button type="button" class="textbtn" id="mathDiagramMoveDownBtn"></button>
                      <button type="button" class="textbtn" id="mathDiagramMoveRightBtn"></button>
                      <button type="button" class="textbtn" id="mathDiagramRotateLeftBtn">15</button>
                      <button type="button" class="textbtn" id="mathDiagramRotateRightBtn">15</button>
                      <button type="button" class="textbtn" id="mathDiagramEditTextBtn"></button>
                    </div>
                  </div>

                  <div class="math-diagram-opts">
                    <label class="toggle" style="gap:8px;">
                      <span class="note" style="min-width:74px;"></span>
                      <input type="checkbox" id="mathDiagramGridToggle" />
                    </label>
                    <label class="toggle" style="gap:8px;">
                      <span class="note" style="min-width:74px;"></span>
                      <input type="checkbox" id="mathDiagramAxisToggle" />
                    </label>
                    <!-- DRAW_EDITOR_V2V3 -->
                    <label class="toggle" style="gap:8px;">
                      <span class="note" style="min-width:74px;"></span>
                      <input type="checkbox" id="mathDiagramSnapToggle" />
                    </label>
                    <!-- DRAW_EDITOR_V2V3 -->
                    <label class="toggle" style="gap:8px;">
                      <span class="note" style="min-width:74px;"></span>
                      <input type="checkbox" id="mathDiagramBoundsDebugToggle" />
                    </label>
                    <label style="display:flex; gap:8px; align-items:center;">
                      <span class="note"></span>
                      <input class="spell-input" id="mathPointLabelInput" type="text" maxlength="2" placeholder="A" style="max-width:74px;" />
                    </label>
                    <!-- DRAW_EDITOR_V2V3 -->
                    <label style="display:flex; gap:8px; align-items:center;">
                      <span class="note"></span>
                      <input id="mathDiagramFontSizeRange" type="range" min="10" max="64" step="1" value="20" />
                    </label>
                  </div>
                </div>

                <div class="math-diagram-canvas-wrap">
                  <canvas id="mathDiagramCanvas" width="900" height="280"></canvas>
                </div>
                <!-- DRAW_EDITOR_V2V3 -->
                <input id="mathDiagramImageInput" type="file" accept="image/*" class="hidden" />

                <footer class="math-diagram-footer">
                  <div id="mathDiagramStatus" class="note" style="margin:0;"></div>
                </footer>
              </section>

              <div class="result-box" id="presetMcqSection" style="padding:12px;">
                <div class="note" style="margin-bottom:6px;"> EXAM MODE</div>
                <div class="note" style="margin-bottom:10px;">41</div>

                <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;">
                  <label class="toggle" style="gap:8px;">
                    <span class="note" style="min-width:150px;"></span>
                    <input type="checkbox" id="mcqEnable" />
                  </label>

                  <div style="display:flex; gap:10px; flex-wrap:wrap;">
                    <button class="textbtn" id="mcqFillCorrectBtn" type="button">meaning</button>
                    <button class="textbtn" id="mcqClearBtn" type="button"></button>
                  </div>
                </div>

                <div id="mcqFields" class="hidden" style="margin-top:12px; display:grid; gap:10px;">
                  <div style="display:flex; gap:10px; align-items:center;">
                    <label style="display:flex; align-items:center; gap:8px; min-width:56px;">
                      <input type="radio" name="mcqCorrect" value="0" />
                      <span class="note" style="font-weight:600; color:var(--text);">A</span>
                    </label>
                    <input class="spell-input" id="mcqChoice0" placeholder=" A" style="flex:1; min-width:220px;" />
                  </div>
                  <div style="display:flex; gap:10px; align-items:center;">
                    <label style="display:flex; align-items:center; gap:8px; min-width:56px;">
                      <input type="radio" name="mcqCorrect" value="1" />
                      <span class="note" style="font-weight:600; color:var(--text);">B</span>
                    </label>
                    <input class="spell-input" id="mcqChoice1" placeholder=" B" style="flex:1; min-width:220px;" />
                  </div>
                  <div style="display:flex; gap:10px; align-items:center;">
                    <label style="display:flex; align-items:center; gap:8px; min-width:56px;">
                      <input type="radio" name="mcqCorrect" value="2" />
                      <span class="note" style="font-weight:600; color:var(--text);">C</span>
                    </label>
                    <input class="spell-input" id="mcqChoice2" placeholder=" C" style="flex:1; min-width:220px;" />
                  </div>
                  <div style="display:flex; gap:10px; align-items:center;">
                    <label style="display:flex; align-items:center; gap:8px; min-width:56px;">
                      <input type="radio" name="mcqCorrect" value="3" />
                      <span class="note" style="font-weight:600; color:var(--text);">D</span>
                    </label>
                    <input class="spell-input" id="mcqChoice3" placeholder=" D" style="flex:1; min-width:220px;" />
                  </div>
                </div>
              </div>

              <div>
                <div class="note" style="margin-bottom:6px;"></div>
                <div class="note" id="bulkHintEnglish" style="margin-bottom:6px;"><code>id  </code> 1OK//</div>
                <div class="note hidden" id="bulkHintGeneric" style="margin-bottom:6px;"><code>id  </code> 1 / 2 / <code> | </code></div>
                <textarea id="bulkTextarea" style="width:100%; min-height:120px; border:1px solid var(--border); border-radius:12px; padding:12px; font-size:14px; line-height:1.5; outline:none;"></textarea>
                <div style="display:flex; gap:10px; margin-top:8px; flex-wrap:wrap;">
                  <button class="navbtn" id="bulkAddBtn" type="button"></button>
                  <button class="textbtn" id="bulkClearBtn" type="button"></button>
                  <button class="textbtn" id="presetClearWordsBtn" type="button"></button>
                </div>
              </div>

              <div>
                <div class="note" style="margin-bottom:6px;" id="presetPreviewTitle">50</div>
                <div class="result-box" style="padding:12px; max-height:240px; overflow:auto;">
                  <div id="presetWordsPreview" style="display:flex; flex-direction:column; gap:10px;"></div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="sheet-footer">
          <button class="textbtn" id="presetCloseBtn2" type="button"></button>
        </div>
      </div>
    </div>

    <div class="scan-gen-overlay hidden" id="scanGenOverlay" role="dialog" aria-modal="true" aria-label="">
      <button class="scan-gen-backdrop" type="button" data-scan-action="close" aria-label=""></button>
      <section class="scan-gen-sheet" aria-live="polite">
        <header class="scan-gen-head">
          <div>
            <div class="scan-gen-title"></div>
            <p class="scan-sub"></p>
          </div>
          <button class="icon-btn" type="button" data-scan-action="close" aria-label=""></button>
        </header>

        <div class="scan-gen-body">
          <section class="scan-card">
            <h4>1) </h4>
            <div class="scan-row">
              <label class="scan-type-chip">
                <input type="radio" name="scanGenType" value="single" checked />
                <span>Single</span>
              </label>
              <label class="scan-type-chip">
                <input type="radio" name="scanGenType" value="double" />
                <span>Double</span>
              </label>
            </div>
          </section>

          <section class="scan-card">
            <h4>2) </h4>
            <div class="scan-row">
              <label class="textbtn scan-file-btn">
                
                <input id="scanMainImageInput" type="file" accept="image/*" />
              </label>
              <span class="scan-sub"></span>
            </div>
            <div id="scanMainThumbList" class="scan-thumb-list"></div>
            <div id="scanImageMeta" class="scan-sub"></div>
            <div id="scanRefBlock" class="hidden" style="display:grid; gap:10px;">
              <div class="scan-row">
                <label class="textbtn scan-file-btn">
                  
                  <input id="scanRefImageInput" type="file" accept="image/*" />
                </label>
                <span class="scan-sub">Double</span>
              </div>
              <div id="scanRefThumbList" class="scan-thumb-list"></div>
            </div>
          </section>

          <section class="scan-card">
            <h4>3) </h4>
            <textarea id="scanPromptInput" class="spell-input" style="min-height:112px; resize:vertical;" placeholder="424"></textarea>
          </section>

          <section class="scan-card">
            <h4>4) </h4>
            <div class="scan-formats">
              <label class="scan-format-chip"><input type="checkbox" data-scan-format="mcq" checked /> 4</label>
              <label class="scan-format-chip"><input type="checkbox" data-scan-format="write" checked /> </label>
              <label class="scan-format-chip"><input type="checkbox" data-scan-format="select" checked /> </label>
            </div>
          </section>

          <section class="scan-card">
            <h4>5) </h4>
            <div class="scan-grid">
              <div class="scan-field">
                <label for="scanCountInput">1260</label>
                <input id="scanCountInput" class="spell-input" type="number" min="12" max="60" step="1" value="24" />
              </div>
              <div class="scan-field">
                <label for="scanMarkerInput"></label>
                <input id="scanMarkerInput" class="spell-input" type="number" min="1" max="60" step="1" value="4" />
              </div>
              <div class="scan-field">
                <label for="scanExtractCharsSelect"></label>
                <select id="scanExtractCharsSelect" class="select">
                  <option value="10">10</option>
                  <option value="15" selected>15</option>
                  <option value="20">20</option>
                  <option value="30">30</option>
                </select>
              </div>
              <div class="scan-field">
                <label for="scanDifficultySelect"></label>
                <select id="scanDifficultySelect" class="select">
                  <option value="easy">easy</option>
                  <option value="normal" selected>normal</option>
                  <option value="hard">hard</option>
                </select>
              </div>
            </div>
          </section>

          <section class="scan-card">
            <h4>6) </h4>
            <ul id="scanStepList" class="scan-steps">
              <li class="scan-step" data-step-index="0"><span class="dot"></span><span></span></li>
              <li class="scan-step" data-step-index="1"><span class="dot"></span><span></span></li>
              <li class="scan-step" data-step-index="2"><span class="dot"></span><span></span></li>
              <li class="scan-step" data-step-index="3"><span class="dot"></span><span></span></li>
              <li class="scan-step" data-step-index="4"><span class="dot"></span><span></span></li>
              <li class="scan-step" data-step-index="5"><span class="dot"></span><span></span></li>
              <li class="scan-step" data-step-index="6"><span class="dot"></span><span></span></li>
            </ul>
            <div id="scanStatus" class="scan-status"></div>
            <details id="scanDebugDetails" class="scan-debug hidden">
              <summary>debug</summary>
              <pre id="scanDebugPre"></pre>
            </details>
            <div class="scan-row">
              <button class="navbtn" type="button" data-scan-action="run"></button>
              <button class="textbtn" type="button" data-scan-action="cancel"></button>
              <button class="textbtn hidden" id="scanRetryBtn" type="button" data-scan-action="retry"></button>
            </div>
          </section>

          <section id="scanResultCard" class="scan-card hidden">
            <h4></h4>
            <div id="scanResultMeta" class="scan-result-meta"></div>
            <div id="scanReconstructedView" class="scan-reconstructed"></div>
            <div id="scanQuestionList" class="scan-question-list"></div>
            <div class="scan-result-actions">
              <button class="navbtn" type="button" data-scan-action="addPreset"></button>
              <button class="textbtn" type="button" data-scan-action="copyJson">JSON</button>
              <button class="textbtn" type="button" data-scan-action="close"></button>
            </div>
          </section>
        </div>

        <footer class="scan-gen-foot">
          <button class="textbtn" type="button" data-scan-action="close"></button>
        </footer>
      </section>
    </div>

    <div class="overlay hidden" id="settingsOverlay" role="dialog" aria-modal="true" aria-label="">
      <div class="sheet settings-fullsheet">
        <div class="settings-nav">
          <button class="icon-btn settings-back-btn" id="closeSettingsBtn" aria-label="" title="">
            <span class="ms" aria-hidden="true">arrow_back</span>
          </button>
          <div class="settings-nav-title" id="settingsNavTitle"></div>
          <button class="textbtn hidden" id="closeSettingsBtn2" type="button"></button>
        </div>

        <div class="settings-screen-wrap">
          <div id="settingsMainPane">
            <section class="settings-page is-active" id="settingsPageRoot" data-settings-page="root">
              <div class="settings-section-title"></div>
              <div class="settings-group">
                <button class="settings-row" type="button" data-settings-nav="practice">
                  <span class="label">Practice</span>
                  <span class="value" id="settingsSummaryPractice"></span>
                </button>
                <button class="settings-row" type="button" data-settings-nav="sound">
                  <span class="label">Sound</span>
                  <span class="value" id="settingsSummarySound">BGM ON</span>
                </button>
                <button class="settings-row" type="button" data-settings-nav="display">
                  <span class="label">Display</span>
                  <span class="value" id="settingsSummaryDisplay">Auto</span>
                </button>
                <button class="settings-row" type="button" data-settings-nav="account">
                  <span class="label"></span>
                  <span class="value" id="settingsSummaryAccount"></span>
                </button>
              </div>

              <div class="settings-section-title"></div>
              <div class="settings-group">
                <button class="settings-row" type="button" data-settings-nav="data">
                  <span class="label"></span>
                  <span class="value">></span>
                </button>
                <button class="settings-row" type="button" data-settings-nav="admin">
                  <span class="label">Admin</span>
                  <span class="value" id="settingsSummaryAdmin"></span>
                </button>
              </div>
            </section>

            <section class="settings-page" id="settingsPagePractice" data-settings-page="practice">
              <div class="settings-section-title">Practice</div>
              <div class="settings-group">
                <div class="settings-row is-static">
                  <span class="label"></span>
                  <div class="settings-seg" role="tablist" aria-label="">
                    <button type="button" id="dirEnJaBtn" role="tab" aria-selected="false"></button>
                    <button type="button" id="dirJaEnBtn" role="tab" aria-selected="false"></button>
                  </div>
                </div>
                <label class="settings-row is-static" for="settingsQuestionCountSelect">
                  <span class="label">EXAM/WRITE </span>
                  <select id="settingsQuestionCountSelect" class="select settings-select">
                    <option value="10">10</option>
                    <option value="20">20</option>
                    <option value="50">50</option>
                    <option value="100">100</option>
                  </select>
                </label>
                <label class="settings-row is-static" for="settingsExamTimeSelect">
                  <span class="label">EXAM </span>
                  <select id="settingsExamTimeSelect" class="select settings-select">
                    <option value="0"></option>
                    <option value="5">5</option>
                    <option value="10">10</option>
                    <option value="30">30</option>
                    <option value="60">60</option>
                  </select>
                </label>
                <label class="settings-row is-static" for="settingsAutoNextToggle">
                  <span class="label"></span>
                  <span class="toggle"><input type="checkbox" id="settingsAutoNextToggle" /></span>
                </label>
                <div class="settings-note"></div>
              </div>
            </section>

            <section class="settings-page" id="settingsPageSound" data-settings-page="sound">
              <div class="settings-section-title">Sound</div>
              <div class="settings-group">
                <label class="settings-row settings-cell is-static" for="bgmToggle">
                  <span class="label">BGM</span>
                  <span class="right"><span class="toggle"><input type="checkbox" id="bgmToggle" /></span></span>
                </label>
                <label class="settings-row settings-cell is-static" for="sfxToggle">
                  <span class="label"></span>
                  <span class="right"><span class="toggle"><input type="checkbox" id="sfxToggle" /></span></span>
                </label>
                <div class="settings-row settings-cell is-static">
                  <span class="label">BGM</span>
                  <div class="right">
                    <div class="settings-seg" role="tablist" aria-label="BGM ">
                      <button type="button" id="bgmVolSmallBtn" role="tab" aria-selected="false"></button>
                      <button type="button" id="bgmVolDefaultBtn" role="tab" aria-selected="false"></button>
                      <button type="button" id="bgmVolLargeBtn" role="tab" aria-selected="false"></button>
                    </div>
                  </div>
                </div>
                <label class="settings-row settings-cell is-static" for="settingsSfxVolumeSelect">
                  <span class="label"></span>
                  <span class="right">
                    <select id="settingsSfxVolumeSelect" class="select settings-select">
                      <option value="SMALL"></option>
                      <option value="DEFAULT"></option>
                      <option value="LARGE"></option>
                    </select>
                  </span>
                </label>
              </div>
            </section>

            <section class="settings-page" id="settingsPageDisplay" data-settings-page="display">
              <div class="settings-section-title">Display</div>
              <div class="settings-group">
                <label class="settings-row is-static" for="settingsThemeSelect">
                  <span class="label"></span>
                  <select id="settingsThemeSelect" class="select settings-select">
                    <option value="AUTO">Auto</option>
                    <option value="LIGHT">Light</option>
                    <option value="DARK">Dark</option>
                  </select>
                </label>
                <label class="settings-row is-static" for="settingsFontSizeSelect">
                  <span class="label"></span>
                  <select id="settingsFontSizeSelect" class="select settings-select">
                    <option value="SMALL"></option>
                    <option value="DEFAULT"></option>
                    <option value="LARGE"></option>
                  </select>
                </label>
                <label class="settings-row is-static" for="animToggle">
                  <span class="label"></span>
                  <span class="toggle"><input type="checkbox" id="animToggle" /></span>
                </label>
              </div>
            </section>

            <section class="settings-page" id="settingsPageAccount" data-settings-page="account">
              <div class="settings-section-title"></div>
              <div class="settings-group">
                <div class="settings-row is-static">
                  <span class="label"></span>
                  <span class="value" id="settingsAccountStateLine"></span>
                </div>
                <div class="settings-row is-static">
                  <span class="label"></span>
                  <span class="value" id="settingsAccountUserLine"></span>
                </div>
              </div>
              <div class="account-user-card" id="settingsAccountUserCard">
                <div class="account-user-title" id="settingsAccountCardTitle"></div>
                <div class="account-user-meta" id="settingsAccountCardMeta"></div>
              </div>
              <div class="settings-group">
                <button class="settings-row" id="settingsAccountOpenLoginBtn" type="button">
                  <span class="label"></span>
                  <span class="value"></span>
                </button>
                <button class="settings-row" id="settingsAccountOpenRegisterBtn" type="button">
                  <span class="label"></span>
                  <span class="value"></span>
                </button>
                <button class="settings-row hidden" id="settingsAccountSwitchFromGuestBtn" type="button">
                  <span class="label"></span>
                  <span class="value"></span>
                </button>
                <button class="settings-row hidden" id="settingsAccountLogoutBtn" type="button">
                  <span class="label"></span>
                  <span class="value"></span>
                </button>
                <button class="settings-row danger-action hidden" id="settingsAccountDeleteBtn" type="button">
                  <span class="label"></span>
                  <span class="value"></span>
                </button>
              </div>
              <div id="settingsAccountStatus" class="drawer-share-status" aria-live="polite"></div>
            </section>

            <section class="settings-page" id="settingsPageData" data-settings-page="data">
              <div class="settings-section-title"></div>
              <div class="settings-group">
                <button class="settings-row" id="backupCreateNowBtn" type="button">
                  <span class="label"></span>
                  <span class="value"></span>
                </button>
                <button class="settings-row" id="backupExportBtn" type="button">
                  <span class="label">JSON</span>
                  <span class="value"></span>
                </button>
                <button class="settings-row" id="backupImportBtn" type="button">
                  <span class="label">JSON</span>
                  <span class="value"></span>
                </button>
                <button class="settings-row" id="backupRestoreLatestBtn" type="button">
                  <span class="label"></span>
                  <span class="value"></span>
                </button>
                <button class="settings-row danger-action" id="settingsDeleteLogsBtn" type="button">
                  <span class="label"></span>
                  <span class="value"></span>
                </button>
                <button class="settings-row danger-action" id="settingsClearShareCacheBtn" type="button">
                  <span class="label"></span>
                  <span class="value"></span>
                </button>
                <button class="settings-row danger-action" id="settingsFactoryResetBtn" type="button">
                  <span class="label"></span>
                  <span class="value"></span>
                </button>
                <label class="settings-row is-static" for="debugToggle">
                  <span class="label"></span>
                  <span class="toggle"><input type="checkbox" id="debugToggle" /></span>
                </label>
              </div>
              <div id="backupStatus" class="drawer-share-status" aria-live="polite"></div>
            </section>

            <section class="settings-page" id="settingsPageAdmin" data-settings-page="admin">
              <div class="settings-section-title">Admin</div>
              <div class="settings-group">
                <div class="settings-row is-static">
                  <span class="label"></span>
                  <span class="value" id="adminAuthStateLine"></span>
                </div>
                <div class="settings-row is-static">
                  <span class="label"></span>
                  <span class="value" id="adminAuthRoleLine">User</span>
                </div>
                <div class="settings-row is-static">
                  <button class="textbtn" id="adminLoginBtn" type="button">Admin Login</button>
                  <button class="textbtn" id="adminLogoutBtn" type="button">Logout</button>
                </div>
                <button class="settings-row hidden" id="adminOpenNotifEditorBtn" type="button">
                  <span class="label"></span>
                  <span class="value">></span>
                </button>
                <button class="settings-row hidden" id="adminOpenHelpEditorBtn" type="button">
                  <span class="label"></span>
                  <span class="value">></span>
                </button>
              </div>
              <div id="adminAuthStatus" class="drawer-share-status" aria-live="polite"></div>
              <div class="settings-section-title"></div>
              <div id="adminMaintenanceLockedNote" class="note">Admin</div>
              <div class="settings-group" id="adminMaintenanceGroup">
                <label class="settings-row is-static" for="adminMaintenanceEnabled">
                  <span class="label"></span>
                  <span class="toggle"><input type="checkbox" id="adminMaintenanceEnabled" /></span>
                </label>
                <label class="settings-row is-static" for="adminMaintenanceStartAt">
                  <span class="label"></span>
                  <input class="spell-input" id="adminMaintenanceStartAt" type="datetime-local" />
                </label>
                <label class="settings-row is-static" for="adminMaintenanceEndAt">
                  <span class="label"></span>
                  <input class="spell-input" id="adminMaintenanceEndAt" type="datetime-local" />
                </label>
                <label class="settings-row is-static" for="adminMaintenanceTitle">
                  <span class="label"></span>
                  <input class="spell-input" id="adminMaintenanceTitle" type="text" maxlength="80" placeholder="" />
                </label>
                <label class="settings-row is-static" for="adminMaintenanceMessage">
                  <span class="label"></span>
                  <textarea class="spell-input" id="adminMaintenanceMessage" rows="3" placeholder=""></textarea>
                </label>
                <button class="settings-row" id="adminMaintenanceSaveBtn" type="button">
                  <span class="label"></span>
                  <span class="value"></span>
                </button>
                <button class="settings-row" id="adminMaintenanceClearExpiredBtn" type="button">
                  <span class="label"></span>
                  <span class="value"></span>
                </button>
              </div>
              <div id="adminMaintenanceStatus" class="drawer-share-status" aria-live="polite"></div>
              <div id="adminMaintenancePreview" class="maintenance-admin-preview" aria-live="polite"></div>
              <div class="settings-section-title">AIRAG</div>
              <div id="adminAiIngestLockedNote" class="note">RAGAdmin</div>
              <div class="settings-group hidden" id="adminAiIngestGroup">
                <label class="settings-row is-static" for="adminAiIngestKey">
                  <span class="label">Admin Key</span>
                  <input class="spell-input" id="adminAiIngestKey" type="password" autocomplete="off" placeholder="env.ADMIN_KEY" />
                </label>
                <label class="settings-row is-static" for="adminAiIngestJson">
                  <span class="label">JSON</span>
                  <textarea class="spell-input" id="adminAiIngestJson" rows="8" placeholder='{\"docs\":[{\"id\":\"help-001\",\"title\":\"\",\"tags\":[\"share\",\"qr\"],\"text\":\"...\",\"updatedAt\":1730000000000}]}'></textarea>
                </label>
                <button class="settings-row" id="adminAiIngestBtn" type="button">
                  <span class="label">RAG</span>
                  <span class="value"></span>
                </button>
              </div>
              <div id="adminAiIngestStatus" class="drawer-share-status" aria-live="polite"></div>
            </section>
          </div>

          <section class="admin-notif-editor hidden" id="adminNotifEditor">
            <div class="text">
              <div class="name"></div>
              <div class="note">Firestore: notificationsAdmin</div>
            </div>
            <div class="admin-editor-actions">
              <button class="textbtn" id="adminNotifBackBtn" type="button"></button>
              <button class="textbtn" id="adminNotifReloadBtn" type="button"></button>
            </div>
            <div id="adminNotifStatus" class="drawer-share-status" aria-live="polite"></div>
            <div class="admin-editor-form">
              <input id="adminNotifDocId" type="hidden" />
              <label>
                
                <input class="spell-input" id="adminNotifTitle" type="text" placeholder="" />
              </label>
              <label>
                
                <textarea class="spell-input" id="adminNotifBody" placeholder="## UPDATE&#10;**IMPORTANT**&#10;![img](https://example.com/a.jpg)&#10;[video](https://example.com/a.mp4)&#10;[link](https://example.com)"></textarea>
              </label>
              <div class="note">/</div>
              <div class="admin-editor-grid">
                <label>
                  Category
                  <select class="select" id="adminNotifCategory">
                    <option value="Update">Update</option>
                    <option value="Study">Study</option>
                    <option value="Preset">Preset</option>
                    <option value="System">System</option>
                  </select>
                </label>
                <label>
                  Priority
                  <select class="select" id="adminNotifPriority">
                    <option value="normal">normal</option>
                    <option value="low">low</option>
                    <option value="high">high</option>
                  </select>
                </label>
                <label>
                  PublishedAt
                  <input class="spell-input" id="adminNotifPublishedAt" type="datetime-local" />
                </label>
              </div>
              <div class="admin-editor-submit">
                <button class="navbtn" id="adminNotifSaveBtn" type="button"></button>
                <button class="textbtn" id="adminNotifClearBtn" type="button"></button>
                <button class="textbtn hidden" id="adminNotifCancelEditBtn" type="button"></button>
              </div>
            </div>
            <div class="admin-notif-list" id="adminNotifList"></div>
            <div class="note hidden" id="adminNotifEmpty"></div>
          </section>
        </div>

        <div class="settings-statusbar">
          <div id="settingsInlineStatus" class="drawer-share-status" aria-live="polite"></div>
          <input id="backupImportFile" type="file" accept="application/json,.json" class="hidden" />
        </div>
      </div>
    </div>

    <div class="overlay hidden" id="timeOverlay" role="dialog" aria-modal="true" aria-label="">
      <div class="sheet">
        <div class="sheet-header">
          <div class="sheet-title">1</div>
          <button class="icon-btn" id="closeTimeBtn" aria-label="" title=""></button>
        </div>

        <div class="sheet-body">
          <div class="section-title" style="margin:0; text-transform:none; letter-spacing:normal;">
            <span></span><span class="right">1</span>
          </div>

          <div class="actions" style="margin-top:0;">
            <button class="btn" id="time5Btn"><div class="label"><span>5</span></div><div class="desc"></div></button>
            <button class="btn" id="time10Btn"><div class="label"><span>10</span></div><div class="desc"></div></button>
            <button class="btn" id="time30Btn"><div class="label"><span>30</span></div><div class="desc"></div></button>
            <button class="btn" id="time60Btn"><div class="label"><span>60</span></div><div class="desc"></div></button>
            <button class="btn" id="timeNoneBtn" style="grid-column:1 / -1;">
              <div class="label"><span></span></div>
              <div class="desc"></div>
            </button>
          </div>

          <div class="fineprint" style="margin-top:0;">
            <span class="badge">Note</span>
            <span></span>
          </div>
        </div>

        <div class="sheet-footer">
          <button class="textbtn" id="cancelTimeBtn"></button>
        </div>
      </div>
    </div>

    <div class="corner">
      <div class="version">
        Version 1.0<br />
         2026 RintyStudio
      </div>
    </div>
  </div>

  

  <!-- Update Notes -->
  <div class="overlay hidden" id="updateOverlay" role="dialog" aria-modal="true" aria-label="">
    <div class="sheet update-sheet">
      <div class="sheet-header">
        <div class="sheet-title">VocabuQuiz</div>
        <button class="icon-btn" id="updateCloseXBtn" aria-label="" title=""></button>
      </div>

      <div class="sheet-body">
        <article class="update-article">
          <h2 class="update-headline">VocabuQuiz</h2>
          <div class="update-date">2026-02-14 0:00</div>

          <div class="update-content">
          <p>VocabuQuiz verv.1.0 </p>
            <ul>
              <li><b></b> <br></br><b> () EXAM MODE  </b> <b></b> </li>
              <li><b></b><b>""</b></li>
            </ul>
            <p class="update-note"> </p>
          </div>
        </article>
      </div>

      <div class="sheet-footer update-footer">
        <label class="checkrow">
          <input type="checkbox" id="updateDontShowChk" />
          <span></span>
        </label>
        <button class="textbtn" id="updateCloseBtn" type="button"></button>
      </div>
    </div>
  </div>
  
  <!-- Insights Dashboard -->
  <div class="overlay hidden" id="insightsOverlay" role="dialog" aria-modal="true" aria-label="Insights">
    <div class="sheet insights-sheet" id="insightsPanel">
      <div class="sheet-header" id="insightsHeader">
        <div>
          <div class="sheet-title"></div>
          <div class="sheet-sub"></div>
        </div>
        <button class="icon-btn" id="insightsCloseBtn" aria-label="" title=""></button>
      </div>

      <div class="sheet-body insights-body" id="insightsBody">
        <div class="insights-filters" id="insightsFilters">
          <div class="filter-item">
            <div class="filter-label"></div>
            <select id="insightsPresetSelect" class="select" aria-label="Preset"></select>
          </div>
          <div class="filter-item">
            <div class="filter-label"></div>
            <select id="insightsModeSelect" class="select" aria-label="Mode">
              <option value="ALL">ALL</option>
              <option value="HAND">WRITE MODE</option>
              <option value="CHOICE">EXAM MODE</option>
              <option value="RND">RANDOM MODE</option>
              <option value="SEQ">TURN MODE</option>
            </select>
          </div>
          <div class="filter-item">
            <div class="filter-label">Range</div>
            <select id="insightsRangeSelect" class="select" aria-label="Range">
              <option value="7D">7D</option>
              <option value="30D" selected>30D</option>
              <option value="ALL">ALL</option>
            </select>
          </div>
        </div>

        <div class="insights-summary" id="insightsSummary"></div>

        <div class="insights-grid">
          <section class="insight-card">
            <div class="insight-head">
              <div class="insight-title"></div>
              <div class="insight-note" id="trendNote"></div>
            </div>
            <div class="chart" id="chartAccuracyTrend"></div>
          </section>

          <section class="insight-card">
            <div class="insight-head">
              <div class="insight-title"> </div>
              <div class="insight-note">A-1</div>
            </div>
            <div class="chart" id="chartDailyVolume"></div>
          </section>

          <section class="insight-card">
            <div class="insight-head">
              <div class="insight-title"> </div>
              <div class="insight-note">A-2</div>
            </div>
            <div class="chart" id="chartDailyAccuracy"></div>
          </section>

          <section class="insight-card">
            <div class="insight-head">
              <div class="insight-title"> </div>
              <div class="insight-note">A-3</div>
            </div>
            <div class="table-wrap" id="tableModeDistribution"></div>
          </section>

          <section class="insight-card" id="modeAccuracyCard">
            <div class="insight-head">
              <div class="insight-title"></div>
              <div class="insight-note"></div>
            </div>
            <div class="chart" id="chartModeAccuracy"></div>
          </section>

          <section class="insight-card">
            <div class="insight-head">
              <div class="insight-title"></div>
              <div class="insight-note">10</div>
            </div>
            <div class="weak-list" id="chartWeakTop10"></div>
          </section>

          <section class="insight-card">
            <div class="insight-head">
              <div class="insight-title"> </div>
              <div class="insight-note">C-1</div>
            </div>
            <div class="chart" id="chartAvgTimeTrend"></div>
          </section>

          <section class="insight-card">
            <div class="insight-head">
              <div class="insight-title"></div>
              <div class="insight-note">C-2</div>
            </div>
            <div class="table-wrap" id="tableTimeoutByMode"></div>
          </section>

          <section class="insight-card">
            <div class="insight-head">
              <div class="insight-title"> vs </div>
              <div class="insight-note">E-1</div>
            </div>
            <div class="table-wrap" id="tableWeekCompare"></div>
          </section>

          <section class="insight-card">
            <div class="insight-head">
              <div class="insight-title">30 vs 30</div>
              <div class="insight-note">E-2</div>
            </div>
            <div class="table-wrap" id="tableMonthCompare"></div>
          </section>

          <section class="insight-card">
            <div class="insight-head">
              <div class="insight-title">Data</div>
              <div class="insight-note">Export / Delete</div>
            </div>
            <div class="insights-actions">
              <button class="textbtn" id="insightsExportBtn" type="button">/JSON</button>
              <button class="textbtn" id="insightsDeleteBtn" type="button">/</button>
            </div>
            <div class="note" style="margin-top:10px; line-height:1.6;">
               
            </div>
          </section>
        </div>
      </div>
    </div>
  </div>


  <!-- In-app Alerts -->
  <div class="ui-modal" id="uiModal" aria-hidden="true">
    <div class="ui-modal-backdrop" data-close="1"></div>
    <div class="ui-modal-card" role="dialog" aria-modal="true" aria-labelledby="uiModalTitle" aria-describedby="uiModalMessage">
      <div class="ui-modal-title" id="uiModalTitle"></div>
      <div class="ui-modal-message" id="uiModalMessage"></div>
      <div class="ui-modal-actions">
        <button class="textbtn" id="uiModalCancel" type="button"></button>
        <button class="navbtn" id="uiModalOk" type="button">OK</button>
      </div>
    </div>
  </div>


  <!-- Notifications -->
  <div class="overlay hidden" id="notifyOverlay" role="dialog" aria-modal="true" aria-label="">
    <div class="sheet notify-sheet">
      <div class="sheet-header">
        <div>
          <div class="sheet-title"></div>
          <div class="sheet-sub">Updates & messages</div>
        </div>
        <button class="icon-btn" id="notifyCloseBtn" aria-label="" title="">
          <span class="ms" aria-hidden="true">close</span>
        </button>
      </div>

      <div class="sheet-body notify-body">
        <div class="notify-pane" id="notifyListPane">
          <div class="notify-empty hidden" id="notifyEmpty"></div>
          <div class="notify-list" id="notifyList"></div>
        </div>
        <div class="notify-pane hidden" id="notifyDetailPane">
          <div class="notify-detail-wrap">
            <div class="notify-detail-head">
              <button class="textbtn" id="notifyDetailBackBtn" type="button"></button>
              <div class="notify-detail-meta" id="notifyDetailMeta"></div>
            </div>
            <h3 class="notify-detail-title" id="notifyDetailTitle"></h3>
            <div id="notifyDetailContent" class="notify-detail-content"></div>
          </div>
        </div>
      </div>

      <div class="sheet-footer">
        <button class="textbtn" id="notifyCloseBtn2" type="button"></button>
      </div>
    </div>
  </div>


  <!-- Search -->
  <div class="overlay hidden" id="searchOverlay" role="dialog" aria-modal="true" aria-label="">
    <div class="sheet search-sheet">
      <div class="sheet-header">
        <div>
          <div class="sheet-title"></div>
          <div class="sheet-sub"></div>
        </div>
        <button class="icon-btn" id="searchCloseBtn" aria-label="" title="">
          <span class="ms" aria-hidden="true">close</span>
        </button>
      </div>

      <div class="sheet-body search-body">
        <div class="search-input-wrap">
          <input id="searchInput" class="spell-input" type="text"
            placeholder="No / word / meaning"
            inputmode="text" autocomplete="off" autocapitalize="none" spellcheck="false" />
        </div>

        <div class="search-empty hidden" id="searchEmpty">No results. </div>
        <div class="search-list" id="searchList" role="listbox" aria-label=""></div>
      </div>
    </div>
  </div>

  <!-- Optional public config fallback. Keep placeholder-only in repo. -->
  <script src="./config.public.example.js"></script>
  <!-- Optional local runtime config (create config.public.js locally; keep it out of git). -->
  <script src="./config.public.js"></script>
  <!-- Optional QR decoding fallback (used only when BarcodeDetector is unavailable). -->
  <script src="https://www.gstatic.com/firebasejs/10.13.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.13.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.13.2/firebase-firestore-compat.js"></script>
  <script src="https://unpkg.com/jsqr@1.4.0/dist/jsQR.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@emailjs/browser@4/dist/email.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" crossorigin="anonymous"></script>

<script>
    ;(() => {
      "use strict";

      // Security: load publish-safe config from config.public.js, legacy globals, meta, and cache.
      const PUBLIC_RUNTIME_CACHE_KEY = "app.public.config.v1";
      function _sanitizePublicConfigValue(v){
        const s = String(v ?? "").trim();
        if (!s) return "";
        if (/^__.+__$/.test(s)) return "";
        if (/^YOUR_[A-Z0-9_]+$/i.test(s)) return "";
        return s;
      }
      function _metaConfigValue(name){
        const el = document.querySelector(`meta[name="${name}"]`);
        if (!el) return "";
        return _sanitizePublicConfigValue(el.getAttribute("content"));
      }
      function _metaConfigValueAny(names){
        for (const name of (Array.isArray(names) ? names : [])){
          const v = _metaConfigValue(name);
          if (v) return v;
        }
        return "";
      }
      function _readPublicRuntimeCache(){
        try{
          const raw = window.localStorage.getItem(PUBLIC_RUNTIME_CACHE_KEY);
          if (!raw) return {};
          const parsed = JSON.parse(raw);
          return (parsed && typeof parsed === "object") ? parsed : {};
        }catch{
          return {};
        }
      }
      function _savePublicRuntimeCache(cfg){
        try{
          if (!cfg || typeof cfg !== "object") return;
          window.localStorage.setItem(PUBLIC_RUNTIME_CACHE_KEY, JSON.stringify(cfg));
        }catch{}
      }
      function _normalizeFirebaseConfig(raw){
        const src = (raw && typeof raw === "object") ? raw : {};
        return {
          apiKey: _sanitizePublicConfigValue(src.apiKey || src.piKey || src.API_KEY || src.firebaseApiKey),
          authDomain: _sanitizePublicConfigValue(src.authDomain || src.AUTH_DOMAIN),
          projectId: _sanitizePublicConfigValue(src.projectId || src.projectID || src.PROJECT_ID || src.firebaseProjectId),
          storageBucket: _sanitizePublicConfigValue(src.storageBucket || src.STORAGE_BUCKET),
          messagingSenderId: _sanitizePublicConfigValue(src.messagingSenderId || src.messaging_sender_id || src.MESSAGING_SENDER_ID),
          appId: _sanitizePublicConfigValue(src.appId || src.APP_ID)
        };
      }
      function _normalizeEmailJsConfig(raw){
        const src = (raw && typeof raw === "object") ? raw : {};
        return {
          serviceId: _sanitizePublicConfigValue(src.serviceId),
          templateId: _sanitizePublicConfigValue(src.templateId),
          publicKey: _sanitizePublicConfigValue(src.publicKey)
        };
      }
      function _hasFirebaseConfig(cfg){
        const c = _normalizeFirebaseConfig(cfg);
        return !!(c.apiKey && c.projectId);
      }
      function _hasEmailJsConfig(cfg){
        const c = _normalizeEmailJsConfig(cfg);
        return !!(c.serviceId && c.templateId && c.publicKey);
      }
      function _readPublicRuntimeConfig(){
        const root = (window.__PUBLIC_CONFIG__ && typeof window.__PUBLIC_CONFIG__ === "object")
          ? window.__PUBLIC_CONFIG__
          : {};
        const cache = _readPublicRuntimeCache();
        const firebaseLegacy = (window.__FIREBASE_CONFIG__ && typeof window.__FIREBASE_CONFIG__ === "object")
          ? window.__FIREBASE_CONFIG__
          : ((window.firebaseConfig && typeof window.firebaseConfig === "object")
            ? window.firebaseConfig
            : ((window.__firebaseConfig__ && typeof window.__firebaseConfig__ === "object")
              ? window.__firebaseConfig__
              : {}));
        const emailjsLegacy = (window.__EMAILJS_CONFIG__ && typeof window.__EMAILJS_CONFIG__ === "object")
          ? window.__EMAILJS_CONFIG__
          : {};
        const firebaseRaw = (root.firebase && typeof root.firebase === "object")
          ? root.firebase
          : ((root.firebaseConfig && typeof root.firebaseConfig === "object")
            ? root.firebaseConfig
            : (((root.apiKey || root.projectId) && typeof root === "object") ? root : {}));
        const emailjsRaw = (root.emailjs && typeof root.emailjs === "object")
          ? root.emailjs
          : ((root.emailJs && typeof root.emailJs === "object")
            ? root.emailJs
            : (((root.serviceId || root.templateId || root.publicKey) && typeof root === "object") ? root : {}));
        const firebaseFromCache = (cache.firebase && typeof cache.firebase === "object") ? cache.firebase : {};
        const emailjsFromCache = (cache.emailjs && typeof cache.emailjs === "object") ? cache.emailjs : {};
        const firebase = _normalizeFirebaseConfig({
          apiKey: firebaseRaw.apiKey || firebaseLegacy.apiKey || firebaseFromCache.apiKey || _metaConfigValueAny(["firebase-api-key", "public-api-key"]),
          authDomain: firebaseRaw.authDomain || firebaseLegacy.authDomain || firebaseFromCache.authDomain || _metaConfigValueAny(["firebase-auth-domain", "public-auth-domain"]),
          projectId: firebaseRaw.projectId || firebaseLegacy.projectId || firebaseFromCache.projectId || _metaConfigValueAny(["firebase-project-id", "public-project-id"]),
          storageBucket: firebaseRaw.storageBucket || firebaseLegacy.storageBucket || firebaseFromCache.storageBucket || _metaConfigValueAny(["firebase-storage-bucket", "public-storage-bucket"]),
          messagingSenderId: firebaseRaw.messagingSenderId || firebaseLegacy.messagingSenderId || firebaseFromCache.messagingSenderId || _metaConfigValueAny(["firebase-messaging-sender-id", "public-messaging-sender-id"]),
          appId: firebaseRaw.appId || firebaseLegacy.appId || firebaseFromCache.appId || _metaConfigValueAny(["firebase-app-id", "public-app-id"])
        });
        const emailjs = _normalizeEmailJsConfig({
          serviceId: emailjsRaw.serviceId || emailjsLegacy.serviceId || emailjsFromCache.serviceId || _metaConfigValue("emailjs-service-id"),
          templateId: emailjsRaw.templateId || emailjsLegacy.templateId || emailjsFromCache.templateId || _metaConfigValue("emailjs-template-id"),
          publicKey: emailjsRaw.publicKey || emailjsLegacy.publicKey || emailjsFromCache.publicKey || _metaConfigValue("emailjs-public-key")
        });
        const resolved = { firebase, emailjs };
        if (_hasFirebaseConfig(firebase) || _hasEmailJsConfig(emailjs)){
          _savePublicRuntimeCache(resolved);
        }
        return resolved;
      }
      function _resolveFirebaseConfigNow(){
        const direct = _normalizeFirebaseConfig(window.__FIREBASE_CONFIG__);
        if (_hasFirebaseConfig(direct)) return direct;
        const root = (window.__PUBLIC_CONFIG__ && typeof window.__PUBLIC_CONFIG__ === "object")
          ? window.__PUBLIC_CONFIG__
          : {};
        const fromRootRaw = (root.firebase && typeof root.firebase === "object")
          ? root.firebase
          : ((root.firebaseConfig && typeof root.firebaseConfig === "object")
            ? root.firebaseConfig
            : root);
        const fromRoot = _normalizeFirebaseConfig(fromRootRaw);
        if (_hasFirebaseConfig(fromRoot)){
          window.__FIREBASE_CONFIG__ = fromRoot;
          return fromRoot;
        }
        const runtime = _readPublicRuntimeConfig();
        const fromRuntime = _normalizeFirebaseConfig(runtime.firebase);
        if (_hasFirebaseConfig(fromRuntime)){
          window.__FIREBASE_CONFIG__ = fromRuntime;
          return fromRuntime;
        }
        return null;
      }
      const PUBLIC_RUNTIME_CONFIG = _readPublicRuntimeConfig();
      if (_hasFirebaseConfig(PUBLIC_RUNTIME_CONFIG.firebase)){
        window.__FIREBASE_CONFIG__ = _normalizeFirebaseConfig(PUBLIC_RUNTIME_CONFIG.firebase);
      }

      // =========================
      // Audio (user-provided mp3)
      // =========================
      // Change these paths if you want different filenames/locations.
     const AUDIO_PATHS = {
  bgm: "",
  correct: "",
  wrong: "",
};


      const audio = {
        ready: false,
        bgm: null,
        sfxOk: null,
        sfxNg: null,
      };

      function initAudio(){
        if (audio.ready) return;
        audio.ready = true;

        audio.bgm = new Audio(AUDIO_PATHS.bgm);
        audio.bgm.loop = true;           // BGM must loop
        audio.bgm.preload = "auto";
        audio.bgm.volume = getBgmVolumeValue();

        audio.sfxOk = new Audio(AUDIO_PATHS.correct);
        audio.sfxOk.loop = false;        // SFX must NOT loop
        audio.sfxOk.preload = "auto";

        audio.sfxNg = new Audio(AUDIO_PATHS.wrong);
        audio.sfxNg.loop = false;        // SFX must NOT loop
        audio.sfxNg.preload = "auto";
        applySfxVolume();
      }


      const BGM_VOLUME_VALUES = {
        LARGE: 0.70,
        DEFAULT: 0.52,
        SMALL: 0.38
      };
      const SFX_VOLUME_VALUES = {
        LARGE: 1.0,
        DEFAULT: 0.78,
        SMALL: 0.5
      };

      function getBgmVolumeValue(){
        const k = state.settings.bgmVolume || "DEFAULT";
        return (k in BGM_VOLUME_VALUES) ? BGM_VOLUME_VALUES[k] : BGM_VOLUME_VALUES.DEFAULT;
      }
      function getSfxVolumeValue(){
        const k = state.settings.sfxVolume || "DEFAULT";
        return (k in SFX_VOLUME_VALUES) ? SFX_VOLUME_VALUES[k] : SFX_VOLUME_VALUES.DEFAULT;
      }

      function applyBgmVolume(){
        if (!audio.ready || !audio.bgm) return;
        audio.bgm.volume = getBgmVolumeValue();
      }
      function applySfxVolume(){
        if (!audio.ready) return;
        const v = getSfxVolumeValue();
        if (audio.sfxOk) audio.sfxOk.volume = v;
        if (audio.sfxNg) audio.sfxNg.volume = v;
      }

      function playBgm(){
        if (!state.settings.bgm) return;
        initAudio();
        if (!audio.bgm) return;
        applyBgmVolume();
        if (!audio.bgm.paused) return;

        const p = audio.bgm.play();
        if (p && p.catch) p.catch(() => {});
      }

      function stopBgm(reset=false){
        if (!audio.ready || !audio.bgm) return;
        audio.bgm.pause();
        if (reset){
          try{ audio.bgm.currentTime = 0; } catch {}
        }
      }

      function syncBgmToView(){
        if (!state.settings.bgm) { stopBgm(); return; }
        if (state.view === "QUIZ") playBgm();
        else stopBgm();
      }

      function playSfx(kind){
        if (!state.settings.sfx) return;
        initAudio();
        applySfxVolume();
        const a = (kind === "ok") ? audio.sfxOk : audio.sfxNg;
        if (!a) return;

        try{
          a.pause();
          a.currentTime = 0;
        } catch {}

        const p = a.play();
        if (p && p.catch) p.catch(() => {});
      }

      // =========================
      // RAW_DATA (confirmed)
      // =========================
      const RAW_DATA_1_200 = `
1 ability  51 maker  101 defeat  151 eager 
2 ad  52 match  102 destroy  152 engaged 
3 agenda  53 merchant  103 disappoint  153 exclusive 
4 alternative  54 mixture  104 do me a favor  154 expensive 
5 ankle  55 nature  105 dump  155 fat 
6 architect  56 obligation  106 encounter  156 friendly 
7 assistance  57 opportunity  107 escape  157 harsh 
8 automobile  58 pain  108 exist  158 immediate 
9 benefit / 59 path  109 extend  159 initial 
10 breast  60 period  110 flow  160 latter 
11 candidate  61 pit  111 gather  161 medium 
12 chairman  62 politician  112 graduate  162 naked 
13 circuit  63 prayer  113 hate  163 nuclear 
14 coal  64 principle  114 imitate  164 numerous 
15 commission  65 profit  115 inform  165 overwhelming 
16 compassion  66 proverb  116 interrupt  166 plain 
17 condition  67 quantity  117 keep in mind  167 precious 
18 constitution  68 reduction  118 live on  168 prompt 
19 contribution  69 representative  119 lose  169 raw 
20 court  70 restriction  120 manufacturing  170 responsible 
21 criticism  71 rumor  121 nod  171 secondhand 
22 deadline  72 secretary  122 originate  172 smart 
23 delivery  73 sign  123 pitch  173 stupid 
24 destination  74 souvenir  124 preserve / 174 talented 
25 dignity  75 stock / 125 prove  175 tough 
26 disorder  76 substance  126 put together  176 uncomfortable 
27 doubt  77 supply  127 recognize  177 urgent 
28 economics  78 tale  128 release  178 vital 
29 emergency  79 term  129 reply  179 adequate 
30 environment  80 tissue  130 retire  180 aloud 
31 evidence  81 trait  131 run away  181 bravely 
32 expectation  82 truth  132 select  182 especially 
33 extent  83 variation  133 slip  183 forward 
34 fame  84 vocabulary  134 spread  184 immediately 
35 fellow  85 wisdom  135 strain  185 later 
36 flood  86 abandon  136 summon  186 nevertheless 
37 fraction  87 acquaint  137 take after  187 particularly 
38 gene  88 affect  138 transfer  188 rapidly 
39 grace  89 answer for  139 undertake  189 sincerely 
40 harbor  90 argue  140 wear  190 terribly 
41 hemisphere  91 astonish  141 wrap  191 as far as I know 
42 humidity  92 beat  142 wrong  192 at one time 
43 impact  93 bleed  143 aggressive  193 be familiar with 
44 industry  94 break out  144 agricultural  194 before long 
45 injection  95 capture  145 artificial  195 for example  
46 insurance  96 civilize  146 biological  196 in advance 
47 joint  97 commute  147 civil  197 in practice , 
48 laboratory  98 concern  148 concrete  198 not yet 
49 layer  99 contain  149 creative  199 on the way to 
50 litter  100 criticize  150 desirable  200 to start with 
      `;

      const RAW_DATA_201_400 = `
201 abortion  251 male  301 defend  351 economic 
202 addition  252 mate  302 detect  352 enormous 
203 agent  253 mess  303 discover  353 expired 
204 altitude  254 moment  304 do well  354 famous 
205 anniversary  255 navy  305 earn  355 favorite 
206 argument  256 observation  306 encourage  356 frightened 
207 association  257 opposition  307 establish  357 historical 
208 avenue  258 palm  308 expand  358 imperial 
209 beverage  259 patience  309 face / 359 innocent 
210 breath  260 permission  310 focus on  360 lazy 
211 capacity  261 planet  311 gaze  361 mental 
212 chamber  262 politics  312 greet  362 narrow 
213 circumstance  263 predator  313 hear from  363 obvious 
214 coast  264 priority  314 immigrate  364 overall 
215 commissioner  265 progress  315 insist  365 own 
216 competition  266 province  316 introduce  366 pleasant 
217 conduct  267 quarrel  317 keep up with  367 precise 
218 construction  268 reference  318 load / 368 proper 
219 conversation  269 republic  319 made of  369 rear 
220 crack  270 result  320 mean  370 reverse 
221 critics  271 sacrifice  321 notice / 371 senior /
222 dealer  272 seed  322 overcome  372 social 
223 demand / 273 silence  323 play a role in  373 subtle 
224 destruction  274 species  324 pretend  374 technical 
225 direction  275 stomach  325 provide  375 toxic 
226 distance  276 suburb  326 put up with  376 unexpected 
227 dozen 12 277 supporter  327 recommend  377 useful 
228 economy  278 talent  328 relieve  378 vivid 
229 emperor  279 terror  329 represent  379 accustomed 
230 envy  280 toe  330 reuse  380 altogether 
231 evolution  281 transition  331 run out of  381 briefly 
232 expense  282 tuition  332 settle down  382 essentially 
233 extinction  283 vehicle  333 smell  383 frequently , 
234 famine  284 voyage  334 squeeze  384 increasingly 
235 female  285 witness / 335 strengthen  385 literally 
236 focus  286 abolish  336 suppose  386 newly 
237 fragment  287 acquire  337 take care  387 partly 
238 generation  288 afford  338 transform  388 rarely 
239 grammar  289 apologize  339 urge  389 slightly 
240 harm / 290 arise  340 weigh  390 therefore 
241 heritage  291 attach to  341 yell  391 as if 
242 hunger  292 beg  342 absolute  392 at present 
243 implication  293 blink  343 alike  393 be filled with 
244 infant  294 breathe  344 armed  394 by chance 
245 injury  295 carry out  345 ashamed  395 for free 
246 intelligence  296 climb  346 bitter  396 in case 
247 journal  297 compare  347 civilized  397 in reality 
248 lack  298 conclude  348 confident  398 nursery school 
249 lecture  299 continue  349 criminal  399 one day 
250 location  300 cruise  350 detailed  400 up to 
      `;

      const RAW_DATA_401_600 = `
401 absence  451 mammal  501 delay  551 entire 
402 address  452 material  502 determine  552 extensive 
403 aggression  453 metal  503 discuss  553 federal 
404 ambition  454 motive  504 dominate  554 frequent 
405 anxiety  455 necessity  505 educate  555 fundamental 
406 arms  456 observer  506 end up  556 holy 
407 assumption  457 orbit ,  507 estimate  557 impossible 
408 award  458 pan  508 expect  558 intelligent 
409 bill  459 patient  509 fail  559 legal 
410 breeze  460 personality  510 fold  560 mere 
411 capital  461 plant  511 generate  561 national 
412 chapter  462 pollution  512 guarantee / 562 odd 
413 citizen  463 preference  513 hesitate  563 painful 
414 collaboration  464 prison  514 imply  564 physical 
415 commitment  465 promotion  515 insist on  565 polite 
416 competitor  466 psychology  516 invade  566 pregnant 
417 conference  467 quarter  517 laugh at  567 proud 
418 consumer  468 reflection  518 locate  568 reasonable 
419 cooperation  469 reputation  519 maintain  569 ridiculous 
420 craft  470 retail  520 measure / 570 sensitive 
421 crop  471 salary  521 obey  571 sole 
422 debate  472 separation  522 overlap  572 sudden 
423 democracy  473 similarity  523 plenty of  573 temporary 
424 detail  474 spectator  524 prevent  574 traditional 
425 director  475 storage  525 publish  575 unique 
426 distinction  476 success  526 qualify  576 useless 
427 drift  477 surface  527 recover  577 warm 
428 edge  478 task  528 rely on  578 abroad 
429 emphasis  479 theory  529 require  579 annually 
430 equality  480 toll  530 reveal  580 certainly 
431 examination  481 translation  531 rush  581 eventually 
432 experiment  482 tumor  532 share / 582 fully 
433 eyesight  483 vending machine  533 snap  583 indeed 
434 fancy  484 wage  534 stand out  584 luckily 
435 fertilizer  485 Muslim  535 stretch  585 normally 
436 folk  486 absorb  536 surround  586 permanently 
437 frown  487 adapt  537 take over ,  587 rather 
438 genius  488 agree with  538 translate  588 socially 
439 grant  489 appeal  539 utilize  589 totally 
440 harmony  490 arrange  540 welcome  590 a bunch of 
441 hesitation  491 attend  541 abstract  591 as well 
442 ideal  492 behave  542 alive  592 at that time 
443 impression  493 block  543 asleep  593 be good at 
444 infection  494 breed  544 bare  594 by heart 
445 inquiry  495 cast  545 bloody  595 for instance  
446 intention  496 clip / 546 classical  596 in charge of 
447 journey  497 compete  547 conscious  597 in response 
448 landscape  498 confess  548 critical  598 off duty 
449 leftover  499 contribute  549 distant ,  599 out of date 
450 log  500 cure  550 educational  600 out of stock 
	`;

      const RAW_DATA_600_800 = `
601 accommodation  651 manager  701 delete  751 equal 
602 administration  652 matter  702 develop  752 extinct 
603 agreement  653 method  703 dislike  753 financial 
604 ambulance  654 mummy  704 donate  754 gay 
605 apology  655 negotiation  705 elect  755 harmful 
606 arrangement  656 obstacle  706 endanger  756 honest 
607 astronaut  657 order  707 evaluate  757 impressive 
608 awareness  658 parking lot  708 expire  758 intensive 
609 billion 10 659 payment  709 fascinate  759 likely 
610 brick  660 phase  710 forecast  760 mindful 
611 carbon  661 plastic bag  711 get along with  761 natural 
612 charge / 662 popularity  712 guess  762 offensive 
613 civilian  663 prejudice  713 hide  763 parallel 
614 colleague  664 prisoner  714 import  764 political 
615 committee  665 pronunciation  715 inspire  765 practical 
616 complexity  666 publication  716 invent  766 present 
617 confidence  667 range  717 launch  767 psychological 
618 consumption  668 refrigerator  718 look down on  768 recent 
619 cop  669 research / 719 make a difference  769 right 
620 creation  670 retirement  720 melt  770 several 
621 crowd  671 satellite  721 observe  771 solid 
622 debt  672 sequence  722 overwhelm  772 sufficient 
623 dentist  673 site  723 possess  773 terminal 
624 detective  674 sphere  724 produce  774 trivial 
625 disadvantage  675 stranger  725 pull off  775 universal 
626 district  676 suffering  726 quit  776 utter 
627 drought  677 surgery  727 reduce  777 wealthy 
628 editor  678 taste / 728 remain  778 absolutely 
629 empire  679 therapy  729 reserve  779 anyway 
630 equipment  680 tongue  730 revise  780 closely 
631 exception  681 transportation  731 satisfy  781 exactly 
632 expert  682 twin  732 shed  782 furthermore 
633 fabric  683 vessel  733 soak  783 initially 
634 fare  684 war  734 stand still  784 mainly 
635 fiber  685 Buddhist  735 strike  785 nowadays 
636 force  686 accept  736 survive  786 personally 
637 fuel  687 add  737 take part in  787 recently 
638 germ  688 aim  738 transport  788 somehow 
639 grass  689 appear  739 vanish  789 truly 
640 headline  690 arrest  740 whisper  790 a couple of 
641 hierarchy  691 attract  741 academic  791 at a loss 
642 identity  692 believe in  742 ambiguous  792 at the same time 
643 improvement  693 bloom  743 atomic  793 be known as 
644 inflation  694 bring  744 bored  794 by nature 
645 insect  695 catch up with  745 certain  795 for sure 
646 interpretation  696 collapse  746 comfortable  796 in common 
647 joy  697 complain of  747 considerable  797 in spite of 
648 language  698 confirm  748 cruel  798 on average 
649 legend  699 convert  749 distinct  799 out of order 
650 logic  700 cut down on  750 efficient  800 in stock 
	`;

      const RAW_DATA_800_1000 = `
801 accomplishment  851 manner  901 deliver  951 equivalent 
802 admission  852 maximum  902 die  952 extra 
803 agriculture  853 military  903 display  953 firm 
804 amount  854 murder  904 drag  954 generous 
805 appearance  855 neighbor  905 eliminate  955 huge 
806 arrival  856 occasion  906 endure  956 illegal 
807 atmosphere  857 organ  907 evolve  957 incredible 
808 background  858 parliament  908 explain  958 interior 
809 biology  859 peak  909 feed  959 literary 
810 brightness  860 phenomenon  910 forget  960 minimum 
811 carbon dioxide CO2 861 pleasure  911 get back  961 nearby 
812 charm  862 population  912 hand in  962 opposite 
813 civilization  863 preparation  913 highlight  963 particular 
814 college  864 prize  914 impress  964 popular 
815 commodity  865 proof  915 install  965 preserved 
816 component  866 publicity  916 invest  966 prior 
817 conflict  867 rating  917 lead to  967 public 
818 container  868 region  918 look forward to ,  968 regional 
819 copyright  869 reservation  919 make fun of  969 rough 
820 creature  870 revenge / 920 mention  970 severe 
821 crown  871 satisfaction  921 obtain  971 specific 
822 decade 10 872 servant  922 owe  972 suitable 
823 department  873 sneeze / 923 postpone  973 terrible 
824 development  874 state  924 prohibit  974 tropical 
825 disaster  875 strategy  925 punish  975 unknown 
826 division  876 suggestion  926 raise  976 vague 
827 drug  877 survey / 927 refer to  977 well-known 
828 education  878 tax  928 remember  978 academically 
829 employee  879 thermometer  929 resist  979 apart 
830 era  880 tourism  930 rid  980 constantly 
831 excess  881 treasure  931 scatter  981 exceptionally 
832 explanation  882 twist  932 show up  982 generously 
833 facility  883 victim  933 solve  983 innocently 
834 fate  884 waste / 934 stand up  984 maybe 
835 figure  885 Arctic  935 struggle with  985 nowhere 
836 formation  886 accommodate  936 suspect  986 possibly 
837 fund  887 adjust  937 tap  987 regardless 
838 girlfriend  888 allow  938 treat  988 somewhat 
839 grave  889 apply for  939 vary  989 typically 
840 headquarters  890 assemble  940 whistle  990 a number of 
841 history  891 attribute  941 accurate  991 at a time 
842 ignorance  892 belong  942 ancient  992 at times 
843 impulse  893 blow  943 attractive  993 be known for 
844 influence / 894 broadcast  944 brief  994 by the end of 
845 insight  895 cause / 945 commercial  995 from now on 
846 invention  896 collect  946 comprehensive  996 in fact , 
847 judgement  897 compose  947 consistent  997 in terms of 
848 lap  898 confuse  948 curious  998 on behalf of 
849 leisure  899 convey  949 dizzy  999 since then 
850 lord  900 dare  950 elderly  1000 in short 
	`;

      const RAW_DATA_ALL = RAW_DATA_1_200 + "\n" + RAW_DATA_201_400 + "\n" + RAW_DATA_401_600 + "\n" + RAW_DATA_600_800 + "\n" + RAW_DATA_800_1000;

      // =========================
      // Parse (robust)
      // =========================
      const jpRegex = /[---]/;

      function parseWords(raw, maxId){
        const normalized = String(raw).replace(/\s+/g, " ").trim();

        // id boundary: positive integer followed by spaces + ASCII letter (avoid "12" etc)
        const idRegex = /(^|\s)(\d{1,4})(?=\s+[A-Za-z])/g;
        const matches = [];
        for (const m of normalized.matchAll(idRegex)){
          const lead = m[1] || "";
          const idStr = m[2];
          const start = (m.index ?? 0) + lead.length;
          const id = Number(idStr);
          if (Number.isFinite(id) && id >= 1 && id <= maxId){
            matches.push({ id, start });
          }
        }

        const found = [];
        const parseErrors = [];

        for (let i = 0; i < matches.length; i++){
          const start = matches[i].start;
          const end = (i + 1 < matches.length) ? matches[i + 1].start : normalized.length;
          const chunk = normalized.slice(start, end).trim();
          const mm = chunk.match(/^(\d+)\s+(.+)$/);
          if (!mm) continue;

          const id = Number(mm[1]);
          if (!(id >= 1 && id <= maxId)) continue;

          const rest = mm[2] ?? "";
          const jpIndex = rest.search(PRESET_JP_REGEX);

          let word = "";
          let meaning = "";

          if (jpIndex === -1){
            word = rest.trim();
            meaning = "";
            parseErrors.push(id);
          } else {
            // meaning should start at token containing first JP char (so "12" keeps 12)
            const prevSpace = rest.lastIndexOf(" ", jpIndex);
            const meaningStart = (prevSpace === -1) ? 0 : (prevSpace + 1);

            word = rest.slice(0, meaningStart).trim();
            meaning = rest.slice(meaningStart).trim();
            if (!word || !meaning) parseErrors.push(id);
          }

          found.push({ id, word, meaning });
        }

        found.sort((a,b) => a.id - b.id);

        const byId = new Map();
        const duplicates = [];
        for (const item of found){
          if (byId.has(item.id)){
            duplicates.push(item.id);
            continue;
          }
          byId.set(item.id, item);
        }

        const missing = [];
        for (let id = 1; id <= maxId; id++){
          if (!byId.has(id)) missing.push(id);
        }

        const parseErrorsUnique = Array.from(new Set(parseErrors)).sort((a,b)=>a-b);
        const words = Array.from(byId.values()).sort((a,b)=>a.id - b.id);

        return {
          maxId,
          words,
          byId,
          missing,
          duplicates: Array.from(new Set(duplicates)).sort((a,b)=>a-b),
          parseErrors: parseErrorsUnique
        };
      }

      function collectRawIds(raw, minId = 1, maxId = 9999){
        const normalized = String(raw ?? "").replace(/\s+/g, " ").trim();
        if (!normalized) return [];
        const idRegex = /(^|\s)(\d{1,4})(?=\s+[A-Za-z])/g;
        const ids = [];
        for (const m of normalized.matchAll(idRegex)){
          const n = Number(m[2]);
          if (!Number.isInteger(n)) continue;
          if (n < minId || n > maxId) continue;
          ids.push(n);
        }
        return ids;
      }

      function analyzeAddedRawIds(raw, existingMax, dataObj){
        const ids = collectRawIds(raw, 1, 1000);
        const seen = new Set();
        const duplicates = [];
        const legacyCollisions = [];
        for (const id of ids){
          if (id <= existingMax){
            legacyCollisions.push(id);
          }
          if (seen.has(id)){
            duplicates.push(id);
            continue;
          }
          seen.add(id);
        }
        const missingAddedRange = [];
        for (let id = existingMax + 1; id <= 1000; id++){
          if (!dataObj?.byId?.has(id)) missingAddedRange.push(id);
        }
        return {
          legacyCollisions: Array.from(new Set(legacyCollisions)).sort((a,b)=>a-b),
          duplicates: Array.from(new Set(duplicates)).sort((a,b)=>a-b),
          missingAddedRange
        };
      }

      function shuffle(arr){
        const a = arr.slice();
        for (let i = a.length - 1; i > 0; i--){
          const j = Math.floor(Math.random() * (i + 1));
          [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
      }

      function uniq(arr){
        return Array.from(new Set(arr));
      }

      function clamp(n, min, max){
        return Math.max(min, Math.min(max, n));
      }

      // =========================
      // Presets (user editable)
      // =========================
      const PRESETS_KEY = "wordPractice400.presets.v1";
      let __presetsRev = 0;
      let __searchIndexCache = { rev: -1, items: [] };
      const ACTIVE_PRESET_KEY = "wordPractice400.activePresetId.v1";
      const PRESET_JP_REGEX = /[---]/;

      // =========================
      // In-app alert / confirm (no window.alert/confirm)
      // =========================
      const uiModal = {
        root: document.getElementById("uiModal"),
        backdrop: document.querySelector("#uiModal .ui-modal-backdrop"),
        card: document.querySelector("#uiModal .ui-modal-card"),
        title: document.getElementById("uiModalTitle"),
        message: document.getElementById("uiModalMessage"),
        ok: document.getElementById("uiModalOk"),
        cancel: document.getElementById("uiModalCancel"),
      };

      let _modalResolver = null;
      let _modalType = "alert"; // "alert" | "confirm"
      let _modalOnClose = null;
      let _modalQueue = Promise.resolve();

      function uiModalOnClose(fn){ _modalOnClose = (typeof fn === "function") ? fn : null; }

      function _openModal(payload){
        if (!uiModal.root) return;
        const { type, title, message, okText, cancelText, danger } = payload;
        _modalType = type;

        uiModal.root.classList.add("is-open");
        uiModal.root.setAttribute("aria-hidden", "false");

        if (uiModal.title) uiModal.title.textContent = title || (type === "confirm" ? "" : "");
        if (uiModal.message){
          const htmlStr = payload.html;
          if (htmlStr != null){
            uiModal.message.innerHTML = String(htmlStr);
            uiModal.message.classList.add("is-html");
          }else{
            uiModal.message.textContent = String(message ?? "");
            uiModal.message.classList.remove("is-html");
          }
        }

        if (uiModal.ok) uiModal.ok.textContent = okText || "OK";
        if (uiModal.cancel) uiModal.cancel.textContent = cancelText || "";
        if (uiModal.cancel) uiModal.cancel.style.display = (type === "confirm") ? "" : "none";
        if (uiModal.card) uiModal.card.classList.toggle("is-danger", !!danger);
        try{
          _customSelectEnhance(uiModal.card || uiModal.root);
        }catch{}

        // Focus
        setTimeout(() => {
          (uiModal.ok || uiModal.cancel)?.focus?.();
        }, 0);
      }

      function _closeModal(result){
        if (!uiModal.root) return;
        uiModal.root.classList.remove("is-open");
        uiModal.root.setAttribute("aria-hidden", "true");
        try{ if (typeof _modalOnClose === "function") _modalOnClose(); }catch{}
        _modalOnClose = null;
        const r = _modalResolver;
        _modalResolver = null;
        if (typeof r === "function") r(result);
      }

      function uiAlert(message, opts = {}){
        const payload = {
          type: "alert",
          title: opts.title || "",
          message: String(message ?? ""),
          okText: opts.okText || "OK",
          cancelText: "",
          danger: false
        };
        _modalQueue = _modalQueue.then(() => new Promise((resolve) => {
          _modalResolver = () => resolve(true);
          _openModal(payload);
        }));
        return _modalQueue.then(() => {});
      }

      function uiConfirm(message, opts = {}){
        const payload = {
          type: "confirm",
          title: opts.title || "",
          message: String(message ?? ""),
          okText: opts.okText || "OK",
          cancelText: opts.cancelText || "",
          danger: !!opts.danger
        };
        _modalQueue = _modalQueue.then(() => new Promise((resolve) => {
          _modalResolver = resolve;
          _openModal(payload);
        }));
        return _modalQueue;
      }

      function uiHtml(html, opts = {}){
        const payload = {
          type: "alert",
          title: opts.title || "",
          message: "",
          html: String(html ?? ""),
          okText: opts.okText || "",
          cancelText: "",
          danger: false
        };
        _modalQueue = _modalQueue.then(() => new Promise((resolve) => {
          _modalResolver = () => resolve(true);
          _openModal(payload);
        }));
        return _modalQueue.then(() => {});
      }

      function uiConfirmHtml(html, opts = {}){
        const payload = {
          type: "confirm",
          title: opts.title || "",
          message: "",
          html: String(html ?? ""),
          okText: opts.okText || "OK",
          cancelText: opts.cancelText || "",
          danger: !!opts.danger
        };
        _modalQueue = _modalQueue.then(() => new Promise((resolve) => {
          _modalResolver = (r) => resolve(!!r);
          _openModal(payload);
        }));
        return _modalQueue.then((r) => r);
      }

      let _toastTimer = null;
      function uiToast(message){
        const text = String(message ?? "").trim();
        if (!text) return;
        let elToast = document.getElementById("uiToast");
        if (!elToast){
          elToast = document.createElement("div");
          elToast.id = "uiToast";
          elToast.className = "ui-toast";
          document.body.appendChild(elToast);
        }
        elToast.textContent = text;
        elToast.classList.add("show");
        if (_toastTimer) clearTimeout(_toastTimer);
        _toastTimer = setTimeout(() => elToast.classList.remove("show"), 1800);
      }

      // =========================
      // Custom select UI (non-native)
      // =========================
      const _customSelectState = {
        inited: false,
        uid: 0,
        openWrap: null,
        portal: null,
        panel: null
      };

      function _customSelectEnsurePortal(){
        let portal = _customSelectState.portal;
        if (portal && document.body.contains(portal)) return portal;
        portal = document.getElementById("xselectPortal");
        if (!portal){
          portal = document.createElement("div");
          portal.id = "xselectPortal";
          portal.className = "xselect-portal";
          portal.hidden = true;
          portal.setAttribute("aria-hidden", "true");
          document.body.appendChild(portal);
        }
        if (portal.dataset.bound !== "1"){
          portal.dataset.bound = "1";
          portal.addEventListener("click", (e) => {
            if (e.target === portal) _customSelectClose();
          }, { passive: true });
        }
        _customSelectState.portal = portal;
        return portal;
      }

      function _customSelectGetWrapFromScope(scope){
        const list = [];
        if (!scope) return list;
        if (scope instanceof HTMLElement && scope.classList.contains("xselect")){
          list.push(scope);
          return list;
        }
        if (scope instanceof HTMLSelectElement){
          const wrap = scope.closest(".xselect");
          if (wrap) list.push(wrap);
          return list;
        }
        if (scope instanceof Document || scope instanceof HTMLElement){
          list.push(...scope.querySelectorAll(".xselect"));
        }
        return list;
      }

      function _customSelectGetLabelText(selectEl){
        if (!(selectEl instanceof HTMLSelectElement)) return "";
        const opt = selectEl.options[selectEl.selectedIndex] || selectEl.selectedOptions?.[0] || null;
        if (!opt) return "";
        const txt = String(opt.textContent || opt.label || opt.value || "").trim();
        return txt || "";
      }

      function _customSelectRefreshWrap(wrap){
        if (!(wrap instanceof HTMLElement)) return;
        const selectEl = wrap.querySelector("select.xselect-native, select.select");
        const trigger = wrap.querySelector(".xselect-trigger");
        const label = wrap.querySelector(".xselect-label");
        if (!(selectEl instanceof HTMLSelectElement) || !(trigger instanceof HTMLButtonElement) || !(label instanceof HTMLElement)) return;
        label.textContent = _customSelectGetLabelText(selectEl);
        trigger.disabled = !!selectEl.disabled;
        wrap.classList.toggle("is-disabled", !!selectEl.disabled);
        const isOpen = _customSelectState.openWrap === wrap;
        trigger.setAttribute("aria-expanded", String(!!isOpen));
      }

      function _customSelectBuildPanel(wrap){
        const selectEl = wrap.querySelector("select.xselect-native, select.select");
        if (!(selectEl instanceof HTMLSelectElement)) return null;
        const panel = document.createElement("div");
        panel.className = "xselect-menu";
        panel.setAttribute("role", "listbox");
        panel.setAttribute("tabindex", "-1");
        panel.addEventListener("click", (e) => e.stopPropagation());
        panel.addEventListener("keydown", (e) => {
          if (e.key === "Escape"){
            e.preventDefault();
            e.stopPropagation();
            _customSelectClose();
          }
        });

        const frag = document.createDocumentFragment();
        let prevGroup = "";
        const options = Array.from(selectEl.options || []);
        for (let i = 0; i < options.length; i++){
          const opt = options[i];
          if (!(opt instanceof HTMLOptionElement)) continue;
          const parent = opt.parentElement;
          const group = parent && parent.tagName === "OPTGROUP" ? String(parent.getAttribute("label") || "") : "";
          if (group && group !== prevGroup){
            prevGroup = group;
            const g = document.createElement("div");
            g.className = "xselect-group";
            g.textContent = group;
            frag.appendChild(g);
          }
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "xselect-option" + (opt.selected ? " is-selected" : "");
          btn.textContent = String(opt.textContent || opt.label || opt.value || "");
          btn.dataset.index = String(i);
          if (opt.selected) btn.setAttribute("aria-selected", "true");
          const disabled = !!(selectEl.disabled || opt.disabled || (parent && parent instanceof HTMLOptGroupElement && parent.disabled));
          btn.disabled = disabled;
          btn.addEventListener("click", (ev) => {
            ev.preventDefault();
            if (disabled) return;
            const idx = Number(btn.dataset.index);
            if (!Number.isFinite(idx)) return;
            const prevVal = String(selectEl.value);
            selectEl.selectedIndex = idx;
            _customSelectRefreshWrap(wrap);
            const changed = String(selectEl.value) !== prevVal;
            if (changed){
              selectEl.dispatchEvent(new Event("change", { bubbles: true }));
            } else {
              selectEl.dispatchEvent(new Event("input", { bubbles: true }));
            }
            _customSelectClose();
          });
          frag.appendChild(btn);
        }
        if (!frag.childNodes.length){
          const empty = document.createElement("div");
          empty.className = "xselect-group";
          empty.textContent = "";
          frag.appendChild(empty);
        }
        panel.appendChild(frag);
        return panel;
      }

      function _customSelectPositionPanel(wrap, panel){
        if (!(wrap instanceof HTMLElement) || !(panel instanceof HTMLElement)) return;
        const trigger = wrap.querySelector(".xselect-trigger");
        if (!(trigger instanceof HTMLElement)) return;
        if (!document.body.contains(trigger)){
          _customSelectClose();
          return;
        }
        const rect = trigger.getBoundingClientRect();
        const vw = window.innerWidth || document.documentElement.clientWidth || 0;
        const vh = window.innerHeight || document.documentElement.clientHeight || 0;
        const margin = 10;
        const width = Math.max(180, Math.min(Math.round(rect.width), vw - (margin * 2)));
        let left = Math.round(rect.left);
        if (left + width > vw - margin) left = vw - margin - width;
        if (left < margin) left = margin;

        const downSpace = Math.max(0, vh - rect.bottom - margin);
        const upSpace = Math.max(0, rect.top - margin);
        const preferUp = downSpace < 190 && upSpace > downSpace;
        const maxHeight = Math.max(140, Math.min(300, Math.max(downSpace, upSpace) - 8));
        const top = preferUp
          ? Math.max(margin, Math.round(rect.top - maxHeight - 8))
          : Math.min(vh - margin - maxHeight, Math.round(rect.bottom + 8));

        panel.style.left = `${left}px`;
        panel.style.top = `${top}px`;
        panel.style.width = `${width}px`;
        panel.style.maxHeight = `${maxHeight}px`;
      }

      function _customSelectClose(){
        const wrap = _customSelectState.openWrap;
        if (wrap instanceof HTMLElement){
          wrap.classList.remove("is-open");
          const trigger = wrap.querySelector(".xselect-trigger");
          if (trigger) trigger.setAttribute("aria-expanded", "false");
        }
        const panel = _customSelectState.panel;
        if (panel && panel.parentElement) panel.parentElement.removeChild(panel);
        const portal = _customSelectState.portal;
        if (portal){
          portal.hidden = true;
          portal.setAttribute("aria-hidden", "true");
        }
        _customSelectState.panel = null;
        _customSelectState.openWrap = null;
      }

      function _customSelectOpen(wrap){
        if (!(wrap instanceof HTMLElement)) return;
        const selectEl = wrap.querySelector("select.xselect-native, select.select");
        if (!(selectEl instanceof HTMLSelectElement) || selectEl.disabled) return;
        const trigger = wrap.querySelector(".xselect-trigger");
        if (!(trigger instanceof HTMLButtonElement)) return;

        if (_customSelectState.openWrap === wrap){
          _customSelectClose();
          return;
        }
        _customSelectClose();
        _customSelectRefreshWrap(wrap);
        const panel = _customSelectBuildPanel(wrap);
        if (!(panel instanceof HTMLElement)) return;
        const portal = _customSelectEnsurePortal();
        portal.hidden = false;
        portal.setAttribute("aria-hidden", "false");
        portal.appendChild(panel);
        _customSelectState.panel = panel;
        _customSelectState.openWrap = wrap;
        wrap.classList.add("is-open");
        trigger.setAttribute("aria-expanded", "true");
        _customSelectPositionPanel(wrap, panel);
        const selected = panel.querySelector(".xselect-option.is-selected:not([disabled])");
        const first = panel.querySelector(".xselect-option:not([disabled])");
        const target = (selected || first);
        if (target instanceof HTMLButtonElement){
          try{ target.focus({ preventScroll: true }); }catch{}
        }
      }

      function _customSelectEnsureWrap(selectEl){
        if (!(selectEl instanceof HTMLSelectElement)) return null;
        if (selectEl.dataset.nativeUi === "1") return null;
        let wrap = selectEl.closest(".xselect");
        if (wrap) return wrap;

        wrap = document.createElement("div");
        wrap.className = "xselect";
        if (selectEl.classList.contains("settings-select")) wrap.classList.add("settings-select");
        if (selectEl.style.width) wrap.style.width = selectEl.style.width;
        if (selectEl.style.minWidth) wrap.style.minWidth = selectEl.style.minWidth;
        if (selectEl.style.maxWidth) wrap.style.maxWidth = selectEl.style.maxWidth;
        if (selectEl.style.flex) wrap.style.flex = selectEl.style.flex;
        if (selectEl.style.marginLeft) wrap.style.marginLeft = selectEl.style.marginLeft;

        const parent = selectEl.parentElement;
        if (!parent) return null;
        parent.insertBefore(wrap, selectEl);
        wrap.appendChild(selectEl);
        selectEl.classList.add("xselect-native");
        selectEl.setAttribute("aria-hidden", "true");
        selectEl.tabIndex = -1;

        const trigger = document.createElement("button");
        trigger.type = "button";
        trigger.className = "xselect-trigger";
        trigger.setAttribute("aria-haspopup", "listbox");
        trigger.setAttribute("aria-expanded", "false");
        if (!selectEl.id){
          _customSelectState.uid += 1;
          selectEl.id = `xselectNative${_customSelectState.uid}`;
        }
        trigger.setAttribute("aria-labelledby", selectEl.id);
        const label = document.createElement("span");
        label.className = "xselect-label";
        trigger.appendChild(label);
        wrap.appendChild(trigger);

        trigger.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          _customSelectOpen(wrap);
        });
        trigger.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " " || e.key === "ArrowDown" || e.key === "ArrowUp"){
            e.preventDefault();
            e.stopPropagation();
            _customSelectOpen(wrap);
          }
        });
        selectEl.addEventListener("change", () => _customSelectRefreshWrap(wrap));
        selectEl.addEventListener("input", () => _customSelectRefreshWrap(wrap));
        _customSelectRefreshWrap(wrap);
        return wrap;
      }

      function _customSelectRefresh(scope = document){
        const wraps = _customSelectGetWrapFromScope(scope);
        for (const wrap of wraps){
          _customSelectRefreshWrap(wrap);
        }
      }

      function _customSelectEnhance(scope = document){
        if (!_customSelectState.inited){
          _customSelectState.inited = true;
          document.addEventListener("keydown", (e) => {
            if (e.key === "Escape" && _customSelectState.openWrap){
              e.preventDefault();
              e.stopPropagation();
              _customSelectClose();
            }
          });
          window.addEventListener("resize", () => {
            if (_customSelectState.openWrap && _customSelectState.panel){
              _customSelectPositionPanel(_customSelectState.openWrap, _customSelectState.panel);
            }
          }, { passive: true });
          document.addEventListener("scroll", () => {
            if (_customSelectState.openWrap && _customSelectState.panel){
              _customSelectPositionPanel(_customSelectState.openWrap, _customSelectState.panel);
            }
          }, true);
        }

        const root = scope || document;
        const selects = [];
        if (root instanceof HTMLSelectElement){
          selects.push(root);
        } else if (root instanceof Document || root instanceof HTMLElement){
          selects.push(...root.querySelectorAll("select.select, select.settings-select"));
        }
        for (const sel of selects){
          _customSelectEnsureWrap(sel);
        }
        _customSelectRefresh(root);
      }


      uiModal.ok?.addEventListener("click", () => _closeModal(true));
      uiModal.cancel?.addEventListener("click", () => _closeModal(false));
      uiModal.backdrop?.addEventListener("click", () => _closeModal(false));

      document.addEventListener("keydown", (e) => {
        if (!uiModal.root || !uiModal.root.classList.contains("is-open")) return;

        if (e.key === "Escape"){
          e.preventDefault();
          _closeModal(false);
          return;
        }

        if (e.key === "Enter" && _modalType === "confirm"){
          const tag = (document.activeElement?.tagName || "").toLowerCase();
          if (tag === "textarea") return;
          if (tag === "input"){
            const t = (document.activeElement?.type || "").toLowerCase();
            if (t && t !== "button" && t !== "submit") return;
          }
          e.preventDefault();
          _closeModal(true);
        }
      });

      const SUBJECTS_CUSTOM_KEY = "app.subjects.custom.v1";
      const TAGS_CUSTOM_KEY = "app.tags.custom.v1";
      const BUILTIN_SUBJECTS = [
        { id: "sub:english", name: "English", color: "#6aa9ff", builtin: true },
        { id: "sub:math", name: "Math", color: "#7fb0ff", builtin: true },
        { id: "sub:science", name: "Science", color: "#6fcf97", builtin: true },
        { id: "sub:social", name: "Social", color: "#f5b971", builtin: true },
        { id: "sub:japanese", name: "Japanese", color: "#d59bff", builtin: true },
        { id: "sub:other", name: "Other", color: "#a5b4c3", builtin: true }
      ];
      function _normalizeMetaColor(raw){
        const s = String(raw || "").trim();
        if (!s) return "";
        return /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(s) ? s : "";
      }
      function _subjectBuiltinMap(){
        const m = new Map();
        for (const s of BUILTIN_SUBJECTS){
          m.set(String(s.id), { ...s, builtin: true });
        }
        return m;
      }
      function _normalizeSubjectItem(raw){
        if (!raw || typeof raw !== "object") return null;
        const id = String(raw.id || "");
        if (!/^subc:[a-z0-9_-]{4,}$/i.test(id)) return null;
        const name = String(raw.name || "").trim();
        if (!name) return null;
        const color = _normalizeMetaColor(raw.color || "");
        return { id, name, color, builtin: false };
      }
      function _normalizeTagItem(raw){
        if (!raw || typeof raw !== "object") return null;
        const id = String(raw.id || "");
        if (!/^tagc:[a-z0-9_-]{4,}$/i.test(id) && !/^tag:[a-z0-9_-]{2,}$/i.test(id)) return null;
        const name = String(raw.name || "").trim();
        if (!name) return null;
        const color = _normalizeMetaColor(raw.color || "");
        return { id, name, color };
      }
      function loadCustomSubjects(){
        try{
          const raw = window.localStorage.getItem(SUBJECTS_CUSTOM_KEY);
          const arr = raw ? JSON.parse(raw) : [];
          if (!Array.isArray(arr)) return [];
          const map = new Map();
          for (const it of arr){
            const n = _normalizeSubjectItem(it);
            if (!n) continue;
            map.set(n.id, n);
          }
          return Array.from(map.values());
        }catch{
          return [];
        }
      }
      function saveCustomSubjects(arr){
        const src = Array.isArray(arr) ? arr : [];
        const map = new Map();
        for (const it of src){
          const n = _normalizeSubjectItem(it);
          if (!n) continue;
          map.set(n.id, n);
        }
        window.localStorage.setItem(SUBJECTS_CUSTOM_KEY, JSON.stringify(Array.from(map.values())));
        __searchIndexCache.rev = -1;
      }
      function loadCustomTags(){
        try{
          const raw = window.localStorage.getItem(TAGS_CUSTOM_KEY);
          const arr = raw ? JSON.parse(raw) : [];
          if (!Array.isArray(arr)) return [];
          const map = new Map();
          for (const it of arr){
            const n = _normalizeTagItem(it);
            if (!n) continue;
            map.set(n.id, n);
          }
          return Array.from(map.values());
        }catch{
          return [];
        }
      }
      function saveCustomTags(arr){
        const src = Array.isArray(arr) ? arr : [];
        const map = new Map();
        for (const it of src){
          const n = _normalizeTagItem(it);
          if (!n) continue;
          map.set(n.id, n);
        }
        window.localStorage.setItem(TAGS_CUSTOM_KEY, JSON.stringify(Array.from(map.values())));
        __searchIndexCache.rev = -1;
      }
      function getAllSubjects(){
        return [...BUILTIN_SUBJECTS, ...loadCustomSubjects()];
      }
      function getSubjectById(id){
        const sid = String(id || "");
        if (!sid) return null;
        const bmap = _subjectBuiltinMap();
        if (bmap.has(sid)) return bmap.get(sid);
        const custom = loadCustomSubjects().find((s) => s.id === sid);
        return custom || null;
      }
      function subjectNameById(id){
        const s = getSubjectById(id);
        if (!s) return "Other";
        return s.name || "Other";
      }
      function getAllTags(){
        return loadCustomTags();
      }
      function getTagById(id){
        const tid = String(id || "");
        if (!tid) return null;
        return getAllTags().find((t) => t.id === tid) || null;
      }
      function _resolveSubjectId(rawId, opts = {}){
        const fallback = String(opts.fallback || "sub:english");
        const id = String(rawId || "").trim();
        if (!id) return fallback;
        if (id.startsWith("sub:")){
          return getSubjectById(id) ? id : "sub:other";
        }
        if (id.startsWith("subc:")){
          if (opts.allowMissingCustom) return id;
          return getSubjectById(id) ? id : "sub:other";
        }
        return fallback;
      }
      function _subjectNameKey(subjectId){
        const s = subjectNameById(subjectId);
        return String(s || "").trim().toLowerCase();
      }
      function _isEnglishSubjectId(subjectId){
        const sid = String(subjectId || "");
        if (sid === "sub:english") return true;
        const nm = _subjectNameKey(sid);
        return nm === "english" || nm === "";
      }
      function _isMathSubjectId(subjectId){
        const sid = String(subjectId || "");
        if (sid === "sub:math") return true;
        const nm = _subjectNameKey(sid);
        return nm === "math" || nm === "";
      }
      function _normalizeFormatMode(raw, allowLatex){
        const s = String(raw || "").trim().toLowerCase();
        if (allowLatex && s === "latex") return "latex";
        return "text";
      }
      function _normalizeTagIds(raw, opts = {}){
        const arr = Array.isArray(raw) ? raw : [];
        const seen = new Set();
        const out = [];
        for (const it of arr){
          const id = String(it || "").trim();
          if (!id) continue;
          if (!/^tag[c]?:[a-z0-9_-]{2,}$/i.test(id)) continue;
          if (seen.has(id)) continue;
          if (!opts.allowUnknown && !getTagById(id)) continue;
          seen.add(id);
          out.push(id);
        }
        return out;
      }
      function _normalizeCardDiagram(raw){
        if (!raw || typeof raw !== "object") return null;
        const type = String(raw.type || "").trim().toLowerCase();
        const dataUrl = String(raw.dataUrl || "").trim();
        if (type !== "png") return null;
        if (!/^data:image\/png;base64,/i.test(dataUrl)) return null;
        const modelRaw = raw.model && typeof raw.model === "object" ? raw.model : null;
        const model = modelRaw ? _normalizeDiagramModel(modelRaw) : null;
        return model ? { type: "png", dataUrl, model } : { type: "png", dataUrl };
      }
      function _normalizeDiagramCommand(cmd){
        if (!cmd || typeof cmd !== "object") return null;
        const type = String(cmd.type || "").trim().toLowerCase();
        const n = (v) => {
          const x = Number(v);
          return Number.isFinite(x) ? x : 0;
        };
        if (type === "path"){
          const pts = Array.isArray(cmd.points) ? cmd.points : [];
          const points = [];
          for (const p of pts){
            if (!p || typeof p !== "object") continue;
            points.push({ x: n(p.x), y: n(p.y) });
          }
          if (points.length < 2) return null;
          return { type: "path", points, erase: !!cmd.erase };
        }
        if (type === "line"){
          return { type: "line", x1: n(cmd.x1), y1: n(cmd.y1), x2: n(cmd.x2), y2: n(cmd.y2) };
        }
        if (type === "rect"){
          return { type: "rect", x: n(cmd.x), y: n(cmd.y), w: Math.max(1, n(cmd.w)), h: Math.max(1, n(cmd.h)), angle: n(cmd.angle) };
        }
        if (type === "circle"){
          return { type: "circle", cx: n(cmd.cx), cy: n(cmd.cy), r: Math.max(1, n(cmd.r)) };
        }
        if (type === "point"){
          return { type: "point", x: n(cmd.x), y: n(cmd.y), label: String(cmd.label || "").trim().slice(0,2).toUpperCase() };
        }
        if (type === "text"){
          const text = String(cmd.text || "").trim();
          if (!text) return null;
          const fs = Math.max(10, n(cmd.fontSize || 18));
          return {
            type: "text",
            x: n(cmd.x),
            y: n(cmd.y),
            w: Math.max(10, n(cmd.w || (text.length * fs * 0.62))),
            h: Math.max(12, n(cmd.h || (fs * 1.3))),
            text: text.slice(0, 240),
            fontSize: fs,
            color: String(cmd.color || "#18212f"),
            angle: n(cmd.angle)
          };
        }
        if (type === "table"){
          const rows = Math.max(1, Math.round(n(cmd.rows || 2)));
          const cols = Math.max(1, Math.round(n(cmd.cols || 2)));
          const cellTexts = [];
          if (Array.isArray(cmd.cellTexts)){
            for (let r = 0; r < rows; r++){
              const row = [];
              const srcRow = Array.isArray(cmd.cellTexts[r]) ? cmd.cellTexts[r] : [];
              for (let c = 0; c < cols; c++){
                row.push(String(srcRow[c] ?? "").slice(0, 64));
              }
              cellTexts.push(row);
            }
          }
          return {
            type: "table",
            x: n(cmd.x),
            y: n(cmd.y),
            w: Math.max(10, n(cmd.w)),
            h: Math.max(10, n(cmd.h)),
            rows,
            cols,
            angle: n(cmd.angle),
            cellTexts
          };
        }
        if (type === "image"){
          const src = String(cmd.src || "").trim();
          if (!/^data:image\//i.test(src)) return null;
          return {
            type: "image",
            x: n(cmd.x),
            y: n(cmd.y),
            w: Math.max(10, n(cmd.w || 200)),
            h: Math.max(10, n(cmd.h || 140)),
            src,
            angle: n(cmd.angle)
          };
        }
        return null;
      }
      function _normalizeDiagramModel(raw){
        if (!raw || typeof raw !== "object") return null;
        const src = Array.isArray(raw.commands) ? raw.commands : [];
        const commands = [];
        for (const c of src){
          const n = _normalizeDiagramCommand(c);
          if (!n) continue;
          commands.push(n);
          if (commands.length >= 1200) break;
        }
        const view = raw.view && typeof raw.view === "object" ? raw.view : {};
        const scaleRaw = Number(view.scale);
        const normalizedView = {
          tx: Number(view.tx || 0),
          ty: Number(view.ty || 0),
          scale: Number.isFinite(scaleRaw) ? Math.min(4, Math.max(0.25, scaleRaw)) : 1
        };
        if (!commands.length && !raw.grid && !raw.axis && !raw.snap && !raw.debugBounds) return null;
        return {
          commands,
          grid: !!raw.grid,
          axis: !!raw.axis,
          snap: !!raw.snap,
          debugBounds: !!raw.debugBounds,
          view: normalizedView
        };
      }
      function normalizeCardEntry(e, opts = {}){
        const id = Number(e?.id);
        const front = String(e?.front ?? e?.word ?? "").trim();
        const back = String(e?.back ?? e?.meaning ?? "").trim();
        if (!Number.isFinite(id) || id <= 0) return null;
        if (!front || !back) return null;
        const allowLatex = !!opts.allowLatex;
        const frontFormat = _normalizeFormatMode(e?.frontFormat ?? e?.wordFormat ?? "text", allowLatex);
        const backFormat = _normalizeFormatMode(e?.backFormat ?? e?.meaningFormat ?? "text", allowLatex);
        const diagram = _normalizeCardDiagram(e?.diagram);
        return diagram
          ? { id, front, back, frontFormat, backFormat, diagram }
          : { id, front, back, frontFormat, backFormat };
      }
      function _normalizeWordList(raw){
        const src = Array.isArray(raw) ? raw : [];
        const map = new Map();
        for (const it of src){
          const n = normalizeWordEntry(it);
          if (!n) continue;
          map.set(n.id, n);
        }
        return Array.from(map.values()).sort((a,b)=>a.id-b.id);
      }
      function _normalizeCardList(raw, opts = {}){
        const src = Array.isArray(raw) ? raw : [];
        const map = new Map();
        for (const it of src){
          const n = normalizeCardEntry(it, opts);
          if (!n) continue;
          map.set(n.id, n);
        }
        return Array.from(map.values()).sort((a,b)=>a.id-b.id);
      }
      function _cardsToWordList(cards){
        const src = Array.isArray(cards) ? cards : [];
        const out = [];
        for (const c of src){
          const n = normalizeWordEntry({ id: c.id, word: c.front, meaning: c.back });
          if (n) out.push(n);
        }
        out.sort((a,b)=>a.id-b.id);
        return out;
      }
      function _wordsToCardList(words, opts = {}){
        const src = Array.isArray(words) ? words : [];
        const allowLatex = !!opts.allowLatex;
        const out = [];
        for (const w of src){
          const n = normalizeWordEntry(w);
          if (!n) continue;
          out.push({
            id: n.id,
            front: n.word,
            back: n.meaning,
            frontFormat: "text",
            backFormat: "text"
          });
        }
        return _normalizeCardList(out, { allowLatex });
      }
      function _presetEntryCount(preset){
        const p = (preset && typeof preset === "object") ? preset : {};
        const sid = _resolveSubjectId(p.subjectId, { fallback: "sub:english", allowMissingCustom: true });
        if (_isEnglishSubjectId(sid)){
          return _normalizeWordList(p.words).length;
        }
        const cards = _normalizeCardList(p.cards, { allowLatex: _isMathSubjectId(sid) });
        if (cards.length) return cards.length;
        return _normalizeWordList(p.words).length;
      }
      function _normalizePresetMeta(presetRaw, opts = {}){
        const p = (presetRaw && typeof presetRaw === "object") ? presetRaw : {};
        const wordsRaw = Array.isArray(p.words) ? p.words : [];
        const cardsRaw = Array.isArray(p.cards) ? p.cards : [];
        const fallbackSubject = cardsRaw.length && !wordsRaw.length ? "sub:other" : "sub:english";
        const subjectId = _resolveSubjectId(p.subjectId, {
          fallback: fallbackSubject,
          allowMissingCustom: !!opts.allowMissingCustomSubject
        });
        const tagIds = _normalizeTagIds(p.tagIds, { allowUnknown: !!opts.allowUnknownTagIds });
        const isMath = _isMathSubjectId(subjectId);
        const words = _normalizeWordList(wordsRaw.length ? wordsRaw : _cardsToWordList(_normalizeCardList(cardsRaw, { allowLatex: isMath })));
        const cards = _normalizeCardList(cardsRaw.length ? cardsRaw : _wordsToCardList(words, { allowLatex: isMath }), { allowLatex: isMath });
        return { ...p, words, cards, subjectId, tagIds };
      }
      function loadPresets(){
        try{
          const raw = window.localStorage.getItem(PRESETS_KEY);
          if (!raw) return [];
          const arr = JSON.parse(raw);
          if (!Array.isArray(arr)) return [];
          let changed = false;
          const out = [];
          for (const row of arr){
            if (!row || typeof row.id !== "string") continue;
            const n = _normalizePresetMeta(row, {
              allowMissingCustomSubject: false,
              allowUnknownTagIds: true
            });
            if (n.subjectId !== row.subjectId || JSON.stringify(n.tagIds || []) !== JSON.stringify(Array.isArray(row.tagIds) ? row.tagIds : [])){
              changed = true;
            }
            out.push(n);
          }
          if (changed){
            try{ window.localStorage.setItem(PRESETS_KEY, JSON.stringify(out)); }catch{}
          }
          return out;
        }catch{ return []; }
      }
      function savePresets(arr){
        const src = Array.isArray(arr) ? arr : [];
        const out = [];
        for (const row of src){
          if (!row || typeof row.id !== "string") continue;
          out.push(_normalizePresetMeta(row, {
            allowMissingCustomSubject: false,
            allowUnknownTagIds: true
          }));
        }
        window.localStorage.setItem(PRESETS_KEY, JSON.stringify(out));
        __presetsRev++;
        __searchIndexCache.rev = -1;
      }
      function loadActivePresetId(fallbackDeck){
        const fb = fallbackDeck || "A";
        return window.localStorage.getItem(ACTIVE_PRESET_KEY) || `builtin:${fb}`;
      }
      function saveActivePresetId(id){
        window.localStorage.setItem(ACTIVE_PRESET_KEY, id);
      }

      function isBuiltinPreset(id){
        return String(id||"").startsWith("builtin:");
      }
      function builtinNameFromDeck(deckKey){
        if (deckKey === "A") return "0200";
        if (deckKey === "B") return "200400";
        if (deckKey === "C") return "400600";
        if (deckKey === "D") return "600800";
        if (deckKey === "E") return "80010008011000";
        return "ALL";
      }
      function deckFromBuiltinId(pid){
        const k = String(pid).split(":")[1];
        if (k === "A" || k === "B" || k === "C" || k === "D" || k === "E" || k === "ALL") return k;
        return "A";
      }

      function getPresetById(pid){
        if (isBuiltinPreset(pid)){
          const dk = deckFromBuiltinId(pid);
          return {
            id: pid,
            builtin: true,
            name: builtinNameFromDeck(dk),
            modes: {SEQ:true,RND:true,HAND:true,CHOICE:true},
            words: [],
            cards: [],
            subjectId: "sub:english",
            tagIds: []
          };
        }
        const list = loadPresets();
        const hit = list.find(p => p.id === pid) || null;
        return hit ? _normalizePresetMeta(hit, { allowMissingCustomSubject: false, allowUnknownTagIds: true }) : null;
      }

      function normalizeWordEntry(e){
        const id = Number(e?.id);
        const word = String(e?.word ?? "").trim();
        const meaning = String(e?.meaning ?? "").trim();
        if (!Number.isFinite(id) || id <= 0) return null;
        if (!word || !meaning) return null;

        // Optional: custom 4-choice config (for user presets)
        let mcq = null;
        const rawMcq = e?.mcq;
        if (rawMcq && typeof rawMcq === "object"){
          const rawChoices = Array.isArray(rawMcq.choices) ? rawMcq.choices : [];
          const seen = new Set();
          const choices = [];
          for (const v of rawChoices.slice(0,4)){
            const s = String(v ?? "").trim();
            if (!s) continue;
            if (seen.has(s)) continue;
            seen.add(s);
            choices.push(s);
          }
          if (choices.length >= 2){
            let ci = Number(rawMcq.correctIndex);
            if (!Number.isInteger(ci)) ci = -1;
            if (ci < 0 || ci >= choices.length){
              const f = choices.findIndex(x => x === meaning);
              ci = f >= 0 ? f : 0;
            }
            // Enforce strict: correct choice must exactly equal meaning
            if (choices[ci] !== meaning){
              const f = choices.findIndex(x => x === meaning);
              if (f >= 0){
                ci = f;
              } else {
                choices[ci] = meaning;
              }
            }
            mcq = { choices, correctIndex: ci };
          }
        }

        return mcq ? { id, word, meaning, mcq } : { id, word, meaning };
      }

      function getPresetWords(pid){
        if (isBuiltinPreset(pid)){
          const dk = deckFromBuiltinId(pid);
          return data.words.filter(w => (
            dk === "A" ? (w.id >= 1 && w.id <= 200) :
            dk === "B" ? (w.id >= 201 && w.id <= 400) :
            dk === "C" ? (w.id >= 401 && w.id <= 600) :
            dk === "D" ? (w.id >= 601 && w.id <= 800) :
            dk === "E" ? (w.id >= 801 && w.id <= 1000) : true
          ));
        }
        const p = getPresetById(pid);
        const subjectId = _resolveSubjectId(p?.subjectId, { fallback: "sub:english", allowMissingCustom: true });
        if (_isEnglishSubjectId(subjectId)){
          const words = _normalizeWordList(p?.words);
          return words.map((w) => ({
            ...w,
            subjectId: "sub:english",
            frontFormat: "text",
            backFormat: "text"
          }));
        }
        const allowLatex = _isMathSubjectId(subjectId);
        let cards = _normalizeCardList(p?.cards, { allowLatex });
        if (!cards.length){
          cards = _wordsToCardList(_normalizeWordList(p?.words), { allowLatex: false });
        }
        return cards.map((c) => ({
          id: c.id,
          word: c.front,
          meaning: c.back,
          subjectId,
          frontFormat: c.frontFormat,
          backFormat: c.backFormat,
          diagram: c.diagram || null
        }));
      }

      function getPresetModes(pid){
        if (isBuiltinPreset(pid)) return {SEQ:true,RND:true,HAND:true,CHOICE:true};
        const p = getPresetById(pid);
        const m = p?.modes || {};
        return { SEQ:!!m.SEQ, RND:!!m.RND, HAND:!!m.HAND, CHOICE:!!m.CHOICE };
      }

      function getActivePresetId(){
        return state.presetId || `builtin:${state.deck}`;
      }

      function setActivePreset(pid){
        _clearRecommendScope();
        state.presetId = pid;
        saveActivePresetId(pid);
        if (isBuiltinPreset(pid)){
          const dk = deckFromBuiltinId(pid);
          state.deck = dk;
          saveDeck(dk);
        }
        if (state.view === "TITLE") renderAll();
      }

      function getActiveWords(){
        return getPresetWords(getActivePresetId());
      }
      function buildActiveById(){
        const m = new Map();
        for (const w of getActiveWords()) m.set(w.id, w);
        return m;
      }

      // Override getDeckWords to use active preset when custom is selected.
      const _origGetDeckWords = getDeckWords;
      getDeckWords = function(deckKey){
        const pid = getActivePresetId();
        if (!isBuiltinPreset(pid)) return getActiveWords();
        return _origGetDeckWords(deckKey);
      };

      // Use presetId as cache key for 100-question sets on custom presets.
      function getSetKey(deckKey){
        const pid = getActivePresetId();
        if (!isBuiltinPreset(pid)) return pid;
        return deckKey;
      }

      function applyModeVisibility(){
        const pid = getActivePresetId();
        const modes = getPresetModes(pid);
        const count = getActiveWords().length;
        const hasWords = count > 0;

        const canSeq = !!modes.SEQ && hasWords;
        const canRnd = !!modes.RND && hasWords;
        const canHand = !!modes.HAND && hasWords;
        const canChoice = !!modes.CHOICE && hasWords;

        const setDisp = (btn, ok) => { if (!btn) return; btn.style.display = ok ? "" : "none"; };
        setDisp(el.startSeqBtn, canSeq);
        setDisp(el.startRndBtn, canRnd);
        setDisp(el.startHandBtn, canHand);
        setDisp(el.startChoiceBtn, canChoice);

        const any = canSeq || canRnd || canHand || canChoice;
        if (el.modeActions) el.modeActions.classList.toggle("hidden", !any);
        if (el.emptyState) el.emptyState.classList.toggle("hidden", any);
      }

      function syncPresetUI(){
        const pid = getActivePresetId();
        const isMy = !isBuiltinPreset(pid);
        const dk = state.deck;

        el.deckABtn.classList.toggle("active", !isMy && dk === "A");
        el.deckBBtn.classList.toggle("active", !isMy && dk === "B");
        if (el.deckCBtn) el.deckCBtn.classList.toggle("active", !isMy && dk === "C");
        if (el.deckDBtn) el.deckDBtn.classList.toggle("active", !isMy && dk === "D");
        if (el.deckEBtn) el.deckEBtn.classList.toggle("active", !isMy && dk === "E");
        el.deckAllBtn.classList.toggle("active", !isMy && dk === "ALL");
        if (el.deckMyBtn){
          el.deckMyBtn.classList.toggle("active", isMy);
          el.deckMyBtn.setAttribute("aria-selected", String(isMy));
        }
        el.deckABtn.setAttribute("aria-selected", String(!isMy && dk === "A"));
        el.deckBBtn.setAttribute("aria-selected", String(!isMy && dk === "B"));
        if (el.deckCBtn) el.deckCBtn.setAttribute("aria-selected", String(!isMy && dk === "C"));
        if (el.deckDBtn) el.deckDBtn.setAttribute("aria-selected", String(!isMy && dk === "D"));
        if (el.deckEBtn) el.deckEBtn.setAttribute("aria-selected", String(!isMy && dk === "E"));
        el.deckAllBtn.setAttribute("aria-selected", String(!isMy && dk === "ALL"));

        const words = getActiveWords();
        const preset = getPresetById(pid);
        const name = isMy ? (preset?.name || "My") : builtinNameFromDeck(dk);
        const sid = _resolveSubjectId(preset?.subjectId, { fallback: "sub:english", allowMissingCustom: true });
        const subject = subjectNameById(sid);
        const unit = _isEnglishSubjectId(sid) ? "" : "";
        el.deckStatus.textContent = `${name}${words.length}${unit} / ${subject}`;

        if (el.customPresetRow){
          el.customPresetRow.classList.toggle("hidden", !isMy);
        }

        if (el.customPresetSelect){
          const list = loadPresets();
          el.customPresetSelect.innerHTML = "";
          if (!list.length){
            const opt = document.createElement("option");
            opt.value = "";
            opt.textContent = "";
            el.customPresetSelect.appendChild(opt);
            el.customPresetSelect.disabled = true;
          } else {
            el.customPresetSelect.disabled = false;
            for (const p of list){
              const opt = document.createElement("option");
              opt.value = p.id;
              opt.textContent = p.name || "My Preset";
              el.customPresetSelect.appendChild(opt);
            }
            el.customPresetSelect.value = list.some(p => p.id === pid) ? pid : list[0].id;
          }
        }

        applyModeVisibility();
        _customSelectEnhance(el.viewTitle || document);
      }

      // =========================
      // Data
      // =========================
      const data = parseWords(RAW_DATA_ALL, 1000);
      const addedRawCheck = analyzeAddedRawIds(RAW_DATA_600_800 + "\n" + RAW_DATA_800_1000, 600, data);
      data.addedRawCheck = addedRawCheck;

      // =========================
      // Settings
      // =========================
      const SETTINGS_KEY = "wordPractice400.settings.v2";
      const APP_SETTINGS_KEY = "app.settings.v1";
      const DECK_KEY = "wordPractice400.deck.v1";
      const EXAM_SET_KEY_PREFIX = "wordPractice400.examSet.v1"; // + ":" + deckKey
      const UPDATE_NOTES_DISMISS_KEY = "wordPractice400.updateNotes.dismissed.v1";

      const defaultSettings = {
        direction: "EN_JA",     // EN_JA or JA_EN
        animations: true,
        debug: true,
        sfx: true,
        bgm: true,
        bgmVolume: "DEFAULT",   // LARGE | DEFAULT | SMALL
        sfxVolume: "DEFAULT",   // LARGE | DEFAULT | SMALL
        questionCount: 100,     // 10 | 20 | 50 | 100
        choiceTimeLimitSec: 0,  // 0 | 5 | 10 | 30 | 60
        autoNext: true,         // auto next after judge
        theme: "AUTO",          // AUTO | LIGHT | DARK
        fontSize: "DEFAULT"     // SMALL | DEFAULT | LARGE
      };
      const SETTINGS_QUESTION_COUNTS = new Set([10, 20, 50, 100]);
      const SETTINGS_EXAM_TIMES = new Set([0, 5, 10, 30, 60]);
      const SETTINGS_LEVELS = new Set(["SMALL", "DEFAULT", "LARGE"]);
      const SETTINGS_THEMES = new Set(["AUTO", "LIGHT", "DARK"]);
      const START_MODE_QUESTION_COUNTS = Object.freeze([30, 100, 200]);
      const START_MODE_QUESTION_COUNT_SET = new Set(START_MODE_QUESTION_COUNTS);

      function normalizeSettings(input){
        const parsed = (input && typeof input === "object") ? input : {};
        const out = {
          direction: (parsed.direction === "JA_EN") ? "JA_EN" : "EN_JA",
          animations: ("animations" in parsed) ? !!parsed.animations : defaultSettings.animations,
          debug: ("debug" in parsed) ? !!parsed.debug : defaultSettings.debug,
          sfx: ("sfx" in parsed) ? !!parsed.sfx : defaultSettings.sfx,
          bgm: ("bgm" in parsed) ? !!parsed.bgm : defaultSettings.bgm,
          bgmVolume: SETTINGS_LEVELS.has(String(parsed.bgmVolume || "")) ? String(parsed.bgmVolume) : defaultSettings.bgmVolume,
          sfxVolume: SETTINGS_LEVELS.has(String(parsed.sfxVolume || "")) ? String(parsed.sfxVolume) : defaultSettings.sfxVolume,
          questionCount: SETTINGS_QUESTION_COUNTS.has(Number(parsed.questionCount)) ? Number(parsed.questionCount) : defaultSettings.questionCount,
          choiceTimeLimitSec: SETTINGS_EXAM_TIMES.has(Number(parsed.choiceTimeLimitSec)) ? Number(parsed.choiceTimeLimitSec) : defaultSettings.choiceTimeLimitSec,
          autoNext: ("autoNext" in parsed) ? !!parsed.autoNext : defaultSettings.autoNext,
          theme: SETTINGS_THEMES.has(String(parsed.theme || "")) ? String(parsed.theme) : defaultSettings.theme,
          fontSize: SETTINGS_LEVELS.has(String(parsed.fontSize || "")) ? String(parsed.fontSize) : defaultSettings.fontSize
        };
        return out;
      }

      function loadSettings(){
        let legacy = {};
        let modern = {};
        try{
          const raw = window.localStorage.getItem(SETTINGS_KEY);
          if (raw){
            const parsed = JSON.parse(raw);
            if (parsed && typeof parsed === "object") legacy = parsed;
          }
        } catch {}
        try{
          const raw2 = window.localStorage.getItem(APP_SETTINGS_KEY);
          if (raw2){
            const parsed2 = JSON.parse(raw2);
            if (parsed2 && typeof parsed2 === "object") modern = parsed2;
          }
        } catch {}
        try{
          return normalizeSettings({ ...legacy, ...modern });
        } catch {
          return normalizeSettings(defaultSettings);
        }
      }
      function saveSettings(s){
        const normalized = normalizeSettings(s);
        window.localStorage.setItem(SETTINGS_KEY, JSON.stringify(normalized));
        try{
          window.localStorage.setItem(APP_SETTINGS_KEY, JSON.stringify(normalized));
        }catch{}
      }

      function loadDeck(){
        const v = window.localStorage.getItem(DECK_KEY);
        if (v === "B" || v === "C" || v === "D" || v === "E" || v === "ALL") return v;
        return "A";
      }
      function saveDeck(d){
        window.localStorage.setItem(DECK_KEY, d);
      }

      // =========================
      // App state
      // =========================
      const state = {
        settings: loadSettings(),
        view: "TITLE",  // TITLE | QUIZ | RESULT
        resultKind: null, // HAND | CHOICE
        deck: loadDeck(), // A | B | C | D | E | ALL
        startModeQuestionCount: 100,

        mode: null,     // SEQ | RND | CHOICE | HAND | REVIEW_WRONG
        order: [],
        index: 0,

        showAnswer: false,
        done: false,

        // hand mode
        hand: {
          checked: false,
          correct: null,
          input: "",
          busy: false,
          results: [], // {id, expected, given, correct, promptMeaning}
          scoreCorrect: 0
        },
        choice: {
          timeLimitSec: 0,      // 0 means none
          remainingMs: 0,
          timerId: null,
          endAt: 0,
          locked: false,
          options: [],
          correctIndex: -1,
          lastCorrectIndex: -1,
          correctCount: 0,
          results: []
        },

        // review wrong deck (as order)
        wrongOrder: [],

        // memo-check recommended scoped run
        _recommendScopeIds: null,
        _recommendScopedActive: false
      };
      function _clearRecommendScope(){
        state._recommendScopeIds = null;
        state._recommendScopedActive = false;
      }
      function _setRecommendScope(ids){
        const list = Array.from(new Set((Array.isArray(ids) ? ids : [])
          .map(Number)
          .filter(n => Number.isFinite(n))));
        state._recommendScopeIds = list.length ? list : null;
        state._recommendScopedActive = list.length > 0;
      }

      // =========================
      // Auth (Worker + D1)
      // =========================
      const AUTH_TOKEN_KEY = "app.auth.token.v1";
      const AUTH_TOKEN_EXP_KEY = "app.auth.expiresAt.v1";
      const AUTH_MODE_KEY = "app.auth.mode.v1"; // user | guest
      const AUTH_TOS_ACCEPT_KEY = "app.tos.accepted.v1";
      const AUTH_FIRST_RUN_KEY = "app.firstLaunchDone.v1";
      const AUTH_FIRST_RUN_LEGACY_KEY = "app.firstRun.v1";
      const AUTH_PROFILE_KEY = "app.auth.profile.v1";
      const AUTH_LEARN_PROFILE_KEY = "app.profile.v1";
      const AUTH_TOS_VERSION = "1";
      const AUTH_API_TIMEOUT_MS = 12000;
      const AUTH_BOOT_MIN_MS = 600;
      const AUTH_TRANSITION_MS = 650;
      const AUTH_WELCOME_DELAY_MS = 3000;
      const AUTH_GRADE_VALUES = new Set(["J1","J2","J3","H1","H2","H3"]);
      const AUTH_LOADING_ICONS = Object.freeze([
        "edit",
        "menu_book",
        "book_2",
        "note_stack",
        "plagiarism",
        "search",
        "straighten",
        "history_edu"
      ]);
      const FIRST_LAUNCH_LOADING_MIN_MS = 650;
      const FIRST_LAUNCH_LOADING_MAX_MS = 980;
      const authState = {
        mode: "none", // none | guest | user
        token: "",
        user: null,
        panel: "welcome",
        registerDraft: null,
        tosReachedBottom: false,
        tosSubmitting: false,
        welcomeTimer: null,
        firstRun: false,
        flow: "boot",
        booted: false,
        skippedExplanationShown: false,
        profileStep: 1
      };
      const firstLaunchState = {
        root: null,
        stage: null,
        icon: null,
        welcomeIcon: null
      };
      let _authGateHideTimer = null;
      const _loadingState = {
        count: 0
      };

      function _isMotionReduced(){
        try{
          if (state && state.settings && state.settings.animations === false) return true;
        }catch{}
        try{
          return !!(window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches);
        }catch{
          return false;
        }
      }
      function _loadingRender(){
        const overlay = document.getElementById("globalLoadingOverlay") || document.getElementById("globalLoading");
        if (!overlay) return;
        const visible = _loadingState.count > 0;
        overlay.classList.toggle("hidden", !visible);
      }
      function _authRandomLoadingIcon(){
        const list = AUTH_LOADING_ICONS;
        return list[Math.floor(Math.random() * list.length)] || "menu_book";
      }
      function _authApplyLoadingIcon(name){
        const iconName = String(name || _authRandomLoadingIcon());
        if (el.authBootIcon) el.authBootIcon.textContent = iconName;
        if (el.globalLoadingIcon) el.globalLoadingIcon.textContent = iconName;
        if (firstLaunchState.icon) firstLaunchState.icon.textContent = iconName;
        if (firstLaunchState.welcomeIcon) firstLaunchState.welcomeIcon.textContent = iconName;
      }
      function _ensureFirstLaunchOverlay(){
        if (firstLaunchState.root && firstLaunchState.stage && firstLaunchState.icon && firstLaunchState.welcomeIcon) return firstLaunchState;
        let root = document.getElementById("firstLaunchOverlay");
        if (!root){
          root = document.createElement("div");
          root.id = "firstLaunchOverlay";
          root.className = "hidden";
          root.setAttribute("aria-live", "polite");
          root.setAttribute("aria-busy", "true");
          root.innerHTML = `
            <div class="first-launch-shell">
              <div id="firstLaunchStage" data-stage="loading">
                <section class="first-launch-phase is-loading">
                  <div class="first-launch-loader">
                    <span class="ms first-launch-icon" id="firstLaunchIcon" aria-hidden="true">menu_book</span>
                    <span class="first-launch-spinner" aria-hidden="true"></span>
                  </div>
                </section>
                <section class="first-launch-phase is-welcome">
                  <div class="first-launch-welcome">
                    <div class="first-launch-welcome-badge" aria-hidden="true">
                      <span class="ms first-launch-welcome-icon" id="firstLaunchWelcomeIcon">menu_book</span>
                    </div>
                    <h1 class="first-launch-welcome-text">VocabuQuiz</h1>
                  </div>
                </section>
              </div>
            </div>
          `;
          document.body.appendChild(root);
        }
        firstLaunchState.root = root;
        firstLaunchState.stage = root.querySelector("#firstLaunchStage");
        firstLaunchState.icon = root.querySelector("#firstLaunchIcon");
        firstLaunchState.welcomeIcon = root.querySelector("#firstLaunchWelcomeIcon");
        return firstLaunchState;
      }
      function _firstLaunchSetActive(on){
        const ui = _ensureFirstLaunchOverlay();
        const active = !!on;
        document.body.classList.toggle("first-launch-open", active);
        if (active){
          ui.root.classList.remove("hidden");
          ui.root.classList.remove("is-leaving");
          requestAnimationFrame(() => {
            ui.root.classList.add("is-active");
          });
          return;
        }
        ui.root.classList.remove("is-active");
        ui.root.classList.remove("is-leaving");
        ui.root.classList.add("hidden");
      }
      function _firstLaunchSetStage(stage){
        const ui = _ensureFirstLaunchOverlay();
        const next = String(stage || "loading");
        ui.stage?.setAttribute("data-stage", next);
        _authApplyLoadingIcon();
      }
      async function _firstLaunchHide(animate = true){
        const ui = _ensureFirstLaunchOverlay();
        if (!ui.root || ui.root.classList.contains("hidden")){
          document.body.classList.remove("first-launch-open");
          return;
        }
        const useAnim = !!animate && !_isMotionReduced();
        document.body.classList.remove("first-launch-open");
        if (!useAnim){
          _firstLaunchSetActive(false);
          return;
        }
        ui.root.classList.remove("is-active");
        ui.root.classList.add("is-leaving");
        await new Promise((resolve) => {
          let done = false;
          const finish = () => {
            if (done) return;
            done = true;
            ui.root.removeEventListener("transitionend", onEnd);
            resolve();
          };
          const onEnd = (ev) => {
            if (ev.target !== ui.root) return;
            finish();
          };
          ui.root.addEventListener("transitionend", onEnd);
          setTimeout(finish, 480);
        });
        _firstLaunchSetActive(false);
      }
      async function _firstLaunchShowLoading(minMs){
        _firstLaunchSetActive(true);
        _firstLaunchSetStage("loading");
        const ms = Math.max(0, Number(minMs) || 0);
        if (ms > 0) await _authDelay(ms);
      }
      async function _firstLaunchShowWelcome(ms){
        _firstLaunchSetActive(true);
        _firstLaunchSetStage("welcome");
        const wait = Math.max(0, Number(ms) || 0);
        if (wait > 0) await _authDelay(wait);
      }
      function showLoading(message){
        void message;
        if (_loadingState.count <= 0){
          _authApplyLoadingIcon();
        }
        _loadingState.count += 1;
        _loadingRender();
      }
      function hideLoading(){
        _loadingState.count = Math.max(0, _loadingState.count - 1);
        _loadingRender();
      }
      window.__showGlobalLoading = function(labelText){
        showLoading(labelText || "");
      };
      window.__hideGlobalLoading = function(){
        hideLoading();
      };

      function _authApiBaseCandidates(){
        const list = [
          String(AUTH_API_BASE || "").trim(),
          String(AUTH_API_FALLBACK_BASE || "").trim()
        ].map((v) => String(v || "").trim().replace(/\/+$/, ""))
         .filter((v) => /^https?:\/\//i.test(v));
        const out = [];
        const seen = new Set();
        for (const b of list){
          if (seen.has(b)) continue;
          seen.add(b);
          out.push(b);
        }
        return out;
      }
      function _authApiUrl(base, path){
        const b = String(base || "").trim().replace(/\/+$/, "");
        const p = String(path || "");
        const pathPart = p.startsWith("/") ? p : `/${p}`;
        return `${b}${pathPart}`;
      }
      async function _authFetch(path, opts = {}){
        showLoading(opts.loadingText || "");
        const bases = _authApiBaseCandidates();
        if (!bases.length){
          hideLoading();
          throw new Error("API");
        }
        let lastErr = null;
        try{
          const headers = Object.assign({}, opts.headers || {});
          const hasBody = Object.prototype.hasOwnProperty.call(opts, "body") && opts.body != null;
          const hasContentType = Object.keys(headers).some((k) => String(k || "").toLowerCase() === "content-type");
          if (hasBody && !hasContentType){
            headers["Content-Type"] = "application/json";
          }
          for (let i = 0; i < bases.length; i += 1){
            const base = bases[i];
            const ctrl = new AbortController();
            const timer = setTimeout(() => ctrl.abort(), AUTH_API_TIMEOUT_MS);
            try{
              const req = Object.assign({}, opts, { headers, signal: ctrl.signal });
              const res = await fetch(_authApiUrl(base, path), req);
              const txt = await res.text();
              let body = null;
              try{ body = txt ? JSON.parse(txt) : null; }catch{ body = null; }
              if (!res.ok){
                const msg = String(body?.message || body?.error || `${res.status} ${res.statusText}`);
                const err = new Error(msg);
                err.code = String(body?.code || `HTTP_${res.status}`);
                err.status = Number(res.status || 0);
                err.data = body || null;
                const retryable = (res.status >= 500 || res.status === 404);
                if (retryable && i < bases.length - 1){
                  console.warn("[AUTH] retry with fallback base", { base, path, status: res.status });
                  lastErr = err;
                  continue;
                }
                throw err;
              }
              return body || {};
            } catch (err){
              const isAbort = String(err?.name || "").toLowerCase() === "aborterror";
              const status = Number(err?.status || 0);
              const isNetwork = String(err?.message || "").toLowerCase().includes("failed to fetch")
                || String(err?.message || "").toLowerCase().includes("networkerror");
              const retryable = isAbort || isNetwork || status >= 500 || status === 404 || status === 0;
              if (retryable && i < bases.length - 1){
                console.warn("[AUTH] network/server error, fallback next", { base, path, status, message: String(err?.message || err) });
                lastErr = err;
                continue;
              }
              if (isNetwork && i >= bases.length - 1){
                const e = new Error("APICORS");
                e.code = "AUTH_NETWORK_OR_CORS";
                e.status = 0;
                e.data = null;
                throw e;
              }
              throw err;
            } finally {
              clearTimeout(timer);
            }
          }
          if (lastErr) throw lastErr;
          throw new Error("API");
        } finally {
          hideLoading();
        }
      }
      function _authGetToken(){
        try{
          return String(window.localStorage.getItem(AUTH_TOKEN_KEY) || "").trim();
        }catch{
          return "";
        }
      }
      function _authGetTokenExpiresAt(){
        try{
          const raw = String(window.localStorage.getItem(AUTH_TOKEN_EXP_KEY) || "").trim();
          const n = Number(raw);
          return Number.isFinite(n) && n > 0 ? n : 0;
        }catch{
          return 0;
        }
      }
      function _authSetTokenExpiresAt(expiresAt){
        const n = Number(expiresAt);
        try{
          if (Number.isFinite(n) && n > 0) window.localStorage.setItem(AUTH_TOKEN_EXP_KEY, String(Math.trunc(n)));
          else window.localStorage.removeItem(AUTH_TOKEN_EXP_KEY);
        }catch{}
      }
      function _authSetAuthProfile(user){
        try{
          if (user && typeof user === "object") window.localStorage.setItem(AUTH_PROFILE_KEY, JSON.stringify(user));
          else window.localStorage.removeItem(AUTH_PROFILE_KEY);
        }catch{}
      }
      function _authMigrateLegacyTokenKeys(){
        const legacyTokenKeys = ["vq_token", "vqToken", "token", "authToken"];
        const legacyExpKeys = ["vq_token_expires_at", "vqTokenExpiresAt", "tokenExpiresAt", "authTokenExpiresAt"];
        const nowToken = _authGetToken();
        if (!nowToken){
          for (const key of legacyTokenKeys){
            try{
              const v = String(window.localStorage.getItem(key) || "").trim();
              if (!v) continue;
              window.localStorage.setItem(AUTH_TOKEN_KEY, v);
              break;
            }catch{}
          }
        }
        const nowExp = _authGetTokenExpiresAt();
        if (!nowExp){
          for (const key of legacyExpKeys){
            try{
              const raw = String(window.localStorage.getItem(key) || "").trim();
              const n = Number(raw);
              if (!Number.isFinite(n) || n <= 0) continue;
              window.localStorage.setItem(AUTH_TOKEN_EXP_KEY, String(Math.trunc(n)));
              break;
            }catch{}
          }
        }
        for (const key of legacyTokenKeys){
          if (key === AUTH_TOKEN_KEY) continue;
          try{ window.localStorage.removeItem(key); }catch{}
        }
        for (const key of legacyExpKeys){
          if (key === AUTH_TOKEN_EXP_KEY) continue;
          try{ window.localStorage.removeItem(key); }catch{}
        }
      }
      function _authSetToken(token){
        const t = String(token || "").trim();
        authState.token = t;
        try{
          if (t) window.localStorage.setItem(AUTH_TOKEN_KEY, t);
          else window.localStorage.removeItem(AUTH_TOKEN_KEY);
        }catch{}
      }
      function _authSetMode(mode){
        const m = (mode === "user" || mode === "guest") ? mode : "none";
        authState.mode = m;
        try{
          if (m === "none") window.localStorage.removeItem(AUTH_MODE_KEY);
          else window.localStorage.setItem(AUTH_MODE_KEY, m);
        }catch{}
      }
      function _authGetMode(){
        if (authState.mode === "user" || authState.mode === "guest") return authState.mode;
        try{
          const m = String(window.localStorage.getItem(AUTH_MODE_KEY) || "");
          if (m === "user" || m === "guest") return m;
        }catch{}
        return "none";
      }
      function _authSetUser(user){
        authState.user = (user && typeof user === "object") ? user : null;
        _authSetAuthProfile(authState.user);
        try{
          if (typeof _chatOnAuthChanged === "function"){
            setTimeout(() => {
              try{ _chatOnAuthChanged(); }catch{}
            }, 0);
          }
        }catch{}
        try{
          if (typeof _maintenanceRenderOverlay === "function"){
            setTimeout(() => {
              try{ _maintenanceRenderOverlay(); }catch{}
            }, 0);
          }
        }catch{}
      }
      function _authClearSession(){
        _authSetToken("");
        _authSetTokenExpiresAt(0);
        _authSetUser(null);
        _authSetMode("none");
      }
      function _authDisplayId(user){
        if (!user) return "";
        const grade = String(user.gradePrefix || "").trim();
        const nickname = String(user.nickname || "").trim();
        if (grade && nickname) return `${grade}-${nickname}`;
        if (nickname) return nickname;
        if (grade) return grade;
        return "";
      }
      function _authNormalizeNickname(raw){
        return String(raw || "").trim().replace(/\s+/g, "");
      }
      function _authSetStatus(elx, msg, kind){
        const target = elx || el.authGlobalStatus;
        if (target){
          target.textContent = String(msg || "");
          target.classList.remove("ok", "error");
          if (kind === "ok") target.classList.add("ok");
          if (kind === "error") target.classList.add("error");
        }
        if (el.authGlobalStatus && target !== el.authGlobalStatus){
          el.authGlobalStatus.textContent = String(msg || "");
          el.authGlobalStatus.classList.remove("ok", "error");
          if (kind === "ok") el.authGlobalStatus.classList.add("ok");
          if (kind === "error") el.authGlobalStatus.classList.add("error");
        }
      }
      function _authClearStatuses(){
        _authSetStatus(el.authEntryStatus, "", "");
        _authSetStatus(el.authRegisterStatus, "", "");
        _authSetStatus(el.authRegisterConfirmStatus, "", "");
        _authSetStatus(el.authLoginStatus, "", "");
        _authSetStatus(el.authProfileStatus, "", "");
        _authSetStatus(el.authGuestStatus, "", "");
        _authSetStatus(el.authTosStatus, "", "");
        _authSetStatus(el.authGlobalStatus, "", "");
      }
      function _authDelay(ms){
        return new Promise((resolve) => setTimeout(resolve, Math.max(0, Number(ms) || 0)));
      }
      function _authIsFirstRun(){
        try{
          const raw = String(window.localStorage.getItem(AUTH_FIRST_RUN_KEY) || "").trim().toLowerCase();
          if (raw === "true" || raw === "1" || raw === "done") return false;
          const legacy = String(window.localStorage.getItem(AUTH_FIRST_RUN_LEGACY_KEY) || "").trim().toLowerCase();
          if (legacy === "true" || legacy === "1" || legacy === "done"){
            window.localStorage.setItem(AUTH_FIRST_RUN_KEY, "true");
            return false;
          }
          return true;
        }catch{
          return true;
        }
      }
      function _authMarkFirstRunDone(){
        try{
          window.localStorage.setItem(AUTH_FIRST_RUN_KEY, "true");
          window.localStorage.setItem(AUTH_FIRST_RUN_LEGACY_KEY, "done");
        }catch{}
        authState.firstRun = false;
      }
      window.__resetFirstLaunch = function(){
        try{
          window.localStorage.removeItem(AUTH_FIRST_RUN_KEY);
          window.localStorage.removeItem(AUTH_FIRST_RUN_LEGACY_KEY);
        }catch{}
        location.reload();
      };
      window.__playFirstLaunch = async function(){
        try{
          _authSetBooting(true);
          await _firstLaunchShowLoading(700);
          await _firstLaunchShowWelcome(AUTH_WELCOME_DELAY_MS);
          await _firstLaunchHide(true);
          if (!authState.user){
            _authOpenGate("entry");
          }
        }finally{
          _authSetBooting(false);
        }
      };
      function _authSaveProfile(payload){
        const base = (payload && typeof payload === "object") ? payload : {};
        const out = {
          studyTime: String(base.studyTime || ""),
          subjectsText: String(base.subjectsText || ""),
          likeStudy: String(base.likeStudy || ""),
          updatedAt: Date.now()
        };
        try{ window.localStorage.setItem(AUTH_LEARN_PROFILE_KEY, JSON.stringify(out)); }catch{}
      }
      function _authSetProfileLike(v){
        const value = (v === "like" || v === "hard") ? v : "";
        if (el.authProfileLike) el.authProfileLike.value = value;
        if (el.authProfileLikeGoodBtn) el.authProfileLikeGoodBtn.classList.toggle("active", value === "like");
        if (el.authProfileLikeHardBtn) el.authProfileLikeHardBtn.classList.toggle("active", value === "hard");
      }
      function _authReadProfile(){
        return {
          studyTime: String(el.authProfileStudyTime?.value || ""),
          subjectsText: String(el.authProfileSubjects?.value || "").trim(),
          likeStudy: String(el.authProfileLike?.value || "")
        };
      }
      function _authSetProfileStep(step){
        const nextStep = Math.max(1, Math.min(3, Number(step) || 1));
        authState.profileStep = nextStep;
        const steps = el.authProfilePanel?.querySelectorAll?.("[data-auth-question-step]") || [];
        steps.forEach((node) => {
          const nodeStep = Number(node.getAttribute("data-auth-question-step") || "0");
          node.classList.toggle("is-active", nodeStep === nextStep);
        });
        if (el.authProfileBackBtn){
          el.authProfileBackBtn.classList.toggle("hidden", nextStep <= 1);
        }
        if (el.authProfileNextBtn){
          el.authProfileNextBtn.textContent = (nextStep >= 3) ? "" : "";
        }
      }
      function _authValidateProfileStep(step){
        const current = Math.max(1, Math.min(3, Number(step) || 1));
        if (current === 1){
          const v = String(el.authProfileStudyTime?.value || "");
          if (!v){
            _authSetStatus(el.authProfileStatus, "", "error");
            return false;
          }
        }
        if (current === 3){
          const v = String(el.authProfileLike?.value || "");
          if (v !== "like" && v !== "hard"){
            _authSetStatus(el.authProfileStatus, "", "error");
            return false;
          }
        }
        _authSetStatus(el.authProfileStatus, "", "");
        return true;
      }
      function _authHandleProfileBack(){
        const step = Math.max(1, Math.min(3, Number(authState.profileStep) || 1));
        if (step <= 1){
          _authShowPanel("tos");
          return;
        }
        _authSetProfileStep(step - 1);
      }
      function _authHandleProfileNext(){
        const step = Math.max(1, Math.min(3, Number(authState.profileStep) || 1));
        if (!_authValidateProfileStep(step)) return;
        if (step < 3){
          _authSetProfileStep(step + 1);
          return;
        }
        _authSubmitRegister(false);
      }
      function _authRenderGuestBadge(){
        if (!el.authGuestBadge) return;
        const show = authState.mode === "guest" && !authState.user;
        el.authGuestBadge.classList.toggle("hidden", !show);
      }
      function _authRenderSettingsAccount(){
        const summary = document.getElementById("settingsSummaryAccount");
        const stateLine = document.getElementById("settingsAccountStateLine");
        const userLine = document.getElementById("settingsAccountUserLine");
        const cardTitle = document.getElementById("settingsAccountCardTitle");
        const cardMeta = document.getElementById("settingsAccountCardMeta");
        const btnLogin = document.getElementById("settingsAccountOpenLoginBtn");
        const btnReg = document.getElementById("settingsAccountOpenRegisterBtn");
        const btnSwitch = document.getElementById("settingsAccountSwitchFromGuestBtn");
        const btnLogout = document.getElementById("settingsAccountLogoutBtn");
        const btnDelete = document.getElementById("settingsAccountDeleteBtn");
        const status = document.getElementById("settingsAccountStatus");
        if (status && !status.textContent) _authSetStatus(status, "", "");

        if (authState.user){
          const idText = _authDisplayId(authState.user);
          if (summary) summary.textContent = idText;
          if (stateLine) stateLine.textContent = "";
          if (userLine) userLine.textContent = idText;
          if (cardTitle) cardTitle.textContent = "";
          if (cardMeta) cardMeta.textContent = `: ${idText}`;
          if (btnLogin) btnLogin.classList.add("hidden");
          if (btnReg) btnReg.classList.add("hidden");
          if (btnSwitch) btnSwitch.classList.add("hidden");
          if (btnLogout) btnLogout.classList.remove("hidden");
          if (btnDelete) btnDelete.classList.remove("hidden");
        } else if (authState.mode === "guest"){
          if (summary) summary.textContent = "";
          if (stateLine) stateLine.textContent = "";
          if (userLine) userLine.textContent = "";
          if (cardTitle) cardTitle.textContent = "";
          if (cardMeta) cardMeta.textContent = "";
          if (btnLogin) btnLogin.classList.add("hidden");
          if (btnReg) btnReg.classList.add("hidden");
          if (btnSwitch) btnSwitch.classList.remove("hidden");
          if (btnLogout) btnLogout.classList.add("hidden");
          if (btnDelete) btnDelete.classList.add("hidden");
        } else {
          if (summary) summary.textContent = "";
          if (stateLine) stateLine.textContent = "";
          if (userLine) userLine.textContent = "";
          if (cardTitle) cardTitle.textContent = "";
          if (cardMeta) cardMeta.textContent = "";
          if (btnLogin) btnLogin.classList.remove("hidden");
          if (btnReg) btnReg.classList.remove("hidden");
          if (btnSwitch) btnSwitch.classList.add("hidden");
          if (btnLogout) btnLogout.classList.add("hidden");
          if (btnDelete) btnDelete.classList.add("hidden");
        }
      }
      function _authShowPanel(panel){
        const next = String(panel || "entry");
        const prev = authState.panel;
        if (authState.welcomeTimer){
          clearTimeout(authState.welcomeTimer);
          authState.welcomeTimer = null;
        }
        authState.panel = next;
        authState.flow = next;
        const root = el.authGate || document;
        root.querySelectorAll?.("[data-auth-panel]").forEach((node) => {
          node.classList.toggle("is-active", node.getAttribute("data-auth-panel") === next);
        });
        const registerLike = (next === "register" || next === "registerConfirm" || next === "tos" || next === "profile");
        const loginLike = (next === "login");
        if (el.authSegRegisterBtn){
          el.authSegRegisterBtn.classList.toggle("active", registerLike);
          el.authSegRegisterBtn.setAttribute("aria-selected", String(registerLike));
        }
        if (el.authSegRegisterBtn2){
          el.authSegRegisterBtn2.classList.toggle("active", registerLike);
          el.authSegRegisterBtn2.setAttribute("aria-selected", String(registerLike));
        }
        if (el.authSegLoginBtn){
          el.authSegLoginBtn.classList.toggle("active", loginLike);
          el.authSegLoginBtn.setAttribute("aria-selected", String(loginLike));
        }
        if (el.authSegLoginBtn2){
          el.authSegLoginBtn2.classList.toggle("active", loginLike);
          el.authSegLoginBtn2.setAttribute("aria-selected", String(loginLike));
        }
        _authClearStatuses();
        if (next === "tos" && prev !== "tos"){
          _authResetTosGate();
        }
        if (next === "guestConfirm" && el.authGuestAcknowledge){
          el.authGuestAcknowledge.checked = false;
          if (el.authGuestConfirmBtn) el.authGuestConfirmBtn.disabled = true;
        }
        if (next === "profile"){
          if (prev !== "profile"){
            if (el.authProfileStudyTime) el.authProfileStudyTime.value = "";
            if (el.authProfileSubjects) el.authProfileSubjects.value = "";
            _authSetProfileLike("");
            _authSetProfileStep(1);
          } else {
            _authSetProfileLike(String(el.authProfileLike?.value || ""));
            _authSetProfileStep(authState.profileStep || 1);
          }
        }
      }
      function _authOpenGate(panel = "entry", msg = ""){
        if (!el.authGate){
          uiToast("Auth Gate UI");
          return;
        }
        if (_authGateHideTimer){
          clearTimeout(_authGateHideTimer);
          _authGateHideTimer = null;
        }
        el.authGate.classList.remove("hidden");
        requestAnimationFrame(() => {
          document.body.classList.add("auth-gate-open");
        });
        _authShowPanel(panel);
        if (msg){
          _authSetStatus(el.authEntryStatus, msg, "error");
        }
      }
      function _authCloseGate(){
        if (!el.authGate) return;
        if (authState.welcomeTimer){
          clearTimeout(authState.welcomeTimer);
          authState.welcomeTimer = null;
        }
        document.body.classList.remove("auth-gate-open");
        const finalize = () => {
          el.authGate.classList.add("hidden");
          if (!authState.user) _authShowPanel("entry");
        };
        if (_authGateHideTimer){
          clearTimeout(_authGateHideTimer);
          _authGateHideTimer = null;
        }
        if (_isMotionReduced()){
          finalize();
          return;
        }
        _authGateHideTimer = setTimeout(() => {
          _authGateHideTimer = null;
          finalize();
        }, 260);
      }
      function _authSetBooting(on){
        if (on){
          _authApplyLoadingIcon();
        }
        document.body.classList.toggle("auth-booting", !!on);
        if (el.authBootSplash){
          el.authBootSplash.classList.toggle("hidden", !on);
        }
      }
      function _authCanSubmitTos(){
        return !!(authState.tosReachedBottom && el.authTosAgree1?.checked && el.authTosAgree2?.checked && !authState.tosSubmitting);
      }
      function _authUpdateTosSubmitState(){
        if (el.authTosSubmitBtn){
          el.authTosSubmitBtn.disabled = !_authCanSubmitTos();
        }
      }
      function _authResetTosGate(){
        authState.tosReachedBottom = false;
        authState.tosSubmitting = false;
        if (el.authTosScroll) el.authTosScroll.scrollTop = 0;
        if (el.authTosAgree1){
          el.authTosAgree1.checked = false;
          el.authTosAgree1.disabled = true;
        }
        if (el.authTosAgree2){
          el.authTosAgree2.checked = false;
          el.authTosAgree2.disabled = true;
        }
        if (el.authTosHint){
          el.authTosHint.textContent = "";
        }
        _authUpdateTosSubmitState();
      }
      function _authHandleTosScroll(){
        if (!el.authTosScroll) return;
        const reached = (el.authTosScroll.scrollTop + el.authTosScroll.clientHeight) >= (el.authTosScroll.scrollHeight - 4);
        if (!reached || authState.tosReachedBottom) return;
        authState.tosReachedBottom = true;
        if (el.authTosAgree1) el.authTosAgree1.disabled = false;
        if (el.authTosAgree2) el.authTosAgree2.disabled = false;
        if (el.authTosHint){
          el.authTosHint.textContent = "2";
        }
        _authUpdateTosSubmitState();
      }
      function _authReadRegisterDraft(){
        const grade = String(el.authRegisterGrade?.value || "J1");
        const nickname = _authNormalizeNickname(el.authRegisterNickname?.value || "");
        const password = String(el.authRegisterPassword?.value || "");
        return { grade, nickname, password };
      }
      function _authValidateRegisterDraft(draft){
        const d = draft || {};
        if (!AUTH_GRADE_VALUES.has(String(d.grade || ""))) return "";
        if (!d.nickname || d.nickname.length < 2 || d.nickname.length > 24) return "224";
        if (!/^[A-Za-z0-9._-]{2,24}$/.test(d.nickname)) return " . _ - ";
        if (!d.password || d.password.length < 8) return "8";
        return "";
      }
      function _authRenderRegisterConfirm(){
        const d = authState.registerDraft || {};
        if (el.authRegisterConfirmGrade) el.authRegisterConfirmGrade.textContent = String(d.grade || "");
        if (el.authRegisterConfirmNickname) el.authRegisterConfirmNickname.textContent = String(d.nickname || "");
        if (el.authRegisterConfirmPassword){
          const len = Math.max(8, String(d.password || "").length || 8);
          el.authRegisterConfirmPassword.textContent = "".repeat(Math.min(16, len));
        }
      }
      async function _authTransitionToHome(){
        showLoading();
        try{
          await _authDelay(AUTH_TRANSITION_MS);
        }finally{
          hideLoading();
        }
        _authCloseGate();
        _authRenderGuestBadge();
        _authRenderSettingsAccount();
        _settingsRefreshSummary();
        _appSetTab("home");
        _maintenanceCheckNow("auth-transition", { silent: true, force: true });
      }
      async function _authSubmitRegister(skipProfile){
        if (authState.tosSubmitting) return;
        const draft = authState.registerDraft;
        if (!draft){
          _authSetStatus(el.authGlobalStatus, "", "error");
          _authShowPanel("register");
          return;
        }
        authState.tosSubmitting = true;
        const disableProfile = [el.authProfileSkipBtn, el.authProfileNextBtn].filter(Boolean);
        disableProfile.forEach((b) => { b.disabled = true; });
        try{
          if (skipProfile){
            _authSaveProfile({ studyTime: "", subjectsText: "", likeStudy: "" });
          }else{
            _authSaveProfile(_authReadProfile());
          }
          const body = await _authFetch("/api/auth/register", {
            method: "POST",
            body: JSON.stringify({
              gradePrefix: draft.grade,
              nickname: draft.nickname,
              password: draft.password,
              tosAccepted: true,
              tosVersion: AUTH_TOS_VERSION
            })
          });
          const token = String(body?.token || "");
          const expiresAt = Number(body?.expiresAt || 0);
          const user = body?.user || null;
          if (!token || !user){
            throw new Error("");
          }
          _authSetToken(token);
          _authSetTokenExpiresAt(expiresAt);
          _authSetUser(user);
          _authSetMode("user");
          try{
            window.localStorage.setItem(AUTH_TOS_ACCEPT_KEY, JSON.stringify({
              acceptedAt: Date.now(),
              version: AUTH_TOS_VERSION
            }));
          }catch{}
          authState.registerDraft = null;
          _authSetStatus(el.authGlobalStatus, "", "ok");
          await _authDelay(1000);
          await _authTransitionToHome();
          uiToast("");
        }catch(err){
          const status = Number(err?.status || 0);
          const code = String(err?.code || "");
          const rawMsg = String(err?.message || err || "");
          const msg = (status >= 500 || /duration/i.test(rawMsg))
            ? ""
            : rawMsg;
          _authShowPanel("register");
          _authSetStatus(el.authRegisterStatus, `: ${code ? `${code} / ` : ""}${msg}`, "error");
        }finally{
          authState.tosSubmitting = false;
          _authUpdateTosSubmitState();
          disableProfile.forEach((b) => { b.disabled = false; });
        }
      }
      async function _authSubmitLogin(){
        const grade = String(el.authLoginGrade?.value || "J1");
        const nickname = _authNormalizeNickname(el.authLoginNickname?.value || "");
        const password = String(el.authLoginPassword?.value || "");
        if (!AUTH_GRADE_VALUES.has(grade)){
          _authSetStatus(el.authLoginStatus, "", "error");
          return;
        }
        if (!nickname || nickname.length < 2){
          _authSetStatus(el.authLoginStatus, "", "error");
          return;
        }
        if (!password){
          _authSetStatus(el.authLoginStatus, "", "error");
          return;
        }
        if (el.authLoginSubmitBtn) el.authLoginSubmitBtn.disabled = true;
        try{
          const body = await _authFetch("/api/auth/login", {
            method: "POST",
            body: JSON.stringify({
              gradePrefix: grade,
              nickname,
              password
            })
          });
          const token = String(body?.token || "");
          const expiresAt = Number(body?.expiresAt || 0);
          const user = body?.user || null;
          if (!token || !user){
            throw new Error("");
          }
          _authSetToken(token);
          _authSetTokenExpiresAt(expiresAt);
          _authSetUser(user);
          _authSetMode("user");
          await _authTransitionToHome();
          uiToast("");
        }catch(err){
          const status = Number(err?.status || 0);
          const code = String(err?.code || "");
          const rawMsg = String(err?.message || err || "");
          const msg = (status >= 500 || /duration/i.test(rawMsg))
            ? ""
            : rawMsg;
          _authSetStatus(el.authLoginStatus, `: ${code ? `${code} / ` : ""}${msg}`, "error");
        }finally{
          if (el.authLoginSubmitBtn) el.authLoginSubmitBtn.disabled = false;
        }
      }
      async function _authContinueAsGuest(){
        if (!el.authGuestAcknowledge?.checked){
          _authSetStatus(el.authGuestStatus, "", "error");
          return;
        }
        _authSetToken("");
        _authSetUser(null);
        _authSetMode("guest");
        await _authTransitionToHome();
        uiToast("");
      }
      async function _authLogout(){
        _authClearSession();
        _authRenderGuestBadge();
        _authRenderSettingsAccount();
        _settingsRefreshSummary();
        _authOpenGate("entry");
        _appSetTab("home");
        _maintenanceState.bypass = false;
        _maintenanceCheckNow("logout", { silent: true, force: true });
        uiToast("");
      }
      function _authPurgeLocalData(){
        const directKeys = [
          AUTH_TOKEN_KEY,
          AUTH_TOKEN_EXP_KEY,
          AUTH_MODE_KEY,
          AUTH_PROFILE_KEY,
          AUTH_TOS_ACCEPT_KEY,
          PRESETS_KEY,
          ACTIVE_PRESET_KEY,
          SETTINGS_KEY,
          APP_SETTINGS_KEY,
          DECK_KEY,
          INSIGHTS_SESSIONS_KEY,
          SHARE_CACHE_KEY,
          NOTIF_SEEN_KEY,
          NOTIF_KEY,
          BACKUP_LATEST_KEY,
          BACKUP_LAST_RUN_DATE_KEY,
          CHAT_HISTORY_KEY,
          CHAT_HISTORY_META_KEY,
          CHAT_MEMORY_KEY,
          CHAT_LAST_INTENT_KEY,
          HOME_RESUME_KEY,
          MEMO_CHECK_KEY,
          AUTH_LEARN_PROFILE_KEY,
          SUBJECTS_CUSTOM_KEY,
          TAGS_CUSTOM_KEY
        ].filter(Boolean).map((v) => String(v));
        const directSet = new Set(directKeys);
        const prefixKeys = [EXAM_SET_KEY_PREFIX, CHOICE_SET_KEY_PREFIX]
          .filter(Boolean)
          .map((v) => String(v));
        try{
          const keys = [];
          for (let i = 0; i < window.localStorage.length; i += 1){
            const k = window.localStorage.key(i);
            if (k) keys.push(String(k));
          }
          for (const key of keys){
            const removeByPrefix = prefixKeys.some((prefix) => key === prefix || key.startsWith(`${prefix}:`));
            if (directSet.has(key) || removeByPrefix){
              window.localStorage.removeItem(key);
            }
          }
        }catch{}
      }
      async function _authDeleteAccount(){
        const status = document.getElementById("settingsAccountStatus");
        const deleteBtn = document.getElementById("settingsAccountDeleteBtn");
        if (!authState.user){
          _authSetStatus(status, "", "error");
          return;
        }
        const token = _authGetToken();
        if (!token){
          _authSetStatus(status, "", "error");
          return;
        }

        const step1 = await uiConfirm(
          "",
          { title: "", okText: "", cancelText: "" }
        );
        if (!step1) return;

        const step2 = await uiConfirm(
          "",
          { title: "", okText: "", cancelText: "", danger: true }
        );
        if (!step2) return;

        if (deleteBtn) deleteBtn.disabled = true;
        _authSetStatus(status, "", "");
        try{
          const body = await _authFetch("/api/auth/delete", {
            method: "POST",
            headers: { Authorization: `Bearer ${token}` }
          });
          if (!body || body.ok !== true){
            throw new Error("");
          }
          _authSetStatus(status, "", "ok");
          _authPurgeLocalData();
          _authClearSession();
          _authSetUser(null);
          _authSetMode("none");
          _authRenderGuestBadge();
          _authRenderSettingsAccount();
          _settingsRefreshSummary();
          uiToast("");
          setTimeout(() => { location.reload(); }, 300);
        }catch(err){
          const code = String(err?.code || "");
          const msg = String(err?.message || err || "");
          _authSetStatus(status, `: ${code ? `${code} / ` : ""}${msg}`, "error");
          if (deleteBtn) deleteBtn.disabled = false;
        }
      }
      async function _authVerifyToken(token){
        const t = String(token || "").trim();
        if (!t) return { ok: false };
        try{
          const body = await _authFetch("/api/auth/me", {
            method: "GET",
            headers: {
              Authorization: `Bearer ${t}`
            }
          });
          if (!body?.user) return { ok: false };
          return { ok: true, user: body.user };
        }catch{
          return { ok: false };
        }
      }
      async function _authBootstrap(){
        const bootStart = Date.now();
        _authSetBooting(true);
        try{
          _authMigrateLegacyTokenKeys();
          _ensureFirstLaunchOverlay();
          const mode = _authGetMode();
          const token = _authGetToken();
          authState.firstRun = _authIsFirstRun();
          _authSetMode(mode === "user" || mode === "guest" ? mode : "none");
          _authSetToken(token);
          _authSetUser(null);
          let gateShouldOpen = true;

          if (token){
            const me = await _authVerifyToken(token);
            if (me.ok){
              _authSetMode("user");
              _authSetUser(me.user);
              gateShouldOpen = false;
            } else {
              _authClearSession();
              gateShouldOpen = true;
            }
          } else if (mode === "guest"){
            // Guest mode also returns to auth choice screen on reload.
            gateShouldOpen = true;
          } else {
            gateShouldOpen = true;
          }

          _authRenderGuestBadge();
          _authRenderSettingsAccount();
          _settingsRefreshSummary();
          if (gateShouldOpen){
            const openPanel = "entry";
            if (authState.firstRun){
              await _firstLaunchShowLoading(FIRST_LAUNCH_LOADING_MAX_MS);
              await _firstLaunchShowWelcome(AUTH_WELCOME_DELAY_MS);
              _authMarkFirstRunDone();
              await _firstLaunchHide(true);
            } else {
              await _firstLaunchHide(false);
            }
            if (!authState.user){
              _authOpenGate(openPanel);
            }
          } else {
            await _firstLaunchHide(false);
            _authCloseGate();
          }
          authState.booted = true;
        }catch(err){
          _authClearSession();
          await _firstLaunchHide(false);
          _authOpenGate("entry", `: ${String(err?.message || err)}`);
          _authRenderGuestBadge();
          _authRenderSettingsAccount();
          _settingsRefreshSummary();
          authState.booted = true;
        } finally {
          const elapsed = Date.now() - bootStart;
          if (elapsed < AUTH_BOOT_MIN_MS){
            await _authDelay(AUTH_BOOT_MIN_MS - elapsed);
          }
          _authSetBooting(false);
          try{
            await _maintenanceBootstrap();
          }catch(err){
            _maintenanceSetAdminStatus(`: ${String(err?.message || err)}`, "error");
          }
        }
      }
      window.VQDebug = Object.assign({}, window.VQDebug || {}, {
        printAuth(){
          const token = String(window.localStorage.getItem(AUTH_TOKEN_KEY) || "");
          const exp = String(window.localStorage.getItem(AUTH_TOKEN_EXP_KEY) || "");
          const profile = String(window.localStorage.getItem(AUTH_PROFILE_KEY) || "");
          console.log("[VQDebug.printAuth]", {
            TOKEN_KEY: AUTH_TOKEN_KEY,
            TOKEN_EXP_KEY: AUTH_TOKEN_EXP_KEY,
            PROFILE_KEY: AUTH_PROFILE_KEY,
            token,
            expiresAt: exp,
            profile
          });
        },
        async testMe(){
          const token = String(window.localStorage.getItem(AUTH_TOKEN_KEY) || "").trim();
          const url = `${String(AUTH_API_BASE || "").trim().replace(/\/+$/, "")}/api/auth/me`;
          if (!token){
            console.log("[VQDebug.testMe] token is empty", { key: AUTH_TOKEN_KEY, url });
            return;
          }
          try{
            const res = await fetch(url, {
              method: "GET",
              headers: { Authorization: `Bearer ${token}` }
            });
            const bodyText = await res.text();
            console.log("[VQDebug.testMe]", { status: res.status, url, body: bodyText });
          }catch(err){
            console.log("[VQDebug.testMe] fetch failed", { url, error: String(err?.message || err) });
          }
        }
      });
      function _authBindEvents(){
        if (!el.authGate){
          uiToast("Auth Gate UI");
          return;
        }
        el.authOpenRegisterBtn?.addEventListener("click", () => _authShowPanel("register"));
        el.authOpenLoginBtn?.addEventListener("click", () => _authShowPanel("login"));
        el.authOpenGuestConfirmBtn?.addEventListener("click", () => _authShowPanel("guestConfirm"));
        el.authSegRegisterBtn?.addEventListener("click", () => _authShowPanel("register"));
        el.authSegLoginBtn?.addEventListener("click", () => _authShowPanel("login"));
        el.authSegRegisterBtn2?.addEventListener("click", () => _authShowPanel("register"));
        el.authSegLoginBtn2?.addEventListener("click", () => _authShowPanel("login"));
        el.authRegisterBackBtn?.addEventListener("click", () => _authShowPanel("entry"));
        el.authLoginBackBtn?.addEventListener("click", () => _authShowPanel("entry"));
        el.authGuestBackBtn?.addEventListener("click", () => _authShowPanel("entry"));
        el.authRegisterConfirmBackBtn?.addEventListener("click", () => _authShowPanel("register"));
        el.authRegisterConfirmNextBtn?.addEventListener("click", () => {
          if (!authState.registerDraft){
            _authShowPanel("register");
            return;
          }
          _authShowPanel("tos");
        });
        el.authTosBackBtn?.addEventListener("click", () => _authShowPanel("registerConfirm"));
        el.authRegisterNextBtn?.addEventListener("click", () => {
          const draft = _authReadRegisterDraft();
          const err = _authValidateRegisterDraft(draft);
          if (err){
            _authSetStatus(el.authRegisterStatus, err, "error");
            return;
          }
          authState.registerDraft = { grade: draft.grade, nickname: draft.nickname, password: draft.password };
          _authRenderRegisterConfirm();
          _authShowPanel("registerConfirm");
        });
        el.authLoginSubmitBtn?.addEventListener("click", () => {
          _authSubmitLogin();
        });
        el.authProfileLikeGoodBtn?.addEventListener("click", () => _authSetProfileLike("like"));
        el.authProfileLikeHardBtn?.addEventListener("click", () => _authSetProfileLike("hard"));
        el.authProfileBackBtn?.addEventListener("click", () => _authHandleProfileBack());
        el.authProfileSkipBtn?.addEventListener("click", () => _authSubmitRegister(true));
        el.authProfileNextBtn?.addEventListener("click", () => _authHandleProfileNext());
        el.authGuestConfirmBtn?.addEventListener("click", () => {
          _authContinueAsGuest();
        });
        el.authGuestAcknowledge?.addEventListener("change", () => {
          if (el.authGuestConfirmBtn){
            el.authGuestConfirmBtn.disabled = !el.authGuestAcknowledge?.checked;
          }
        });
        el.authTosSubmitBtn?.addEventListener("click", () => {
          if (!_authCanSubmitTos()){
            _authSetStatus(el.authTosStatus, "2", "error");
            return;
          }
          _authShowPanel("profile");
        });
        el.authTosScroll?.addEventListener("scroll", _authHandleTosScroll, { passive: true });
        el.authTosAgree1?.addEventListener("change", _authUpdateTosSubmitState);
        el.authTosAgree2?.addEventListener("change", _authUpdateTosSubmitState);

        document.addEventListener("keydown", (e) => {
          const ae = document.activeElement;
          const typing = ae && (ae.tagName === "INPUT" || ae.tagName === "TEXTAREA" || ae.tagName === "SELECT" || ae.isContentEditable);
          if (!typing) return;
          if (!el.authGate || el.authGate.classList.contains("hidden")) return;
          if (e.key !== "Enter" || e.shiftKey) return;
          if (authState.panel === "login"){
            e.preventDefault();
            _authSubmitLogin();
            return;
          }
          if (authState.panel === "register"){
            e.preventDefault();
            const draft = _authReadRegisterDraft();
            const err = _authValidateRegisterDraft(draft);
            if (err){
              _authSetStatus(el.authRegisterStatus, err, "error");
              return;
            }
            authState.registerDraft = { grade: draft.grade, nickname: draft.nickname, password: draft.password };
            _authRenderRegisterConfirm();
            _authShowPanel("registerConfirm");
            return;
          }
          if (authState.panel === "registerConfirm"){
            e.preventDefault();
            if (!authState.registerDraft){
              _authShowPanel("register");
              return;
            }
            _authShowPanel("tos");
            return;
          }
          if (authState.panel === "tos" && _authCanSubmitTos()){
            e.preventDefault();
            _authShowPanel("profile");
            return;
          }
          if (authState.panel === "profile"){
            e.preventDefault();
            _authHandleProfileNext();
          }
        }, true);
      }
      applyTheme();
      applyFontSize();
      applyMotionSetting();
      try{ insights.reduceMotion = _isMotionReduced(); }catch{}
      try{
        const mq = window.matchMedia ? window.matchMedia("(prefers-color-scheme: dark)") : null;
        if (mq && typeof mq.addEventListener === "function"){
          mq.addEventListener("change", () => {
            if (String(state.settings.theme || "AUTO") === "AUTO") applyTheme();
          });
        }
      }catch{}
      // =========================
      // Preset selection init (after state exists)
      // =========================
      state.presetId = loadActivePresetId(state.deck);

      // If stored custom preset doesn't exist anymore, fallback safely.
      if (!isBuiltinPreset(state.presetId)){
        const list = loadPresets();
        if (!list.some(p => p.id === state.presetId)){
          state.presetId = list[0]?.id || `builtin:${state.deck}`;
        }
      }

      // If builtin preset, ensure deck follows it.
      if (isBuiltinPreset(state.presetId)){
        const dk = deckFromBuiltinId(state.presetId);
        state.deck = dk;
        saveDeck(dk);
      }

      saveActivePresetId(state.presetId);



      // =========================
      // Elements
      // =========================
      const el = {
        backBtn: document.getElementById("backBtn"),
        settingsBtn: document.getElementById("settingsBtn"),
        insightsBtn: document.getElementById("insightsBtn"),
        notifyBtn: document.getElementById("notifyBtn"),
        notifyDot: document.getElementById("notifyDot"),
        notifyOverlay: document.getElementById("notifyOverlay"),
        notifyCloseBtn: document.getElementById("notifyCloseBtn"),
        notifyCloseBtn2: document.getElementById("notifyCloseBtn2"),
        notifyList: document.getElementById("notifyList"),
        notifyEmpty: document.getElementById("notifyEmpty"),
        notifyListPane: document.getElementById("notifyListPane"),
        notifyDetailPane: document.getElementById("notifyDetailPane"),
        notifyDetailBackBtn: document.getElementById("notifyDetailBackBtn"),
        notifyDetailTitle: document.getElementById("notifyDetailTitle"),
        notifyDetailMeta: document.getElementById("notifyDetailMeta"),
        notifyDetailContent: document.getElementById("notifyDetailContent"),
        topPresetBtn: document.getElementById("topPresetBtn"),
        searchBtn: document.getElementById("searchBtn"),
        searchOverlay: document.getElementById("searchOverlay"),
        searchCloseBtn: document.getElementById("searchCloseBtn"),
        searchInput: document.getElementById("searchInput"),
        searchList: document.getElementById("searchList"),
        searchEmpty: document.getElementById("searchEmpty"),

        viewStart: document.getElementById("viewStart"),
        startAppBtn: document.getElementById("startAppBtn"),

        viewTitle: document.getElementById("viewTitle"),
        viewQuiz: document.getElementById("viewQuiz"),
        viewResult: document.getElementById("viewResult"),

        deckABtn: document.getElementById("deckABtn"),
        deckBBtn: document.getElementById("deckBBtn"),
        deckCBtn: document.getElementById("deckCBtn"),
        deckDBtn: document.getElementById("deckDBtn"),
        deckEBtn: document.getElementById("deckEBtn"),
        deckAllBtn: document.getElementById("deckAllBtn"),
        deckMyBtn: document.getElementById("deckMyBtn"),
        presetManageBtn: document.getElementById("presetManageBtn"),
        customPresetRow: document.getElementById("customPresetRow"),
        customPresetSelect: document.getElementById("customPresetSelect"),
        customPresetNewBtn: document.getElementById("customPresetNewBtn"),
        deckStatus: document.getElementById("deckStatus"),
        practiceHint: document.getElementById("practiceHint"),

        modeActions: document.getElementById("modeActions"),
        emptyState: document.getElementById("emptyState"),

        startSeqBtn: document.getElementById("startSeqBtn"),
        startRndBtn: document.getElementById("startRndBtn"),
        startChoiceBtn: document.getElementById("startChoiceBtn"),
        startHandBtn: document.getElementById("startHandBtn"),

        badgeSeq: document.getElementById("badgeSeq"),
        badgeRnd: document.getElementById("badgeRnd"),
        badgeChoice: document.getElementById("badgeChoice"),
        badgeHand: document.getElementById("badgeHand"),

        dataStatusText: document.getElementById("dataStatusText"),

        progressText: document.getElementById("progressText"),
        timerPill: document.getElementById("timerPill"),
        modePill: document.getElementById("modePill"),
        noText: document.getElementById("noText"),
        dirLabel: document.getElementById("dirLabel"),
        judgeBadge: document.getElementById("judgeBadge"),
        promptText: document.getElementById("promptText"),
        promptDiagramWrap: document.getElementById("promptDiagramWrap"),
        promptDiagramImg: document.getElementById("promptDiagramImg"),
        choiceWrap: document.getElementById("choiceWrap"),
        choices: document.getElementById("choices"),
        answerWrap: document.getElementById("answerWrap"),
        answerText: document.getElementById("answerText"),
        yourText: document.getElementById("yourText"),

        // marks
        markLayer: document.getElementById("markLayer"),
        svgOk: document.getElementById("svgOk"),
        svgNg: document.getElementById("svgNg"),

        spellWrap: document.getElementById("spellWrap"),
        spellInput: document.getElementById("spellInput"),
        readCanvasBtn: document.getElementById("readCanvasBtn"),

        handWrap: document.getElementById("handWrap"),
        handCanvas: document.getElementById("handCanvas"),
        handMini: document.getElementById("handMini"),
        clearCanvasBtn: document.getElementById("clearCanvasBtn"),

        primaryBtn: document.getElementById("primaryBtn"),
        prevBtn: document.getElementById("prevBtn"),
        nextBtn: document.getElementById("nextBtn"),
        restartBtn: document.getElementById("restartBtn"),
        newSetBtn: document.getElementById("newSetBtn"),

        debugBar: document.getElementById("debugBar"),
        card: document.getElementById("card"),

        // settings
        settingsOverlay: document.getElementById("settingsOverlay"),
        updateOverlay: document.getElementById("updateOverlay"),
        updateCloseBtn: document.getElementById("updateCloseBtn"),
        updateCloseXBtn: document.getElementById("updateCloseXBtn"),
        updateDontShowChk: document.getElementById("updateDontShowChk"),
        timeOverlay: document.getElementById("timeOverlay"),
        closeTimeBtn: document.getElementById("closeTimeBtn"),
        cancelTimeBtn: document.getElementById("cancelTimeBtn"),
        time5Btn: document.getElementById("time5Btn"),
        time10Btn: document.getElementById("time10Btn"),
        time30Btn: document.getElementById("time30Btn"),
        time60Btn: document.getElementById("time60Btn"),
        timeNoneBtn: document.getElementById("timeNoneBtn"),
        closeSettingsBtn: document.getElementById("closeSettingsBtn"),
        closeSettingsBtn2: document.getElementById("closeSettingsBtn2"),
        dirEnJaBtn: document.getElementById("dirEnJaBtn"),
        dirJaEnBtn: document.getElementById("dirJaEnBtn"),
        animToggle: document.getElementById("animToggle"),
        sfxToggle: document.getElementById("sfxToggle"),
        bgmToggle: document.getElementById("bgmToggle"),
        bgmVolLargeBtn: document.getElementById("bgmVolLargeBtn"),
        bgmVolDefaultBtn: document.getElementById("bgmVolDefaultBtn"),
        bgmVolSmallBtn: document.getElementById("bgmVolSmallBtn"),
        debugToggle: document.getElementById("debugToggle"),
        backupCreateNowBtn: document.getElementById("backupCreateNowBtn"),
        backupExportBtn: document.getElementById("backupExportBtn"),
        backupImportBtn: document.getElementById("backupImportBtn"),
        backupRestoreLatestBtn: document.getElementById("backupRestoreLatestBtn"),
        backupImportFile: document.getElementById("backupImportFile"),
        backupStatus: document.getElementById("backupStatus"),

        // result
        resultSub: document.getElementById("resultSub"),
        scoreBig: document.getElementById("scoreBig"),
        scoreSub: document.getElementById("scoreSub"),
        wrongDetails: document.getElementById("wrongDetails"),
	        wrongSummary: document.getElementById("wrongSummary"),
	        wrongList: document.getElementById("wrongList"),
	        resultRestartBtn: document.getElementById("resultRestartBtn"),
	        resultNewSetBtn: document.getElementById("resultNewSetBtn"),
	        resultTitleBtn: document.getElementById("resultTitleBtn"),
	        resultReviewBtn: document.getElementById("resultReviewBtn"),

        // app tabs
        appTabBar: document.getElementById("appTabBar"),
        homeResumeBtn: document.getElementById("homeResumeBtn"),
        homeActivePresetName: document.getElementById("homeActivePresetName"),
        homeActivePresetMeta: document.getElementById("homeActivePresetMeta"),
        appLibraryPage: document.getElementById("appLibraryPage"),
        appLibrarySubjectFilter: document.getElementById("appLibrarySubjectFilter"),
        appLibrarySearchInput: document.getElementById("appLibrarySearchInput"),
        appLibraryTagFilters: document.getElementById("appLibraryTagFilters"),
        appLibraryBuiltinList: document.getElementById("appLibraryBuiltinList"),
        appLibraryMyList: document.getElementById("appLibraryMyList"),
        appInboxPage: document.getElementById("appInboxPage"),
        appInboxAdminBtn: document.getElementById("appInboxAdminBtn"),
        appInboxList: document.getElementById("appInboxList"),
        appInboxEmpty: document.getElementById("appInboxEmpty"),
        appInboxListPane: document.getElementById("appInboxListPane"),
        appInboxDetailPane: document.getElementById("appInboxDetailPane"),
        appInboxDetailTitle: document.getElementById("appInboxDetailTitle"),
        appInboxDetailMeta: document.getElementById("appInboxDetailMeta"),
        appInboxDetailContent: document.getElementById("appInboxDetailContent"),
        appInsightsPage: document.getElementById("appInsightsPage"),
        appInsightsSummaryCards: document.getElementById("appInsightsSummaryCards"),
        appInsightsPresetSelect: document.getElementById("appInsightsPresetSelect"),
        appInsightsModeSelect: document.getElementById("appInsightsModeSelect"),
        appInsightsRangeSelect: document.getElementById("appInsightsRangeSelect"),
        appInsightsDailyVolume: document.getElementById("appInsightsDailyVolume"),
        appInsightsDailyAccuracy: document.getElementById("appInsightsDailyAccuracy"),
        appInsightsModeDistribution: document.getElementById("appInsightsModeDistribution"),
        appChatPage: document.getElementById("appChatPage"),
        appChatQuestionRow: document.getElementById("appChatQuestionRow"),
        appChatIntentSearch: document.getElementById("appChatIntentSearch"),
        appChatIntentGroups: document.getElementById("appChatIntentGroups"),
        appChatIntentCount: document.getElementById("appChatIntentCount"),
        appChatAutoPickToggleBtn: document.getElementById("appChatAutoPickToggleBtn"),
        appChatScroll: document.getElementById("appChatScroll"),
        appChatList: document.getElementById("appChatList"),
        appChatEmpty: document.getElementById("appChatEmpty"),
        appChatHistoryCount: document.getElementById("appChatHistoryCount"),
        appChatQuotaStatus: document.getElementById("appChatQuotaStatus"),
        appChatModeNormalBtn: document.getElementById("appChatModeNormalBtn"),
        appChatModeReasonBtn: document.getElementById("appChatModeReasonBtn"),
        appChatModeToggleBtn: document.getElementById("appChatModeToggleBtn"),
        appChatModeToggleText: document.getElementById("appChatModeToggleText"),
        appChatModeMenu: document.getElementById("appChatModeMenu"),
        appChatModeOptionNormal: document.getElementById("appChatModeOptionNormal"),
        appChatModeOptionReason: document.getElementById("appChatModeOptionReason"),
        appChatModeNote: document.getElementById("appChatModeNote"),
        appChatLimitBanner: document.getElementById("appChatLimitBanner"),
        appChatLimitTitle: document.getElementById("appChatLimitTitle"),
        appChatLimitSub: document.getElementById("appChatLimitSub"),
        appChatComposer: document.getElementById("appChatComposer"),
        appChatInput: document.getElementById("appChatInput"),
        appChatSendBtn: document.getElementById("appChatSendBtn"),
        appSettingsPage: document.getElementById("appSettingsPage"),

        // auth
        authBootIcon: document.getElementById("authBootIcon"),
        authBootSplash: document.getElementById("authBootSplash"),
        authGate: document.getElementById("authGate"),
        authGuestBadge: document.getElementById("authGuestBadge"),
        authWelcomePanel: document.getElementById("authWelcomePanel"),
        authSegRegisterBtn: document.getElementById("authSegRegisterBtn"),
        authSegLoginBtn: document.getElementById("authSegLoginBtn"),
        authSegRegisterBtn2: document.getElementById("authSegRegisterBtn2"),
        authSegLoginBtn2: document.getElementById("authSegLoginBtn2"),
        authOpenRegisterBtn: document.getElementById("authOpenRegisterBtn"),
        authOpenLoginBtn: document.getElementById("authOpenLoginBtn"),
        authOpenGuestConfirmBtn: document.getElementById("authOpenGuestConfirmBtn"),
        authRegisterGrade: document.getElementById("authRegisterGrade"),
        authRegisterNickname: document.getElementById("authRegisterNickname"),
        authRegisterPassword: document.getElementById("authRegisterPassword"),
        authRegisterBackBtn: document.getElementById("authRegisterBackBtn"),
        authRegisterNextBtn: document.getElementById("authRegisterNextBtn"),
        authRegisterConfirmPanel: document.getElementById("authRegisterConfirmPanel"),
        authRegisterConfirmGrade: document.getElementById("authRegisterConfirmGrade"),
        authRegisterConfirmNickname: document.getElementById("authRegisterConfirmNickname"),
        authRegisterConfirmPassword: document.getElementById("authRegisterConfirmPassword"),
        authRegisterConfirmBackBtn: document.getElementById("authRegisterConfirmBackBtn"),
        authRegisterConfirmNextBtn: document.getElementById("authRegisterConfirmNextBtn"),
        authLoginGrade: document.getElementById("authLoginGrade"),
        authLoginNickname: document.getElementById("authLoginNickname"),
        authLoginPassword: document.getElementById("authLoginPassword"),
        authLoginBackBtn: document.getElementById("authLoginBackBtn"),
        authLoginSubmitBtn: document.getElementById("authLoginSubmitBtn"),
        authProfilePanel: document.getElementById("authProfilePanel"),
        authProfileStudyTime: document.getElementById("authProfileStudyTime"),
        authProfileSubjects: document.getElementById("authProfileSubjects"),
        authProfileLike: document.getElementById("authProfileLike"),
        authProfileLikeGoodBtn: document.getElementById("authProfileLikeGoodBtn"),
        authProfileLikeHardBtn: document.getElementById("authProfileLikeHardBtn"),
        authProfileBackBtn: document.getElementById("authProfileBackBtn"),
        authProfileSkipBtn: document.getElementById("authProfileSkipBtn"),
        authProfileNextBtn: document.getElementById("authProfileNextBtn"),
        authGuestBackBtn: document.getElementById("authGuestBackBtn"),
        authGuestAcknowledge: document.getElementById("authGuestAcknowledge"),
        authGuestConfirmBtn: document.getElementById("authGuestConfirmBtn"),
        authTosScroll: document.getElementById("authTosScroll"),
        authTosHint: document.getElementById("authTosHint"),
        authTosAgree1: document.getElementById("authTosAgree1"),
        authTosAgree2: document.getElementById("authTosAgree2"),
        authTosBackBtn: document.getElementById("authTosBackBtn"),
        authTosSubmitBtn: document.getElementById("authTosSubmitBtn"),
        authEntryStatus: document.getElementById("authEntryStatus"),
        authRegisterStatus: document.getElementById("authRegisterStatus"),
        authRegisterConfirmStatus: document.getElementById("authRegisterConfirmStatus"),
        authLoginStatus: document.getElementById("authLoginStatus"),
        authProfileStatus: document.getElementById("authProfileStatus"),
        authGuestStatus: document.getElementById("authGuestStatus"),
        authTosStatus: document.getElementById("authTosStatus"),
        authGlobalStatus: document.getElementById("authGlobalStatus"),
        globalLoadingIcon: document.getElementById("globalLoadingIcon"),
        maintenanceOverlay: document.getElementById("maintenanceOverlay"),
        maintenanceTitle: document.getElementById("maintenanceTitle"),
        maintenanceMessage: document.getElementById("maintenanceMessage"),
        maintenancePeriod: document.getElementById("maintenancePeriod"),
        maintenanceRemaining: document.getElementById("maintenanceRemaining"),
        maintenanceStatus: document.getElementById("maintenanceStatus"),
        maintenanceReloadBtn: document.getElementById("maintenanceReloadBtn"),
        maintenanceBypassBtn: document.getElementById("maintenanceBypassBtn"),
        maintenanceAdminLoginBtn: document.getElementById("maintenanceAdminLoginBtn")
	      };

      // =========================
      // Debug summary UI
      // =========================
      function formatList(ids, max = 14){
        if (!ids.length) return "";
        const head = ids.slice(0, max).join(", ");
        const tail = ids.length > max ? ` (+${ids.length - max})` : "";
        return head + tail;
      }

      function updateDataStatus(){
        const ok = (data.words.length === data.maxId) && data.missing.length === 0 && data.duplicates.length === 0 && data.parseErrors.length === 0;
        const parts = [];
        parts.push(ok ? `OK${data.words.length}/${data.maxId}` : `${data.words.length}/${data.maxId}`);
        if (data.missing.length) parts.push(`: ${formatList(data.missing)}`);
        if (data.duplicates.length) parts.push(`: ${formatList(data.duplicates)}`);
        if (data.parseErrors.length) parts.push(`: ${formatList(data.parseErrors)}`);
        if (data.addedRawCheck?.missingAddedRange?.length) parts.push(`: ${formatList(data.addedRawCheck.missingAddedRange)}`);
        if (data.addedRawCheck?.duplicates?.length) parts.push(`: ${formatList(data.addedRawCheck.duplicates)}`);
        if (data.addedRawCheck?.legacyCollisions?.length) parts.push(`1600: ${formatList(data.addedRawCheck.legacyCollisions)}`);
        el.dataStatusText.textContent = parts.join(" / ");
      }

      function updateDebugBar(){
        if (!state.settings.debug){
          el.debugBar.textContent = "";
          return;
        }
        const lines = [];
        if (data.missing.length) lines.push(`: ${formatList(data.missing)}`);
        if (data.duplicates.length) lines.push(`: ${formatList(data.duplicates)}`);
        if (data.parseErrors.length) lines.push(`: ${formatList(data.parseErrors)}`);
        if (data.addedRawCheck?.missingAddedRange?.length) lines.push(`: ${formatList(data.addedRawCheck.missingAddedRange)}`);
        if (data.addedRawCheck?.duplicates?.length) lines.push(`: ${formatList(data.addedRawCheck.duplicates)}`);
        if (data.addedRawCheck?.legacyCollisions?.length) lines.push(`1600: ${formatList(data.addedRawCheck.legacyCollisions)}`);

        if (!lines.length){
          el.debugBar.textContent = "";
          return;
        }
        el.debugBar.innerHTML = `<strong>Data check</strong>  ${lines.join(" / ")}`;
      }

      // =========================
      // Deck
      // =========================
      function deckLabel(deckKey){
        if (deckKey === "A") return "0200";
        if (deckKey === "B") return "200400";
        if (deckKey === "C") return "400600";
        if (deckKey === "D") return "600800";
        if (deckKey === "E") return "80010008011000";
        return "ALL";
      }

      function getDeckWords(deckKey){
        if (deckKey === "A") return data.words.filter(w => w.id >= 1 && w.id <= 200);
        if (deckKey === "B") return data.words.filter(w => w.id >= 201 && w.id <= 400);
        if (deckKey === "C") return data.words.filter(w => w.id >= 401 && w.id <= 600);
        if (deckKey === "D") return data.words.filter(w => w.id >= 601 && w.id <= 800);
        if (deckKey === "E") return data.words.filter(w => w.id >= 801 && w.id <= 1000);
        return data.words.slice();
      }

      function deckSize(deckKey){
        return getDeckWords(deckKey).length;
      }

      // =========================
      // Mode labels
      // =========================
      
      function modeLabel(){
        const qCount = Number(state?.settings?.questionCount || 100);
        const qLabel = [10,20,50,100].includes(qCount) ? qCount : 100;
        switch (state.mode){
          case "SEQ": return "";
          case "RND": return "1";
          case "CHOICE": return `4${qLabel}`;
          case "HAND": return `${qLabel}`;
          case "REVIEW_WRONG": return "";
          default: return "";
        }
      }
      function _activeSubjectId(){
        const p = getPresetById(getActivePresetId());
        return _resolveSubjectId(p?.subjectId, { fallback: "sub:english", allowMissingCustom: true });
      }
      function _entrySubjectId(entry){
        const sid = String(entry?.subjectId || "").trim();
        if (sid) return _resolveSubjectId(sid, { fallback: "sub:english", allowMissingCustom: true });
        return _activeSubjectId();
      }
      function _entryFormats(entry){
        const sid = _entrySubjectId(entry);
        if (_isEnglishSubjectId(sid)){
          return { front: "text", back: "text", subjectId: sid };
        }
        const allowLatex = _isMathSubjectId(sid);
        return {
          front: _normalizeFormatMode(entry?.frontFormat, allowLatex),
          back: _normalizeFormatMode(entry?.backFormat, allowLatex),
          subjectId: sid
        };
      }
      function _renderFieldWithFormat(node, text, format, opts = {}){
        if (!node) return;
        const value = String(text ?? "");
        const fmt = String(format || "text").toLowerCase();
        if (fmt === "latex" && value){
          const holder = document.createElement("span");
          holder.className = "math-rendered";
          try{
            if (window.katex && typeof window.katex.render === "function"){
              window.katex.render(value, holder, {
                throwOnError: false,
                strict: "ignore",
                displayMode: !!opts.displayMode
              });
            } else {
              holder.textContent = value;
            }
          }catch{
            holder.textContent = value;
          }
          node.replaceChildren(holder);
          return;
        }
        node.textContent = value;
      }

      function dirLabel(){
        const sid = _activeSubjectId();
        if (!_isEnglishSubjectId(sid)){
          if (state.mode === "HAND") return "  ";
          if (state.mode === "CHOICE") return "  4";
          return "  ";
        }
        if (state.mode === "HAND") return "  ";
        if (state.mode === "CHOICE") return "  4";
        return state.settings.direction === "EN_JA" ? "  " : "  ";
      }
// =========================
      // View + render helpers
      // =========================
      function setView(next){
        state.view = next;

        if (el.viewStart) el.viewStart.classList.toggle("active", next === "START");
        el.viewTitle.classList.toggle("active", next === "TITLE");
        el.viewQuiz.classList.toggle("active", next === "QUIZ");
        el.viewResult.classList.toggle("active", next === "RESULT");

        const tabsVisible = (next === "TITLE");
        document.body.classList.toggle("app-tabs-visible", tabsVisible);
        if (!tabsVisible){
          document.body.dataset.appTab = "home";
          _appSetTopTitleByTab("home");
        } else if (!document.body.dataset.appTab){
          document.body.dataset.appTab = "home";
        }

        el.backBtn.disabled = (next === "START" || next === "TITLE");

        // keep BGM synced to view (quiz only)
        syncBgmToView();
      }

      function animateCardSwap(fnRender){
        if (!state.settings.animations){
          fnRender();
          return;
        }
        el.card.classList.add("fade-out");
        window.setTimeout(() => {
          fnRender();
          el.card.classList.remove("fade-out");
        }, 140);
      }

      function getCurrent(){
        if (!state.order.length) return null;
        return state.order[state.index] || null;
      }

      // =========================
      // Build order
      // =========================
      const EXAM_SET_KEY = () => `${EXAM_SET_KEY_PREFIX}:${state.deck}`;
      function getSavedPracticeQuestionCount(){
        const n = Number(state?.settings?.questionCount);
        return SETTINGS_QUESTION_COUNTS.has(n) ? n : defaultSettings.questionCount;
      }
      function getPracticeQuestionCount(){
        const startCount = Number(state?.startModeQuestionCount);
        if (START_MODE_QUESTION_COUNT_SET.has(startCount)) return startCount;
        return getSavedPracticeQuestionCount();
      }
      function getChoiceDefaultTimeLimitSec(){
        const n = Number(state?.settings?.choiceTimeLimitSec);
        return SETTINGS_EXAM_TIMES.has(n) ? n : defaultSettings.choiceTimeLimitSec;
      }
      function isAutoNextEnabled(){
        return state?.settings?.autoNext !== false;
      }

      function sampleIdsUnique(ids, n){
        return shuffle(ids).slice(0, Math.min(n, ids.length));
      }

      function loadExamSetIds(deckKey){
        try{
          const raw = window.localStorage.getItem(`${EXAM_SET_KEY_PREFIX}:${deckKey}`);
          if (!raw) return null;
          const obj = JSON.parse(raw);
          if (!obj || !Array.isArray(obj.ids)) return null;
          const ids = obj.ids.map(Number).filter(n => Number.isFinite(n));
          return ids.length ? ids : null;
        } catch {
          return null;
        }
      }

      function saveExamSetIds(deckKey, ids){
        const payload = { ids: ids.slice(), createdAt: Date.now() };
        window.localStorage.setItem(`${EXAM_SET_KEY_PREFIX}:${deckKey}`, JSON.stringify(payload));
      }

      function createExamSetIds(deckKey, forceNew = false){
        const scopedIdsRaw = Array.isArray(state._recommendScopeIds) ? state._recommendScopeIds : null;
        const scopedSet = (scopedIdsRaw && scopedIdsRaw.length)
          ? new Set(scopedIdsRaw.map(Number).filter(n => Number.isFinite(n)))
          : null;
        const deck = (scopedSet && scopedSet.size)
          ? data.words.filter(w => scopedSet.has(Number(w.id)))
          : getDeckWords(deckKey);
        const baseIds = deck.map(w => w.id);
        const want = Math.min(getPracticeQuestionCount(), baseIds.length);
        if (scopedSet && scopedSet.size){
          return sampleIdsUnique(baseIds, want);
        }
        const existing = loadExamSetIds(deckKey);
        if (!forceNew && existing && existing.length){
          const set = existing.filter(id => baseIds.includes(id));
          if (set.length >= want) return set.slice(0, want);
        }
        const ids = sampleIdsUnique(baseIds, want);
        saveExamSetIds(deckKey, ids);
        return ids;
      }

      
      const CHOICE_SET_KEY_PREFIX = "wordPractice400.choiceSet.v1";

      function loadChoiceSetIds(deckKey){
        try{
          const raw = window.localStorage.getItem(`${CHOICE_SET_KEY_PREFIX}:${deckKey}`);
          if (!raw) return null;
          const obj = JSON.parse(raw);
          if (!obj || !Array.isArray(obj.ids)) return null;
          const ids = obj.ids.map(Number).filter(n => Number.isFinite(n));
          return ids.length ? ids : null;
        } catch {
          return null;
        }
      }

      function saveChoiceSetIds(deckKey, ids){
        const payload = { ids: ids.slice(), createdAt: Date.now() };
        window.localStorage.setItem(`${CHOICE_SET_KEY_PREFIX}:${deckKey}`, JSON.stringify(payload));
      }

      function createChoiceSetIds(deckKey, forceNew = false){
        const scopedIdsRaw = Array.isArray(state._recommendScopeIds) ? state._recommendScopeIds : null;
        const scopedSet = (scopedIdsRaw && scopedIdsRaw.length)
          ? new Set(scopedIdsRaw.map(Number).filter(n => Number.isFinite(n)))
          : null;
        const deck = (scopedSet && scopedSet.size)
          ? data.words.filter(w => scopedSet.has(Number(w.id)))
          : getDeckWords(deckKey);
        const baseIds = deck.map(w => w.id);
        const want = Math.min(getPracticeQuestionCount(), baseIds.length);
        if (scopedSet && scopedSet.size){
          return sampleIdsUnique(baseIds, want);
        }
        const existing = loadChoiceSetIds(deckKey);
        if (!forceNew && existing && existing.length){
          const set = existing.filter(id => baseIds.includes(id));
          if (set.length >= want) return set.slice(0, want);
        }
        const ids = sampleIdsUnique(baseIds, want);
        saveChoiceSetIds(deckKey, ids);
        return ids;
      }

      function buildOrder(mode){
        const base = getDeckWords(state.deck);

        if (mode === "SEQ") return base.slice();
        if (mode === "RND") return shuffle(base);

        if (mode === "HAND"){
          const key = getSetKey(state.deck);
          const ids = createExamSetIds(key, false);
          const scopedIdsRaw = Array.isArray(state._recommendScopeIds) ? state._recommendScopeIds : null;
          const scopedSet = (scopedIdsRaw && scopedIdsRaw.length)
            ? new Set(scopedIdsRaw.map(Number).filter(n => Number.isFinite(n)))
            : null;
          const globalMap = (data && data.byId instanceof Map) ? data.byId : new Map();
          const activeMap = buildActiveById();
          const out = [];
          for (const id of ids){
            const w = (scopedSet && scopedSet.size)
              ? (globalMap.get(id) || activeMap.get(id))
              : activeMap.get(id);
            if (w) out.push(w);
          }
          return out;
        }

        if (mode === "CHOICE"){
          const key = getSetKey(state.deck);
          const ids = createChoiceSetIds(key, false);
          const scopedIdsRaw = Array.isArray(state._recommendScopeIds) ? state._recommendScopeIds : null;
          const scopedSet = (scopedIdsRaw && scopedIdsRaw.length)
            ? new Set(scopedIdsRaw.map(Number).filter(n => Number.isFinite(n)))
            : null;
          const globalMap = (data && data.byId instanceof Map) ? data.byId : new Map();
          const activeMap = buildActiveById();
          const out = [];
          for (const id of ids){
            const w = (scopedSet && scopedSet.size)
              ? (globalMap.get(id) || activeMap.get(id))
              : activeMap.get(id);
            if (w) out.push(w);
          }
          return out;
        }

        if (mode === "REVIEW_WRONG"){
          return state.wrongOrder.slice();
        }

        return base.slice();
      }
// =========================
      // Prompt/Answer
      // =========================
      function displayPromptAnswer(wordObj){
        const fm = _entryFormats(wordObj);
        const isEnglish = _isEnglishSubjectId(fm.subjectId);
        if (!isEnglish){
          return {
            prompt: String(wordObj?.word ?? ""),
            answer: String(wordObj?.meaning ?? ""),
            promptFormat: fm.front,
            answerFormat: fm.back
          };
        }
        if (state.mode === "HAND"){
          return { prompt: wordObj.meaning, answer: wordObj.word, promptFormat: "text", answerFormat: "text" };
        }
        const isEnJa = state.settings.direction === "EN_JA";
        return {
          prompt: isEnJa ? wordObj.word : wordObj.meaning,
          answer: isEnJa ? wordObj.meaning : wordObj.word,
          promptFormat: "text",
          answerFormat: "text"
        };
      }
      function _renderPromptDiagram(entry){
        if (!el.promptDiagramWrap || !el.promptDiagramImg){
          return;
        }
        const sid = _entrySubjectId(entry);
        const diagram = _normalizeCardDiagram(entry?.diagram);
        if (!_isMathSubjectId(sid) || !diagram || !diagram.dataUrl){
          el.promptDiagramWrap.classList.add("hidden");
          el.promptDiagramImg.removeAttribute("src");
          return;
        }
        el.promptDiagramImg.src = diagram.dataUrl;
        el.promptDiagramWrap.classList.remove("hidden");
      }

      
      // =========================
      // Choice exam (4) helpers
      // =========================
      function resetChoiceSession(timeLimitSec){
        state.choice.timeLimitSec = Number(timeLimitSec) || 0;
        state.choice.remainingMs = 0;
        state.choice.timerId = null;
        state.choice.endAt = 0;
        state.choice.locked = false;
        state.choice.options = [];
        state.choice.correctIndex = -1;
        state.choice.lastCorrectIndex = -1;
        state.choice.correctCount = 0;
        state.choice.results = [];
      }

      function clearChoiceTimer(){
        if (state.choice.timerId){
          clearInterval(state.choice.timerId);
          state.choice.timerId = null;
        }
        state.choice.endAt = 0;
        state.choice.remainingMs = 0;
      }

      function setTimerPill(sec){
        if (!el.timerPill) return;
        if (!sec || sec <= 0){
          el.timerPill.classList.add("hidden");
          el.timerPill.textContent = "";
          return;
        }
        el.timerPill.classList.remove("hidden");
        el.timerPill.textContent = ` ${sec} `;
      }

      function startChoiceTimer(){
        clearChoiceTimer();
        const limit = state.choice.timeLimitSec || 0;
        if (!limit || limit <= 0){
          setTimerPill(0);
          return;
        }
        const now = Date.now();
        state.choice.endAt = now + (limit * 1000);
        state.choice.remainingMs = limit * 1000;
        setTimerPill(limit);

        state.choice.timerId = setInterval(() => {
          const ms = Math.max(0, state.choice.endAt - Date.now());
          state.choice.remainingMs = ms;
          const sec = Math.ceil(ms / 1000);
          setTimerPill(sec);

          if (ms <= 0){
            clearChoiceTimer();
            if (!state.choice.locked && state.view === "QUIZ" && state.mode === "CHOICE"){
              handleChoiceTimeout();
            }
          }
        }, 80);
      }

      function pickDummyMeanings(curId, correctMeaning, count){
        const deckPool = getDeckWords(state.deck)
          .filter(w => w.id !== curId && w.meaning && w.meaning !== correctMeaning)
          .map(w => w.meaning);

        // Fallback pool: always allow enough choices even for small custom presets.
        const sid = _activeSubjectId();
        const globalPool = _isEnglishSubjectId(sid)
          ? data.words
              .filter(w => w.id !== curId && w.meaning && w.meaning !== correctMeaning)
              .map(w => w.meaning)
          : getActiveWords()
              .filter(w => w.id !== curId && w.meaning && w.meaning !== correctMeaning)
              .map(w => w.meaning);

        const pool = deckPool.concat(globalPool);

        const dummies = [];
        const seen = new Set([correctMeaning]);

        for (const m of shuffle(pool)){
          if (seen.has(m)) continue;
          seen.add(m);
          dummies.push(m);
          if (dummies.length >= count) break;
        }
        return dummies;
      }


function shuffleWithNoConsecutiveSameCorrect(options, correctMeaning){
        let tries = 0;
        let out = options.slice();
        let correctIndex = -1;
        while (tries < 10){
          out = shuffle(out);
          correctIndex = out.indexOf(correctMeaning);
          if (correctIndex !== state.choice.lastCorrectIndex) break;
          tries++;
        }
        if (correctIndex === state.choice.lastCorrectIndex && out.length > 1){
          // rotate once to avoid consecutive same
          out = out.slice(1).concat(out.slice(0,1));
          correctIndex = out.indexOf(correctMeaning);
        }
        return { out, correctIndex };
      }

      function buildChoiceOptionsForCurrent(){
        const cur = getCurrent();
        if (!cur) return;
        const correctMeaning = cur.meaning; // MUST be exact string

        // Base choices:
        // - If cur has custom MCQ config (user preset), use it (up to 4).
        // - Otherwise, generate from deck meanings (3 dummies).
        let base = null;

        if (cur.mcq && Array.isArray(cur.mcq.choices) && cur.mcq.choices.length){
          const raw = cur.mcq.choices.slice(0,4).map(v => String(v ?? "").trim()).filter(Boolean);
          const seen = new Set();
          const cleaned = [];
          for (const s of raw){
            if (seen.has(s)) continue;
            seen.add(s);
            cleaned.push(s);
          }
          if (cleaned.length){
            // Ensure exact correct meaning is included (strict)
            if (!cleaned.includes(correctMeaning)){
              const idx = Number(cur.mcq.correctIndex);
              if (Number.isInteger(idx) && idx >= 0 && idx < cleaned.length){
                cleaned[idx] = correctMeaning;
              } else if (cleaned.length < 4){
                cleaned.unshift(correctMeaning);
              } else {
                cleaned[0] = correctMeaning;
              }
            }
            base = cleaned;
          }
        }

        if (!base){
          base = [correctMeaning, ...pickDummyMeanings(cur.id, correctMeaning, 3)];
        }

        // Fill to 4 (avoid duplicates)
        const deckPool = getDeckWords(state.deck)
          .filter(w => w.id !== cur.id && w.meaning && w.meaning !== correctMeaning)
          .map(w => w.meaning);

        const sid = _activeSubjectId();
        const globalPool = _isEnglishSubjectId(sid)
          ? data.words
              .filter(w => w.id !== cur.id && w.meaning && w.meaning !== correctMeaning)
              .map(w => w.meaning)
          : getActiveWords()
              .filter(w => w.id !== cur.id && w.meaning && w.meaning !== correctMeaning)
              .map(w => w.meaning);

        const pool = deckPool.concat(globalPool);

        const uniq = [];
        const seen = new Set();
        for (const s of base){
          const k = String(s ?? "").trim();
          if (!k) continue;
          if (seen.has(k)) continue;
          seen.add(k);
          uniq.push(k);
        }
        base = uniq;

        for (const m of shuffle(pool)){
          if (base.length >= 4) break;
          if (seen.has(m)) continue;
          seen.add(m);
          base.push(m);
        }

        // Safety: ensure correct meaning present
        if (!base.includes(correctMeaning)){
          if (base.length) base[0] = correctMeaning;
          else base = [correctMeaning];
        }

        if (base.length > 4){
          base = base.slice(0,4);
          if (!base.includes(correctMeaning)){
            base[base.length - 1] = correctMeaning;
          }
        }

        if (base.length < 4){
          // Fallback to default generation
          const dummies = pickDummyMeanings(cur.id, correctMeaning, 3);
          base = [correctMeaning, ...dummies];
        }

        const { out, correctIndex } = shuffleWithNoConsecutiveSameCorrect(base, correctMeaning);
        state.choice.options = out;
        state.choice.correctIndex = correctIndex;
        state.choice.locked = false;
      }

function renderChoiceOptions(){
        if (!el.choices) return;
        const options = state.choice.options || [];
        const labels = ["A", "B", "C", "D"];
        const cur = getCurrent();
        const fm = _entryFormats(cur);
        const optionFormat = _isEnglishSubjectId(fm.subjectId) ? "text" : fm.back;

        el.choices.innerHTML = "";
        for (let i = 0; i < options.length; i++){
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "choice-btn";
          btn.dataset.idx = String(i);
          const key = document.createElement("span");
          key.className = "k";
          key.textContent = labels[i] || String(i + 1);
          btn.appendChild(key);
          const txt = document.createElement("span");
          txt.style.flex = "1";
          txt.style.minWidth = "0";
          _renderFieldWithFormat(txt, options[i], optionFormat, { displayMode: false });
          btn.appendChild(txt);
          el.choices.appendChild(btn);
        }
      }

      function lockChoiceButtons(){
        const btns = el.choices ? el.choices.querySelectorAll("button.choice-btn") : [];
        btns.forEach(b => b.disabled = true);
      }

      function markChoiceButtons(selectedIndex, correctIndex){
        const btns = el.choices ? el.choices.querySelectorAll("button.choice-btn") : [];
        btns.forEach((b) => {
          const i = Number(b.dataset.idx);
          b.classList.remove("correct","wrong");
          if (i === correctIndex) b.classList.add("correct");
          if (selectedIndex !== null && i === selectedIndex && selectedIndex !== correctIndex) b.classList.add("wrong");
        });
      }

      function pushChoiceResult(cur, selectedIndex, timedOut){
        const correctMeaning = cur.meaning;
        const chosen = (selectedIndex === null) ? "" : (state.choice.options[selectedIndex] || "");
        const correct = (!timedOut) ? (selectedIndex === state.choice.correctIndex) : false;

        state.choice.results.push({
          id: cur.id,
          word: cur.word,
          correctMeaning: correctMeaning,
          chosenMeaning: timedOut ? "(TIMEOUT)" : (chosen || "(NO SELECT)"),
          correct: correct,
          timedOut: !!timedOut
        });

        if (correct) state.choice.correctCount += 1;
        return correct;
      }

      function scheduleChoiceNext(){
        const delay = 720; // 0.60.8 sec
        window.setTimeout(() => {
          if (state.mode !== "CHOICE" || state.view !== "QUIZ") return;

          if (state.index >= state.order.length - 1){
            goResult("CHOICE");
            return;
          }

          state.index += 1;
          state.showAnswer = false;
          state.done = false;

          // Prepare next question (prompt/options)
          buildChoiceOptionsForCurrent();

          // Render next question with a small fade
          animateCardSwap(() => {
            renderAll();
            startChoiceTimer();
          });
        }, delay);
      }

      function renderChoiceHeaderExtras(){
        // show/hide timer pill based on timeLimit and question state
        if (state.mode !== "CHOICE"){
          setTimerPill(0);
          return;
        }
        const limit = state.choice.timeLimitSec || 0;
        if (!limit || limit <= 0){
          setTimerPill(0);
        } else {
          const ms = state.choice.remainingMs || (limit * 1000);
          const sec = Math.ceil(ms / 1000);
          setTimerPill(sec);
        }
      }

      function handleChoiceSelect(selectedIndex){
        const cur = getCurrent();
        if (!cur) return;
        if (state.mode !== "CHOICE") return;
        if (state.choice.locked) return;

        state.choice.locked = true;
        clearChoiceTimer();
        lockChoiceButtons();

        const isCorrect = pushChoiceResult(cur, selectedIndex, false);

        markChoiceButtons(selectedIndex, state.choice.correctIndex);
        showMark(isCorrect);
        playSfx(isCorrect ? "ok" : "ng");

        // show correct meaning briefly
        el.answerWrap.classList.remove("hidden");
        const fm = _entryFormats(cur);
        _renderFieldWithFormat(el.answerText, cur.meaning, _isEnglishSubjectId(fm.subjectId) ? "text" : fm.back, { displayMode: true });

        if (isAutoNextEnabled()){
          scheduleChoiceNext();
        }else{
          el.nextBtn.classList.remove("hidden");
          el.nextBtn.textContent = (state.index >= state.order.length - 1) ? "" : "";
        }
        renderHeaderOnly();
      }

      function handleChoiceTimeout(){
        const cur = getCurrent();
        if (!cur) return;
        if (state.mode !== "CHOICE") return;
        if (state.choice.locked) return;

        state.choice.locked = true;
        clearChoiceTimer();
        lockChoiceButtons();

        pushChoiceResult(cur, null, true);
        markChoiceButtons(null, state.choice.correctIndex);
        showMark(false);
        playSfx("ng");

        // show correct meaning briefly
        el.answerWrap.classList.remove("hidden");
        const fm = _entryFormats(cur);
        _renderFieldWithFormat(el.answerText, cur.meaning, _isEnglishSubjectId(fm.subjectId) ? "text" : fm.back, { displayMode: true });

        if (isAutoNextEnabled()){
          scheduleChoiceNext();
        }else{
          el.nextBtn.classList.remove("hidden");
          el.nextBtn.textContent = (state.index >= state.order.length - 1) ? "" : "";
        }
        renderHeaderOnly();
      }

      function openTimeSelect(){
        if (!el.timeOverlay) return;
        el.timeOverlay.classList.remove("hidden");
      }

      function closeTimeSelect(){
        if (!el.timeOverlay) return;
        el.timeOverlay.classList.add("hidden");
      }
// =========================
      // Handwriting helpers
      // =========================
      let canvasCtx = null;
      let drawing = false;

      function ensureCanvasReady(){
        if (!el.handCanvas) return;
        if (!canvasCtx){
          canvasCtx = el.handCanvas.getContext("2d", { alpha: false });
        }
        resizeCanvasToCSS();
        primeCanvasStyle();
      }

      function primeCanvasStyle(){
        if (!canvasCtx) return;
        canvasCtx.lineCap = "round";
        canvasCtx.lineJoin = "round";
        canvasCtx.strokeStyle = "#111214";
        canvasCtx.lineWidth = 3.2;
      }

      function resizeCanvasToCSS(){
        if (!el.handCanvas || !canvasCtx) return;
        const rect = el.handCanvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;

        const w = Math.max(1, Math.round(rect.width * dpr));
        const h = Math.max(1, Math.round(rect.height * dpr));

        if (el.handCanvas.width !== w || el.handCanvas.height !== h){
          el.handCanvas.width = w;
          el.handCanvas.height = h;
          canvasCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
          clearCanvas();
          primeCanvasStyle();
        }
      }

      function clearCanvas(){
        if (!canvasCtx || !el.handCanvas) return;
        canvasCtx.save();
        canvasCtx.setTransform(1,0,0,1,0,0);
        canvasCtx.fillStyle = "#ffffff";
        canvasCtx.fillRect(0,0, el.handCanvas.width, el.handCanvas.height);
        canvasCtx.restore();
        primeCanvasStyle();
      }

      function canvasPointFromEvent(e){
        const r = el.handCanvas.getBoundingClientRect();
        return { x: e.clientX - r.left, y: e.clientY - r.top };
      }

      function bindCanvasEvents(){
        if (!el.handCanvas) return;

        el.handCanvas.addEventListener("pointerdown", (e) => {
          if (state.mode !== "HAND") return;
          ensureCanvasReady();
          drawing = true;
          el.handCanvas.setPointerCapture(e.pointerId);
          const p = canvasPointFromEvent(e);
          canvasCtx.beginPath();
          canvasCtx.moveTo(p.x, p.y);
        });

        el.handCanvas.addEventListener("pointermove", (e) => {
          if (state.mode !== "HAND") return;
          if (!drawing) return;
          const p = canvasPointFromEvent(e);
          canvasCtx.lineTo(p.x, p.y);
          canvasCtx.stroke();
        });

        const end = () => { drawing = false; };
        el.handCanvas.addEventListener("pointerup", end);
        el.handCanvas.addEventListener("pointercancel", end);
        el.handCanvas.addEventListener("pointerleave", end);

        window.addEventListener("resize", () => {
          if (state.mode === "HAND"){
            ensureCanvasReady();
          }
        });
      }

      function normalizeCompare(s){
        return String(s || "")
          .toLowerCase()
          .trim()
          .replace(/\s+/g, " ");
      }

      function normalizeNoSpace(s){
        return normalizeCompare(s).replace(/\s+/g, "");
      }

      function computeCorrect(expected, given){
        const a = normalizeCompare(expected);
        const b = normalizeCompare(given);
        if (!a || !b) return false;
        if (a === b) return true;
        // allow ignoring spaces (helps recognition for phrases)
        return normalizeNoSpace(a) === normalizeNoSpace(b);
      }

      function resetHandPerQuestion(){
        state.hand.checked = false;
        state.hand.correct = null;
        state.hand.input = "";
        state.hand.busy = false;

        el.spellInput.value = "";
        el.spellInput.disabled = false;

        // judge badge
        el.judgeBadge.classList.add("hidden");
        el.judgeBadge.classList.remove("ok","ng");
        el.judgeBadge.textContent = "";

        // answer area
        el.yourText.textContent = "";

        // marks
        hideMark();

        // buttons
        el.primaryBtn.disabled = false;
        el.primaryBtn.textContent = "";

        ensureCanvasReady();
        clearCanvas();
      }

      function escapeHtml(s){
        return String(s ?? "")
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;");
      }

      // =========================
      // OCR (TextDetector) with preprocessing
      // =========================
      function hasTextDetector(){
        return ("TextDetector" in window);
      }

      function cleanOCRText(raw){
        // keep letters and spaces; normalize spaces
        return String(raw || "")
          .replace(/[^A-Za-z\s]/g, " ")
          .replace(/\s+/g, " ")
          .trim();
      }

      function levenshtein(a, b){
        a = normalizeNoSpace(a);
        b = normalizeNoSpace(b);
        const n = a.length;
        const m = b.length;
        if (n === 0) return m;
        if (m === 0) return n;
        const dp = new Array(m + 1);
        for (let j = 0; j <= m; j++) dp[j] = j;

        for (let i = 1; i <= n; i++){
          let prev = dp[0];
          dp[0] = i;
          for (let j = 1; j <= m; j++){
            const tmp = dp[j];
            const cost = a[i - 1] === b[j - 1] ? 0 : 1;
            dp[j] = Math.min(
              dp[j] + 1,
              dp[j - 1] + 1,
              prev + cost
            );
            prev = tmp;
          }
        }
        return dp[m];
      }

      function cropAndScaleForOCR(srcCanvas){
        const w = srcCanvas.width;
        const h = srcCanvas.height;

        const tmp = document.createElement("canvas");
        tmp.width = w;
        tmp.height = h;
        const tctx = tmp.getContext("2d", { alpha: false });
        tctx.drawImage(srcCanvas, 0, 0);

        const img = tctx.getImageData(0, 0, w, h);
        const d = img.data;

        let minX = w, minY = h, maxX = 0, maxY = 0;
        let found = false;

        const step = 2;
        const thr = 235;
        for (let y = 0; y < h; y += step){
          for (let x = 0; x < w; x += step){
            const i = (y * w + x) * 4;
            const r = d[i], g = d[i+1], b = d[i+2];
            const lum = 0.2126*r + 0.7152*g + 0.0722*b;
            if (lum < thr){
              found = true;
              if (x < minX) minX = x;
              if (y < minY) minY = y;
              if (x > maxX) maxX = x;
              if (y > maxY) maxY = y;
            }
          }
        }

        if (!found){
          return srcCanvas;
        }

        const pad = Math.round(Math.min(w, h) * 0.05) + 14;
        const sx = clamp(minX - pad, 0, w - 1);
        const sy = clamp(minY - pad, 0, h - 1);
        const ex = clamp(maxX + pad, 0, w - 1);
        const ey = clamp(maxY + pad, 0, h - 1);
        const sw = Math.max(1, ex - sx);
        const sh = Math.max(1, ey - sy);

        const scale = 2.0;
        const out = document.createElement("canvas");
        out.width = Math.max(1, Math.round(sw * scale));
        out.height = Math.max(1, Math.round(sh * scale));
        const octx = out.getContext("2d", { alpha: false });

        octx.fillStyle = "#ffffff";
        octx.fillRect(0,0,out.width,out.height);
        octx.imageSmoothingEnabled = true;
        octx.drawImage(srcCanvas, sx, sy, sw, sh, 0, 0, out.width, out.height);

        const oimg = octx.getImageData(0,0,out.width,out.height);
        const od = oimg.data;
        let sum = 0;
        const count = out.width * out.height;
        for (let i = 0; i < od.length; i += 4){
          const lum = 0.2126*od[i] + 0.7152*od[i+1] + 0.0722*od[i+2];
          sum += lum;
        }
        const avg = sum / count;
        const th2 = clamp(avg - 18, 175, 238);

        for (let i = 0; i < od.length; i += 4){
          const lum = 0.2126*od[i] + 0.7152*od[i+1] + 0.0722*od[i+2];
          const v = lum < th2 ? 0 : 255;
          od[i] = od[i+1] = od[i+2] = v;
          od[i+3] = 255;
        }
        octx.putImageData(oimg, 0, 0);

        return out;
      }

      async function detectTextFromCanvasProcessed(){
        if (!hasTextDetector()) return null;
        try{
          const detector = new TextDetector();
          const processed = cropAndScaleForOCR(el.handCanvas);
          const results = await detector.detect(processed);
          const raw = results.map(r => r.rawValue).join(" ").trim();
          return raw || null;
        } catch {
          return null;
        }
      }

      function pickBestCandidate(raw, expected){
        const cleaned = cleanOCRText(raw);
        if (!cleaned) return null;

        const candidates = new Set();
        candidates.add(cleaned);

        const tokens = cleaned.split(" ").filter(Boolean);
        if (tokens.length) {
          candidates.add(tokens.join(" "));
          candidates.add(tokens.join(""));
        }
        if (tokens.length >= 1){
          candidates.add(tokens[0]);
          candidates.add(tokens[tokens.length - 1]);
        }

        let best = null;
        let bestDist = Infinity;
        for (const c of candidates){
          const dist = levenshtein(expected, c);
          if (dist < bestDist){
            bestDist = dist;
            best = c;
          }
        }
        return best || cleaned;
      }

      async function readCanvasIntoInput(expected){
        const raw = await detectTextFromCanvasProcessed();
        if (!raw) return null;
        const best = pickBestCandidate(raw, expected);
        if (!best) return null;
        el.spellInput.value = best;
        return best;
      }

      // =========================
      // Marks (maru/batsu)
      // =========================
      function hideMark(){
        el.markLayer.classList.add("hidden");
        el.markLayer.classList.remove("show","ok","ng");
        el.svgOk.classList.add("hidden");
        el.svgNg.classList.add("hidden");
      }

      function showMark(isCorrect){
        el.markLayer.classList.remove("ok","ng");
        el.markLayer.classList.remove("show");
        el.markLayer.classList.remove("hidden");

        el.svgOk.classList.toggle("hidden", !isCorrect);
        el.svgNg.classList.toggle("hidden", isCorrect);

        void el.markLayer.offsetWidth;

        el.markLayer.classList.add(isCorrect ? "ok" : "ng");
        el.markLayer.classList.add("show");

        window.setTimeout(() => {
          el.markLayer.classList.remove("show");
          window.setTimeout(() => {
            el.markLayer.classList.add("hidden");
          }, 220);
        }, 900);
      }

      // =========================
      // Check (hand mode)
      // =========================
      async function checkHand(){
        const cur = getCurrent();
        if (!cur) return;
        if (state.hand.checked) return;
        if (state.hand.busy) return;

        state.hand.busy = true;
        el.primaryBtn.disabled = true;
        const fm = _entryFormats(cur);
        const isEnglish = _isEnglishSubjectId(fm.subjectId);
        const expected = isEnglish ? String(cur.word || "") : String(cur.meaning || "");

        // If input empty and detector exists, try OCR automatically
        let given = (el.spellInput.value || "").trim();
        if (!given && hasTextDetector()){
          el.primaryBtn.textContent = "";
          await readCanvasIntoInput(expected);
          given = (el.spellInput.value || "").trim();
        }
        const correct = computeCorrect(expected, given);

        // sound (SFX only, never loop)
        playSfx(correct ? "ok" : "ng");

        state.hand.checked = true;
        state.hand.correct = correct;
        state.hand.input = given;

        state.hand.results.push({
          id: cur.id,
          expected,
          given: given,
          correct: correct,
          promptMeaning: isEnglish ? cur.meaning : cur.word
        });

        if (correct) state.hand.scoreCorrect += 1;

        // UI
        el.spellInput.disabled = true;

        el.judgeBadge.classList.remove("hidden");
        el.judgeBadge.classList.toggle("ok", correct);
        el.judgeBadge.classList.toggle("ng", !correct);
        el.judgeBadge.textContent = correct ? "Correct" : "Wrong";

        showMark(correct);

        el.answerWrap.classList.remove("hidden");
        _renderFieldWithFormat(el.answerText, expected, isEnglish ? "text" : fm.back, { displayMode: true });
        el.yourText.textContent = given ? `${given}` : "";

        el.primaryBtn.textContent = "";
        el.primaryBtn.disabled = true;

        state.hand.busy = false;

        renderHeaderOnly();
        if (isAutoNextEnabled()){
          window.setTimeout(() => {
            if (state.view !== "QUIZ") return;
            if (state.mode !== "HAND") return;
            if (!state.hand.checked) return;
            next();
          }, 720);
        }
      }

      // =========================
      // Render
      // =========================
      
      function renderTitleHeader(){
        const d = state.deck;
        el.deckABtn.classList.toggle("active", d === "A");
        el.deckABtn.setAttribute("aria-selected", String(d === "A"));
        el.deckBBtn.classList.toggle("active", d === "B");
        el.deckBBtn.setAttribute("aria-selected", String(d === "B"));
        if (el.deckCBtn){
          el.deckCBtn.classList.toggle("active", d === "C");
          el.deckCBtn.setAttribute("aria-selected", String(d === "C"));
        }
        if (el.deckDBtn){
          el.deckDBtn.classList.toggle("active", d === "D");
          el.deckDBtn.setAttribute("aria-selected", String(d === "D"));
        }
        if (el.deckEBtn){
          el.deckEBtn.classList.toggle("active", d === "E");
          el.deckEBtn.setAttribute("aria-selected", String(d === "E"));
        }
        el.deckAllBtn.classList.toggle("active", d === "ALL");
        el.deckAllBtn.setAttribute("aria-selected", String(d === "ALL"));

        const sizeA = deckSize("A");
        const sizeB = deckSize("B");
        const sizeC = deckSize("C");
        const sizeD = deckSize("D");
        const sizeE = deckSize("E");
        const sizeAll = deckSize("ALL");
        el.deckStatus.textContent = `0200: ${sizeA} | 200400: ${sizeB} | 400600: ${sizeC} | 600800: ${sizeD} | 8001000: ${sizeE} | ALL: ${sizeAll}`;

        const curSize = deckSize(state.deck);
        const practiceCount = getPracticeQuestionCount();
        el.practiceHint.textContent = `${deckLabel(state.deck)}${curSize}`;

        el.badgeSeq.textContent = `${curSize}`;
        el.badgeRnd.textContent = `${curSize}`;
        el.badgeChoice.textContent = `${Math.min(practiceCount, curSize)}`;
        el.badgeHand.textContent = `${Math.min(practiceCount, curSize)}`;

        const can = curSize > 0;
        el.startSeqBtn.disabled = !can;
        el.startRndBtn.disabled = !can;
        el.startChoiceBtn.disabled = !can;
        el.startHandBtn.disabled = !can;
      
        syncPresetUI();
      }

      function renderHeaderOnly(){
        const total = state.order.length || 0;
        const qIndex = clamp(state.index + 1, 0, total);

        if (state.mode === "HAND"){
          const corr = state.hand.scoreCorrect;
          el.progressText.innerHTML = `<strong>${qIndex}</strong> / ${total} ${corr}`;
        } else if (state.mode === "CHOICE"){
          const corr = state.choice.correctCount;
          el.progressText.innerHTML = `<strong>${qIndex}</strong> / ${total} ${corr}`;
        } else {
          el.progressText.innerHTML = `<strong>${qIndex}</strong> / ${total}`;
        }

        el.modePill.textContent = `${deckLabel(state.deck)}  ${modeLabel()}`;
        el.dirLabel.textContent = dirLabel();

        if (state.mode !== "CHOICE") setTimerPill(0);
      }
function renderQuestion(){
        const cur = getCurrent();
        if (!cur){
          el.noText.textContent = "No.";
          el.promptText.textContent = "";
          _renderPromptDiagram(null);
          el.answerText.textContent = "";
          el.answerWrap.classList.add("hidden");
          el.spellWrap.classList.add("hidden");
          el.handWrap.classList.add("hidden");
          el.choiceWrap.classList.add("hidden");
          hideMark();
          setTimerPill(0);
          return;
        }

        renderHeaderOnly();
        el.noText.textContent = `No.${cur.id}`;

        const isHand = (state.mode === "HAND");
        const isChoice = (state.mode === "CHOICE");
        _renderPromptDiagram(cur);

        // prompt
        if (isChoice){
          const fm = _entryFormats(cur);
          _renderFieldWithFormat(el.promptText, cur.word, _isEnglishSubjectId(fm.subjectId) ? "text" : fm.front, { displayMode: true });
        } else {
          const { prompt, answer, promptFormat, answerFormat } = displayPromptAnswer(cur);
          _renderFieldWithFormat(el.promptText, prompt, promptFormat, { displayMode: true });
          _renderFieldWithFormat(el.answerText, answer, answerFormat, { displayMode: true });
        }

        // Prev only for SEQ/REVIEW_WRONG
        const allowPrev = (state.mode === "SEQ" || state.mode === "REVIEW_WRONG");
        el.prevBtn.classList.toggle("hidden", !allowPrev);
        el.prevBtn.disabled = !allowPrev || state.index === 0;

        // next button visibility
        const showChoiceManualNext = isChoice && !isAutoNextEnabled() && !!state.choice.locked;
        el.nextBtn.classList.toggle("hidden", isChoice && !showChoiceManualNext);
        el.nextBtn.disabled = false;

        // new set button: hand only
        el.newSetBtn.classList.toggle("hidden", !(state.mode === "HAND"));

        // primary button: hidden for choice
        el.primaryBtn.classList.toggle("hidden", isChoice);

        // Hand UI
        el.spellWrap.classList.toggle("hidden", !isHand);
        el.handWrap.classList.toggle("hidden", !isHand);

        // Choice UI
        el.choiceWrap.classList.toggle("hidden", !isChoice);

        if (isChoice){
          // setup options/timer per question if not ready
          if (!state.choice.options || state.choice.options.length !== 4){
            buildChoiceOptionsForCurrent();
          }
          renderChoiceOptions();
          renderChoiceHeaderExtras();

          // answer hidden until resolved
          el.answerWrap.classList.add("hidden");
          el.answerText.textContent = "";
          el.yourText.textContent = "";
          el.judgeBadge.classList.add("hidden");
          el.judgeBadge.classList.remove("ok","ng");
          el.judgeBadge.textContent = "";
          hideMark();

          // controls
          el.restartBtn.classList.remove("hidden");
        } else if (isHand){
          el.handMini.textContent = hasTextDetector() ? "" : "";
          el.readCanvasBtn.classList.toggle("hidden", !hasTextDetector());

          el.primaryBtn.textContent = state.hand.checked ? "" : (state.hand.busy ? "" : "");
          el.primaryBtn.disabled = state.hand.checked || state.hand.busy;

          if (!state.hand.checked){
            el.answerWrap.classList.add("hidden");
            hideMark();
          } else {
            el.answerWrap.classList.remove("hidden");
          }

          if (!state.hand.checked){
            el.judgeBadge.classList.add("hidden");
            el.judgeBadge.classList.remove("ok","ng");
            el.judgeBadge.textContent = "";
          }

          // timer off
          setTimerPill(0);

        } else {
          // Study modes
          setTimerPill(0);
          el.readCanvasBtn.classList.add("hidden");
          hideMark();

          el.primaryBtn.disabled = false;
          if (state.showAnswer){
            el.answerWrap.classList.remove("hidden");
            el.primaryBtn.textContent = "";
          } else {
            el.answerWrap.classList.add("hidden");
            el.primaryBtn.textContent = "";
          }

          el.judgeBadge.classList.add("hidden");
          el.judgeBadge.classList.remove("ok","ng");
          el.judgeBadge.textContent = "";
        }

        // next button text (non-choice)
        if (!isChoice){
          if (state.mode === "HAND"){
            el.nextBtn.textContent = (state.index >= state.order.length - 1) ? "" : "";
          } else if (state.done){
            el.nextBtn.textContent = "";
          } else {
            el.nextBtn.textContent = (state.index >= state.order.length - 1) ? "" : "";
          }
        } else if (showChoiceManualNext){
          el.nextBtn.textContent = (state.index >= state.order.length - 1) ? "" : "";
        }
      }

      function renderResult(){
        const kind = state.resultKind || state.mode || "HAND";
        const activeSid = _activeSubjectId();
        const isEnglish = _isEnglishSubjectId(activeSid);

        let total = 0;
        let correct = 0;
        let wrongItems = [];

        if (kind === "CHOICE"){
          total = state.choice.results.length;
          correct = state.choice.correctCount;
          wrongItems = state.choice.results.filter(r => !r.correct);
          const pct = total ? Math.round((correct / total) * 1000) / 10 : 0;

          el.resultSub.textContent = `${deckLabel(state.deck)}  ${total}`;
          el.scoreBig.textContent = `${correct} / ${total}`;
          el.scoreSub.textContent = ` ${pct}%`;

          el.wrongSummary.textContent = `${wrongItems.length}`;
          el.wrongList.innerHTML = "";

          if (wrongItems.length === 0){
            el.wrongList.innerHTML = `<li class="wrong-item"><div class="mid"></div></li>`;
            el.wrongDetails.open = false;
          } else {
            for (const r of wrongItems){
              const li = document.createElement("li");
              li.className = "wrong-item";
              li.innerHTML = `
                <div class="top"><span>No.${r.id}</span><span>${isEnglish ? "4" : "4"}</span></div>
                <div class="mid">
                  <div style="margin-bottom:6px;"><strong>${escapeHtml(r.word)}</strong></div>
                  <div><code>${escapeHtml((r.chosenMeaning || "").trim() || "")}</code></div>
                  <div><code>${escapeHtml(r.correctMeaning)}</code></div>
                </div>
              `;
              el.wrongList.appendChild(li);
            }
            el.wrongDetails.open = true;
          }

        } else {
          total = state.hand.results.length;
          correct = state.hand.scoreCorrect;
          wrongItems = state.hand.results.filter(r => !r.correct);
          const pct = total ? Math.round((correct / total) * 1000) / 10 : 0;

          el.resultSub.textContent = `${deckLabel(state.deck)}  ${total}`;
          el.scoreBig.textContent = `${correct} / ${total}`;
          el.scoreSub.textContent = ` ${pct}%`;

          el.wrongSummary.textContent = `${wrongItems.length}`;
          el.wrongList.innerHTML = "";

          if (wrongItems.length === 0){
            el.wrongList.innerHTML = `<li class="wrong-item"><div class="mid"></div></li>`;
            el.wrongDetails.open = false;
          } else {
            for (const r of wrongItems){
              const li = document.createElement("li");
              li.className = "wrong-item";
              li.innerHTML = `
                <div class="top"><span>No.${r.id}</span><span>${isEnglish ? "" : ""}</span></div>
                <div class="mid">
                  <div style="margin-bottom:6px; color: var(--muted);">${escapeHtml(r.promptMeaning)}</div>
                  <div><code>${escapeHtml((r.given || "").trim() || "")}</code></div>
                  <div><code>${escapeHtml(r.expected)}</code></div>
                </div>
              `;
              el.wrongList.appendChild(li);
            }
            el.wrongDetails.open = true;
          }
        }

        // Review button visibility (hide if no wrong)
        if (wrongItems.length === 0){
          el.resultReviewBtn.disabled = true;
          el.resultReviewBtn.style.opacity = "0.55";
        } else {
          el.resultReviewBtn.disabled = false;
          el.resultReviewBtn.style.opacity = "";
        }
      }
      function renderAll(){
        updateDataStatus();
        updateDebugBar();

        const isEnJa = state.settings.direction === "EN_JA";
        if (el.dirEnJaBtn){
          el.dirEnJaBtn.classList.toggle("active", isEnJa);
          el.dirEnJaBtn.setAttribute("aria-selected", String(isEnJa));
        }
        if (el.dirJaEnBtn){
          el.dirJaEnBtn.classList.toggle("active", !isEnJa);
          el.dirJaEnBtn.setAttribute("aria-selected", String(!isEnJa));
        }

        if (el.animToggle) el.animToggle.checked = state.settings.animations;
        if (el.sfxToggle) el.sfxToggle.checked = state.settings.sfx;
        if (el.bgmToggle) el.bgmToggle.checked = state.settings.bgm;
        // BGM volume buttons
        const bv = state.settings.bgmVolume || "DEFAULT";
        if (el.bgmVolLargeBtn){
          el.bgmVolLargeBtn.classList.toggle("active", bv === "LARGE");
          el.bgmVolLargeBtn.setAttribute("aria-selected", String(bv === "LARGE"));
        }
        if (el.bgmVolDefaultBtn){
          el.bgmVolDefaultBtn.classList.toggle("active", bv === "DEFAULT");
          el.bgmVolDefaultBtn.setAttribute("aria-selected", String(bv === "DEFAULT"));
        }
        if (el.bgmVolSmallBtn){
          el.bgmVolSmallBtn.classList.toggle("active", bv === "SMALL");
          el.bgmVolSmallBtn.setAttribute("aria-selected", String(bv === "SMALL"));
        }

        if (el.debugToggle) el.debugToggle.checked = state.settings.debug;
        _settingsSyncControls();
        if (el.settingsOverlay && !el.settingsOverlay.classList.contains("hidden")){
          _adminRenderUI();
        }

        if (state.view === "TITLE"){
          renderTitleHeader();
          _appRenderCurrentTab();
        } else if (state.view === "QUIZ"){
          renderQuestion();
        } else if (state.view === "RESULT"){
          renderResult();
        }
        _customSelectEnhance(document);
      }

      // =========================
      // Navigation
      // =========================
      
      function startMode(mode, jumpId){
        state.mode = mode;
        state.index = 0;
        state.showAnswer = false;
        state.done = false;

        clearChoiceTimer();

        if (mode === "HAND"){
          state.hand.checked = false;
          state.hand.correct = null;
          state.hand.input = "";
          state.hand.busy = false;
          state.hand.results = [];
          state.hand.scoreCorrect = 0;
        }

        state.order = buildOrder(mode);

        // optional: jump to a specific word id (used by Search)
        if (mode === "SEQ" && jumpId != null){
          const jid = Number(jumpId);
          const idx = state.order.findIndex(w => w && Number(w.id) === jid);
          if (idx >= 0) state.index = idx;
        }
        if (mode === "HAND"){
          _appSaveResume("HAND");
        }

        setView("QUIZ");
        if (mode === "HAND") resetHandPerQuestion();

        syncBgmToView();
        animateCardSwap(renderAll);
      }

      function startChoiceMode(timeLimitSec){
        closeTimeSelect();
        const resolvedLimit = (timeLimitSec === undefined || timeLimitSec === null)
          ? getChoiceDefaultTimeLimitSec()
          : (Number(timeLimitSec) || 0);

        state.mode = "CHOICE";
        state.index = 0;
        state.showAnswer = false;
        state.done = false;

        resetChoiceSession(resolvedLimit);

        // Always create a fresh random set for each start
        createChoiceSetIds(getSetKey(state.deck), true);

        state.order = buildOrder("CHOICE");
        _appSaveResume("CHOICE");

        // prepare first question
        buildChoiceOptionsForCurrent();
        renderChoiceOptions();

        setView("QUIZ");
        syncBgmToView();
        startChoiceTimer();

        animateCardSwap(renderAll);
      }

      let _startCountPicking = false;
      async function _pickStartQuestionCount(modeLabel){
        const fallback = START_MODE_QUESTION_COUNT_SET.has(Number(state.startModeQuestionCount))
          ? Number(state.startModeQuestionCount)
          : 100;
        let selected = fallback;
        const options = START_MODE_QUESTION_COUNTS.map((n) => `<option value="${n}">${n}</option>`).join("");
        const htmlStr = `
          <div style="display:flex; flex-direction:column; gap:10px;">
            <div class="note">${modeLabel} </div>
            <label class="settings-row is-static" for="startQuestionCountSelect" style="margin:0;">
              <span class="label"></span>
              <select id="startQuestionCountSelect" class="select settings-select">${options}</select>
            </label>
          </div>
        `;
        const p = uiConfirmHtml(htmlStr, {
          title: `${modeLabel} `,
          okText: "",
          cancelText: ""
        });
        _runIdle(() => {
          const sel = document.getElementById("startQuestionCountSelect");
          if (!sel) return;
          sel.value = String(fallback);
          selected = Number(sel.value) || fallback;
          _customSelectEnhance(sel);
          _customSelectRefresh(sel);
          sel.addEventListener("change", () => {
            const v = Number(sel.value);
            if (START_MODE_QUESTION_COUNT_SET.has(v)) selected = v;
          });
        });
        const ok = await p;
        if (!ok) return null;
        return START_MODE_QUESTION_COUNT_SET.has(selected) ? selected : fallback;
      }

      async function _startModeWithQuestionCountPick(kind){
        if (_startCountPicking) return;
        _startCountPicking = true;
        try{
          const isChoice = kind === "CHOICE";
          const modeLabel = isChoice ? "EXAM MODE" : "WRITE MODE";
          const picked = await _pickStartQuestionCount(modeLabel);
          if (!Number.isFinite(picked)) return;
          state.startModeQuestionCount = Number(picked);
          if (isChoice) startChoiceMode(getChoiceDefaultTimeLimitSec());
          else startMode("HAND");
        } finally {
          _startCountPicking = false;
        }
      }

function goTitle(){
        stopBgm(true);
        clearChoiceTimer();
        closeTimeSelect();
        _clearRecommendScope();
        state.mode = null;
        state.order = [];
        state.index = 0;
        state.showAnswer = false;
        state.done = false;
        setView("TITLE");
        renderAll();
      }

      function goResult(kind){
        clearChoiceTimer();
        state.resultKind = kind || state.mode || null;
        setView("RESULT");
        renderAll();
      }

      function next(){
        if (state.view !== "QUIZ") return;

        if (state.mode === "HAND"){
          // IMPORTANT: NO auto-judge here.
          if (!state.hand.checked) return;

          if (state.index >= state.order.length - 1){
            goResult("HAND");
            return;
          }

          state.index += 1;
          resetHandPerQuestion();
          animateCardSwap(renderAll);
          return;
        }
        if (state.mode === "CHOICE"){
          if (!state.choice.locked) return;
          if (state.index >= state.order.length - 1){
            goResult("CHOICE");
            return;
          }
          state.index += 1;
          state.showAnswer = false;
          state.done = false;
          state.choice.options = [];
          state.choice.correctIndex = -1;
          state.choice.locked = false;
          buildChoiceOptionsForCurrent();
          animateCardSwap(() => {
            renderAll();
            startChoiceTimer();
          });
          return;
        }

        if (state.done){
          goTitle();
          return;
        }

        if (state.index >= state.order.length - 1){
          state.done = true;
          state.showAnswer = true;
          animateCardSwap(renderAll);
          return;
        }

        state.index += 1;
        state.showAnswer = false;
        animateCardSwap(renderAll);
      }

      function prev(){
        if (state.view !== "QUIZ") return;

        const allowPrev = (state.mode === "SEQ" || state.mode === "REVIEW_WRONG");
        if (!allowPrev) return;
        if (state.index <= 0) return;

        state.index -= 1;
        state.showAnswer = false;

        animateCardSwap(renderAll);
      }

      function primaryAction(){
        if (state.view !== "QUIZ") return;

        if (state.mode === "HAND"){
          checkHand();
          return;
        }

        state.showAnswer = !state.showAnswer;
        animateCardSwap(renderAll);
      }

      
      function restart(){
        if (state.view !== "QUIZ") return;

        clearChoiceTimer();

        state.index = 0;
        state.done = false;
        state.showAnswer = false;

        if (state.mode === "RND"){
          state.order = buildOrder("RND");

        } else if (state.mode === "HAND"){
          state.hand.checked = false;
          state.hand.correct = null;
          state.hand.input = "";
          state.hand.busy = false;
          state.hand.results = [];
          state.hand.scoreCorrect = 0;
          state.order = buildOrder("HAND");
          resetHandPerQuestion();

        } else if (state.mode === "CHOICE"){
          // keep chosen timeLimitSec; reset score/results
          const t = state.choice.timeLimitSec || 0;
          resetChoiceSession(t);
          state.order = buildOrder("CHOICE");
          buildChoiceOptionsForCurrent();
          renderChoiceOptions();
          startChoiceTimer();

        } else if (state.mode === "SEQ"){
          state.order = buildOrder("SEQ");

        } else if (state.mode === "REVIEW_WRONG"){
          state.order = buildOrder("REVIEW_WRONG");
        }

        animateCardSwap(renderAll);
      }

      function newHandSet(){
        createExamSetIds(getSetKey(state.deck), true);
        if (state.mode !== "HAND"){
          startMode("HAND");
          return;
        }
        restart();
      }

      function newChoiceSet(){
        createChoiceSetIds(getSetKey(state.deck), true);
        if (state.mode !== "CHOICE"){
          startChoiceMode(getChoiceDefaultTimeLimitSec());
          return;
        }
        restart();
      }
function setDeck(deckKey){
        _clearRecommendScope();
        state.deck = deckKey;
        saveDeck(deckKey);
        state.presetId = `builtin:${deckKey}`;
        saveActivePresetId(state.presetId);
        renderAll();
      }

      // =========================
      // Settings overlay
      // =========================
      const _settingsState = {
        stack: ["root"],
        page: "root",
        openedFromMenu: false
      };
      const _settingsTitleMap = {
        root: "",
        practice: "Practice",
        sound: "Sound",
        display: "Display",
        account: "",
        data: "",
        admin: "Admin"
      };
      function _settingsCurrentPage(){
        return _settingsState.page || "root";
      }
      function _settingsSetStatus(msg, kind){
        const x = document.getElementById("settingsInlineStatus");
        if (!x) return;
        x.textContent = String(msg || "");
        x.classList.remove("ok", "error");
        if (kind === "ok") x.classList.add("ok");
        if (kind === "error") x.classList.add("error");
      }
      function _settingsApplyPage(page){
        const p = (page && _settingsTitleMap[page]) ? page : "root";
        _customSelectClose();
        _settingsState.page = p;
        const pages = document.querySelectorAll("#settingsMainPane .settings-page[data-settings-page]");
        pages.forEach((node) => {
          node.classList.toggle("is-active", node.getAttribute("data-settings-page") === p);
        });
        const titleEl = document.getElementById("settingsNavTitle");
        if (titleEl){
          titleEl.textContent = _settingsTitleMap[p] || "";
        }
      }
      function _settingsPushPage(page){
        const p = (page && _settingsTitleMap[page]) ? page : "root";
        if (_settingsState.stack[_settingsState.stack.length - 1] !== p){
          _settingsState.stack.push(p);
        }
        _settingsApplyPage(p);
      }
      function _settingsBack(){
        if (_adminState.editorOpen){
          _adminShowEditor(false);
          return;
        }
        if (_settingsState.stack.length > 1){
          _settingsState.stack.pop();
          const prev = _settingsState.stack[_settingsState.stack.length - 1] || "root";
          _settingsApplyPage(prev);
          return;
        }
        closeSettings();
      }
      function _settingsResetToRoot(){
        _settingsState.stack = ["root"];
        _settingsApplyPage("root");
      }
      function _settingsSummaryTextByTime(sec){
        const n = Number(sec) || 0;
        return n <= 0 ? "" : `${n}`;
      }
      function _settingsSummaryTextByLevel(level){
        if (level === "SMALL") return "";
        if (level === "LARGE") return "";
        return "";
      }
      function _settingsRefreshSummary(){
        const p = document.getElementById("settingsSummaryPractice");
        const s = document.getElementById("settingsSummarySound");
        const d = document.getElementById("settingsSummaryDisplay");
        const ac = document.getElementById("settingsSummaryAccount");
        const a = document.getElementById("settingsSummaryAdmin");
        if (p){
          p.textContent = `${state.settings.direction === "JA_EN" ? "" : ""} / ${getSavedPracticeQuestionCount()}`;
        }
        if (s){
          s.textContent = `${state.settings.bgm ? "BGM ON" : "BGM OFF"} / SE ${state.settings.sfx ? "ON" : "OFF"}`;
        }
        if (d){
          const theme = String(state.settings.theme || "AUTO");
          const font = _settingsSummaryTextByLevel(state.settings.fontSize || "DEFAULT");
          d.textContent = `${theme} / ${font}`;
        }
        if (ac){
          if (authState.user){
            ac.textContent = _authDisplayId(authState.user);
          } else if (authState.mode === "guest"){
            ac.textContent = "";
          } else {
            ac.textContent = "";
          }
        }
        if (a){
          const email = String(_adminState.user?.email || "").trim();
          a.textContent = email || "";
        }
      }
      function _settingsSyncControls(){
        const dirEn = document.getElementById("dirEnJaBtn");
        const dirJa = document.getElementById("dirJaEnBtn");
        const isEnJa = state.settings.direction === "EN_JA";
        if (dirEn){
          dirEn.classList.toggle("active", isEnJa);
          dirEn.setAttribute("aria-selected", String(isEnJa));
        }
        if (dirJa){
          dirJa.classList.toggle("active", !isEnJa);
          dirJa.setAttribute("aria-selected", String(!isEnJa));
        }

        const anim = document.getElementById("animToggle");
        const sfx = document.getElementById("sfxToggle");
        const bgm = document.getElementById("bgmToggle");
        const debug = document.getElementById("debugToggle");
        if (anim) anim.checked = !!state.settings.animations;
        if (sfx) sfx.checked = !!state.settings.sfx;
        if (bgm) bgm.checked = !!state.settings.bgm;
        if (debug) debug.checked = !!state.settings.debug;

        const qCount = document.getElementById("settingsQuestionCountSelect");
        const examTime = document.getElementById("settingsExamTimeSelect");
        const autoNext = document.getElementById("settingsAutoNextToggle");
        const sfxVol = document.getElementById("settingsSfxVolumeSelect");
        const theme = document.getElementById("settingsThemeSelect");
        const font = document.getElementById("settingsFontSizeSelect");

        if (qCount) qCount.value = String(getSavedPracticeQuestionCount());
        if (examTime) examTime.value = String(getChoiceDefaultTimeLimitSec());
        if (autoNext) autoNext.checked = isAutoNextEnabled();
        if (sfxVol) sfxVol.value = String(state.settings.sfxVolume || "DEFAULT");
        if (theme) theme.value = String(state.settings.theme || "AUTO");
        if (font) font.value = String(state.settings.fontSize || "DEFAULT");

        const bv = state.settings.bgmVolume || "DEFAULT";
        const volLarge = document.getElementById("bgmVolLargeBtn");
        const volDefault = document.getElementById("bgmVolDefaultBtn");
        const volSmall = document.getElementById("bgmVolSmallBtn");
        if (volLarge){
          volLarge.classList.toggle("active", bv === "LARGE");
          volLarge.setAttribute("aria-selected", String(bv === "LARGE"));
        }
        if (volDefault){
          volDefault.classList.toggle("active", bv === "DEFAULT");
          volDefault.setAttribute("aria-selected", String(bv === "DEFAULT"));
        }
        if (volSmall){
          volSmall.classList.toggle("active", bv === "SMALL");
          volSmall.setAttribute("aria-selected", String(bv === "SMALL"));
        }

        _settingsRefreshSummary();
        _authRenderSettingsAccount();
        _customSelectEnhance(el.settingsOverlay || document);
      }
      function _resolveThemeMode(){
        const t = String(state.settings.theme || "AUTO");
        if (t === "LIGHT") return "light";
        if (t === "DARK") return "dark";
        return "light";
      }
      function applyTheme(){
        const root = document.documentElement;
        if (!root) return;
        const mode = _resolveThemeMode();
        root.setAttribute("data-theme-mode", mode);
        const meta = document.querySelector('meta[name="color-scheme"]');
        if (meta){
          meta.setAttribute("content", mode === "dark" ? "dark light" : "light dark");
        }
      }
      function applyFontSize(){
        const root = document.documentElement;
        if (!root) return;
        const size = SETTINGS_LEVELS.has(String(state.settings.fontSize || "")) ? String(state.settings.fontSize) : "DEFAULT";
        const pct = size === "SMALL" ? 94 : (size === "LARGE" ? 108 : 100);
        root.setAttribute("data-font-size", size);
        root.style.webkitTextSizeAdjust = `${pct}%`;
        root.style.textSizeAdjust = `${pct}%`;
        if (document.body){
          document.body.style.webkitTextSizeAdjust = `${pct}%`;
          document.body.style.textSizeAdjust = `${pct}%`;
        }
      }
      function applyMotionSetting(){
        const root = document.documentElement;
        if (!root) return;
        root.setAttribute("data-animations", state.settings.animations ? "on" : "off");
      }
      function openSettings(opts = {}){
        if (!el.settingsOverlay){
          uiToast("Settings UI");
          return;
        }
        _settingsState.openedFromMenu = !!opts?.fromMenu;
        _settingsSetStatus("");
        _settingsResetToRoot();
        _adminShowEditor(false);
        _settingsSyncControls();
        el.settingsOverlay.classList.remove("hidden");
        _customSelectEnhance(el.settingsOverlay);
        _adminEnsureAuthWatcher();
        _adminRenderUI();
        _maintenanceCheckNow("settings-open", { silent: true });
      }
      function closeSettings(){
        if (!el.settingsOverlay){
          uiToast("Settings UI");
          return;
        }
        _customSelectClose();
        const backToMenu = !!_settingsState.openedFromMenu;
        _settingsState.openedFromMenu = false;
        _settingsResetToRoot();
        _settingsSetStatus("");
        _adminShowEditor(false);
        el.settingsOverlay.classList.add("hidden");
        if (backToMenu){
          _runIdle(() => {
            try{
              openMenu();
              _setMenuView("root");
            }catch{}
          });
        }
      }

      function openUpdateNotes(){ if (el.updateOverlay) el.updateOverlay.classList.remove("hidden"); }
      function closeUpdateNotes(){
        try{
          if (el.updateDontShowChk && el.updateDontShowChk.checked){
            window.localStorage.setItem(UPDATE_NOTES_DISMISS_KEY, "1");
          }
        }catch{}
        if (el.updateOverlay) el.updateOverlay.classList.add("hidden");
      }
      function maybeShowUpdateNotes(){
        try{
          if (window.localStorage.getItem(UPDATE_NOTES_DISMISS_KEY) === "1") return;
        }catch{}
        openUpdateNotes();
      }

      function setDirection(dir){
        state.settings.direction = (dir === "JA_EN") ? "JA_EN" : "EN_JA";
        saveSettings(state.settings);
        _settingsSyncControls();
        renderAll();
      }
      function setAnimations(on){
        state.settings.animations = !!on;
        saveSettings(state.settings);
        applyMotionSetting();
        try{ insights.reduceMotion = _isMotionReduced(); }catch{}
        _settingsSyncControls();
        renderAll();
      }
      function setSfx(on){
        state.settings.sfx = !!on;
        saveSettings(state.settings);
        _settingsSyncControls();
        renderAll();
      }
      function setBgm(on){
        state.settings.bgm = !!on;
        saveSettings(state.settings);
        if (!on) stopBgm(false);
        else applyBgmVolume();
        syncBgmToView(); // start/stop immediately
        _settingsSyncControls();
        renderAll();
      }

      function setBgmVolume(level){
        const v = (level === "LARGE" || level === "SMALL" || level === "DEFAULT") ? level : "DEFAULT";
        state.settings.bgmVolume = v;
        saveSettings(state.settings);
        applyBgmVolume();
        _settingsSyncControls();
        renderAll();
      }
      function setSfxVolume(level){
        const v = (level === "LARGE" || level === "SMALL" || level === "DEFAULT") ? level : "DEFAULT";
        state.settings.sfxVolume = v;
        saveSettings(state.settings);
        applySfxVolume();
        _settingsSyncControls();
      }
      function setQuestionCount(count){
        const n = Number(count);
        state.settings.questionCount = SETTINGS_QUESTION_COUNTS.has(n) ? n : defaultSettings.questionCount;
        saveSettings(state.settings);
        _settingsSyncControls();
        renderAll();
      }
      function setChoiceTimeLimitSec(sec){
        const n = Number(sec);
        state.settings.choiceTimeLimitSec = SETTINGS_EXAM_TIMES.has(n) ? n : defaultSettings.choiceTimeLimitSec;
        saveSettings(state.settings);
        _settingsSyncControls();
      }
      function setAutoNext(on){
        state.settings.autoNext = !!on;
        saveSettings(state.settings);
        _settingsSyncControls();
      }
      function setTheme(theme){
        const v = SETTINGS_THEMES.has(String(theme || "")) ? String(theme) : "AUTO";
        state.settings.theme = v;
        saveSettings(state.settings);
        applyTheme();
        _settingsSyncControls();
      }
      function setFontSize(size){
        const v = SETTINGS_LEVELS.has(String(size || "")) ? String(size) : "DEFAULT";
        state.settings.fontSize = v;
        saveSettings(state.settings);
        applyFontSize();
        _settingsSyncControls();
        renderAll();
      }

      function setDebug(on){
        state.settings.debug = !!on;
        saveSettings(state.settings);
        _settingsSyncControls();
        renderAll();
      }

      // =========================
      // Result actions
      // =========================
      
      function buildWrongOrderFromResults(){
        const kind = state.resultKind || state.mode || "HAND";
        const wrongIds = (kind === "CHOICE")
          ? state.choice.results.filter(r => !r.correct).map(r => r.id)
          : state.hand.results.filter(r => !r.correct).map(r => r.id);

        const ids = uniq(wrongIds);
        const out = [];
        const byId = buildActiveById();
        for (const id of ids){
          const w = byId.get(id);
          if (w) out.push(w);
        }
        out.sort((a,b)=>a.id-b.id);
        return out;
      }
function reviewWrong(){
        const wrong = buildWrongOrderFromResults();
        state.wrongOrder = wrong;
        if (!wrong.length){
          goTitle();
          return;
        }
        state.mode = "REVIEW_WRONG";
        state.order = wrong;
        state.index = 0;
        state.showAnswer = false;
        state.done = false;
        setView("QUIZ");
        animateCardSwap(renderAll);
      }


      // =========================
      // Notifications (local)
      // =========================
      const NOTIF_KEY = "app.notifications.v1";
      const NOTIF_SEEN_KEY = "app.notifications.seenAt.v1";
      const ADMIN_EMAIL = "Matsushiri20pc@gmail.com";
      const NOTIF_MAX = 200;
      const _adminState = {
        authWatchStarted: false,
        auth: null,
        db: null,
        user: null,
        isAdmin: false,
        editorOpen: false,
        notifItems: [],
        loading: false,
        aiIngestBusy: false
      };
      const MAINTENANCE_COLLECTION = "appConfig";
      const MAINTENANCE_DOC_ID = "maintenance";
      const MAINTENANCE_POLL_MS = 30000;
      const MAINTENANCE_COUNTDOWN_MS = 10000;
      const _maintenanceState = {
        config: null,
        active: false,
        bypass: false,
        loaded: false,
        polling: false,
        pollTimer: 0,
        countdownTimer: 0,
        lastCheckAt: 0,
        saving: false,
        visibilityBound: false
      };

      function _fmt2(n){ return String(n).padStart(2,"0"); }
      function formatDateTime(ts){
        try{
          const d = new Date(ts);
          const y = d.getFullYear();
          const m = _fmt2(d.getMonth()+1);
          const da = _fmt2(d.getDate());
          const hh = _fmt2(d.getHours());
          const mm = _fmt2(d.getMinutes());
          return `${y}-${m}-${da} ${hh}:${mm}`;
        } catch {
          return "";
        }
      }
      function _toLocalDateTimeInput(ms){
        const n = Number(ms) || 0;
        if (!n) return "";
        const d = new Date(n);
        const pad = (x) => String(x).padStart(2, "0");
        return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
      }
      function _parseLocalDateTimeInput(v){
        const s = String(v || "").trim();
        if (!s) return 0;
        const ms = new Date(s).getTime();
        return Number.isFinite(ms) ? ms : 0;
      }
      function _notifTsToMs(v){
        if (!v) return 0;
        if (typeof v.toMillis === "function") return Number(v.toMillis()) || 0;
        if (typeof v.seconds === "number"){
          return (Number(v.seconds) * 1000) + Math.floor(Number(v.nanoseconds || 0) / 1e6);
        }
        const n = Number(v);
        return Number.isFinite(n) ? n : 0;
      }
      function _notifNormalizeCategory(v){
        const s = String(v || "Update");
        if (s === "Study" || s === "Preset" || s === "System") return s;
        return "Update";
      }
      function _notifNormalizePriority(v){
        const s = String(v || "normal");
        if (s === "low" || s === "high") return s;
        return "normal";
      }
      function _notifNormalizeItem(raw){
        const id = String(raw?.id || "").trim();
        if (!id) return null;
        const title = String(raw?.title || "").trim();
        const body = String(raw?.body || "");
        const publishedAtMs = _notifTsToMs(raw?.publishedAtMs || raw?.publishedAt);
        const createdAtMs = _notifTsToMs(raw?.createdAtMs || raw?.createdAt);
        const updatedAtMs = _notifTsToMs(raw?.updatedAtMs || raw?.updatedAt);
        const ts = _notifTsToMs(raw?.ts) || publishedAtMs || createdAtMs || updatedAtMs || 0;
        return {
          id,
          title,
          body,
          category: _notifNormalizeCategory(raw?.category),
          priority: _notifNormalizePriority(raw?.priority),
          publishedAtMs,
          createdAtMs,
          updatedAtMs,
          ts
        };
      }
      function _notifFromDoc(doc){
        const raw = (doc && typeof doc.data === "function") ? (doc.data() || {}) : {};
        return _notifNormalizeItem({
          id: doc?.id || "",
          title: raw.title,
          body: raw.body,
          category: raw.category,
          priority: raw.priority,
          publishedAt: raw.publishedAt,
          createdAt: raw.createdAt,
          updatedAt: raw.updatedAt
        });
      }
      function _notifSeenAt(){
        try{
          const n = Number(window.localStorage.getItem(NOTIF_SEEN_KEY) || 0);
          return Number.isFinite(n) ? n : 0;
        }catch{
          return 0;
        }
      }
      function _notifSetSeenAt(ts){
        const n = Number(ts) || 0;
        if (!n) return;
        try{ window.localStorage.setItem(NOTIF_SEEN_KEY, String(n)); }catch{}
      }
      function _notifMarkSeenByList(list){
        const maxTs = (Array.isArray(list) ? list : []).reduce((mx, n) => Math.max(mx, Number(n?.ts) || 0), 0);
        if (maxTs > 0) _notifSetSeenAt(maxTs);
      }

      function loadNotifications(){
        try{
          const raw = window.localStorage.getItem(NOTIF_KEY);
          if (!raw) return [];
          const arr = JSON.parse(raw);
          if (!Array.isArray(arr)) return [];
          return arr
            .map(_notifNormalizeItem)
            .filter(Boolean)
            .sort((a,b) => (b.ts || 0) - (a.ts || 0))
            .slice(0, NOTIF_MAX);
        }catch{
          return [];
        }
      }
      function saveNotifications(list){
        try{
          const arr = (Array.isArray(list) ? list : [])
            .map(_notifNormalizeItem)
            .filter(Boolean)
            .slice(0, NOTIF_MAX)
            .map(n => ({
              id: n.id,
              title: n.title,
              body: n.body,
              category: n.category,
              priority: n.priority,
              publishedAtMs: n.publishedAtMs || 0,
              createdAtMs: n.createdAtMs || 0,
              updatedAtMs: n.updatedAtMs || 0,
              ts: n.ts || 0
            }));
          window.localStorage.setItem(NOTIF_KEY, JSON.stringify(arr));
        }catch{}
      }
      function ensureDemoNotification(){
        return loadNotifications();
      }

      function _adminSetStatus(msg, kind){
        const elx = document.getElementById("adminAuthStatus");
        if (!elx){
          if (msg) uiToast(String(msg));
          return;
        }
        elx.textContent = String(msg || "");
        elx.classList.remove("ok", "error");
        if (kind === "ok") elx.classList.add("ok");
        if (kind === "error") elx.classList.add("error");
      }
      function _adminSetNotifStatus(msg, kind){
        const elx = document.getElementById("adminNotifStatus");
        if (!elx){
          if (msg) uiToast(String(msg));
          return;
        }
        elx.textContent = String(msg || "");
        elx.classList.remove("ok", "error");
        if (kind === "ok") elx.classList.add("ok");
        if (kind === "error") elx.classList.add("error");
      }
      function _adminSetAiIngestStatus(msg, kind){
        const elx = document.getElementById("adminAiIngestStatus");
        if (!elx){
          if (msg) uiToast(String(msg));
          return;
        }
        elx.textContent = String(msg || "");
        elx.classList.remove("ok", "error");
        if (kind === "ok") elx.classList.add("ok");
        if (kind === "error") elx.classList.add("error");
      }
      function _adminSetAiIngestBusy(busy){
        const on = !!busy;
        _adminState.aiIngestBusy = on;
        const ids = ["adminAiIngestKey", "adminAiIngestJson", "adminAiIngestBtn"];
        for (const id of ids){
          const node = document.getElementById(id);
          if (!node) continue;
          node.disabled = on || !_adminState.isAdmin;
        }
      }
      function _adminUserIsAdmin(user){
        const email = String(user?.email || "").trim().toLowerCase();
        return !!email && email === String(ADMIN_EMAIL).trim().toLowerCase();
      }
      function _maintenanceDefaultConfig(){
        return {
          enabled: false,
          startAt: 0,
          endAt: 0,
          title: "",
          message: "",
          updatedAt: 0,
          updatedBy: ""
        };
      }
      function _maintenanceNormalizeConfig(input){
        const d = _maintenanceDefaultConfig();
        const src = (input && typeof input === "object") ? input : {};
        const startAt = Number(src.startAt || 0);
        const endAt = Number(src.endAt || 0);
        return {
          enabled: !!src.enabled,
          startAt: Number.isFinite(startAt) ? startAt : 0,
          endAt: Number.isFinite(endAt) ? endAt : 0,
          title: String(src.title || d.title || "").trim() || d.title,
          message: String(src.message || d.message || "").trim() || d.message,
          updatedAt: Number(src.updatedAt || 0) || 0,
          updatedBy: String(src.updatedBy || "").trim()
        };
      }
      function _maintenanceIsActive(config, nowMs){
        const cfg = _maintenanceNormalizeConfig(config);
        const now = Number(nowMs || Date.now());
        return !!(cfg.enabled && cfg.startAt > 0 && cfg.endAt > cfg.startAt && now >= cfg.startAt && now < cfg.endAt);
      }
      function _maintenanceFmtDate(ms){
        const n = Number(ms) || 0;
        if (!n) return "";
        return formatDateTime(n);
      }
      function _maintenanceFmtRemain(ms){
        const n = Math.max(0, Number(ms) || 0);
        if (!n) return "00:00";
        const sec = Math.floor(n / 1000);
        const h = Math.floor(sec / 3600);
        const m = Math.floor((sec % 3600) / 60);
        const s = sec % 60;
        if (h > 0){
          return `${h}:${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
        }
        return `${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
      }
      function _maintenanceCanBypass(){
        if (_adminState.isAdmin) return true;
        if (_adminUserIsAdmin(_adminState.user)) return true;
        if (_adminUserIsAdmin(authState.user)) return true;
        const email = String(authState?.user?.email || "").trim().toLowerCase();
        return !!email && email === String(ADMIN_EMAIL).trim().toLowerCase();
      }
      function _maintenanceSetOverlayStatus(msg, kind){
        const elx = el.maintenanceStatus;
        if (!elx) return;
        elx.textContent = String(msg || "");
        elx.classList.remove("ok", "error");
        if (kind === "ok") elx.classList.add("ok");
        if (kind === "error") elx.classList.add("error");
      }
      function _maintenanceSetAdminStatus(msg, kind){
        const elx = document.getElementById("adminMaintenanceStatus");
        if (!elx){
          if (msg) uiToast(String(msg));
          return;
        }
        elx.textContent = String(msg || "");
        elx.classList.remove("ok", "error");
        if (kind === "ok") elx.classList.add("ok");
        if (kind === "error") elx.classList.add("error");
      }
      function _maintenanceSetAdminBusy(busy){
        const disabled = !!busy;
        const ids = [
          "adminMaintenanceEnabled",
          "adminMaintenanceStartAt",
          "adminMaintenanceEndAt",
          "adminMaintenanceTitle",
          "adminMaintenanceMessage",
          "adminMaintenanceSaveBtn",
          "adminMaintenanceClearExpiredBtn"
        ];
        for (const id of ids){
          const node = document.getElementById(id);
          if (!node) continue;
          node.disabled = disabled || !_adminState.isAdmin;
        }
      }
      function _maintenanceReadAdminForm(){
        const enabledEl = document.getElementById("adminMaintenanceEnabled");
        const startEl = document.getElementById("adminMaintenanceStartAt");
        const endEl = document.getElementById("adminMaintenanceEndAt");
        const titleEl = document.getElementById("adminMaintenanceTitle");
        const messageEl = document.getElementById("adminMaintenanceMessage");
        if (!enabledEl || !startEl || !endEl || !titleEl || !messageEl){
          throw new Error("UI");
        }
        const enabled = !!enabledEl.checked;
        const current = _maintenanceNormalizeConfig(_maintenanceState.config || _maintenanceDefaultConfig());
        let startAt = _parseLocalDateTimeInput(startEl.value);
        let endAt = _parseLocalDateTimeInput(endEl.value);
        if (!startAt){
          startAt = Number(current.startAt || 0) || Date.now();
        }
        if (!endAt){
          endAt = Number(current.endAt || 0) || (startAt + 3600000);
        }
        const title = String(titleEl.value || "").trim() || "";
        const message = String(messageEl.value || "").trim() || "";
        if (enabled && (!startAt || !endAt)){
          throw new Error("");
        }
        if (enabled && endAt <= startAt){
          throw new Error("");
        }
        return { enabled, startAt, endAt, title, message };
      }
      function _maintenanceRenderAdminPreview(){
        const pv = document.getElementById("adminMaintenancePreview");
        if (!pv) return;
        const cfgBase = _maintenanceNormalizeConfig(_maintenanceState.config || _maintenanceDefaultConfig());
        const enabledEl = document.getElementById("adminMaintenanceEnabled");
        const startEl = document.getElementById("adminMaintenanceStartAt");
        const endEl = document.getElementById("adminMaintenanceEndAt");
        const titleEl = document.getElementById("adminMaintenanceTitle");
        const messageEl = document.getElementById("adminMaintenanceMessage");
        const cfg = _maintenanceNormalizeConfig({
          ...cfgBase,
          enabled: enabledEl ? !!enabledEl.checked : cfgBase.enabled,
          startAt: startEl ? (_parseLocalDateTimeInput(startEl.value) || cfgBase.startAt) : cfgBase.startAt,
          endAt: endEl ? (_parseLocalDateTimeInput(endEl.value) || cfgBase.endAt) : cfgBase.endAt,
          title: titleEl ? String(titleEl.value || cfgBase.title || "") : cfgBase.title,
          message: messageEl ? String(messageEl.value || cfgBase.message || "") : cfgBase.message
        });
        const now = Date.now();
        const active = _maintenanceIsActive(cfg, now);
        let nowLine = ": ";
        if (cfg.enabled && now < cfg.startAt){
          nowLine = ": ";
        } else if (active){
          nowLine = ": ";
        } else if (cfg.enabled && now >= cfg.endAt && cfg.endAt > 0){
          nowLine = ": ";
        } else if (cfg.enabled){
          nowLine = ": ";
        }
        const remainText = active ? _maintenanceFmtRemain(cfg.endAt - now) : "";
        pv.innerHTML = `
          <div class="now">${escapeHtml(nowLine)}</div>
          <div>: ${escapeHtml(_maintenanceFmtDate(cfg.startAt))}  ${escapeHtml(_maintenanceFmtDate(cfg.endAt))}</div>
          <div>: ${escapeHtml(remainText)}</div>
          <div>: ${escapeHtml(cfg.updatedBy || "")} / : ${escapeHtml(_maintenanceFmtDate(cfg.updatedAt))}</div>
        `;
      }
      function _maintenanceRenderAdminForm(){
        const cfg = _maintenanceNormalizeConfig(_maintenanceState.config || _maintenanceDefaultConfig());
        const groupEl = document.getElementById("adminMaintenanceGroup");
        const lockedNoteEl = document.getElementById("adminMaintenanceLockedNote");
        const previewEl = document.getElementById("adminMaintenancePreview");
        const enabledEl = document.getElementById("adminMaintenanceEnabled");
        const startEl = document.getElementById("adminMaintenanceStartAt");
        const endEl = document.getElementById("adminMaintenanceEndAt");
        const titleEl = document.getElementById("adminMaintenanceTitle");
        const messageEl = document.getElementById("adminMaintenanceMessage");
        if (groupEl) groupEl.classList.toggle("hidden", !_adminState.isAdmin);
        if (lockedNoteEl) lockedNoteEl.classList.toggle("hidden", !!_adminState.isAdmin);
        if (previewEl) previewEl.classList.toggle("hidden", !_adminState.isAdmin);
        if (!_adminState.isAdmin){
          _maintenanceSetAdminBusy(false);
          return;
        }
        const ae = document.activeElement;
        const editingActive = !!(ae && (
          ae === enabledEl ||
          ae === startEl ||
          ae === endEl ||
          ae === titleEl ||
          ae === messageEl
        ));
        if (!_maintenanceState.saving && !editingActive){
          if (enabledEl) enabledEl.checked = !!cfg.enabled;
          if (startEl) startEl.value = _toLocalDateTimeInput(cfg.startAt || 0);
          if (endEl) endEl.value = _toLocalDateTimeInput(cfg.endAt || 0);
          if (titleEl) titleEl.value = cfg.title || "";
          if (messageEl) messageEl.value = cfg.message || "";
        }
        _maintenanceSetAdminBusy(_maintenanceState.saving);
        _maintenanceRenderAdminPreview();
      }
      function _maintenanceStopCountdown(){
        if (_maintenanceState.countdownTimer){
          clearInterval(_maintenanceState.countdownTimer);
          _maintenanceState.countdownTimer = 0;
        }
      }
      function _maintenanceRenderOverlay(){
        const overlay = el.maintenanceOverlay;
        if (!overlay) return;
        const cfg = _maintenanceNormalizeConfig(_maintenanceState.config || _maintenanceDefaultConfig());
        const now = Date.now();
        const active = _maintenanceIsActive(cfg, now);
        _maintenanceState.active = active;
        if (!active){
          _maintenanceState.bypass = false;
        }
        const canBypass = _maintenanceCanBypass();
        const blocked = active && !(canBypass && _maintenanceState.bypass);
        overlay.classList.toggle("hidden", !blocked);
        document.body.classList.toggle("maintenance-open", blocked);
        if (el.maintenanceTitle) el.maintenanceTitle.textContent = cfg.title || "";
        if (el.maintenanceMessage) el.maintenanceMessage.textContent = cfg.message || "";
        if (el.maintenancePeriod){
          el.maintenancePeriod.textContent = `${_maintenanceFmtDate(cfg.startAt)}  ${_maintenanceFmtDate(cfg.endAt)}`;
        }
        if (el.maintenanceRemaining){
          el.maintenanceRemaining.textContent = active ? _maintenanceFmtRemain(cfg.endAt - now) : "";
        }
        if (el.maintenanceBypassBtn){
          el.maintenanceBypassBtn.classList.toggle("hidden", !(active && canBypass));
        }
        if (el.maintenanceAdminLoginBtn){
          el.maintenanceAdminLoginBtn.classList.toggle("hidden", !active || canBypass);
        }
        if (!blocked){
          _maintenanceSetOverlayStatus("");
          _maintenanceStopCountdown();
          return;
        }
        if (!_maintenanceState.countdownTimer){
          _maintenanceState.countdownTimer = setInterval(() => {
            _maintenanceRenderOverlay();
            _maintenanceRenderAdminPreview();
            if (!_maintenanceState.active){
              _maintenanceCheckNow("auto-release", { silent: true, force: true });
            }
          }, MAINTENANCE_COUNTDOWN_MS);
        }
      }
      async function _maintenanceFetchConfig(){
        const db = _drawerShareGetDb();
        const snap = await db.collection(MAINTENANCE_COLLECTION).doc(MAINTENANCE_DOC_ID).get();
        if (!snap || !snap.exists){
          return _maintenanceDefaultConfig();
        }
        return _maintenanceNormalizeConfig(snap.data() || {});
      }
      async function _maintenanceCheckNow(reason, opts = {}){
        const force = !!opts.force;
        const silent = !!opts.silent;
        const now = Date.now();
        if (!force && (now - (_maintenanceState.lastCheckAt || 0)) < 1200){
          _maintenanceRenderOverlay();
          _maintenanceRenderAdminForm();
          return;
        }
        _maintenanceState.lastCheckAt = now;
        try{
          const cfg = await _maintenanceFetchConfig();
          _maintenanceState.config = _maintenanceNormalizeConfig(cfg);
          _maintenanceState.loaded = true;
        }catch(err){
          if (!_maintenanceState.loaded){
            _maintenanceState.config = _maintenanceDefaultConfig();
          }
          if (!silent){
            const msg = String(err?.message || err || "");
            _maintenanceSetAdminStatus(`: ${msg}`, "error");
            _maintenanceSetOverlayStatus(`: ${msg}`, "error");
          }
        }
        _maintenanceRenderAdminForm();
        _maintenanceRenderOverlay();
      }
      function _maintenanceStopPolling(){
        if (_maintenanceState.pollTimer){
          clearInterval(_maintenanceState.pollTimer);
          _maintenanceState.pollTimer = 0;
        }
        _maintenanceState.polling = false;
      }
      function _maintenanceStartPolling(){
        if (_maintenanceState.pollTimer) return;
        if (document.visibilityState === "hidden") return;
        _maintenanceState.polling = true;
        _maintenanceState.pollTimer = setInterval(() => {
          if (document.visibilityState === "hidden") return;
          _maintenanceCheckNow("poll", { silent: true });
        }, MAINTENANCE_POLL_MS);
      }
      function _maintenanceBindVisibility(){
        if (_maintenanceState.visibilityBound) return;
        _maintenanceState.visibilityBound = true;
        document.addEventListener("visibilitychange", () => {
          if (document.visibilityState === "hidden"){
            _maintenanceStopPolling();
            return;
          }
          _maintenanceCheckNow("visible", { silent: true, force: true });
          _maintenanceStartPolling();
        });
      }
      async function _maintenanceBootstrap(){
        await _maintenanceCheckNow("boot", { silent: true, force: true });
        _maintenanceBindVisibility();
        _maintenanceStartPolling();
      }
      function _maintenanceUpdatedBy(){
        const uid = String(_adminState.user?.uid || "").trim();
        const email = String(_adminState.user?.email || "").trim();
        if (uid && email) return `${uid}:${email}`;
        if (email) return email;
        const aid = _authDisplayId(authState.user);
        return String(aid || "admin");
      }
      async function _maintenanceSaveFromAdmin(){
        if (!_adminState.isAdmin){
          _maintenanceSetAdminStatus("Admin", "error");
          return;
        }
        let form;
        try{
          form = _maintenanceReadAdminForm();
        }catch(err){
          _maintenanceSetAdminStatus(String(err?.message || err), "error");
          return;
        }
        _maintenanceState.saving = true;
        _maintenanceSetAdminBusy(true);
        _maintenanceSetAdminStatus("");
        showLoading("");
        try{
          const db = _adminGetDb();
          const payload = {
            enabled: !!form.enabled,
            startAt: Number(form.startAt || 0),
            endAt: Number(form.endAt || 0),
            title: String(form.title || ""),
            message: String(form.message || ""),
            updatedAt: Date.now(),
            updatedBy: _maintenanceUpdatedBy()
          };
          await db.collection(MAINTENANCE_COLLECTION).doc(MAINTENANCE_DOC_ID).set(payload, { merge: true });
          _maintenanceState.config = _maintenanceNormalizeConfig(payload);
          _maintenanceState.loaded = true;
          _maintenanceState.bypass = false;
          _maintenanceSetAdminStatus("", "ok");
          uiToast("");
          _maintenanceRenderAdminForm();
          _maintenanceRenderOverlay();
        }catch(err){
          const code = String(err?.code || "ERROR");
          const msg = String(err?.message || err);
          if (code === "permission-denied"){
            _maintenanceSetAdminStatus(": permission-denied / Firestore Rules appConfig/maintenance  write admin", "error");
          }else{
            _maintenanceSetAdminStatus(`: ${code} / ${msg}`, "error");
          }
        }finally{
          _maintenanceState.saving = false;
          _maintenanceSetAdminBusy(false);
          hideLoading();
        }
      }
      async function _maintenanceClearExpiredFlagFromAdmin(){
        if (!_adminState.isAdmin){
          _maintenanceSetAdminStatus("Admin", "error");
          return;
        }
        const cfg = _maintenanceNormalizeConfig(_maintenanceState.config || _maintenanceDefaultConfig());
        if (!cfg.enabled){
          _maintenanceSetAdminStatus("enabled  false ");
          return;
        }
        if ((Number(cfg.endAt) || 0) > Date.now()){
          _maintenanceSetAdminStatus("", "error");
          return;
        }
        _maintenanceState.saving = true;
        _maintenanceSetAdminBusy(true);
        _maintenanceSetAdminStatus("");
        showLoading("");
        try{
          const db = _adminGetDb();
          const payload = {
            enabled: false,
            updatedAt: Date.now(),
            updatedBy: _maintenanceUpdatedBy()
          };
          await db.collection(MAINTENANCE_COLLECTION).doc(MAINTENANCE_DOC_ID).set(payload, { merge: true });
          _maintenanceState.config = _maintenanceNormalizeConfig({ ...cfg, ...payload });
          _maintenanceState.bypass = false;
          _maintenanceSetAdminStatus("enabled  false ", "ok");
          uiToast("");
          _maintenanceRenderAdminForm();
          _maintenanceRenderOverlay();
        }catch(err){
          const code = String(err?.code || "ERROR");
          const msg = String(err?.message || err);
          if (code === "permission-denied"){
            _maintenanceSetAdminStatus(": permission-denied / Firestore Rules appConfig/maintenance  write admin", "error");
          }else{
            _maintenanceSetAdminStatus(`: ${code} / ${msg}`, "error");
          }
        }finally{
          _maintenanceState.saving = false;
          _maintenanceSetAdminBusy(false);
          hideLoading();
        }
      }
      async function _adminStartLoginFlow(loginBtn, statusFn){
        const setStatus = (typeof statusFn === "function") ? statusFn : _adminSetStatus;
        _adminEnsureAuthWatcher();
        const env = _adminCheckAuthEnvironment();
        if (!env.ok){
          setStatus(env.reason, "error");
          return false;
        }
        let auth;
        try{
          auth = _adminGetAuth();
        }catch(err){
          setStatus(`Firebase: ${String(err?.message || err)}`, "error");
          return false;
        }
        try{
          if (loginBtn) loginBtn.disabled = true;
          setStatus("Google");
          const provider = new window.firebase.auth.GoogleAuthProvider();
          const result = await auth.signInWithPopup(provider);
          const user = (result && result.user) ? result.user : auth.currentUser;
          _adminState.user = user || null;
          _adminState.isAdmin = _adminUserIsAdmin(user);
          if (_adminState.isAdmin){
            setStatus("Admin", "ok");
            _maintenanceSetOverlayStatus("", "ok");
            return true;
          }
          const signedEmail = String(user?.email || "").trim();
          setStatus(`: ${signedEmail || ""}`, "error");
          _maintenanceSetOverlayStatus("", "error");
          return false;
        }catch(err){
          const code = String(err?.code || "AUTH_ERROR");
          const msg = String(err?.message || "");
          const fallbackCodes = new Set([
            "auth/popup-blocked",
            "auth/web-storage-unsupported",
            "auth/operation-not-supported-in-this-environment"
          ]);
          if (fallbackCodes.has(code) && typeof auth.signInWithRedirect === "function"){
            try{
              setStatus(` (${code})`);
              const provider = new window.firebase.auth.GoogleAuthProvider();
              await auth.signInWithRedirect(provider);
              return true;
            }catch(err2){
              const code2 = String(err2?.code || "AUTH_ERROR");
              const msg2 = String(err2?.message || "");
              setStatus(`: ${code2} / ${msg2}`, "error");
              return false;
            }
          }
          setStatus(`: ${code} / ${msg}`, "error");
          return false;
        }finally{
          if (loginBtn) loginBtn.disabled = false;
          _adminRenderUI();
          _maintenanceRenderOverlay();
        }
      }
      function _adminGetDb(){
        if (_adminState.db) return _adminState.db;
        _adminState.db = _drawerShareGetDb();
        return _adminState.db;
      }
      function _adminGetAuth(){
        if (_adminState.auth) return _adminState.auth;
        if (!window.firebase || typeof window.firebase.auth !== "function"){
          throw new Error("Firebase Auth SDK ");
        }
        _adminGetDb(); // app
        _adminState.auth = window.firebase.auth();
        return _adminState.auth;
      }
      function _adminCheckAuthEnvironment(){
        const proto = String(location.protocol || "");
        if (!/^https?:$/.test(proto) && proto !== "chrome-extension:"){
          return {
            ok: false,
            reason: `Googleprotocol=${proto || "unknown"}https`
          };
        }
        try{
          const k = "__admin_auth_probe__";
          window.localStorage.setItem(k, "1");
          window.localStorage.removeItem(k);
        }catch{
          return {
            ok: false,
            reason: "Web StorageCookie/"
          };
        }
        return { ok: true, reason: "" };
      }
      async function _adminHandleRedirectResult(){
        let auth;
        try{
          auth = _adminGetAuth();
        }catch{
          return;
        }
        if (!auth || typeof auth.getRedirectResult !== "function") return;
        try{
          const result = await auth.getRedirectResult();
          if (result && result.user){
            _adminState.user = result.user;
            _adminState.isAdmin = _adminUserIsAdmin(result.user);
            if (_adminState.isAdmin){
              _adminSetStatus("Google", "ok");
              _maintenanceSetOverlayStatus("", "ok");
            }else{
              const signedEmail = String(result.user?.email || "").trim();
              _adminSetStatus(`: ${signedEmail || ""}`, "error");
              _maintenanceSetOverlayStatus("", "error");
            }
            _adminRenderUI();
          }
        }catch(err){
          const code = String(err?.code || "AUTH_ERROR");
          const msg = String(err?.message || "");
          _adminSetStatus(`: ${code} / ${msg}`, "error");
        }
      }
      function _adminRenderUI(){
        const stateLine = document.getElementById("adminAuthStateLine");
        const roleLine = document.getElementById("adminAuthRoleLine");
        const loginBtn = document.getElementById("adminLoginBtn");
        const logoutBtn = document.getElementById("adminLogoutBtn");
        const openEditorBtn = document.getElementById("adminOpenNotifEditorBtn");
        const openHelpBtn = document.getElementById("adminOpenHelpEditorBtn");
        const maintenanceGroup = document.getElementById("adminMaintenanceGroup");
        const maintenanceLockedNote = document.getElementById("adminMaintenanceLockedNote");
        const maintenancePreview = document.getElementById("adminMaintenancePreview");
        const aiIngestGroup = document.getElementById("adminAiIngestGroup");
        const aiIngestLockedNote = document.getElementById("adminAiIngestLockedNote");
        const mainPane = document.getElementById("settingsMainPane");
        const editorPane = document.getElementById("adminNotifEditor");
        const titleEl = document.getElementById("settingsNavTitle");
        const email = String(_adminState.user?.email || "").trim();
        if (stateLine){
          stateLine.textContent = email ? `: ${email}` : "";
        }
        if (roleLine){
          roleLine.textContent = _adminState.isAdmin ? ": Admin" : ": User";
        }
        if (loginBtn) loginBtn.disabled = !!email;
        if (logoutBtn) logoutBtn.disabled = !email;
        if (openEditorBtn) openEditorBtn.classList.toggle("hidden", !_adminState.isAdmin);
        if (openHelpBtn) openHelpBtn.classList.toggle("hidden", !_adminState.isAdmin);
        if (maintenanceGroup) maintenanceGroup.classList.toggle("hidden", !_adminState.isAdmin);
        if (maintenanceLockedNote) maintenanceLockedNote.classList.toggle("hidden", !!_adminState.isAdmin);
        if (maintenancePreview) maintenancePreview.classList.toggle("hidden", !_adminState.isAdmin);
        if (aiIngestGroup) aiIngestGroup.classList.toggle("hidden", !_adminState.isAdmin);
        if (aiIngestLockedNote) aiIngestLockedNote.classList.toggle("hidden", !!_adminState.isAdmin);
        _adminSetAiIngestBusy(_adminState.aiIngestBusy);
        if (!_adminState.isAdmin && _adminState.editorOpen){
          _adminState.editorOpen = false;
        }
        if (mainPane && editorPane){
          mainPane.classList.toggle("hidden", !!_adminState.editorOpen);
          editorPane.classList.toggle("hidden", !_adminState.editorOpen);
        }
        if (titleEl && !el.settingsOverlay?.classList.contains("hidden")){
          titleEl.textContent = _adminState.editorOpen ? "" : (_settingsTitleMap[_settingsCurrentPage()] || "");
        }
        _settingsRefreshSummary();
        _maintenanceRenderAdminForm();
        _maintenanceRenderOverlay();
        try{ _appSyncInboxAdminButton(); }catch{}
      }
      function _adminEnsureAuthWatcher(){
        if (_adminState.authWatchStarted) return;
        try{
          const auth = _adminGetAuth();
          _adminState.authWatchStarted = true;
          _adminHandleRedirectResult();
          auth.onAuthStateChanged((user) => {
            _adminState.user = user || null;
            _adminState.isAdmin = _adminUserIsAdmin(user);
            _adminRenderUI();
          });
        }catch(err){
          _adminSetStatus(`Admin: ${String(err?.message || err)}`, "error");
        }
      }
      function _adminShowEditor(open){
        const mainPane = document.getElementById("settingsMainPane");
        const editorPane = document.getElementById("adminNotifEditor");
        if (!mainPane || !editorPane){
          _adminSetStatus("UI", "error");
          return false;
        }
        if (open && !_adminState.isAdmin){
          _adminSetStatus("Admin", "error");
          return false;
        }
        const wasOpen = !!_adminState.editorOpen;
        _adminState.editorOpen = !!open;
        if (!open && wasOpen){
          _settingsApplyPage("admin");
          _settingsState.stack = ["root", "admin"];
        }
        _adminRenderUI();
        return true;
      }
      async function _adminIngestRagDocs(){
        if (!_adminState.isAdmin){
          _adminSetAiIngestStatus("Admin", "error");
          return;
        }
        const keyEl = document.getElementById("adminAiIngestKey");
        const jsonEl = document.getElementById("adminAiIngestJson");
        const adminKey = String(keyEl?.value || "").trim();
        const raw = String(jsonEl?.value || "").trim();
        if (!adminKey){
          _adminSetAiIngestStatus("Admin Key ", "error");
          return;
        }
        if (!raw){
          _adminSetAiIngestStatus("JSON", "error");
          return;
        }
        let parsed;
        try{
          parsed = JSON.parse(raw);
        }catch(err){
          _adminSetAiIngestStatus(`JSON: ${String(err?.message || err)}`, "error");
          return;
        }
        const docs = Array.isArray(parsed) ? parsed : (Array.isArray(parsed?.docs) ? parsed.docs : []);
        if (!docs.length){
          _adminSetAiIngestStatus("docs ", "error");
          return;
        }
        _adminSetAiIngestBusy(true);
        _adminSetAiIngestStatus("RAG");
        showLoading("RAG");
        try{
          const headers = { "Content-Type": "application/json" };
          const authToken = (typeof _authGetToken === "function") ? String(_authGetToken() || "").trim() : "";
          if (authToken){
            headers.Authorization = `Bearer ${authToken}`;
          }
          const res = await fetch(CHAT_AI_INGEST_URL, {
            method: "POST",
            headers,
            body: JSON.stringify({ adminKey, docs })
          });
          const txt = await res.text();
          let body = null;
          try{ body = txt ? JSON.parse(txt) : {}; }catch{ body = {}; }
          if (!res.ok){
            _adminSetAiIngestStatus(`: ${String(body?.code || res.status)} / ${String(body?.message || txt || "")}`, "error");
            return;
          }
          const inserted = Math.max(0, Number(body?.inserted || 0));
          const chunks = Math.max(0, Number(body?.chunks || inserted));
          _adminSetAiIngestStatus(`: ${inserted}${chunks}`, "ok");
          uiToast(`RAG: ${inserted}`);
        }catch(err){
          _adminSetAiIngestStatus(`: ${String(err?.message || err)}`, "error");
        }finally{
          _adminSetAiIngestBusy(false);
          hideLoading();
        }
      }
      function _adminClearNotifForm(){
        const idEl = document.getElementById("adminNotifDocId");
        const titleEl = document.getElementById("adminNotifTitle");
        const bodyEl = document.getElementById("adminNotifBody");
        const categoryEl = document.getElementById("adminNotifCategory");
        const priorityEl = document.getElementById("adminNotifPriority");
        const publishedEl = document.getElementById("adminNotifPublishedAt");
        const saveBtn = document.getElementById("adminNotifSaveBtn");
        const cancelBtn = document.getElementById("adminNotifCancelEditBtn");
        if (idEl) idEl.value = "";
        if (titleEl) titleEl.value = "";
        if (bodyEl) bodyEl.value = "";
        if (categoryEl) categoryEl.value = "Update";
        if (priorityEl) priorityEl.value = "normal";
        if (publishedEl) publishedEl.value = "";
        if (saveBtn) saveBtn.textContent = "";
        if (cancelBtn) cancelBtn.classList.add("hidden");
      }
      function _adminFillNotifForm(item){
        const n = _notifNormalizeItem(item);
        if (!n) return;
        const idEl = document.getElementById("adminNotifDocId");
        const titleEl = document.getElementById("adminNotifTitle");
        const bodyEl = document.getElementById("adminNotifBody");
        const categoryEl = document.getElementById("adminNotifCategory");
        const priorityEl = document.getElementById("adminNotifPriority");
        const publishedEl = document.getElementById("adminNotifPublishedAt");
        const saveBtn = document.getElementById("adminNotifSaveBtn");
        const cancelBtn = document.getElementById("adminNotifCancelEditBtn");
        if (idEl) idEl.value = n.id;
        if (titleEl) titleEl.value = n.title;
        if (bodyEl) bodyEl.value = n.body;
        if (categoryEl) categoryEl.value = n.category;
        if (priorityEl) priorityEl.value = n.priority;
        if (publishedEl) publishedEl.value = _toLocalDateTimeInput(n.publishedAtMs || n.ts || Date.now());
        if (saveBtn) saveBtn.textContent = "";
        if (cancelBtn) cancelBtn.classList.remove("hidden");
      }
      function _adminReadNotifForm(){
        const idEl = document.getElementById("adminNotifDocId");
        const titleEl = document.getElementById("adminNotifTitle");
        const bodyEl = document.getElementById("adminNotifBody");
        const categoryEl = document.getElementById("adminNotifCategory");
        const priorityEl = document.getElementById("adminNotifPriority");
        const publishedEl = document.getElementById("adminNotifPublishedAt");
        if (!idEl || !titleEl || !bodyEl || !categoryEl || !priorityEl || !publishedEl){
          throw new Error("UI");
        }
        const title = String(titleEl.value || "").trim();
        const body = String(bodyEl.value || "").trim();
        if (!title) throw new Error("title ");
        if (!body) throw new Error("body ");
        const publishedAtMs = _parseLocalDateTimeInput(publishedEl.value) || Date.now();
        return {
          id: String(idEl.value || "").trim(),
          title,
          body,
          category: _notifNormalizeCategory(categoryEl.value),
          priority: _notifNormalizePriority(priorityEl.value),
          publishedAtMs
        };
      }
      function _adminRenderNotifList(){
        const listEl = document.getElementById("adminNotifList");
        const emptyEl = document.getElementById("adminNotifEmpty");
        if (!listEl || !emptyEl){
          _adminSetNotifStatus("UI", "error");
          return;
        }
        const list = Array.isArray(_adminState.notifItems) ? _adminState.notifItems.slice() : [];
        listEl.innerHTML = "";
        if (!list.length){
          emptyEl.classList.remove("hidden");
          return;
        }
        emptyEl.classList.add("hidden");
        const frag = document.createDocumentFragment();
        for (const n of list){
          const item = document.createElement("article");
          item.className = "admin-notif-item";
          const title = document.createElement("div");
          title.className = "admin-notif-title";
          title.textContent = n.title || "(untitled)";
          const meta = document.createElement("div");
          meta.className = "admin-notif-meta";
          const publishedText = n.ts ? formatDateTime(n.ts) : "";
          meta.innerHTML = `<span>${escapeHtml(n.category || "Update")}</span><span>${escapeHtml(n.priority || "normal")}</span><span>${escapeHtml(publishedText)}</span>`;
          const body = document.createElement("div");
          body.className = "admin-notif-body";
          body.textContent = String(n.body || "");
          const actions = document.createElement("div");
          actions.className = "admin-notif-item-actions";
          const editBtn = document.createElement("button");
          editBtn.type = "button";
          editBtn.className = "textbtn";
          editBtn.textContent = "";
          editBtn.dataset.adminNotifAction = "edit";
          editBtn.dataset.id = n.id;
          const delBtn = document.createElement("button");
          delBtn.type = "button";
          delBtn.className = "textbtn";
          delBtn.textContent = "";
          delBtn.dataset.adminNotifAction = "delete";
          delBtn.dataset.id = n.id;
          actions.appendChild(editBtn);
          actions.appendChild(delBtn);
          item.appendChild(title);
          item.appendChild(meta);
          item.appendChild(body);
          item.appendChild(actions);
          frag.appendChild(item);
        }
        listEl.appendChild(frag);
      }
      async function _fetchNotificationsFromFirestore(){
        showLoading("");
        try{
          const db = _adminGetDb();
          const map = new Map();
          let successCount = 0;
          const tryQuery = async (field) => {
            try{
              const snap = await db.collection("notifications").orderBy(field, "desc").limit(NOTIF_MAX).get();
              successCount++;
              snap.forEach((doc) => {
                const item = _notifFromDoc(doc);
                if (!item) return;
                map.set(item.id, item);
              });
            }catch(_){}
          };
          await tryQuery("publishedAt");
          await tryQuery("createdAt");
          if (!successCount){
            const snap = await db.collection("notifications").limit(NOTIF_MAX).get();
            snap.forEach((doc) => {
              const item = _notifFromDoc(doc);
              if (!item) return;
              map.set(item.id, item);
            });
          }
          const list = Array.from(map.values())
            .filter(n => n && n.id)
            .sort((a,b) => (b.ts || 0) - (a.ts || 0))
            .slice(0, NOTIF_MAX);
          saveNotifications(list);
          return list;
        } finally {
          hideLoading();
        }
      }
      async function _refreshNotificationsFromFirestore(options){
        const opt = options || {};
        const list = await _fetchNotificationsFromFirestore();
        updateNotifyDot();
        if (el.notifyOverlay && !el.notifyOverlay.classList.contains("hidden")){
          renderNotifyList();
          _notifMarkSeenByList(list);
          renderNotifyList();
          updateNotifyDot();
        }
        if (opt.forAdmin){
          _adminState.notifItems = list.slice();
          _adminRenderNotifList();
        }
        return list;
      }
      function updateNotifyDot(){
        if (!el.notifyDot) return;
        const seenAt = _notifSeenAt();
        const list = loadNotifications();
        const unread = list.some(n => (Number(n?.ts) || 0) > seenAt);
        el.notifyDot.classList.toggle("hidden", !unread);
      }
      const _notifyDetailState = {
        activeId: "",
        players: [],
        cleanups: []
      };
      function _notifySafeUrl(raw){
        const s = String(raw || "").trim();
        if (!s) return "";
        try{
          const u = new URL(s, location.href);
          const p = String(u.protocol || "").toLowerCase();
          if (p === "http:" || p === "https:"){
            return u.href;
          }
        }catch{
          // noop
        }
        return "";
      }
      function _notifyPreviewText(body){
        let txt = String(body || "");
        txt = txt.replace(/\r\n?/g, "\n");
        txt = txt.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, "$1");
        txt = txt.replace(/\[video\]\(([^)]+)\)/gi, "[video]");
        txt = txt.replace(/\[([^\]]+)\]\(([^)]+)\)/g, "$1");
        txt = txt.replace(/^##\s+/gm, "");
        txt = txt.replace(/\*\*([^*]+)\*\*/g, "$1");
        txt = txt.replace(/\s+/g, " ").trim();
        return txt;
      }
      function _notifyTimeText(sec){
        const n = Number(sec);
        if (!Number.isFinite(n) || n < 0) return "00:00";
        const s = Math.floor(n);
        const mm = String(Math.floor(s / 60)).padStart(2, "0");
        const ss = String(s % 60).padStart(2, "0");
        return `${mm}:${ss}`;
      }
      function _notifyAddCleanup(fn){
        if (typeof fn !== "function") return;
        _notifyDetailState.cleanups.push(fn);
      }
      function _notifyPauseOtherVideos(exceptVideo){
        for (const p of _notifyDetailState.players){
          if (!p || !p.video || p.video === exceptVideo) continue;
          try{ p.video.pause(); }catch{}
          try{ if (p.playBtn) p.playBtn.textContent = ""; }catch{}
        }
      }
      function _notifyDestroyDetailMedia(){
        for (const p of _notifyDetailState.players){
          if (!p || !p.video) continue;
          try{ p.video.pause(); }catch{}
          try{ p.video.removeAttribute("src"); p.video.load(); }catch{}
        }
        _notifyDetailState.players = [];
        for (const fn of _notifyDetailState.cleanups){
          try{ fn(); }catch{}
        }
        _notifyDetailState.cleanups = [];
      }
      function _notifyShowListPane(){
        _notifyDestroyDetailMedia();
        _notifyDetailState.activeId = "";
        if (el.notifyDetailContent) el.notifyDetailContent.replaceChildren();
        if (el.notifyDetailTitle) el.notifyDetailTitle.textContent = "";
        if (el.notifyDetailMeta) el.notifyDetailMeta.textContent = "";
        if (el.notifyListPane) el.notifyListPane.classList.remove("hidden");
        if (el.notifyDetailPane) el.notifyDetailPane.classList.add("hidden");
      }
      function _notifyAppendInlineMarkdown(parent, text){
        const src = String(text || "");
        const tokenRe = /(\*\*([^*]+)\*\*|\[([^\]]+)\]\(([^)]+)\))/g;
        let last = 0;
        let m;
        while ((m = tokenRe.exec(src))){
          if (m.index > last){
            parent.appendChild(document.createTextNode(src.slice(last, m.index)));
          }
          if (m[2] != null){
            const strong = document.createElement("strong");
            strong.textContent = m[2];
            parent.appendChild(strong);
          } else {
            const label = String(m[3] || "");
            const url = _notifySafeUrl(m[4] || "");
            if (!url){
              const bad = document.createElement("span");
              bad.className = "notify-invalid";
              bad.textContent = `: ${label || "link"}`;
              parent.appendChild(bad);
            } else {
              const a = document.createElement("a");
              a.href = url;
              a.target = "_blank";
              a.rel = "noopener noreferrer";
              a.textContent = label || url;
              parent.appendChild(a);
            }
          }
          last = tokenRe.lastIndex;
        }
        if (last < src.length){
          parent.appendChild(document.createTextNode(src.slice(last)));
        }
      }
      function _notifyCreateImageBlock(alt, rawUrl){
        const wrap = document.createElement("div");
        wrap.className = "notify-media";
        const safe = _notifySafeUrl(rawUrl);
        if (!safe){
          const bad = document.createElement("div");
          bad.className = "notify-invalid";
          bad.textContent = "URL";
          wrap.appendChild(bad);
          return wrap;
        }
        const img = document.createElement("img");
        img.loading = "lazy";
        img.decoding = "async";
        img.alt = String(alt || "");
        img.src = safe;
        const err = document.createElement("div");
        err.className = "notify-invalid hidden";
        err.textContent = "";
        const onErr = () => {
          err.classList.remove("hidden");
          img.classList.add("hidden");
        };
        img.addEventListener("error", onErr);
        _notifyAddCleanup(() => img.removeEventListener("error", onErr));
        wrap.appendChild(img);
        wrap.appendChild(err);
        return wrap;
      }
      function _notifyCreateVideoBlock(rawUrl){
        const safe = _notifySafeUrl(rawUrl);
        const wrap = document.createElement("div");
        wrap.className = "notify-video";
        if (!safe){
          const bad = document.createElement("div");
          bad.className = "notify-invalid";
          bad.textContent = "URL";
          wrap.appendChild(bad);
          return wrap;
        }
        const video = document.createElement("video");
        video.className = "notify-video-screen";
        video.src = safe;
        video.preload = "metadata";
        video.playsInline = true;
        video.setAttribute("playsinline", "");
        const controls = document.createElement("div");
        controls.className = "notify-video-controls";
        const row = document.createElement("div");
        row.className = "notify-video-row";
        const playBtn = document.createElement("button");
        playBtn.type = "button";
        playBtn.className = "textbtn";
        playBtn.textContent = "";
        const muteBtn = document.createElement("button");
        muteBtn.type = "button";
        muteBtn.className = "textbtn";
        muteBtn.textContent = "";
        const time = document.createElement("div");
        time.className = "notify-video-time";
        time.textContent = "00:00 / 00:00";
        const seek = document.createElement("input");
        seek.type = "range";
        seek.className = "notify-video-seek";
        seek.min = "0";
        seek.max = "1000";
        seek.step = "1";
        seek.value = "0";
        const err = document.createElement("div");
        err.className = "notify-invalid hidden";
        err.textContent = "";

        const updateTime = () => {
          const cur = Number(video.currentTime) || 0;
          const dur = Number(video.duration);
          const durTxt = Number.isFinite(dur) && dur > 0 ? _notifyTimeText(dur) : "00:00";
          time.textContent = `${_notifyTimeText(cur)} / ${durTxt}`;
          if (Number.isFinite(dur) && dur > 0){
            seek.value = String(Math.max(0, Math.min(1000, Math.round((cur / dur) * 1000))));
          } else {
            seek.value = "0";
          }
        };
        const onPlay = () => {
          _notifyPauseOtherVideos(video);
          playBtn.textContent = "";
        };
        const onPause = () => { playBtn.textContent = ""; };
        const onEnded = () => {
          playBtn.textContent = "";
          seek.value = "0";
        };
        const onErr = () => { err.classList.remove("hidden"); };
        const onPlayClick = async () => {
          try{
            if (video.paused) await video.play();
            else video.pause();
          }catch{}
        };
        const onMuteClick = () => {
          video.muted = !video.muted;
          muteBtn.textContent = video.muted ? "" : "";
        };
        const onSeekInput = () => {
          const dur = Number(video.duration);
          if (!Number.isFinite(dur) || dur <= 0) return;
          const ratio = (Number(seek.value) || 0) / 1000;
          video.currentTime = Math.max(0, Math.min(dur, dur * ratio));
          updateTime();
        };

        playBtn.addEventListener("click", onPlayClick);
        muteBtn.addEventListener("click", onMuteClick);
        seek.addEventListener("input", onSeekInput);
        video.addEventListener("loadedmetadata", updateTime);
        video.addEventListener("durationchange", updateTime);
        video.addEventListener("timeupdate", updateTime);
        video.addEventListener("play", onPlay);
        video.addEventListener("pause", onPause);
        video.addEventListener("ended", onEnded);
        video.addEventListener("error", onErr);

        _notifyAddCleanup(() => playBtn.removeEventListener("click", onPlayClick));
        _notifyAddCleanup(() => muteBtn.removeEventListener("click", onMuteClick));
        _notifyAddCleanup(() => seek.removeEventListener("input", onSeekInput));
        _notifyAddCleanup(() => video.removeEventListener("loadedmetadata", updateTime));
        _notifyAddCleanup(() => video.removeEventListener("durationchange", updateTime));
        _notifyAddCleanup(() => video.removeEventListener("timeupdate", updateTime));
        _notifyAddCleanup(() => video.removeEventListener("play", onPlay));
        _notifyAddCleanup(() => video.removeEventListener("pause", onPause));
        _notifyAddCleanup(() => video.removeEventListener("ended", onEnded));
        _notifyAddCleanup(() => video.removeEventListener("error", onErr));

        row.appendChild(playBtn);
        row.appendChild(muteBtn);
        row.appendChild(time);
        controls.appendChild(row);
        controls.appendChild(seek);
        wrap.appendChild(video);
        wrap.appendChild(controls);
        wrap.appendChild(err);
        _notifyDetailState.players.push({ video, playBtn });
        return wrap;
      }
      function _notifyRenderDetailContent(bodyRaw){
        const root = document.createDocumentFragment();
        const text = String(bodyRaw || "").replace(/\r\n?/g, "\n");
        const lines = text.split("\n");
        let paraLines = [];
        const flushParagraph = () => {
          if (!paraLines.length) return;
          const p = document.createElement("div");
          p.className = "notify-detail-text";
          paraLines.forEach((line, idx) => {
            if (idx > 0) p.appendChild(document.createElement("br"));
            _notifyAppendInlineMarkdown(p, line);
          });
          root.appendChild(p);
          paraLines = [];
        };
        for (const lineRaw of lines){
          const line = String(lineRaw || "");
          const h = line.match(/^##\s+(.+)$/);
          const img = line.match(/^!\[([^\]]*)\]\(([^)]+)\)\s*$/);
          const vid = line.match(/^\[video\]\(([^)]+)\)\s*$/i);
          if (h){
            flushParagraph();
            const heading = document.createElement("h3");
            _notifyAppendInlineMarkdown(heading, h[1]);
            root.appendChild(heading);
            continue;
          }
          if (img){
            flushParagraph();
            root.appendChild(_notifyCreateImageBlock(img[1], img[2]));
            continue;
          }
          if (vid){
            flushParagraph();
            root.appendChild(_notifyCreateVideoBlock(vid[1]));
            continue;
          }
          paraLines.push(line);
        }
        flushParagraph();
        if (!root.childNodes.length){
          const empty = document.createElement("div");
          empty.className = "notify-empty";
          empty.textContent = "";
          root.appendChild(empty);
        }
        return root;
      }
      function _notifyOpenDetail(idRaw){
        const id = String(idRaw || "").trim();
        if (!id || !el.notifyDetailPane || !el.notifyListPane){
          if (el.notifyEmpty){
            el.notifyEmpty.textContent = "UI";
            el.notifyEmpty.classList.remove("hidden");
          }
          return;
        }
        const list = loadNotifications();
        const item = list.find(n => String(n?.id || "") === id);
        if (!item){
          if (el.notifyEmpty){
            el.notifyEmpty.textContent = "";
            el.notifyEmpty.classList.remove("hidden");
          }
          return;
        }
        _notifyDestroyDetailMedia();
        _notifyDetailState.activeId = id;
        if (el.notifyDetailTitle) el.notifyDetailTitle.textContent = item.title || "(untitled)";
        if (el.notifyDetailMeta){
          const timeTxt = item.ts ? formatDateTime(item.ts) : "";
          el.notifyDetailMeta.innerHTML =
            `<span>${escapeHtml(item.category || "Update")}</span>` +
            `<span>${escapeHtml(item.priority || "normal")}</span>` +
            `<span>${escapeHtml(timeTxt)}</span>`;
        }
        if (el.notifyDetailContent){
          el.notifyDetailContent.replaceChildren();
          el.notifyDetailContent.appendChild(_notifyRenderDetailContent(item.body || ""));
        }
        el.notifyListPane.classList.add("hidden");
        el.notifyDetailPane.classList.remove("hidden");
      }
      function renderNotifyList(){
        if (!el.notifyList || !el.notifyEmpty) return;
        const seenAt = _notifSeenAt();
        const list = loadNotifications().sort((a,b) => (b.ts || 0) - (a.ts || 0));
        el.notifyList.replaceChildren();
        if (!list.length){
          el.notifyEmpty.textContent = "";
          el.notifyEmpty.classList.remove("hidden");
          return;
        }
        el.notifyEmpty.classList.add("hidden");
        const frag = document.createDocumentFragment();
        for (const n of list){
          const unread = (Number(n.ts) || 0) > seenAt;
          const item = document.createElement("div");
          item.className = "notify-item" + (unread ? " unread" : "");
          const h = document.createElement("h3");
          h.className = "notify-title";
          h.textContent = n.title || "(untitled)";
          const p = document.createElement("p");
          p.className = "notify-bodytext";
          p.textContent = _notifyPreviewText(n.body || "");
          const t = document.createElement("div");
          t.className = "notify-time";
          const timeTxt = n.ts ? formatDateTime(n.ts) : "";
          t.innerHTML = `<span class="ms" aria-hidden="true" style="font-size:16px; opacity:.8;">schedule</span><span>${escapeHtml(timeTxt)}</span>`;
          const actions = document.createElement("div");
          actions.className = "notify-actions";
          const detailBtn = document.createElement("button");
          detailBtn.type = "button";
          detailBtn.className = "textbtn";
          detailBtn.textContent = "";
          detailBtn.dataset.notifyAction = "detail";
          detailBtn.dataset.id = String(n.id || "");
          actions.appendChild(detailBtn);
          item.appendChild(h);
          item.appendChild(p);
          item.appendChild(t);
          item.appendChild(actions);
          frag.appendChild(item);
        }
        el.notifyList.appendChild(frag);
      }
      function openNotify(){
        if (!el.notifyOverlay){
          uiToast("UI");
          return;
        }
        _notifyShowListPane();
        el.notifyOverlay.classList.remove("hidden");
        renderNotifyList();
        const cached = loadNotifications();
        _notifMarkSeenByList(cached);
        renderNotifyList();
        updateNotifyDot();
        _refreshNotificationsFromFirestore()
          .catch((err) => {
            const msg = String(err?.message || err || "unknown error");
            if (el.notifyEmpty && (!cached || !cached.length)){
              el.notifyEmpty.textContent = `: ${msg}`;
              el.notifyEmpty.classList.remove("hidden");
            }
          });
      }
      function closeNotify(){
        if (!el.notifyOverlay) return;
        _notifyShowListPane();
        el.notifyOverlay.classList.add("hidden");
      }
      const BACKUP_LATEST_KEY = "app.backup.latest.v1";
      const BACKUP_LAST_RUN_DATE_KEY = "app.backup.lastRunDate.v1";
      const BACKUP_SCHEMA_VERSION = 1;
      const BACKUP_MAX_SESSIONS = 500;
      function _backupSetStatus(msg, kind){
        if (!el.backupStatus){
          if (msg) uiToast(String(msg));
          return;
        }
        el.backupStatus.textContent = String(msg || "");
        el.backupStatus.classList.remove("ok", "error");
        if (kind === "ok") el.backupStatus.classList.add("ok");
        if (kind === "error") el.backupStatus.classList.add("error");
      }
      function _backupYmd(ts){
        const n = Number(ts) || Date.now();
        const d = new Date(n);
        const y = d.getFullYear();
        const m = String(d.getMonth() + 1).padStart(2, "0");
        const da = String(d.getDate()).padStart(2, "0");
        return `${y}-${m}-${da}`;
      }
      function _backupDeepClone(v){
        try{
          return JSON.parse(JSON.stringify(v));
        }catch{
          return null;
        }
      }
      function _backupBuildPayload(){
        const presets = _backupDeepClone(loadPresets()) || [];
        const customSubjects = _backupDeepClone(loadCustomSubjects()) || [];
        const customTags = _backupDeepClone(loadCustomTags()) || [];
        const settings = _backupDeepClone(state.settings || loadSettings()) || { ...defaultSettings };
        const sessions = _backupDeepClone(_insightsLoadSessions()) || [];
        const shareCache = _backupDeepClone(_shareCacheLoad()) || {};
        const activePresetId = String((typeof getActivePresetId === "function" ? getActivePresetId() : state.presetId) || "");
        const seenAt = _notifSeenAt();
        const appVersion = (typeof APP_VERSION === "string" && APP_VERSION) ? APP_VERSION : "v26";
        return {
          schemaVersion: BACKUP_SCHEMA_VERSION,
          createdAt: Date.now(),
          appVersion,
          data: {
            presets,
            activePresetId,
            customSubjects,
            customTags,
            settings,
            sessions: Array.isArray(sessions) ? sessions.slice(-BACKUP_MAX_SESSIONS) : [],
            shareCache,
            notificationReadState: { seenAt: Number(seenAt) || 0 }
          }
        };
      }
      function _backupWriteLatest(payload, updateLastRunDate){
        if (!payload || typeof payload !== "object"){
          throw new Error("");
        }
        window.localStorage.setItem(BACKUP_LATEST_KEY, JSON.stringify(payload));
        if (updateLastRunDate){
          window.localStorage.setItem(BACKUP_LAST_RUN_DATE_KEY, _backupYmd(payload.createdAt || Date.now()));
        }
      }
      function _backupReadLatest(){
        try{
          const raw = window.localStorage.getItem(BACKUP_LATEST_KEY);
          if (!raw) return null;
          return JSON.parse(raw);
        }catch{
          return null;
        }
      }
      function _backupNormalizePayload(raw){
        if (!raw || typeof raw !== "object"){
          throw new Error("JSON");
        }
        const schemaVersion = Number(raw.schemaVersion || 0);
        if (schemaVersion !== BACKUP_SCHEMA_VERSION){
          throw new Error(`schemaVersion : ${schemaVersion}`);
        }
        const dataRaw = raw.data;
        if (!dataRaw || typeof dataRaw !== "object"){
          throw new Error("data ");
        }
        const presets = Array.isArray(dataRaw.presets) ? dataRaw.presets : [];
        const activePresetId = String(dataRaw.activePresetId || "");
        const customSubjects = Array.isArray(dataRaw.customSubjects) ? dataRaw.customSubjects : [];
        const customTags = Array.isArray(dataRaw.customTags) ? dataRaw.customTags : [];
        const settings = (dataRaw.settings && typeof dataRaw.settings === "object")
          ? dataRaw.settings
          : { ...defaultSettings };
        const sessions = Array.isArray(dataRaw.sessions) ? dataRaw.sessions.slice(-BACKUP_MAX_SESSIONS) : [];
        const shareCache = (dataRaw.shareCache && typeof dataRaw.shareCache === "object") ? dataRaw.shareCache : {};
        const seenAt = Number(dataRaw.notificationReadState?.seenAt || 0);
        return {
          schemaVersion: BACKUP_SCHEMA_VERSION,
          createdAt: Number(raw.createdAt || Date.now()) || Date.now(),
          appVersion: String(raw.appVersion || "v26"),
          data: {
            presets,
            activePresetId,
            customSubjects,
            customTags,
            settings,
            sessions,
            shareCache,
            notificationReadState: { seenAt: Number.isFinite(seenAt) ? seenAt : 0 }
          }
        };
      }
      function _backupCreateNow(options = {}){
        const payload = _backupBuildPayload();
        _backupWriteLatest(payload, !!options.updateLastRunDate);
        const stamp = formatDateTime(payload.createdAt);
        _backupSetStatus(`: ${stamp}`, "ok");
        if (!options.silentToast){
          uiToast(options.toastText || "");
        }
        return payload;
      }
      function _backupDownloadJson(payload){
        const obj = payload || _backupReadLatest() || _backupCreateNow({ silentToast: true, updateLastRunDate: false });
        const text = JSON.stringify(obj, null, 2);
        const blob = new Blob([text], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const d = new Date();
        const y = d.getFullYear();
        const m = String(d.getMonth() + 1).padStart(2, "0");
        const da = String(d.getDate()).padStart(2, "0");
        const hh = String(d.getHours()).padStart(2, "0");
        const mm = String(d.getMinutes()).padStart(2, "0");
        const a = document.createElement("a");
        a.href = url;
        a.download = `vocabuquiz_backup_${y}${m}${da}_${hh}${mm}.json`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }
      function _backupApplyPayload(payload){
        const normalized = _backupNormalizePayload(payload);
        const dataObj = normalized.data;
        window.localStorage.setItem(PRESETS_KEY, JSON.stringify(dataObj.presets || []));
        saveCustomSubjects(dataObj.customSubjects || []);
        saveCustomTags(dataObj.customTags || []);
        if (dataObj.activePresetId){
          window.localStorage.setItem(ACTIVE_PRESET_KEY, dataObj.activePresetId);
        }
        const normalizedSettings = normalizeSettings(dataObj.settings || { ...defaultSettings });
        window.localStorage.setItem(SETTINGS_KEY, JSON.stringify(normalizedSettings));
        window.localStorage.setItem(APP_SETTINGS_KEY, JSON.stringify(normalizedSettings));
        window.localStorage.setItem(INSIGHTS_SESSIONS_KEY, JSON.stringify(Array.isArray(dataObj.sessions) ? dataObj.sessions.slice(-BACKUP_MAX_SESSIONS) : []));
        window.localStorage.setItem(SHARE_CACHE_KEY, JSON.stringify(dataObj.shareCache || {}));
        const seenAt = Number(dataObj.notificationReadState?.seenAt || 0);
        if (seenAt > 0) window.localStorage.setItem(NOTIF_SEEN_KEY, String(seenAt));
        else window.localStorage.removeItem(NOTIF_SEEN_KEY);

        let deck = "";
        const pid = String(dataObj.activePresetId || "");
        if (pid.startsWith("builtin:")){
          const maybe = pid.split(":")[1] || "";
          if (maybe === "A" || maybe === "B" || maybe === "C" || maybe === "D" || maybe === "E" || maybe === "ALL") deck = maybe;
        }
        if (deck){
          window.localStorage.setItem(DECK_KEY, deck);
        }
        _backupWriteLatest(normalized, true);
      }
      async function _backupRestoreWithConfirm(payload, sourceLabel){
        const stamp = formatDateTime(Number(payload?.createdAt || Date.now()));
        const ok = await uiConfirm(
          `${sourceLabel} \n\n: ${stamp}\n\n`,
          {
            title: "",
            okText: "",
            cancelText: "",
            danger: true
          }
        );
        if (!ok) return false;
        try{
          _backupApplyPayload(payload);
          _backupSetStatus("", "ok");
          uiToast("");
          setTimeout(() => location.reload(), 120);
          return true;
        }catch(err){
          _backupSetStatus(`: ${String(err?.message || err)}`, "error");
          return false;
        }
      }
      async function _backupImportFromFile(file){
        if (!file) throw new Error("JSON");
        const text = await file.text();
        let parsed;
        try{
          parsed = JSON.parse(text);
        }catch{
          throw new Error("JSON");
        }
        const normalized = _backupNormalizePayload(parsed);
        return _backupRestoreWithConfirm(normalized, "JSON");
      }
      function _backupRunAutoDaily(){
        const today = _backupYmd(Date.now());
        const last = String(window.localStorage.getItem(BACKUP_LAST_RUN_DATE_KEY) || "");
        if (last === today) return false;
        const payload = _backupCreateNow({
          silentToast: true,
          updateLastRunDate: true
        });
        _backupSetStatus(`: ${formatDateTime(payload.createdAt)}`, "ok");
        uiToast("");
        return true;
      }
      function _backupScheduleAuto(){
        const run = () => {
          try{
            _backupRunAutoDaily();
          }catch(err){
            _backupSetStatus(`: ${String(err?.message || err)}`, "error");
          }
        };
        if (typeof requestIdleCallback === "function"){
          requestIdleCallback(() => run(), { timeout: 1500 });
        }else{
          setTimeout(run, 1200);
        }
      }
      function _removeStorageByPrefix(prefix){
        const p = String(prefix || "");
        if (!p) return;
        const keys = [];
        for (let i = 0; i < window.localStorage.length; i++){
          const k = window.localStorage.key(i);
          if (k && k.startsWith(p)) keys.push(k);
        }
        for (const k of keys){
          window.localStorage.removeItem(k);
        }
      }
      async function _settingsDeleteLogs(){
        const ok = await uiConfirm("", {
          title: "",
          okText: "",
          cancelText: "",
          danger: true
        });
        if (!ok) return;
        window.localStorage.removeItem(INSIGHTS_SESSIONS_KEY);
        _insightsSessionsCache = [];
        _insightsSessionsRev++;
        _insightsFilteredCacheKey = "";
        _insightsFilteredCache = null;
        _insightsFilterCacheMap.clear();
        _backupSetStatus("", "ok");
        uiToast("");
      }
      async function _settingsClearShareCache(){
        const ok = await uiConfirm("", {
          title: "",
          okText: "",
          cancelText: "",
          danger: true
        });
        if (!ok) return;
        window.localStorage.removeItem(SHARE_CACHE_KEY);
        _menuState.presetShare.entry = null;
        _backupSetStatus("", "ok");
        uiToast("");
      }
      async function _settingsFactoryReset(){
        const step1 = await uiConfirm("", {
          title: "",
          okText: "",
          cancelText: "",
          danger: true
        });
        if (!step1) return;
        const step2 = await uiConfirm("", {
          title: "",
          okText: "",
          cancelText: "",
          danger: true
        });
        if (!step2) return;
        try{
          window.localStorage.removeItem(PRESETS_KEY);
          window.localStorage.removeItem(ACTIVE_PRESET_KEY);
          window.localStorage.removeItem(SETTINGS_KEY);
          window.localStorage.removeItem(APP_SETTINGS_KEY);
          window.localStorage.removeItem(DECK_KEY);
          window.localStorage.removeItem(INSIGHTS_SESSIONS_KEY);
          window.localStorage.removeItem(SHARE_CACHE_KEY);
          window.localStorage.removeItem(NOTIF_SEEN_KEY);
          window.localStorage.removeItem(NOTIF_KEY);
          window.localStorage.removeItem(BACKUP_LATEST_KEY);
          window.localStorage.removeItem(BACKUP_LAST_RUN_DATE_KEY);
          _removeStorageByPrefix(EXAM_SET_KEY_PREFIX);
          _removeStorageByPrefix(CHOICE_SET_KEY_PREFIX);
          _removeStorageByPrefix("app.memoCheck.");
          _backupSetStatus("", "ok");
          uiToast("");
          setTimeout(() => location.reload(), 160);
        }catch(err){
          _backupSetStatus(`: ${String(err?.message || err)}`, "error");
        }
      }
      async function _adminReloadNotifications(silent){
        if (!_adminState.isAdmin){
          _adminSetNotifStatus("Admin", "error");
          return;
        }
        if (_adminState.loading) return;
        _adminState.loading = true;
        if (!silent) _adminSetNotifStatus("");
        try{
          const list = await _refreshNotificationsFromFirestore({ forAdmin: true });
          _adminState.notifItems = list.slice();
          _adminRenderNotifList();
          if (!silent) _adminSetNotifStatus(`: ${list.length}`, "ok");
        }catch(err){
          _adminSetNotifStatus(`: ${String(err?.code || "ERROR")} / ${String(err?.message || err)}`, "error");
        }finally{
          _adminState.loading = false;
        }
      }
      async function _adminSaveNotification(){
        if (!_adminState.isAdmin){
          _adminSetNotifStatus("Admin", "error");
          return;
        }
        let form;
        try{
          form = _adminReadNotifForm();
        }catch(err){
          _adminSetNotifStatus(String(err?.message || err), "error");
          return;
        }
        _adminSetNotifStatus(form.id ? "" : "");
        showLoading(form.id ? "" : "");
        try{
          const db = _adminGetDb();
          const fs = window.firebase?.firestore;
          if (!fs || !fs.FieldValue || !fs.Timestamp){
            throw new Error("Firestore SDK ");
          }
          const payloadBase = {
            title: form.title,
            body: form.body,
            category: form.category,
            priority: form.priority,
            publishedAt: fs.Timestamp.fromMillis(form.publishedAtMs || Date.now()),
            updatedAt: fs.FieldValue.serverTimestamp()
          };
          if (form.id){
            await db.collection("notifications").doc(form.id).set(payloadBase, { merge: true });
          }else{
            await db.collection("notifications").add({
              ...payloadBase,
              createdAt: fs.FieldValue.serverTimestamp()
            });
          }
          _adminClearNotifForm();
          await _adminReloadNotifications(true);
          _adminSetNotifStatus(form.id ? "" : "", "ok");
          uiToast(form.id ? "" : "");
        }catch(err){
          _adminSetNotifStatus(`: ${String(err?.code || "ERROR")} / ${String(err?.message || err)}`, "error");
        } finally {
          hideLoading();
        }
      }
      async function _adminDeleteNotification(docId){
        const id = String(docId || "").trim();
        if (!id){
          _adminSetNotifStatus("ID", "error");
          return;
        }
        if (!_adminState.isAdmin){
          _adminSetNotifStatus("Admin", "error");
          return;
        }
        const ok = await uiConfirm("", {
          title: "",
          okText: "",
          cancelText: "",
          danger: true
        });
        if (!ok) return;
        _adminSetNotifStatus("");
        showLoading("");
        try{
          const db = _adminGetDb();
          await db.collection("notifications").doc(id).delete();
          const currentId = String(document.getElementById("adminNotifDocId")?.value || "");
          if (currentId && currentId === id){
            _adminClearNotifForm();
          }
          await _adminReloadNotifications(true);
          _adminSetNotifStatus("", "ok");
          uiToast("");
        }catch(err){
          _adminSetNotifStatus(`: ${String(err?.code || "ERROR")} / ${String(err?.message || err)}`, "error");
        } finally {
          hideLoading();
        }
      }

      // =========================
      // Search dropdown
      // =========================
      let _searchDebTimer = null;
      let _searchResults = [];

      function _extractSearchId(q){
        const s = String(q||"").trim();
        if (!s) return null;
        const m = s.match(/^(?:no\.?|#)?\s*(\d+)\s*$/i);
        if (!m) return null;
        const n = Number(m[1]);
        return Number.isFinite(n) ? n : null;
      }

      function _searchNormalize(s){
        return String(s ?? "").toLowerCase();
      }

      function _presetLabelForSearch(preset){
        if (!preset) return "";
        const subjectLabel = subjectNameById(preset.subjectId || "sub:english");
        if (preset.builtin){
          if (preset.id === "builtin:A") return "Preset: 0-200";
          if (preset.id === "builtin:B") return "Preset: 200-400";
          if (preset.id === "builtin:C") return "Preset: 400-600";
          if (preset.id === "builtin:D") return "Preset: 600-800";
          if (preset.id === "builtin:E") return "Preset: 800-1000(801-1000)";
          return `Preset: ALL / ${subjectLabel}`;
        }
        return `My: ${preset.name || "My Preset"} / ${subjectLabel}`;
      }

      function _buildSearchIndexAll(){
        const items = [];
        const presetIds = ["builtin:A", "builtin:B", "builtin:C", "builtin:D", "builtin:E"];
        const user = loadPresets();
        for (const p of user) presetIds.push(p.id);

        const seen = new Set();
        for (const pid of presetIds){
          const preset = getPresetById(pid);
          if (!preset) continue;
          const label = _presetLabelForSearch(preset);
          const words = getPresetWords(pid) || [];
          for (const w of words){
            const key = `${pid}:${w.id}`;
            if (seen.has(key)) continue;
            seen.add(key);
            items.push({
              presetId: pid,
              presetLabel: label,
              id: w.id,
              word: w.word,
              meaning: w.meaning
            });
          }
        }
        items.sort((a,b)=> (a.id - b.id) || String(a.presetLabel).localeCompare(String(b.presetLabel)));
        return items;
      }

      function _getSearchIndexAll(){
        if (__searchIndexCache.rev === __presetsRev && Array.isArray(__searchIndexCache.items) && __searchIndexCache.items.length){
          return __searchIndexCache.items;
        }
        const items = _buildSearchIndexAll();
        __searchIndexCache = { rev: __presetsRev, items };
        return items;
      }

      function openSearch(){
        if (!el.searchOverlay) return;
        // Close notify if open to avoid overlap
        if (el.notifyOverlay && !el.notifyOverlay.classList.contains("hidden")) closeNotify();

        el.searchOverlay.classList.remove("hidden");
        if (el.searchEmpty) el.searchEmpty.classList.add("hidden");
        if (el.searchList) el.searchList.replaceChildren();

        if (el.searchInput){
          el.searchInput.value = "";
          // Render initial items (top 20)
          renderSearchResults("");
          setTimeout(() => { try{ el.searchInput.focus(); }catch{} }, 0);
        }
      }

      function closeSearch(){
        if (!el.searchOverlay) return;
        el.searchOverlay.classList.add("hidden");
        if (_searchDebTimer){ clearTimeout(_searchDebTimer); _searchDebTimer = null; }
        _searchResults = [];
      }

      function scheduleSearch(){
        if (_searchDebTimer) clearTimeout(_searchDebTimer);
        _searchDebTimer = setTimeout(() => {
          renderSearchResults(el.searchInput?.value || "");
        }, 100);
      }

      function renderSearchResults(query){
        const listEl = el.searchList;
        const emptyEl = el.searchEmpty;
        if (!listEl || !emptyEl) return;

        const words = getActiveWords();
        listEl.replaceChildren();
        _searchResults = [];

        if (!words || words.length === 0){
          emptyEl.textContent = "";
          emptyEl.classList.remove("hidden");
          return;
        }

        const q = String(query||"").trim();
        let results = [];

        const asId = _extractSearchId(q);
        if (asId != null){
          results = words.filter(w => Number(w.id) === asId).slice(0, 20);
        }else if (!q){
          results = words.slice(0, 20);
        }else{
          const ql = _searchNormalize(q);
          for (const w of words){
            const wl = _searchNormalize(w.word);
            const ml = _searchNormalize(w.meaning);
            if (wl.includes(ql) || ml.includes(ql)){
              results.push(w);
              if (results.length >= 20) break;
            }
          }
        }

        if (!results.length){
          emptyEl.textContent = "No results. ";
          emptyEl.classList.remove("hidden");
          return;
        }
        emptyEl.classList.add("hidden");

        _searchResults = results.slice();

        const frag = document.createDocumentFragment();
        for (const w of results){
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "search-item";
          btn.dataset.id = String(w.id);

          const row = document.createElement("div");
          row.className = "row";

          const no = document.createElement("div");
          no.className = "no";
          no.textContent = `No.${w.id}`;

          const word = document.createElement("div");
          word.className = "word";
          word.textContent = String(w.word || "");

          row.appendChild(no);
          row.appendChild(word);

          const meaning = document.createElement("div");
          meaning.className = "meaning";
          meaning.textContent = String(w.meaning || "");

          const preset = document.createElement("div");
          preset.className = "preset";
          preset.textContent = String(w.presetLabel || "");

          btn.appendChild(row);
          btn.appendChild(meaning);
          btn.appendChild(preset);
          frag.appendChild(btn);
        }
        listEl.appendChild(frag);
      }

      
      function openWordDetailFromSearch(w){
        if (!w) return;
        const dir = (state.settings && state.settings.direction) ? state.settings.direction : "EN_JA";
        const frontLabel = (dir === "JA_EN") ? "" : "";
        const backLabel  = (dir === "JA_EN") ? "" : "";
        const frontText = (dir === "JA_EN") ? String(w.meaning || "") : String(w.word || "");
        const backText  = (dir === "JA_EN") ? String(w.word || "") : String(w.meaning || "");

        const htmlStr = `
          <div style="display:grid; gap:12px;">
            <div style="display:flex; align-items:baseline; justify-content:space-between; gap:10px;">
              <div style="font-weight:800; letter-spacing:.01em;">No.${w.id}</div>
              <div style="font-size:12px; color:var(--muted);">Search</div>
            </div>

            <div style="display:grid; gap:10px;">
              <div style="font-size:12px; color:var(--muted);">${frontLabel}</div>
              <div style="font-size:22px; font-weight:800; line-height:1.25; letter-spacing:.01em;">${escapeHtml(frontText)}</div>

              <div style="margin-top:4px; padding:12px; border:1px solid rgba(17,18,20,.08); border-radius:14px; background:rgba(17,18,20,.03);">
                <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
                  <div style="font-size:12px; color:var(--muted);">${backLabel}</div>
                  <button id="wdToggleBtn" type="button" class="textbtn"></button>
                </div>
                <div id="wdAnswer" style="margin-top:8px; display:none;">
                  <div style="font-size:16px; line-height:1.5;">${escapeHtml(backText)}</div>
                </div>
              </div>
            </div>
          </div>
        `;

        uiHtml(htmlStr, { title:"", okText:"" });

        _runIdle(() => {
          const btn = document.getElementById("wdToggleBtn");
          const ans = document.getElementById("wdAnswer");
          if (!btn || !ans) return;

          let shown = false;
          btn.onclick = () => {
            shown = !shown;
            ans.style.display = shown ? "" : "none";
            btn.textContent = shown ? "" : "";
          };

          // When closing, restore focus back to search input if search is open
          uiModalOnClose(() => {
            try{
              if (el.searchOverlay && !el.searchOverlay.classList.contains("hidden") && el.searchInput){
                el.searchInput.focus();
              }
            }catch{}
            uiModalOnClose(null);
          });
        });
      }

function _openSearchResultByIndex(i){
        const w = _searchResults[i];
        if (!w) return;
        openWordDetailFromSearch(w);
      }

      const HOME_RESUME_KEY = "app.home.resume.v1";
      const APP_TAB_KEY = Object.freeze({
        HOME: "home",
        LIBRARY: "library",
        INBOX: "inbox",
        INSIGHT: "insight",
        CHAT: "chat"
      });
      const APP_TAB_LIST = Object.freeze([
        APP_TAB_KEY.HOME,
        APP_TAB_KEY.LIBRARY,
        APP_TAB_KEY.INBOX,
        APP_TAB_KEY.INSIGHT,
        APP_TAB_KEY.CHAT
      ]);
      const APP_TAB_ALIAS = Object.freeze({
        home: APP_TAB_KEY.HOME,
        library: APP_TAB_KEY.LIBRARY,
        inbox: APP_TAB_KEY.INBOX,
        insight: APP_TAB_KEY.INSIGHT,
        insights: APP_TAB_KEY.INSIGHT,
        chat: APP_TAB_KEY.CHAT
      });
      function _appNormalizeTabKey(tab){
        const k = String(tab || "").trim().toLowerCase();
        return APP_TAB_ALIAS[k] || APP_TAB_KEY.HOME;
      }
      let _appCurrentTab = APP_TAB_KEY.HOME;
      let _appInboxDetailId = "";
      const _appInboxRowById = new Map();
      const _appLibraryFilter = {
        subjectId: "ALL",
        tagIds: [],
        query: ""
      };

      function _appSetTopTitleByTab(tab){
        const titleEl = document.querySelector(".brand-title");
        const subEl = document.querySelector(".brand-sub");
        if (!titleEl || !subEl) return;
        titleEl.textContent = "VocabuQuiz";
        if (state.view !== "TITLE"){
          subEl.textContent = "v.1 Public";
          return;
        }
        if (tab === APP_TAB_KEY.HOME){
          subEl.textContent = "Quick Start";
        } else if (tab === APP_TAB_KEY.LIBRARY){
          subEl.textContent = "Preset";
        } else if (tab === APP_TAB_KEY.INBOX){
          subEl.textContent = "Notifications";
        } else if (tab === APP_TAB_KEY.INSIGHT){
          subEl.textContent = "Analytics";
        } else if (tab === APP_TAB_KEY.CHAT){
          subEl.textContent = "VQ AI mini-1";
        } else if (tab === "settings"){
          subEl.textContent = "Control";
        } else {
          subEl.textContent = "v.1 Public";
        }
      }

      function _appSaveResume(mode){
        try{
          const payload = {
            mode: String(mode || ""),
            presetId: String(getActivePresetId() || ""),
            deck: String(state.deck || "A"),
            ts: Date.now()
          };
          window.localStorage.setItem(HOME_RESUME_KEY, JSON.stringify(payload));
        }catch{}
      }
      function _appLoadResume(){
        try{
          const raw = window.localStorage.getItem(HOME_RESUME_KEY);
          if (!raw) return null;
          const obj = JSON.parse(raw);
          if (!obj || typeof obj !== "object") return null;
          const mode = String(obj.mode || "");
          if (mode !== "CHOICE" && mode !== "HAND") return null;
          return {
            mode,
            presetId: String(obj.presetId || ""),
            deck: String(obj.deck || "A")
          };
        }catch{
          return null;
        }
      }
      function _appSyncResumeButton(){
        if (!el.homeResumeBtn) return;
        const r = _appLoadResume();
        if (!r){
          el.homeResumeBtn.disabled = true;
          el.homeResumeBtn.textContent = "";
          return;
        }
        const modeLabel = r.mode === "CHOICE" ? "EXAM" : "WRITE";
        el.homeResumeBtn.disabled = false;
        el.homeResumeBtn.textContent = `${modeLabel}`;
      }

      function _appCurrentPresetInfo(){
        const pid = getActivePresetId();
        const preset = getPresetById(pid);
        const name = String(preset?.name || (isBuiltinPreset(pid) ? builtinNameFromDeck(deckFromBuiltinId(pid)) : "My Preset"));
        const words = getPresetWords(pid) || [];
        const count = Array.isArray(words) ? words.length : 0;
        const kind = isBuiltinPreset(pid) ? "builtin" : "My Preset";
        return { id: pid, name, count, kind };
      }

      function _appRenderHomeOverview(){
        const info = _appCurrentPresetInfo();
        if (el.homeActivePresetName) el.homeActivePresetName.textContent = info.name;
        if (el.homeActivePresetMeta){
          const preset = getPresetById(info.id);
          const subject = subjectNameById(preset?.subjectId || "sub:english");
          const tags = _normalizeTagIds(preset?.tagIds, { allowUnknown: false })
            .map((id) => getTagById(id)?.name)
            .filter(Boolean);
          const tagText = tags.length ? ` / ${tags.join(", ")}` : "";
          el.homeActivePresetMeta.textContent = `${info.count} / ${subject}${tagText}`;
        }
        _appSyncResumeButton();
      }

      function _appBuiltinDefs(){
        return [
          { id: "builtin:A", name: "0200" },
          { id: "builtin:B", name: "200400" },
          { id: "builtin:C", name: "400600" },
          { id: "builtin:D", name: "600800" },
          { id: "builtin:E", name: "80010008011000" },
          { id: "builtin:ALL", name: "ALL" }
        ];
      }

      function _appCreateActionButton(label, action, id, klass = "textbtn"){
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = klass;
        btn.textContent = label;
        btn.dataset.libAction = action;
        if (id != null) btn.dataset.id = String(id);
        return btn;
      }

      function _subjectBadgeEl(subjectId){
        const s = getSubjectById(subjectId || "sub:other");
        const elx = document.createElement("span");
        elx.className = "subject-badge";
        elx.textContent = s?.name || "Other";
        if (s?.color) elx.style.borderColor = s.color;
        return elx;
      }
      function _tagChipEl(name, selected){
        const b = document.createElement("button");
        b.type = "button";
        b.className = "tag-chip" + (selected ? " is-selected" : "");
        b.textContent = name;
        return b;
      }
      function _presetMetaRowEl(preset){
        const row = document.createElement("div");
        row.className = "preset-meta-row";
        row.appendChild(_subjectBadgeEl(preset?.subjectId || "sub:english"));
        const ids = _normalizeTagIds(preset?.tagIds, { allowUnknown: false });
        for (const id of ids.slice(0, 4)){
          const t = getTagById(id);
          if (!t) continue;
          const chip = document.createElement("span");
          chip.className = "tag-chip is-muted";
          chip.textContent = t.name;
          if (t.color) chip.style.borderColor = t.color;
          row.appendChild(chip);
        }
        return row;
      }
      function _appRenderLibraryFilters(){
        if (el.appLibrarySubjectFilter){
          const prev = String(_appLibraryFilter.subjectId || "ALL");
          const allSubjects = getAllSubjects();
          el.appLibrarySubjectFilter.innerHTML = "";
          const allOpt = document.createElement("option");
          allOpt.value = "ALL";
          allOpt.textContent = "ALL";
          el.appLibrarySubjectFilter.appendChild(allOpt);
          for (const s of allSubjects){
            const o = document.createElement("option");
            o.value = s.id;
            o.textContent = s.name;
            el.appLibrarySubjectFilter.appendChild(o);
          }
          el.appLibrarySubjectFilter.value = allSubjects.some((s) => s.id === prev) ? prev : "ALL";
          _appLibraryFilter.subjectId = el.appLibrarySubjectFilter.value;
        }
        if (el.appLibrarySearchInput){
          el.appLibrarySearchInput.value = String(_appLibraryFilter.query || "");
        }
        if (el.appLibraryTagFilters){
          el.appLibraryTagFilters.replaceChildren();
          const tags = getAllTags();
          const valid = new Set(tags.map((t) => t.id));
          _appLibraryFilter.tagIds = (Array.isArray(_appLibraryFilter.tagIds) ? _appLibraryFilter.tagIds : []).filter((id) => valid.has(id));
          if (!tags.length){
            const n = document.createElement("span");
            n.className = "note";
            n.textContent = "";
            el.appLibraryTagFilters.appendChild(n);
          } else {
            for (const t of tags){
              const selected = _appLibraryFilter.tagIds.includes(t.id);
              const chip = _tagChipEl(t.name, selected);
              chip.dataset.libTagFilter = t.id;
              if (t.color) chip.style.borderColor = t.color;
              el.appLibraryTagFilters.appendChild(chip);
            }
          }
        }
      }
      function _appPresetMatchesLibraryFilter(preset){
        if (!preset) return false;
        const subjectFilter = String(_appLibraryFilter.subjectId || "ALL");
        if (subjectFilter !== "ALL"){
          const sid = String(preset.subjectId || "sub:english");
          if (sid !== subjectFilter) return false;
        }
        const q = String(_appLibraryFilter.query || "").trim().toLowerCase();
        if (q){
          const nm = String(preset.name || "").toLowerCase();
          if (!nm.includes(q)) return false;
        }
        const selectedTags = Array.isArray(_appLibraryFilter.tagIds) ? _appLibraryFilter.tagIds : [];
        if (selectedTags.length){
          const ownTags = _normalizeTagIds(preset.tagIds, { allowUnknown: false });
          for (const tid of selectedTags){
            if (!ownTags.includes(tid)) return false;
          }
        }
        return true;
      }

      function _appRenderLibrary(){
        if (!el.appLibraryBuiltinList || !el.appLibraryMyList) return;
        _appRenderLibraryFilters();
        el.appLibraryBuiltinList.replaceChildren();
        el.appLibraryMyList.replaceChildren();

        const bFrag = document.createDocumentFragment();
        for (const b of _appBuiltinDefs()){
          const presetObj = getPresetById(b.id);
          if (!_appPresetMatchesLibraryFilter(presetObj)) continue;
          const count = (getPresetWords(b.id) || []).length;
          const card = document.createElement("article");
          card.className = "app-preset-card";
          const title = document.createElement("div");
          title.className = "title";
          title.textContent = b.name;
          const meta = document.createElement("div");
          meta.className = "meta";
          meta.textContent = ` / ${count}`;
          const actions = document.createElement("div");
          actions.className = "app-preset-actions";
          actions.appendChild(_appCreateActionButton("", "useBuiltin", b.id));
          actions.appendChild(_appCreateActionButton("EXAM", "startBuiltinExam", b.id));
          actions.appendChild(_appCreateActionButton("WRITE", "startBuiltinWrite", b.id));
          card.appendChild(title);
          card.appendChild(meta);
          card.appendChild(_presetMetaRowEl(presetObj));
          card.appendChild(actions);
          bFrag.appendChild(card);
        }
        el.appLibraryBuiltinList.appendChild(bFrag);

        const mine = loadPresets();
        const filteredMine = mine.filter((p) => _appPresetMatchesLibraryFilter(p));
        if (!filteredMine.length){
          const empty = document.createElement("div");
          empty.className = "app-empty";
          empty.textContent = mine.length ? " My Preset " : "My Preset ";
          el.appLibraryMyList.appendChild(empty);
          _customSelectEnhance(el.appLibraryPage || document);
          return;
        }
        const mFrag = document.createDocumentFragment();
        for (const p of filteredMine){
          const card = document.createElement("article");
          card.className = "app-preset-card";
          const wc = _presetEntryCount(p);
          const unit = _isEnglishSubjectId(p.subjectId || "sub:english") ? "" : "";
          const title = document.createElement("div");
          title.className = "title";
          title.textContent = p.name || "My Preset";
          const meta = document.createElement("div");
          meta.className = "meta";
          meta.textContent = `${wc}${unit} / ${presetMetaText(p)}`;
          const actions = document.createElement("div");
          actions.className = "app-preset-actions";
          actions.appendChild(_appCreateActionButton("", "useCustom", p.id));
          actions.appendChild(_appCreateActionButton("", "editCustom", p.id));
          actions.appendChild(_appCreateActionButton("", "shareCustom", p.id));
          actions.appendChild(_appCreateActionButton("", "deleteCustom", p.id));
          actions.appendChild(_appCreateActionButton("EXAM", "startCustomExam", p.id));
          actions.appendChild(_appCreateActionButton("WRITE", "startCustomWrite", p.id));
          card.appendChild(title);
          card.appendChild(meta);
          card.appendChild(_presetMetaRowEl(p));
          card.appendChild(actions);
          mFrag.appendChild(card);
        }
        el.appLibraryMyList.appendChild(mFrag);
        _customSelectEnhance(el.appLibraryPage || document);
      }

      function _appUsePresetForStart(pid){
        if (!pid) return false;
        if (isBuiltinPreset(pid)){
          const dk = deckFromBuiltinId(pid);
          setDeck(dk);
          return true;
        }
        const p = getPresetById(pid);
        if (!p || p.builtin) return false;
        setActivePreset(pid);
        return true;
      }

      function _appStartPresetMode(pid, mode){
        if (!_appUsePresetForStart(pid)){
          uiToast("");
          return;
        }
        _appSetTab("home");
        if (mode === "HAND"){
          if (el.startHandBtn) el.startHandBtn.click();
          else startMode("HAND");
          return;
        }
        if (el.startChoiceBtn) el.startChoiceBtn.click();
        else startChoiceMode(getChoiceDefaultTimeLimitSec());
      }

      async function _appDeleteCustomPreset(pid){
        const p = getPresetById(pid);
        if (!p || p.builtin){
          uiToast("");
          return;
        }
        const ok = await uiConfirm(`${p.name || "My Preset"}`, {
          title: "Library",
          okText: "",
          cancelText: "",
          danger: true
        });
        if (!ok) return;
        const list = loadPresets().filter((x) => x.id !== pid);
        savePresets(list);
        if (getActivePresetId() === pid){
          setDeck("A");
        } else {
          renderAll();
        }
        _appRenderLibrary();
      }

      function _appInboxBackToList(){
        _notifyDestroyDetailMedia();
        _appInboxDetailId = "";
        if (el.appInboxListPane) el.appInboxListPane.classList.remove("hidden");
        if (el.appInboxDetailPane) el.appInboxDetailPane.classList.add("hidden");
        if (el.appInboxDetailContent) el.appInboxDetailContent.replaceChildren();
        if (el.appInboxDetailTitle) el.appInboxDetailTitle.textContent = "";
        if (el.appInboxDetailMeta) el.appInboxDetailMeta.textContent = "";
      }

      function _appInboxRelativeTime(ts){
        const n = Number(ts) || 0;
        if (!n) return "";
        const diff = Date.now() - n;
        const abs = Math.abs(diff);
        const suffix = diff >= 0 ? "" : "";
        if (abs < 60000) return diff >= 0 ? "" : "";
        const min = Math.floor(abs / 60000);
        if (min < 60) return `${min}${suffix}`;
        const hour = Math.floor(abs / 3600000);
        if (hour < 24) return `${hour}${suffix}`;
        const day = Math.floor(abs / 86400000);
        if (day < 30) return `${day}${suffix}`;
        const month = Math.floor(day / 30);
        if (month < 12) return `${month}${suffix}`;
        const year = Math.floor(day / 365);
        return `${year}${suffix}`;
      }

      function _appInboxCreateRow(id){
        const row = document.createElement("article");
        row.className = "app-inbox-item app-chat-msg is-ai";
        row.dataset.id = String(id || "");

        const avatar = document.createElement("div");
        avatar.className = "app-inbox-avatar";
        avatar.setAttribute("aria-hidden", "true");
        avatar.textContent = "VQ";

        const body = document.createElement("div");
        body.className = "app-inbox-body";

        const bubble = document.createElement("div");
        bubble.className = "app-chat-bubble app-inbox-bubble";

        const unreadDot = document.createElement("span");
        unreadDot.className = "app-inbox-unread-dot";
        unreadDot.setAttribute("aria-hidden", "true");

        const bubbleHead = document.createElement("div");
        bubbleHead.className = "app-inbox-bubble-head";
        const title = document.createElement("h3");
        title.className = "app-inbox-title";
        const category = document.createElement("span");
        category.className = "app-inbox-category";
        bubbleHead.appendChild(title);
        bubbleHead.appendChild(category);

        const preview = document.createElement("p");
        preview.className = "app-inbox-preview";

        const bubbleMeta = document.createElement("div");
        bubbleMeta.className = "app-inbox-bubble-meta";
        const time = document.createElement("span");
        time.className = "app-inbox-time";
        bubbleMeta.appendChild(time);

        bubble.appendChild(unreadDot);
        bubble.appendChild(bubbleHead);
        bubble.appendChild(preview);
        bubble.appendChild(bubbleMeta);

        const actionRow = document.createElement("div");
        actionRow.className = "app-inbox-action-row";
        const readState = document.createElement("span");
        readState.className = "app-inbox-read-state";
        const detail = document.createElement("button");
        detail.type = "button";
        detail.className = "textbtn app-inbox-action-btn";
        detail.textContent = "";
        detail.dataset.inboxAction = "openDetail";
        detail.dataset.id = String(id || "");
        actionRow.appendChild(readState);
        actionRow.appendChild(detail);

        body.appendChild(bubble);
        body.appendChild(actionRow);
        row.appendChild(avatar);
        row.appendChild(body);

        row._appInboxRefs = { title, category, preview, time, readState, detail };
        return row;
      }

      function _appInboxPatchRow(row, item, unread){
        if (!row || !item) return;
        const refs = row._appInboxRefs || {};
        const id = String(item.id || "");
        const title = item.title || "(untitled)";
        const preview = _notifyPreviewText(item.body || "");
        const category = item.category || "Update";
        const priority = String(item.priority || "normal");
        const ts = Number(item.ts) || 0;
        const absoluteTime = ts ? formatDateTime(ts) : "";
        const relativeTime = ts ? _appInboxRelativeTime(ts) : "";

        row.classList.toggle("unread", !!unread);
        row.classList.toggle("priority-high", priority === "high");
        row.dataset.id = id;

        if (refs.title && refs.title.textContent !== title) refs.title.textContent = title;
        if (refs.preview && refs.preview.textContent !== preview) refs.preview.textContent = preview;
        if (refs.category && refs.category.textContent !== category) refs.category.textContent = category;
        if (refs.time){
          refs.time.textContent = relativeTime;
          refs.time.title = absoluteTime;
        }
        if (refs.readState){
          refs.readState.textContent = unread ? "" : "";
          refs.readState.title = absoluteTime;
        }
        if (refs.detail){
          refs.detail.dataset.id = id;
        }
      }

      function _appInboxOpenDetail(id){
        const item = loadNotifications().find((n) => String(n?.id || "") === String(id || ""));
        if (!item){
          if (el.appInboxEmpty){
            el.appInboxEmpty.textContent = "";
            el.appInboxEmpty.classList.remove("hidden");
          }
          return;
        }
        _notifyDestroyDetailMedia();
        _appInboxDetailId = String(id || "");
        if (el.appInboxDetailTitle) el.appInboxDetailTitle.textContent = item.title || "(untitled)";
        if (el.appInboxDetailMeta){
          const category = escapeHtml(item.category || "Update");
          const priorityRaw = String(item.priority || "normal");
          const priority = escapeHtml(priorityRaw);
          const absolute = escapeHtml(item.ts ? formatDateTime(item.ts) : "");
          const relative = escapeHtml(item.ts ? _appInboxRelativeTime(item.ts) : "");
          const highClass = priorityRaw === "high" ? " is-high" : "";
          el.appInboxDetailMeta.innerHTML =
            `<span class="app-inbox-detail-chip">${category}</span>` +
            `<span class="app-inbox-detail-chip${highClass}">${priority}</span>` +
            `<span class="app-inbox-detail-chip">${relative}</span>` +
            `<span class="app-inbox-detail-chip">${absolute}</span>`;
        }
        if (el.appInboxDetailContent){
          el.appInboxDetailContent.replaceChildren();
          el.appInboxDetailContent.appendChild(_notifyRenderDetailContent(item.body || ""));
        }
        if (el.appInboxListPane) el.appInboxListPane.classList.add("hidden");
        if (el.appInboxDetailPane){
          el.appInboxDetailPane.classList.remove("hidden");
          el.appInboxDetailPane.scrollTop = 0;
        }
      }

      function _appSyncInboxAdminButton(){
        if (!el.appInboxAdminBtn) return;
        el.appInboxAdminBtn.classList.toggle("hidden", !_adminState.isAdmin);
      }

      function _appRenderInbox(){
        if (!el.appInboxList || !el.appInboxEmpty) return;
        _appSyncInboxAdminButton();
        const seenAt = _notifSeenAt();
        const list = loadNotifications().sort((a,b)=>(b.ts||0)-(a.ts||0));
        const keepIds = new Set();
        if (!list.length){
          el.appInboxEmpty.textContent = "";
          el.appInboxEmpty.classList.remove("hidden");
          for (const [id, row] of _appInboxRowById.entries()){
            if (row && row.parentNode) row.parentNode.removeChild(row);
            _appInboxRowById.delete(id);
          }
          return;
        }
        el.appInboxEmpty.classList.add("hidden");
        const frag = document.createDocumentFragment();
        for (const n of list){
          const id = String(n?.id || "").trim();
          if (!id) continue;
          const unread = (Number(n.ts) || 0) > seenAt;
          let row = _appInboxRowById.get(id);
          if (!row || !row.isConnected){
            row = _appInboxCreateRow(id);
            _appInboxRowById.set(id, row);
          }
          _appInboxPatchRow(row, n, unread);
          keepIds.add(id);
          frag.appendChild(row);
        }
        for (const [id, row] of _appInboxRowById.entries()){
          if (keepIds.has(id)) continue;
          if (row && row.parentNode) row.parentNode.removeChild(row);
          _appInboxRowById.delete(id);
        }
        el.appInboxList.appendChild(frag);
      }

      function _appPopulateInsightsFilterPresets(){
        const sel = el.appInsightsPresetSelect;
        if (!sel) return;
        const prev = String(sel.value || "CURRENT");
        const currentPresetId = _appCurrentPresetInfo().id;
        const options = new Map();
        options.set("CURRENT", "CURRENT");
        options.set("ALL", "ALL");
        const sessions = (typeof _insightsLoadSessions === "function") ? (_insightsLoadSessions() || []) : [];
        for (const s of (Array.isArray(sessions) ? sessions : [])){
          const pid = String(s?.presetId || "");
          if (!pid) continue;
          const pname = String(s?.presetName || getPresetById(pid)?.name || pid);
          options.set(pid, pname);
        }
        if (currentPresetId){
          options.set(currentPresetId, String(getPresetById(currentPresetId)?.name || currentPresetId));
        }
        sel.innerHTML = "";
        for (const [value, label] of options.entries()){
          const opt = document.createElement("option");
          opt.value = value;
          opt.textContent = label;
          sel.appendChild(opt);
        }
        if (options.has(prev)) sel.value = prev;
        else sel.value = "CURRENT";
      }

      function _appGetInsightsFilterState(){
        return {
          preset: String(el.appInsightsPresetSelect?.value || "CURRENT"),
          mode: String(el.appInsightsModeSelect?.value || "ALL"),
          range: String(el.appInsightsRangeSelect?.value || "30D"),
          currentPresetId: _appCurrentPresetInfo().id
        };
      }

      function _appRenderInsightsCards(){
        if (!el.appInsightsSummaryCards) return;
        _appPopulateInsightsFilterPresets();
        const filter = _appGetInsightsFilterState();
        const list = (typeof _insightsGetFilteredSessionsBy === "function")
          ? (_insightsGetFilteredSessionsBy(filter) || [])
          : ((typeof _insightsLoadSessions === "function") ? (_insightsLoadSessions() || []) : []);
        const totalSessions = list.length;
        const totalAnswers = list.reduce((a, s) => a + (Number(s?.total) || 0), 0);
        const totalCorrect = list.reduce((a, s) => a + (Number(s?.correct) || 0), 0);
        const totalMs = list.reduce((a, s) => a + (Number(s?.durationMs) || 0), 0);
        const acc = totalAnswers > 0 ? Math.round((totalCorrect / totalAnswers) * 1000) / 10 : 0;
        const mins = Math.round((totalMs / 60000) * 10) / 10;
        const recent = list.filter((s) => {
          const t = Number(s?.ts || 0);
          return t > 0 && (Date.now() - t) <= (7 * 86400000);
        }).length;
        const cards = [
          { k: "", v: String(totalSessions) },
          { k: "", v: `${acc}%` },
          { k: "", v: String(totalAnswers) },
          { k: "", v: `${mins}` },
          { k: "7", v: `${recent} sessions` },
          { k: "", v: String(totalCorrect) }
        ];
        el.appInsightsSummaryCards.innerHTML = cards.map((c) =>
          `<article class="app-ins-card"><div class="app-ins-k">${escapeHtml(c.k)}</div><div class="app-ins-v">${escapeHtml(c.v)}</div></article>`
        ).join("");
        if (typeof _insightsRenderACE === "function"){
          _insightsRenderACE(list, {
            dailyVolume: el.appInsightsDailyVolume,
            dailyAccuracy: el.appInsightsDailyAccuracy,
            modeDistribution: el.appInsightsModeDistribution
          });
        }
        _customSelectEnhance(el.appInsightsPage || document);
      }

      const CHAT_HISTORY_KEY = "app.chat.history.v1";
      const CHAT_HISTORY_META_KEY = "app.chat.history.meta.v1";
      const CHAT_MEMORY_KEY = "app.chat.memory.v1";
      const CHAT_HISTORY_MAX = 200;
      const CHAT_REMOTE_HISTORY_MAX = 200;
      const CHAT_REMOTE_SAVE_DEBOUNCE_MS = 900;
      const CHAT_TYPING_MIN_MS = 400;
      const CHAT_TYPING_MAX_MS = 800;
      const CHAT_TYPE_CHAR_MIN_MS = 20;
      const CHAT_TYPE_CHAR_MAX_MS = 45;
      const CHAT_NEAR_BOTTOM_PX = 84;
      const CHAT_RAG_TOPK = 3;
      const CHAT_LAST_INTENT_KEY = "app.chat.lastIntent.v1";
      const CHAT_AI_MODE_KEY = "app.chat.ai.mode.v1";
      const CHAT_LOCAL_QUOTA_KEY = "app.chat.localQuota.v1";
      const CHAT_AI_MODE_NORMAL = "normal";
      const CHAT_AI_MODE_REASON = "reason";
      const CHAT_AI_MODE_LIMITS = Object.freeze({ normal: 5, reason: 2 });
      const CHAT_INTENT_CATEGORIES = Object.freeze([
        "", "", "", "", "", "", "", "", "", ""
      ]);
      function _chatIntentTypeByCategory(category){
        const c = String(category || "");
        if (c === "") return "TREND";
        if (c === "") return "COMPARE";
        if (c === "") return "WEAK";
        if (c === "" || c === "" || c === "") return "TIPS";
        return "APP_HELP";
      }
      function _chatBuildIntentCatalog(){
        const base = [
          { id: "intent-trend-7d", title: "(7)", category: "", keywords: ["","","7","trend","summary"] },
          { id: "intent-trend-30d", title: "(30)", category: "", keywords: ["","","30","trend","month"] },
          { id: "intent-compare-week-acc", title: "()", category: "", keywords: ["","","","accuracy","week"] },
          { id: "intent-compare-week-volume", title: "()", category: "", keywords: ["","","","","volume"] },
          { id: "intent-weak-top10", title: "TOP10", category: "", keywords: ["","top10","weak","","wrong"] },
          { id: "intent-weak-meaning", title: "TOP()", category: "", keywords: ["","","meaning",""] },
          { id: "intent-write-miss-spell", title: "WRITE()", category: "", keywords: ["write","","","spell",""] },
          { id: "intent-exam-miss-trick", title: "EXAM()", category: "", keywords: ["exam","","",""] },
          { id: "intent-reco-exam20", title: "20EXAM", category: "", keywords: ["","","exam","20",""] },
          { id: "intent-reco-write20", title: "20WRITE", category: "", keywords: ["","","write","20",""] },
          { id: "intent-share-failed", title: "", category: "", keywords: ["","","","qr","share"] },
          { id: "intent-notify-media", title: "/", category: "", keywords: ["","","","markdown","video"] },
          { id: "intent-admin-permission", title: "admin/permission denied", category: "", keywords: ["admin","permission denied","",""] },
          { id: "intent-trouble-unauthorized-domain", title: "unauthorized-domain", category: "", keywords: ["unauthorized-domain","auth","google","domain"] }
        ];
        const templates = {
          "": ["7","7","30","","","1","","","",""],
          "": ["77","3030","","","","EXAM","WRITE","","",""],
          "": ["TOP5","TOP20","","","","EXAM","WRITE","","",""],
          "": ["EXAM","WRITE","TURN","RUNDOM","","","4","","","10"],
          "": ["EXAM","WRITE","10","20","","","","","","30"],
          "": ["EXAM","EXAM","","","","","","JSON","",""],
          "": ["","","","QR","","VERSION_MISMATCH","EXPIRED","NOT_FOUND","",""],
          "": ["","","","","","","","","",""],
          "": ["","","","115","","","","","",""],
          "": ["firebaseConfig","permission-denied","auth","","","","","","",""]
        };
        const out = [];
        const idSet = new Set();
        const pushIntent = (entry) => {
          if (!entry || typeof entry !== "object") return;
          const id = String(entry.id || "").trim();
          const title = String(entry.title || "").trim();
          const category = String(entry.category || "").trim();
          if (!id || !title || !category || idSet.has(id)) return;
          idSet.add(id);
          const keywords = Array.isArray(entry.keywords) ? entry.keywords.map((k) => String(k || "").trim()).filter(Boolean) : [];
          const type = String(entry.type || _chatIntentTypeByCategory(category));
          const actions = Array.isArray(entry.actions) ? entry.actions : [];
          out.push({ id, title, category, type, keywords, actions });
        };
        base.forEach(pushIntent);
        for (const category of CHAT_INTENT_CATEGORIES){
          const rows = Array.isArray(templates[category]) ? templates[category] : [];
          for (let i = 0; i < rows.length; i++){
            const title = rows[i];
            const slug = _chatNormalizeForSearch(title).replace(/\s+/g, "-").replace(/[^a-z0-9----]/g, "").slice(0, 30) || `v${i + 1}`;
            pushIntent({
              id: `intent-${_chatNormalizeForSearch(category).replace(/\s+/g, "")}-${slug}-${i + 1}`,
              title,
              category,
              keywords: [title, category, ..._chatTokenize(title).slice(0, 4)],
              type: _chatIntentTypeByCategory(category)
            });
          }
        }
        let seq = 1;
        while (out.length < 100){
          const category = CHAT_INTENT_CATEGORIES[(seq - 1) % CHAT_INTENT_CATEGORIES.length];
          const type = _chatIntentTypeByCategory(category);
          const title = `${category} ${String(seq).padStart(2, "0")}`;
          pushIntent({
            id: `intent-${_chatNormalizeForSearch(category).replace(/\s+/g, "")}-auto-${seq}`,
            title,
            category,
            keywords: [category, "", "", ..._chatTokenize(title)],
            type
          });
          seq++;
        }
        return out.slice(0, 100);
      }
      const CHAT_INTENTS = Object.freeze(_chatBuildIntentCatalog());
      const CHAT_INTENT_BY_ID = new Map(CHAT_INTENTS.map((it) => [String(it.id), it]));
      const CHAT_QUICK_MAP = Object.freeze({
        trend: { prompt: "(7)", intent: "trend_summary", intentId: "intent-trend-7d" },
        weak: { prompt: "TOP10", intent: "weak", intentId: "intent-weak-top10" },
        today: { prompt: "20EXAM", intent: "recommend", intentId: "intent-reco-exam20" },
        week: { prompt: "()", intent: "compare_week", intentId: "intent-compare-week-acc" },
        improved: { prompt: "(30)", intent: "trend", intentId: "intent-trend-30d" },
        plateau: { prompt: "", intent: "general_help", intentId: "intent---10" },
        exam: { prompt: "EXAM", intent: "tips_exam", intentId: "intent--exam-1" },
        write: { prompt: "WRITE", intent: "tips_write", intentId: "intent--write-2" }
      });
      const CHAT_STUDY_INTENTS = new Set([
        "trend", "trend_summary", "weak", "recommend", "compare_week", "tips_exam", "tips_write",
        "notify_help", "share_help", "general_help"
      ]);
      const CHAT_KEYWORDS = Object.freeze({
        study: [
          "","","","","","","","","","","","","","",
          "","","","","","","","","","","","","","","",
          "","","","","","",""
        ],
        app: [
          "turn","rundom","random","exam","write","mode","preset","my preset","","qr","","","inbox","insights",
          "","admin","report","","help","terms","","","","","","range"
        ],
        romance: [
          "","","","","","","","","","","","","",""
        ],
        game: [
          "","","","","minecraft","","fortnite","apex","valorant","","","",""
        ],
        smalltalk: [
          "","","","","","","","","","","",""
        ]
      });

      const _chatState = {
        loaded: false,
        bound: false,
        history: [],
        transient: [],
        queue: [],
        processing: false,
        composerBusy: false,
        followBottom: true,
        timers: new Set(),
        rafId: 0,
        autoPickCandidate: true,
        pendingMatch: null,
        intentIndexReady: false,
        intentSearchDebounce: 0,
        intentSearchQuery: "",
        lastIntentId: "",
        pinTimer: 0,
        remoteLoadedForUser: "",
        remoteLoading: false,
        remoteSaving: false,
        remoteDirty: false,
        remoteSaveTimer: 0,
        remoteLastErrorAt: 0,
        remoteDisabled: false,
        remoteDisabledReason: "",
        aiMode: CHAT_AI_MODE_NORMAL,
        quota: { normalUsed: 0, normalLimit: CHAT_AI_MODE_LIMITS.normal, reasonUsed: 0, reasonLimit: CHAT_AI_MODE_LIMITS.reason },
        quotaResetAtMs: 0,
        limitNotice: { key: "", mode: CHAT_AI_MODE_NORMAL, resetAtMs: 0, visible: false, dismissed: false },
        memory: { updatedAt: 0, summary: "", focus: [] },
        knowledge: { docs: [], ready: false, pending: false, builtAt: 0, reason: "" }
      };

      function _chatMessageId(prefix = "m"){
        return `${prefix}-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
      }
      function _chatRand(min, max){
        const a = Number(min) || 0;
        const b = Number(max) || a;
        return Math.floor(Math.random() * (b - a + 1)) + a;
      }
      function _chatPick(arr, fallback = ""){
        if (!Array.isArray(arr) || !arr.length) return fallback;
        return arr[Math.floor(Math.random() * arr.length)] || fallback;
      }
      function _chatNormalize(text){
        return String(text || "").toLowerCase().trim();
      }
      function _chatNormalizeForSearch(text){
        return _chatNormalize(text)
          .replace(/[\u3000\s]+/g, " ")
          .replace(/[!"#$%&'()*+,./:;<=>?@[\\\]^_`{|}~-]/g, " ")
          .trim();
      }
      function _chatTokenize(text){
        const src = _chatNormalizeForSearch(text);
        if (!src) return [];
        const out = [];
        const seen = new Set();
        const re = /([a-z0-9_#.-]{2,}|[---]{2,})/g;
        let m;
        while ((m = re.exec(src))){
          const t = String(m[1] || "").trim();
          if (!t || seen.has(t)) continue;
          seen.add(t);
          out.push(t);
          if (out.length >= 40) break;
        }
        return out;
      }
      function _chatExtractTerms(text, max = 4){
        const stop = new Set(["","","","","","","","","","","","",""]);
        const terms = [];
        for (const t of _chatTokenize(text)){
          if (stop.has(t)) continue;
          terms.push(t);
          if (terms.length >= max) break;
        }
        return terms;
      }
      function _chatCountKeywordHits(normalizedText, keywords){
        const src = String(normalizedText || "");
        if (!src || !Array.isArray(keywords)) return 0;
        let c = 0;
        for (const kw of keywords){
          const token = _chatNormalize(kw);
          if (!token) continue;
          if (src.includes(token)) c++;
        }
        return c;
      }
      function _chatReadLastIntent(){
        try{
          const v = String(window.localStorage.getItem(CHAT_LAST_INTENT_KEY) || "").trim();
          return CHAT_INTENT_BY_ID.has(v) ? v : "";
        }catch{
          return "";
        }
      }
      function _chatSaveLastIntent(intentId){
        const id = String(intentId || "").trim();
        if (!CHAT_INTENT_BY_ID.has(id)) return;
        _chatState.lastIntentId = id;
        try{
          window.localStorage.setItem(CHAT_LAST_INTENT_KEY, id);
        }catch{}
      }
      function _chatNormalizeAiMode(raw){
        const v = String(raw || "").trim().toLowerCase();
        return (v === CHAT_AI_MODE_REASON || v === "reasoning" || v === "deep")
          ? CHAT_AI_MODE_REASON
          : CHAT_AI_MODE_NORMAL;
      }
      function _chatModeLabelShort(mode){
        return _chatNormalizeAiMode(mode) === CHAT_AI_MODE_REASON ? "deep" : "instant";
      }
      function _chatModeLabelFull(mode){
        return `VQ AI mini-1 ${_chatModeLabelShort(mode)}`;
      }
      function _chatJstYmd(ts = Date.now()){
        const shifted = (Number(ts) || Date.now()) + 9 * 60 * 60 * 1000;
        const d = new Date(shifted);
        const y = d.getUTCFullYear();
        const m = String(d.getUTCMonth() + 1).padStart(2, "0");
        const da = String(d.getUTCDate()).padStart(2, "0");
        return `${y}-${m}-${da}`;
      }
      function _chatNextJstResetMs(ts = Date.now()){
        const shifted = (Number(ts) || Date.now()) + 9 * 60 * 60 * 1000;
        const d = new Date(shifted);
        const y = d.getUTCFullYear();
        const m = d.getUTCMonth();
        const da = d.getUTCDate();
        return Date.UTC(y, m, da + 1, 0, 0, 0) - 9 * 60 * 60 * 1000;
      }
      function _chatFmtJstReset(ms){
        const n = Number(ms);
        if (!Number.isFinite(n) || n <= 0) return " 00:00 (JST)";
        const d = new Date(n);
        const MM = String(d.getMonth() + 1).padStart(2, "0");
        const DD = String(d.getDate()).padStart(2, "0");
        const hh = String(d.getHours()).padStart(2, "0");
        const mm = String(d.getMinutes()).padStart(2, "0");
        return `${MM}/${DD} ${hh}:${mm} JST`;
      }
      function _chatReadLocalQuota(){
        const today = _chatJstYmd(Date.now());
        const fallback = {
          day: today,
          normalUsed: 0,
          reasonUsed: 0,
          resetAtMs: _chatNextJstResetMs(Date.now())
        };
        try{
          const raw = window.localStorage.getItem(CHAT_LOCAL_QUOTA_KEY);
          if (!raw) return fallback;
          const obj = JSON.parse(raw);
          if (!obj || typeof obj !== "object") return fallback;
          const day = String(obj.day || "");
          if (day !== today) return fallback;
          return {
            day,
            normalUsed: Math.max(0, Number(obj.normalUsed || 0)),
            reasonUsed: Math.max(0, Number(obj.reasonUsed || 0)),
            resetAtMs: Number(obj.resetAtMs || _chatNextJstResetMs(Date.now())) || _chatNextJstResetMs(Date.now())
          };
        }catch{
          return fallback;
        }
      }
      function _chatWriteLocalQuota(quota){
        const q = quota && typeof quota === "object" ? quota : _chatReadLocalQuota();
        try{
          window.localStorage.setItem(CHAT_LOCAL_QUOTA_KEY, JSON.stringify({
            day: String(q.day || _chatJstYmd(Date.now())),
            normalUsed: Math.max(0, Number(q.normalUsed || 0)),
            reasonUsed: Math.max(0, Number(q.reasonUsed || 0)),
            resetAtMs: Number(q.resetAtMs || _chatNextJstResetMs(Date.now())) || _chatNextJstResetMs(Date.now())
          }));
        }catch{}
      }
      function _chatSyncQuotaFromLocal(){
        _chatState.quota = {
          normalUsed: 0,
          normalLimit: CHAT_AI_MODE_LIMITS.normal,
          reasonUsed: 0,
          reasonLimit: CHAT_AI_MODE_LIMITS.reason
        };
        _chatState.quotaResetAtMs = _chatNextJstResetMs(Date.now());
      }
      function _chatIsAdminUnlimitedUser(){
        try{
          const adminRef = String(ADMIN_EMAIL || "").trim().toLowerCase();
          if (!adminRef) return false;
          const authEmail = String(authState?.user?.email || "").trim().toLowerCase();
          if (authEmail && authEmail === adminRef) return true;
          const adminEmail = String(_adminState?.user?.email || "").trim().toLowerCase();
          if (adminEmail && adminEmail === adminRef) return true;
          if (typeof _adminState === "object" && !!_adminState.isAdmin) return true;
        }catch{}
        return false;
      }
      function _chatLocalQuotaGate(mode){
        const m = _chatNormalizeAiMode(mode);
        if (_chatIsAdminUnlimitedUser()){
          return {
            allowed: true,
            mode: m,
            used: 0,
            limitToday: 0,
            remainingToday: Number.POSITIVE_INFINITY,
            resetAtMs: _chatNextJstResetMs(Date.now()),
            adminBypass: true
          };
        }
        const q = (_chatState && typeof _chatState === "object" && _chatState.quota && typeof _chatState.quota === "object")
          ? _chatState.quota
          : { normalUsed: 0, normalLimit: CHAT_AI_MODE_LIMITS.normal, reasonUsed: 0, reasonLimit: CHAT_AI_MODE_LIMITS.reason };
        const limitToday = m === CHAT_AI_MODE_REASON
          ? Math.max(1, Number(q.reasonLimit || CHAT_AI_MODE_LIMITS.reason))
          : Math.max(1, Number(q.normalLimit || CHAT_AI_MODE_LIMITS.normal));
        const used = m === CHAT_AI_MODE_REASON
          ? Math.max(0, Number(q.reasonUsed || 0))
          : Math.max(0, Number(q.normalUsed || 0));
        const remainingToday = Math.max(0, limitToday - used);
        return {
          allowed: remainingToday > 0,
          mode: m,
          used,
          limitToday,
          remainingToday,
          resetAtMs: Number(_chatState.quotaResetAtMs || _chatNextJstResetMs(Date.now()))
        };
      }
      function _chatConsumeLocalQuota(mode){
        const m = _chatNormalizeAiMode(mode);
        const q = {
          normalUsed: Math.max(0, Number(_chatState?.quota?.normalUsed || 0)),
          normalLimit: Math.max(1, Number(_chatState?.quota?.normalLimit || CHAT_AI_MODE_LIMITS.normal)),
          reasonUsed: Math.max(0, Number(_chatState?.quota?.reasonUsed || 0)),
          reasonLimit: Math.max(1, Number(_chatState?.quota?.reasonLimit || CHAT_AI_MODE_LIMITS.reason)),
          resetAtMs: Number(_chatState?.quotaResetAtMs || _chatNextJstResetMs(Date.now())) || _chatNextJstResetMs(Date.now())
        };
        if (m === CHAT_AI_MODE_REASON) q.reasonUsed += 1;
        else q.normalUsed += 1;
        _chatState.quota = {
          normalUsed: q.normalUsed,
          normalLimit: q.normalLimit,
          reasonUsed: q.reasonUsed,
          reasonLimit: q.reasonLimit
        };
        _chatState.quotaResetAtMs = q.resetAtMs;
        _chatWriteLocalQuota({
          day: _chatJstYmd(Date.now()),
          normalUsed: q.normalUsed,
          reasonUsed: q.reasonUsed,
          resetAtMs: q.resetAtMs
        });
        const limitToday = m === CHAT_AI_MODE_REASON ? CHAT_AI_MODE_LIMITS.reason : CHAT_AI_MODE_LIMITS.normal;
        const used = m === CHAT_AI_MODE_REASON ? q.reasonUsed : q.normalUsed;
        return {
          mode: m,
          used,
          limitToday,
          remainingToday: Math.max(0, limitToday - used),
          resetAtMs: q.resetAtMs
        };
      }
      function _chatLoadAiMode(){
        try{
          return _chatNormalizeAiMode(window.localStorage.getItem(CHAT_AI_MODE_KEY) || "");
        }catch{
          return CHAT_AI_MODE_NORMAL;
        }
      }
      function _chatSaveAiMode(mode){
        const m = _chatNormalizeAiMode(mode);
        _chatState.aiMode = m;
        try{
          window.localStorage.setItem(CHAT_AI_MODE_KEY, m);
        }catch{}
      }
      function _chatQuotaText(){
        if (_chatIsAdminUnlimitedUser()){
          return "Admin: ";
        }
        const q = _chatState.quota || {};
        const nUsed = Math.max(0, Number(q.normalUsed || 0));
        const nLimit = Math.max(1, Number(q.normalLimit || CHAT_AI_MODE_LIMITS.normal));
        const rUsed = Math.max(0, Number(q.reasonUsed || 0));
        const rLimit = Math.max(1, Number(q.reasonLimit || CHAT_AI_MODE_LIMITS.reason));
        const nRemain = Math.max(0, nLimit - nUsed);
        const rRemain = Math.max(0, rLimit - rUsed);
        const resetAt = _chatFmtJstReset(_chatState.quotaResetAtMs || _chatNextJstResetMs(Date.now()));
        return `:  ${nRemain}/${nLimit}   ${rRemain}/${rLimit}: ${resetAt}`;
      }
      function _chatRenderQuotaNotice(){
        if (!el.appChatLimitBanner || !el.appChatLimitTitle || !el.appChatLimitSub) return;
        const st = _chatState.limitNotice || {};
        const visible = !!st.visible && !st.dismissed;
        el.appChatLimitBanner.classList.toggle("hidden", !visible);
        if (!visible) return;
        const mode = _chatNormalizeAiMode(st.mode || _chatState.aiMode);
        const resetAtMs = Number(st.resetAtMs || _chatState.quotaResetAtMs || _chatNextJstResetMs(Date.now()));
        el.appChatLimitTitle.textContent = `${_chatModeLabelFull(mode)} `;
        el.appChatLimitSub.textContent = `: ${_chatFmtJstReset(resetAtMs)}`;
      }
      function _chatOpenQuotaNotice(mode, resetAtMs){
        if (_chatIsAdminUnlimitedUser()){
          _chatDismissQuotaNotice();
          return;
        }
        const m = _chatNormalizeAiMode(mode || _chatState.aiMode);
        const reset = Number(resetAtMs || _chatState.quotaResetAtMs || _chatNextJstResetMs(Date.now()));
        const key = `${m}:${reset}`;
        if (!_chatState.limitNotice || typeof _chatState.limitNotice !== "object"){
          _chatState.limitNotice = { key: "", mode: m, resetAtMs: reset, visible: true, dismissed: false };
        }
        _chatState.limitNotice.dismissed = false;
        _chatState.limitNotice.key = key;
        _chatState.limitNotice.mode = m;
        _chatState.limitNotice.resetAtMs = reset;
        _chatState.limitNotice.visible = true;
        _chatRenderQuotaNotice();
      }
      function _chatDismissQuotaNotice(){
        if (!_chatState.limitNotice || typeof _chatState.limitNotice !== "object"){
          _chatState.limitNotice = { key: "", mode: _chatState.aiMode, resetAtMs: 0, visible: false, dismissed: true };
        }
        _chatState.limitNotice.dismissed = true;
        _chatState.limitNotice.visible = false;
        _chatRenderQuotaNotice();
      }
      function _chatApplyComposerAvailability(){
        const mode = _chatNormalizeAiMode(_chatState.aiMode);
        const gate = _chatLocalQuotaGate(mode);
        const busy = !!_chatState.composerBusy;
        if (el.appChatSendBtn){
          el.appChatSendBtn.disabled = busy || !gate.allowed;
          el.appChatSendBtn.classList.toggle("is-locked", !gate.allowed);
          el.appChatSendBtn.title = gate.allowed ? "" : `: ${_chatFmtJstReset(gate.resetAtMs)}`;
        }
        if (el.appChatInput){
          el.appChatInput.disabled = busy;
        }
        if (gate.allowed){
          if (_chatState.limitNotice && _chatState.limitNotice.visible){
            _chatState.limitNotice.visible = false;
            _chatRenderQuotaNotice();
          }
        }
      }
      function _chatRenderModeUi(){
        const mode = _chatNormalizeAiMode(_chatState.aiMode);
        const gate = _chatLocalQuotaGate(mode);
        const adminUnlimited = !!gate.adminBypass || _chatIsAdminUnlimitedUser();
        if (el.appChatModeNormalBtn){
          const active = mode === CHAT_AI_MODE_NORMAL;
          el.appChatModeNormalBtn.classList.toggle("is-active", active);
          el.appChatModeNormalBtn.setAttribute("aria-pressed", active ? "true" : "false");
          el.appChatModeNormalBtn.textContent = "instant";
        }
        if (el.appChatModeReasonBtn){
          const active = mode === CHAT_AI_MODE_REASON;
          el.appChatModeReasonBtn.classList.toggle("is-active", active);
          el.appChatModeReasonBtn.setAttribute("aria-pressed", active ? "true" : "false");
          el.appChatModeReasonBtn.textContent = "deep";
        }
        if (el.appChatModeToggleText){
          el.appChatModeToggleText.textContent = mode === CHAT_AI_MODE_REASON ? "deep" : "instant";
        }
        if (el.appChatModeOptionNormal){
          const active = mode === CHAT_AI_MODE_NORMAL;
          el.appChatModeOptionNormal.classList.toggle("is-active", active);
          el.appChatModeOptionNormal.setAttribute("aria-selected", active ? "true" : "false");
        }
        if (el.appChatModeOptionReason){
          const active = mode === CHAT_AI_MODE_REASON;
          el.appChatModeOptionReason.classList.toggle("is-active", active);
          el.appChatModeOptionReason.setAttribute("aria-selected", active ? "true" : "false");
        }
        if (el.appChatModeNote){
          if (adminUnlimited){
            el.appChatModeNote.textContent = "VQ AI mini-1 instant/deepAdmin: ";
          } else if (!gate.allowed){
            el.appChatModeNote.textContent = `${_chatModeLabelFull(mode)} : ${_chatFmtJstReset(gate.resetAtMs)}`;
          } else {
            el.appChatModeNote.textContent = mode === CHAT_AI_MODE_REASON
              ? "VQ AI mini-1 deeptoken 512 / 2/"
              : "VQ AI mini-1 instanttoken 256 / 5/";
          }
        }
        if (el.appChatQuotaStatus){
          el.appChatQuotaStatus.textContent = _chatQuotaText();
        }
        _chatApplyComposerAvailability();
        _chatRenderQuotaNotice();
      }
      function _chatSetModeMenuOpen(open){
        const menu = el.appChatModeMenu;
        if (!menu) return;
        const on = !!open;
        menu.classList.toggle("hidden", !on);
        if (el.appChatModeToggleBtn){
          el.appChatModeToggleBtn.setAttribute("aria-expanded", on ? "true" : "false");
        }
      }
      function _chatSetAiMode(mode){
        const next = _chatNormalizeAiMode(mode);
        _chatSaveAiMode(next);
        _chatSetModeMenuOpen(false);
        const gate = _chatLocalQuotaGate(next);
        if (!gate.allowed){
          _chatOpenQuotaNotice(next, gate.resetAtMs);
        }
        _chatRenderModeUi();
      }
      function _chatUpdateQuotaFromMeta(meta){
        const q = meta && typeof meta === "object" ? (meta.quota || {}) : {};
        const next = {
          normalUsed: Math.max(0, Number(q.normalUsed || _chatState.quota?.normalUsed || 0)),
          normalLimit: Math.max(1, Number(q.normalLimit || _chatState.quota?.normalLimit || CHAT_AI_MODE_LIMITS.normal)),
          reasonUsed: Math.max(0, Number(q.reasonUsed || _chatState.quota?.reasonUsed || 0)),
          reasonLimit: Math.max(1, Number(q.reasonLimit || _chatState.quota?.reasonLimit || CHAT_AI_MODE_LIMITS.reason))
        };
        _chatState.quota = next;
        _chatState.quotaResetAtMs = Number(meta?.resetAtMs || _chatState.quotaResetAtMs || _chatNextJstResetMs(Date.now()));
        _chatRenderModeUi();
      }
      function _chatBuildIntentIndexIfNeeded(force = false){
        if (_chatState.intentIndexReady && !force) return;
        const rows = [];
        for (const intent of CHAT_INTENTS){
          const titleNorm = _chatNormalizeForSearch(intent.title);
          const kwNorm = (Array.isArray(intent.keywords) ? intent.keywords : []).map((k) => _chatNormalizeForSearch(k)).filter(Boolean);
          const tokenSet = new Set();
          for (const t of _chatTokenize(titleNorm)){
            tokenSet.add(t);
          }
          for (const k of kwNorm){
            for (const t of _chatTokenize(k)){
              tokenSet.add(t);
            }
          }
          rows.push({
            id: intent.id,
            titleNorm,
            categoryNorm: _chatNormalizeForSearch(intent.category),
            keywordsNorm: kwNorm,
            tokens: Array.from(tokenSet)
          });
        }
        _chatState.intentIndex = rows;
        _chatState.intentIndexReady = true;
      }
      function _chatCategoryHints(category){
        const c = String(category || "");
        if (c === "") return ["","qr","","share","import","export"];
        if (c === "") return ["","inbox","","","",""];
        if (c === "") return ["","theme","sound","bgm","","backup"];
        if (c === "") return ["","","","denied","domain","config"];
        if (c === "") return ["","","wrong","",""];
        if (c === "") return ["","exam","write","",""];
        if (c === "") return ["","","","",""];
        if (c === "") return ["","","","",""];
        if (c === "") return ["","","",""];
        if (c === "") return ["","","","",""];
        return [];
      }
      function _chatMatchIntentScore(norm, tokens, intentRow){
        const intent = CHAT_INTENT_BY_ID.get(intentRow.id);
        if (!intent) return -1;
        let score = 0;
        if (norm && intentRow.titleNorm && norm.includes(intentRow.titleNorm)) score += 24;
        if (norm && intentRow.titleNorm && intentRow.titleNorm.includes(norm) && norm.length >= 2) score += 10;
        for (const kw of intentRow.keywordsNorm){
          if (!kw) continue;
          if (norm === kw) score += 20;
          else if (norm.includes(kw)) score += 7;
          else if (kw.includes(norm) && norm.length >= 2) score += 4;
        }
        for (const token of tokens){
          if (!token) continue;
          if (intentRow.tokens.includes(token)) score += 3;
          if (intentRow.titleNorm.includes(token)) score += 4;
        }
        for (const hint of _chatCategoryHints(intent.category)){
          if (hint && norm.includes(_chatNormalizeForSearch(hint))) score += 3;
        }
        if (_chatState.lastIntentId && _chatState.lastIntentId === intent.id) score += 2.2;
        const lastIntent = CHAT_INTENT_BY_ID.get(_chatState.lastIntentId || "");
        if (lastIntent && lastIntent.category === intent.category) score += 1.1;
        score += Math.random() * 0.18;
        return score;
      }
      function _chatMatchIntents(text, limit = 3){
        _chatBuildIntentIndexIfNeeded();
        const raw = String(text || "");
        const norm = _chatNormalizeForSearch(raw);
        const tokens = _chatTokenize(raw);
        const scored = [];
        for (const row of (_chatState.intentIndex || [])){
          const score = _chatMatchIntentScore(norm, tokens, row);
          scored.push({ id: row.id, score });
        }
        scored.sort((a, b) => b.score - a.score);
        const out = [];
        for (const item of scored){
          const intent = CHAT_INTENT_BY_ID.get(item.id);
          if (!intent) continue;
          out.push({
            id: intent.id,
            title: intent.title,
            category: intent.category,
            type: intent.type,
            score: item.score
          });
          if (out.length >= limit) break;
        }
        return out;
      }
      function _chatRenderIntentBrowser(){
        _chatBuildIntentIndexIfNeeded();
        if (!el.appChatIntentGroups || !el.appChatIntentCount) return;
        const q = _chatNormalizeForSearch(_chatState.intentSearchQuery || "");
        const groups = new Map();
        for (const category of CHAT_INTENT_CATEGORIES){
          groups.set(category, []);
        }
        for (const intent of CHAT_INTENTS){
          if (q){
            const hay = `${_chatNormalizeForSearch(intent.title)} ${_chatNormalizeForSearch((intent.keywords || []).join(" "))}`.trim();
            if (!hay.includes(q)){
              const qs = _chatTokenize(q);
              const hs = _chatTokenize(hay);
              const overlap = qs.some((token) => hs.includes(token));
              if (!overlap) continue;
            }
          }
          if (!groups.has(intent.category)){
            groups.set(intent.category, []);
          }
          groups.get(intent.category).push(intent);
        }
        let visible = 0;
        const frag = document.createDocumentFragment();
        for (const [category, list] of groups.entries()){
          if (!list.length) continue;
          visible += list.length;
          const details = document.createElement("details");
          details.className = "app-chat-intent-group";
          details.open = q ? true : (category === "" || category === "" || category === "");
          const summary = document.createElement("summary");
          summary.innerHTML = `<span>${escapeHtml(category)}</span><span>${list.length}</span>`;
          const body = document.createElement("div");
          body.className = "app-chat-intent-group-body";
          for (const intent of list){
            const btn = document.createElement("button");
            btn.type = "button";
            btn.className = "app-chat-intent-btn";
            btn.textContent = intent.title;
            btn.setAttribute("data-chat-prompt", intent.title);
            btn.setAttribute("data-chat-intent-id", intent.id);
            body.appendChild(btn);
          }
          details.appendChild(summary);
          details.appendChild(body);
          frag.appendChild(details);
        }
        el.appChatIntentGroups.replaceChildren(frag);
        el.appChatIntentCount.textContent = `${visible}/${CHAT_INTENTS.length} intents`;
        if (el.appChatAutoPickToggleBtn){
          el.appChatAutoPickToggleBtn.textContent = `1: ${_chatState.autoPickCandidate ? "ON" : "OFF"}`;
        }
      }
      function _chatScheduleIntentRender(){
        if (_chatState.intentSearchDebounce){
          clearTimeout(_chatState.intentSearchDebounce);
          _chatState.intentSearchDebounce = 0;
        }
        _chatState.intentSearchDebounce = setTimeout(() => {
          _chatState.intentSearchDebounce = 0;
          _chatRenderIntentBrowser();
        }, 100);
      }
      function _chatCancelPendingMatch(removeCard = true){
        const pending = _chatState.pendingMatch;
        if (!pending) return;
        if (pending.timerId){
          clearTimeout(pending.timerId);
          _chatState.timers.delete(pending.timerId);
        }
        if (removeCard && pending.cardId){
          _chatRemoveTransient(pending.cardId);
        }
        _chatState.pendingMatch = null;
      }
      function _chatBuildMatchActions(candidates){
        const actions = [];
        for (const c of (Array.isArray(candidates) ? candidates : [])){
          actions.push({
            type: "chooseIntent",
            label: c.title,
            intentId: c.id,
            prompt: c.title
          });
        }
        actions.push({
          type: "toggleAutoPick",
          label: `1: ${_chatState.autoPickCandidate ? "ON" : "OFF"}`
        });
        return actions;
      }
      function _chatResolvePendingIntent(intentId, autoPicked = false){
        const pending = _chatState.pendingMatch;
        if (!pending || pending.resolved) return false;
        const pickedRaw = String(intentId || pending.candidates?.[0]?.id || "").trim();
        const picked = CHAT_INTENT_BY_ID.has(pickedRaw)
          ? pickedRaw
          : String(pending.candidates?.[0]?.id || "").trim();
        if (!picked) return false;
        pending.resolved = true;
        if (pending.timerId){
          clearTimeout(pending.timerId);
          _chatState.timers.delete(pending.timerId);
        }
        _chatRemoveTransient(pending.cardId);
        _chatState.pendingMatch = null;
        _chatState.queue.push({
          text: pending.text,
          intentHint: "",
          intentId: picked,
          autoPicked: !!autoPicked
        });
        _chatSaveLastIntent(picked);
        _appRenderChat({ forceScroll: true });
        _chatProcessQueue();
        return true;
      }
      function _chatStartIntentMatch(userText){
        _chatCancelPendingMatch(true);
        const candidates = _chatMatchIntents(userText, 3);
        const top = candidates.length ? candidates : _chatMatchIntents("", 3);
        const cardId = _chatMessageId("intent-match");
        _chatPushTransient({
          id: cardId,
          ts: Date.now(),
          role: "ai",
          intent: "intent_match",
          scope: "study",
          text: "",
          actions: _chatBuildMatchActions(top)
        });
        _chatState.pendingMatch = {
          cardId,
          text: String(userText || ""),
          candidates: top,
          timerId: 0,
          resolved: false
        };
        _appRenderChat({ forceScroll: true });
        _chatScrollToBottom(true);
        if (_chatState.autoPickCandidate && top.length){
          const t = setTimeout(() => {
            _chatState.timers.delete(t);
            _chatResolvePendingIntent(top[0].id, true);
          }, 600);
          _chatState.pendingMatch.timerId = t;
          _chatState.timers.add(t);
        }
      }
      function _chatToggleAutoPick(){
        _chatState.autoPickCandidate = !_chatState.autoPickCandidate;
        if (el.appChatAutoPickToggleBtn){
          el.appChatAutoPickToggleBtn.textContent = `1: ${_chatState.autoPickCandidate ? "ON" : "OFF"}`;
        }
        const pending = _chatState.pendingMatch;
        if (pending && !pending.resolved){
          if (pending.timerId){
            clearTimeout(pending.timerId);
            _chatState.timers.delete(pending.timerId);
            pending.timerId = 0;
          }
          const row = _chatState.transient.find((m) => String(m?.id || "") === String(pending.cardId));
          if (row && Array.isArray(row.actions)){
            row.actions = _chatBuildMatchActions(pending.candidates || []);
          }
          if (_chatState.autoPickCandidate && pending.candidates && pending.candidates.length){
            const t = setTimeout(() => {
              _chatState.timers.delete(t);
              _chatResolvePendingIntent(pending.candidates[0].id, true);
            }, 600);
            pending.timerId = t;
            _chatState.timers.add(t);
          }
        }
        _appRenderChat();
      }
      function _chatPrefersReducedMotion(){
        return _isMotionReduced();
      }
      function _chatFmtPct(correct, total){
        const c = Number(correct) || 0;
        const t = Number(total) || 0;
        if (t <= 0) return "0.0";
        return (Math.round((c / t) * 1000) / 10).toFixed(1);
      }
      function _chatSafeNum(v, fallback = 0){
        const n = Number(v);
        return Number.isFinite(n) ? n : fallback;
      }
      function _chatPctOrDash(correct, total){
        const c = _chatSafeNum(correct, 0);
        const t = _chatSafeNum(total, 0);
        if (!(t > 0)) return "";
        return (Math.round((c / t) * 1000) / 10).toFixed(1);
      }
      function _chatPctText(correct, total){
        const pct = _chatPctOrDash(correct, total);
        return pct === "" ? "" : `${pct}%`;
      }
      function _chatNormalizeTs(input){
        if (input == null) return 0;
        if (typeof input === "number"){
          if (!Number.isFinite(input) || input <= 0) return 0;
          return input < 1e11 ? Math.round(input * 1000) : Math.round(input);
        }
        if (typeof input === "string"){
          const s = input.trim();
          if (!s) return 0;
          if (/^\d+$/.test(s)){
            const n = Number(s);
            if (!Number.isFinite(n) || n <= 0) return 0;
            return n < 1e11 ? Math.round(n * 1000) : Math.round(n);
          }
          const parsed = Date.parse(s);
          return Number.isFinite(parsed) && parsed > 0 ? parsed : 0;
        }
        if (typeof input === "object"){
          try{
            if (typeof input.toMillis === "function"){
              const ms = Number(input.toMillis());
              if (Number.isFinite(ms) && ms > 0) return Math.round(ms);
            }
          }catch{}
          const sec = _chatSafeNum(input.seconds, 0) || _chatSafeNum(input._seconds, 0);
          const nsec = _chatSafeNum(input.nanoseconds, 0) || _chatSafeNum(input._nanoseconds, 0);
          if (sec > 0){
            return Math.round(sec * 1000 + nsec / 1000000);
          }
          if (input.ts != null) return _chatNormalizeTs(input.ts);
          if (input.createdAt != null) return _chatNormalizeTs(input.createdAt);
          if (input.updatedAt != null) return _chatNormalizeTs(input.updatedAt);
          if (input.date != null) return _chatNormalizeTs(input.date);
        }
        return 0;
      }
      function _chatDateKey(ts){
        const d = new Date(_chatSafeNum(ts, 0));
        if (!Number.isFinite(d.getTime())) return "";
        const y = d.getFullYear();
        const m = String(d.getMonth() + 1).padStart(2, "0");
        const day = String(d.getDate()).padStart(2, "0");
        return `${y}-${m}-${day}`;
      }
      function _chatFmtDate(ts){
        const n = Number(ts) || 0;
        if (!n) return "";
        try{
          return new Date(n).toLocaleString("ja-JP", {
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit"
          });
        }catch{
          return "";
        }
      }
      function _chatFmtTime(ts){
        const n = Number(ts) || 0;
        if (!n) return "";
        try{
          return new Date(n).toLocaleTimeString("ja-JP", { hour: "2-digit", minute: "2-digit" });
        }catch{
          return "";
        }
      }
      function _chatModeName(mode){
        const m = String(mode || "");
        if (m === "SEQ") return "TURN MODE";
        if (m === "RND") return "RUNDOM MODE";
        if (m === "CHOICE") return "EXAM MODE";
        if (m === "HAND") return "WRITE MODE";
        return "";
      }
      function _chatIsStudyIntent(intent){
        const k = String(intent || "");
        if (!k) return false;
        if (CHAT_STUDY_INTENTS.has(k)) return true;
        if (k.startsWith("out_scope")) return false;
        return CHAT_STUDY_INTENTS.has("general_help");
      }
      function _chatSanitizeAction(a){
        const raw = (a && typeof a === "object") ? a : {};
        const type = String(raw.type || "");
        const label = String(raw.label || "").trim();
        if (!type || !label) return null;
        const ids = (Array.isArray(raw.ids) ? raw.ids : [])
          .map(Number)
          .filter((n) => Number.isFinite(n));
        const prompt = String(raw.prompt || "").trim();
        const intentId = String(raw.intentId || "").trim();
        return {
          type,
          label: label.slice(0, 80),
          ids: Array.from(new Set(ids)).slice(0, 40),
          prompt: prompt.slice(0, 240),
          intentId: intentId.slice(0, 96)
        };
      }
      function _chatSanitizeSource(v){
        const raw = (v && typeof v === "object") ? v : {};
        const label = String(raw.label || "").trim();
        const title = String(raw.title || "").trim();
        if (!label || !title) return null;
        const snippet = String(raw.snippet || "").trim();
        return {
          label: label.slice(0, 24),
          title: title.slice(0, 100),
          snippet: snippet.slice(0, 160)
        };
      }
      function _chatSanitizeAiMeta(v){
        const raw = (v && typeof v === "object") ? v : {};
        const mode = _chatNormalizeAiMode(raw.mode || "");
        const maxTokens = Math.max(0, Number(raw.maxTokens || raw.max_tokens || 0));
        const dateJst = String(raw.dateJst || "").slice(0, 20);
        const quota = (raw.quota && typeof raw.quota === "object") ? raw.quota : {};
        const refs = (raw.refsUsed && typeof raw.refsUsed === "object") ? raw.refsUsed : {};
        const helpIds = Array.isArray(refs.helpIds) ? refs.helpIds.map((x) => String(x || "").trim()).filter(Boolean).slice(0, 16) : [];
        const notificationIds = Array.isArray(refs.notificationIds) ? refs.notificationIds.map((x) => String(x || "").trim()).filter(Boolean).slice(0, 16) : [];
        const hasQuota = Number(quota.normalLimit || 0) > 0 || Number(quota.reasonLimit || 0) > 0;
        if (!maxTokens && !dateJst && !helpIds.length && !notificationIds.length && !hasQuota) return null;
        return {
          mode,
          maxTokens,
          dateJst,
          quota: {
            normalUsed: Math.max(0, Number(quota.normalUsed || 0)),
            normalLimit: Math.max(0, Number(quota.normalLimit || 0)),
            reasonUsed: Math.max(0, Number(quota.reasonUsed || 0)),
            reasonLimit: Math.max(0, Number(quota.reasonLimit || 0))
          },
          refsUsed: {
            insights: !!refs.insights,
            helpIds,
            notificationIds
          }
        };
      }
      function _chatSanitizeChart(v){
        const raw = (v && typeof v === "object") ? v : {};
        const tRaw = String(raw.type || "");
        const type = (tRaw === "line" || tRaw === "hbar") ? tRaw : "bar";
        const title = String(raw.title || "").trim();
        const points = (Array.isArray(raw.points) ? raw.points : []).map((p) => {
          const q = (p && typeof p === "object") ? p : {};
          const label = String(q.label || "").trim().slice(0, 14);
          const value = Number(q.value);
          const extra = Number(q.extra);
          return {
            label,
            value: Number.isFinite(value) ? value : 0,
            extra: Number.isFinite(extra) ? extra : 0
          };
        }).filter((p) => p.label).slice(0, 30);
        if (!title || !points.length) return null;
        return { type, title: title.slice(0, 40), points };
      }
      function _chatSanitizeHistoryItem(item){
        const raw = (item && typeof item === "object") ? item : {};
        const role = (raw.role === "user" || raw.role === "ai" || raw.role === "typing") ? raw.role : "";
        const textRaw = raw.text == null ? "" : String(raw.text);
        const textTrimmed = textRaw.trim();
        const allowEmpty = raw.allowEmpty === true || role === "typing";
        if (!role || (!textTrimmed && !allowEmpty)) return null;
        const actionsRaw = Array.isArray(raw.actions) ? raw.actions : [];
        const actions = actionsRaw.map(_chatSanitizeAction).filter(Boolean).slice(0, 4);
        const sourcesRaw = Array.isArray(raw.sources) ? raw.sources : [];
        const sources = sourcesRaw.map(_chatSanitizeSource).filter(Boolean).slice(0, 4);
        const chartsRaw = Array.isArray(raw.charts) ? raw.charts : [];
        const charts = chartsRaw.map(_chatSanitizeChart).filter(Boolean).slice(0, 3);
        const aiMeta = _chatSanitizeAiMeta(raw.aiMeta);
        const intent = String(raw.intent || "").slice(0, 42);
        const scope = String(raw.scope || "").slice(0, 24);
        return {
          id: String(raw.id || _chatMessageId(role)),
          ts: Number(raw.ts) || Date.now(),
          role,
          intent,
          scope,
          text: (allowEmpty ? textRaw : textTrimmed).slice(0, 3200),
          actions,
          sources,
          charts,
          aiMeta
        };
      }
      function _chatReadHistory(){
        try{
          const raw = window.localStorage.getItem(CHAT_HISTORY_KEY);
          if (!raw) return [];
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) return [];
          const list = [];
          for (const row of parsed){
            const role = (row?.role === "user" || row?.role === "ai") ? row.role : "";
            if (!role) continue;
            const text = String(row?.text || "").trim();
            if (!text) continue;
            list.push({
              id: _chatMessageId(role),
              ts: Number(row?.ts) || Date.now(),
              role,
              intent: String(row?.intent || "").slice(0, 42),
              text: text.slice(0, 3200),
              actions: [],
              aiMeta: _chatSanitizeAiMeta(row?.aiMeta)
            });
          }
          return list.slice(-CHAT_HISTORY_MAX);
        }catch{
          return [];
        }
      }
      function _chatReadHistoryMeta(){
        try{
          const raw = window.localStorage.getItem(CHAT_HISTORY_META_KEY);
          if (!raw) return { userKey: "", updatedAtMs: 0 };
          const obj = JSON.parse(raw);
          return {
            userKey: String(obj?.userKey || ""),
            updatedAtMs: Number(obj?.updatedAtMs || 0)
          };
        }catch{
          return { userKey: "", updatedAtMs: 0 };
        }
      }
      function _chatBuildPersistableHistoryList(source){
        const list = (Array.isArray(source) ? source : [])
          .filter((m) => m && (m.role === "user" || m.role === "ai"))
          .slice(-CHAT_REMOTE_HISTORY_MAX)
          .map((m) => ({
            ts: Number(m.ts) || Date.now(),
            role: m.role,
            text: String(m.text || "").slice(0, 3200),
            intent: String(m.intent || "").slice(0, 42),
            aiMeta: m.aiMeta ? _chatSanitizeAiMeta(m.aiMeta) : null
          }));
        return list;
      }
      function _chatRemoteUserKey(){
        const user = (authState && typeof authState === "object") ? authState.user : null;
        if (!user || typeof user !== "object") return "";
        const id = String(user.id ?? user.userId ?? "").trim();
        if (id) return `uid:${id}`;
        const grade = String(user.gradePrefix || "").trim();
        const nickname = String(user.nickname || "").trim().toLowerCase();
        if (grade && nickname) return `gn:${grade}-${nickname}`;
        return "";
      }
      function _chatHistoryApiBase(){
        try{
          const cands = (typeof _authApiBaseCandidates === "function")
            ? _authApiBaseCandidates()
            : [String(AUTH_API_BASE || "").trim().replace(/\/+$/, "")];
          const first = Array.isArray(cands) ? String(cands[0] || "").trim() : "";
          return first.replace(/\/+$/, "");
        }catch{
          return String(AUTH_API_BASE || "").trim().replace(/\/+$/, "");
        }
      }
      function _chatHistoryApiUrl(path){
        const base = _chatHistoryApiBase();
        const p = String(path || "");
        const pathPart = p.startsWith("/") ? p : `/${p}`;
        return `${base}${pathPart}`;
      }
      async function _chatRemoteFetchJson(path, options = {}){
        const token = (typeof _authGetToken === "function") ? String(_authGetToken() || "").trim() : "";
        if (!token){
          const err = new Error("UNAUTHORIZED");
          err.code = "UNAUTHORIZED";
          err.status = 401;
          throw err;
        }
        const method = String(options.method || "GET").toUpperCase();
        const headers = Object.assign({}, options.headers || {}, {
          Authorization: `Bearer ${token}`
        });
        let bodyText = null;
        if (Object.prototype.hasOwnProperty.call(options, "body")){
          headers["Content-Type"] = "application/json";
          bodyText = JSON.stringify(options.body || {});
        }
        const ctrl = new AbortController();
        const timer = setTimeout(() => ctrl.abort(), 12000);
        try{
          const res = await fetch(_chatHistoryApiUrl(path), {
            method,
            headers,
            body: bodyText,
            signal: ctrl.signal
          });
          const txt = await res.text();
          let data = null;
          try{ data = txt ? JSON.parse(txt) : null; }catch{ data = null; }
          if (!res.ok){
            const err = new Error(String(data?.message || data?.error || `${res.status} ${res.statusText}`));
            err.code = String(data?.code || `HTTP_${res.status}`);
            err.status = Number(res.status || 0);
            err.data = data || null;
            throw err;
          }
          return data || {};
        }catch(err){
          if (String(err?.name || "").toLowerCase() === "aborterror"){
            const e = new Error("");
            e.code = "TIMEOUT";
            e.status = 408;
            throw e;
          }
          throw err;
        }finally{
          clearTimeout(timer);
        }
      }
      function _chatRemoteCanSync(){
        if (_chatState.remoteDisabled) return false;
        if (!_chatRemoteUserKey()) return false;
        if (!_chatHistoryApiBase()) return false;
        return true;
      }
      function _chatRemoteNormalizeList(raw){
        const parsed = Array.isArray(raw) ? raw : [];
        const out = [];
        for (const row of parsed){
          const role = (row?.role === "user" || row?.role === "ai") ? row.role : "";
          if (!role) continue;
          const text = String(row?.text || "").trim();
          if (!text) continue;
          const clean = _chatSanitizeHistoryItem({
            id: _chatMessageId(role),
            ts: Number(row?.ts) || Date.now(),
            role,
            intent: String(row?.intent || "").slice(0, 42),
            text,
            aiMeta: _chatSanitizeAiMeta(row?.aiMeta || null)
          });
          if (!clean) continue;
          out.push(clean);
          if (out.length >= CHAT_REMOTE_HISTORY_MAX) break;
        }
        return out.slice(-CHAT_HISTORY_MAX);
      }
      function _chatRemoteNotifyError(err, phase){
        const now = Date.now();
        if (now - Number(_chatState.remoteLastErrorAt || 0) < 12000) return;
        _chatState.remoteLastErrorAt = now;
        const code = String(err?.code || "").trim();
        const msg = String(err?.message || err || "").trim();
        const prefix = phase === "load" ? "()" : "()";
        const permDenied = (code === "permission-denied" || code === "UNAUTHORIZED" || /insufficient permissions|permission[- ]denied|unauthorized/i.test(msg));
        if (permDenied){
          _chatState.remoteDisabled = true;
          _chatState.remoteDisabledReason = code || "permission-denied";
          if (_chatState.remoteSaveTimer){
            clearTimeout(_chatState.remoteSaveTimer);
            _chatState.remoteSaveTimer = 0;
          }
          _chatState.remoteDirty = false;
          uiToast("");
          return;
        }
        if (msg){
          uiToast(`${prefix}`);
        }
      }
      function _chatApiAllowsAuthHeader(url){
        try{
          const u = new URL(String(url || ""), location.href);
          const origin = String(u.origin || "").trim().toLowerCase();
          if (!origin) return false;
          const allowed = new Set(
            [
              String(location.origin || "").trim(),
              String(API_BASE || "").trim().replace(/\/+$/, ""),
              String(AUTH_API_BASE || "").trim().replace(/\/+$/, ""),
              String(SHARE_API_BASE || "").trim().replace(/\/+$/, ""),
              String(CHAT_AI_BASE || "").trim().replace(/\/+$/, ""),
              "https://vocabuquiz-api.rintyblog.workers.dev",
              "https://vocabuquiz-api2.rintyblog.workers.dev"
            ]
              .map((x) => String(x || "").trim().toLowerCase())
              .filter(Boolean)
          );
          return allowed.has(origin);
        }catch{
          return false;
        }
      }
      function _chatRemoteLatestTs(list){
        let max = 0;
        for (const item of (Array.isArray(list) ? list : [])){
          const ts = Number(item?.ts || 0);
          if (ts > max) max = ts;
        }
        return max;
      }
      function _chatRemoteQueueSave(reason = "history"){
        void reason;
        if (!_chatRemoteCanSync()) return;
        _chatState.remoteDirty = true;
        if (_chatState.remoteSaveTimer){
          clearTimeout(_chatState.remoteSaveTimer);
          _chatState.remoteSaveTimer = 0;
        }
        _chatState.remoteSaveTimer = window.setTimeout(() => {
          _chatState.remoteSaveTimer = 0;
          _chatRemoteSaveNow("debounced");
        }, CHAT_REMOTE_SAVE_DEBOUNCE_MS);
      }
      async function _chatRemoteSaveNow(reason = "manual"){
        void reason;
        if (!_chatRemoteCanSync()) return;
        if (_chatState.remoteSaving) return;
        _chatState.remoteSaving = true;
        try{
          const history = _chatBuildPersistableHistoryList(_chatState.history);
          const userKey = _chatRemoteUserKey();
          const payload = {
            schemaVersion: 1,
            userKey,
            history,
            updatedAtMs: Date.now()
          };
          await _chatRemoteFetchJson("/api/chat/history", {
            method: "POST",
            body: payload
          });
          _chatState.remoteDirty = false;
          _chatState.remoteLoadedForUser = userKey;
        }catch(err){
          console.warn("[ChatSync] save failed:", String(err?.message || err));
          _chatRemoteNotifyError(err, "save");
        }finally{
          _chatState.remoteSaving = false;
        }
      }
      async function _chatRemoteLoadIfNeeded(force = false){
        if (!_chatRemoteCanSync()) return;
        const userKey = _chatRemoteUserKey();
        if (!userKey) return;
        if (!force && _chatState.remoteLoadedForUser === userKey) return;
        if (_chatState.remoteLoading) return;
        _chatState.remoteLoading = true;
        try{
          const meta = _chatReadHistoryMeta();
          const localOwner = String(meta.userKey || "");
          if (localOwner && localOwner !== userKey){
            _chatState.history = [];
            _chatSaveHistory();
          }
          const body = await _chatRemoteFetchJson("/api/chat/history", {
            method: "GET"
          });
          if (!body || !Array.isArray(body.history) || !body.history.length){
            _chatState.remoteLoadedForUser = userKey;
            if (_chatState.history.length){
              _chatRemoteQueueSave("seed-empty-remote");
            }
            return;
          }
          const remoteList = _chatRemoteNormalizeList(body.history);
          const localList = Array.isArray(_chatState.history) ? _chatState.history : [];
          const remoteLatest = _chatRemoteLatestTs(remoteList);
          const localLatest = _chatRemoteLatestTs(localList);
          const shouldUseRemote = (
            (remoteList.length && !localList.length) ||
            (remoteLatest >= localLatest && remoteList.length)
          );
          if (shouldUseRemote){
            _chatState.history = remoteList.slice(-CHAT_HISTORY_MAX);
            _chatSaveHistory();
            _chatScheduleKnowledgeBuild("remote-history-load");
            _appRenderChat({ forceScroll: true });
          } else if (localList.length){
            _chatRemoteQueueSave("local-newer");
          }
          _chatState.remoteLoadedForUser = userKey;
        }catch(err){
          console.warn("[ChatSync] load failed:", String(err?.message || err));
          _chatRemoteNotifyError(err, "load");
        }finally{
          _chatState.remoteLoading = false;
        }
      }
      function _chatOnAuthChanged(){
        if (typeof _chatState !== "object") return;
        if (_chatState.remoteSaveTimer){
          clearTimeout(_chatState.remoteSaveTimer);
          _chatState.remoteSaveTimer = 0;
        }
        _chatState.remoteDisabled = false;
        _chatState.remoteDisabledReason = "";
        _chatState.remoteLoadedForUser = "";
        if (!_chatRemoteCanSync()) return;
        _chatEnsureLoaded();
        _chatRemoteLoadIfNeeded(true);
      }
      function _chatReadMemory(){
        try{
          const raw = window.localStorage.getItem(CHAT_MEMORY_KEY);
          if (!raw){
            return { updatedAt: 0, summary: "", focus: [], outScopeExplained: false, outScopeCount: 0, outScopeLastAt: 0 };
          }
          const obj = JSON.parse(raw);
          return {
            updatedAt: Number(obj?.updatedAt) || 0,
            summary: String(obj?.summary || "").slice(0, 320),
            focus: Array.isArray(obj?.focus) ? obj.focus.map((x) => String(x || "").trim()).filter(Boolean).slice(0, 6) : [],
            outScopeExplained: !!obj?.outScopeExplained,
            outScopeCount: Math.max(0, _chatSafeNum(obj?.outScopeCount, 0)),
            outScopeLastAt: _chatSafeNum(obj?.outScopeLastAt, 0)
          };
        }catch{
          return { updatedAt: 0, summary: "", focus: [], outScopeExplained: false, outScopeCount: 0, outScopeLastAt: 0 };
        }
      }
      function _chatSaveMemory(){
        try{
          window.localStorage.setItem(CHAT_MEMORY_KEY, JSON.stringify({
            updatedAt: Number(_chatState.memory?.updatedAt) || Date.now(),
            summary: String(_chatState.memory?.summary || "").slice(0, 320),
            focus: Array.isArray(_chatState.memory?.focus) ? _chatState.memory.focus.map((x) => String(x || "").trim()).filter(Boolean).slice(0, 6) : [],
            outScopeExplained: !!_chatState.memory?.outScopeExplained,
            outScopeCount: Math.max(0, _chatSafeNum(_chatState.memory?.outScopeCount, 0)),
            outScopeLastAt: _chatSafeNum(_chatState.memory?.outScopeLastAt, 0)
          }));
        }catch{}
      }
      function _chatSaveHistory(){
        try{
          const list = _chatBuildPersistableHistoryList(_chatState.history);
          window.localStorage.setItem(CHAT_HISTORY_KEY, JSON.stringify(list));
          window.localStorage.setItem(CHAT_HISTORY_META_KEY, JSON.stringify({
            userKey: _chatRemoteUserKey() || "guest",
            updatedAtMs: Date.now()
          }));
        }catch{}
        _chatRemoteQueueSave("history-save");
      }
      function _chatEnsureLoaded(){
        if (_chatState.loaded) return;
        _chatState.history = _chatReadHistory();
        _chatState.memory = _chatReadMemory();
        _chatState.lastIntentId = _chatReadLastIntent();
        _chatState.aiMode = _chatLoadAiMode();
        _chatSyncQuotaFromLocal();
        _chatState.followBottom = true;
        _chatState.loaded = true;
        _chatScheduleKnowledgeBuild("init");
        _chatRenderModeUi();
        _chatRenderIntentBrowser();
        _chatRemoteLoadIfNeeded(false);
      }
      function _chatPushHistory(role, text, intent = "", meta = {}){
        _chatEnsureLoaded();
        const payload = Array.isArray(meta) ? { actions: meta } : ((meta && typeof meta === "object") ? meta : {});
        const item = _chatSanitizeHistoryItem({
          id: _chatMessageId(role),
          ts: Date.now(),
          role,
          intent,
          text,
          scope: String(payload.scope || ""),
          actions: Array.isArray(payload.actions) ? payload.actions : [],
          sources: Array.isArray(payload.sources) ? payload.sources : [],
          charts: Array.isArray(payload.charts) ? payload.charts : [],
          aiMeta: payload.aiMeta || null
        });
        if (!item) return;
        _chatState.history.push(item);
        if (_chatState.history.length > CHAT_HISTORY_MAX){
          _chatState.history = _chatState.history.slice(-CHAT_HISTORY_MAX);
        }
        _chatSaveHistory();
        _chatScheduleKnowledgeBuild("history-push");
      }
      function _chatPushTransient(item){
        const clean = _chatSanitizeHistoryItem({
          ...(item || {}),
          allowEmpty: true
        });
        if (!clean) return;
        _chatState.transient.push(clean);
      }
      function _chatRemoveTransient(id){
        const key = String(id || "");
        _chatState.transient = _chatState.transient.filter((x) => String(x?.id || "") !== key);
      }
      function _chatCancelRuntime(){
        for (const t of Array.from(_chatState.timers)){
          clearTimeout(t);
          _chatState.timers.delete(t);
        }
        if (_chatState.intentSearchDebounce){
          clearTimeout(_chatState.intentSearchDebounce);
          _chatState.intentSearchDebounce = 0;
        }
        if (_chatState.remoteSaveTimer){
          clearTimeout(_chatState.remoteSaveTimer);
          _chatState.remoteSaveTimer = 0;
        }
        if (_chatState.rafId){
          cancelAnimationFrame(_chatState.rafId);
          _chatState.rafId = 0;
        }
        _chatCancelPendingMatch(true);
        _chatState.transient = [];
        _chatState.queue = [];
        _chatState.processing = false;
        _chatSetComposerBusy(false);
        _chatStopPinLatest();
      }
      function _chatClearHistory(){
        _chatEnsureLoaded();
        _chatCancelRuntime();
        _chatState.history = [];
        _chatSaveHistory();
        _chatStartPinLatest();
        _appRenderChat({ forceScroll: true });
      }
      function _chatIsNearBottom(){
        const sc = el.appChatScroll;
        if (!sc) return true;
        return (sc.scrollHeight - sc.scrollTop - sc.clientHeight) <= CHAT_NEAR_BOTTOM_PX;
      }
      function _chatScrollToBottom(force = false){
        const sc = el.appChatScroll;
        if (!sc) return;
        if (!force && document.body?.dataset?.appTab !== "chat") return;
        sc.scrollTop = sc.scrollHeight;
      }
      function _chatPinLatestNow(){
        _chatScrollToBottom(true);
      }
      function _chatStartPinLatest(){
        if (_chatState.pinTimer) return;
        _chatPinLatestNow();
        _chatState.pinTimer = window.setInterval(() => {
          if (document.body?.dataset?.appTab !== "chat" || state.view !== "TITLE"){
            _chatStopPinLatest();
            return;
          }
          _chatPinLatestNow();
        }, 160);
      }
      function _chatStopPinLatest(){
        if (!_chatState.pinTimer) return;
        clearInterval(_chatState.pinTimer);
        _chatState.pinTimer = 0;
      }
      function _chatForceLatestPosition(){
        _chatState.followBottom = true;
        const run = () => {
          const sc = el.appChatScroll;
          if (!sc) return;
          sc.scrollTop = sc.scrollHeight;
          if (document.body?.dataset?.appTab === "chat"){
            try{
              window.scrollTo(0, document.documentElement.scrollHeight || document.body.scrollHeight || 0);
            }catch{}
          }
        };
        run();
        requestAnimationFrame(() => {
          run();
          requestAnimationFrame(run);
        });
        setTimeout(run, 80);
        setTimeout(run, 220);
        setTimeout(run, 420);
        setTimeout(run, 760);
      }
      function _chatAutoGrowInput(){
        const input = el.appChatInput;
        if (!input) return;
        input.style.height = "0px";
        input.style.height = `${Math.min(160, Math.max(44, input.scrollHeight))}px`;
      }
      function _chatSetComposerBusy(busy){
        _chatState.composerBusy = !!busy;
        _chatApplyComposerAvailability();
      }
      function _chatBindUiOnce(){
        if (_chatState.bound) return;
        _chatState.bound = true;
        el.appChatScroll?.addEventListener("scroll", () => {
          _chatState.followBottom = true;
          if (document.body?.dataset?.appTab === "chat"){
            _chatScrollToBottom(true);
          }
        }, { passive: true });
        window.addEventListener("resize", () => {
          if (document.body?.dataset?.appTab === "chat"){
            _chatForceLatestPosition();
          }
        }, { passive: true });
        window.visualViewport?.addEventListener?.("resize", () => {
          if (document.body?.dataset?.appTab === "chat"){
            _chatForceLatestPosition();
          }
        }, { passive: true });
        document.addEventListener("visibilitychange", () => {
          if (document.visibilityState === "hidden"){
            _chatRemoteSaveNow("visibility-hidden");
          }
        });
        el.appChatComposer?.addEventListener("submit", (e) => {
          e.preventDefault();
          const submitterId = String(e?.submitter?.id || "");
          if (submitterId === "appChatSendBtn"){
            _appChatSubmitInput();
          }
        });
        el.appChatInput?.addEventListener("input", () => {
          _chatAutoGrowInput();
        });
        el.appChatInput?.addEventListener("keydown", (e) => {
          if (e.isComposing || e.keyCode === 229) return;
          if (e.key === "Enter" && (e.ctrlKey || e.metaKey)){
            e.preventDefault();
            _appChatSubmitInput();
          }
        });
        el.appChatIntentSearch?.addEventListener("input", (e) => {
          const t = e.target;
          _chatState.intentSearchQuery = String(t?.value || "");
          _chatScheduleIntentRender();
        });
        _chatAutoGrowInput();
        _chatRenderModeUi();
        _chatRenderIntentBrowser();
        _chatStartPinLatest();
        _chatForceLatestPosition();
        setTimeout(_chatForceLatestPosition, 480);
        setTimeout(_chatForceLatestPosition, 980);
      }
      function _chatCreateDoc(type, title, body, extra = {}){
        const t = String(title || "").trim();
        const b = String(body || "").trim();
        if (!t || !b) return null;
        const sourceType = String(type || "help");
        const titleNorm = _chatNormalizeForSearch(t);
        const bodyNorm = _chatNormalizeForSearch(b);
        const norm = `${titleNorm} ${bodyNorm}`.trim();
        if (!norm) return null;
        return {
          id: String(extra.id || _chatMessageId("doc")),
          type: sourceType,
          title: t.slice(0, 140),
          body: b.slice(0, 1400),
          titleNorm,
          bodyNorm,
          norm,
          tokens: _chatTokenize(norm),
          ts: Number(extra.ts) || 0
        };
      }
      function _chatCollectHelpDocs(){
        const docs = [];
        if (typeof _renderHelpHTML !== "function") return docs;
        let html = "";
        try{ html = String(_renderHelpHTML() || ""); }catch{ html = ""; }
        if (!html) return docs;
        const host = document.createElement("div");
        host.innerHTML = html;

        host.querySelectorAll("details.faq").forEach((node, idx) => {
          const q = node.querySelector("summary")?.textContent || "";
          const a = node.querySelector(".faq-body")?.textContent || node.textContent || "";
          const doc = _chatCreateDoc("faq", q, a, { id: `faq-${idx}` });
          if (doc) docs.push(doc);
        });

        const headings = Array.from(host.querySelectorAll("h2,h3,h4"));
        headings.forEach((hd, idx) => {
          const title = hd.textContent || "";
          let body = "";
          let cur = hd.nextElementSibling;
          let guard = 0;
          while (cur && !/H2|H3|H4/.test(cur.tagName) && guard < 10){
            body += " " + (cur.textContent || "");
            cur = cur.nextElementSibling;
            guard++;
          }
          const doc = _chatCreateDoc("help", title, body, { id: `help-${idx}` });
          if (doc) docs.push(doc);
        });
        return docs.slice(0, 180);
      }
      function _chatCollectNotificationDocs(){
        const docs = [];
        let list = [];
        try{
          if (typeof loadNotifications === "function"){
            const n = loadNotifications();
            list = Array.isArray(n) ? n : [];
          }
        }catch{
          list = [];
        }
        for (const n of list.slice(0, 120)){
          const title = String(n?.title || "").trim();
          const body = String(n?.body || "").trim();
          const cat = String(n?.category || "Update");
          const pri = String(n?.priority || "normal");
          const d = _chatCreateDoc("notification", title || "", `${body}\n${cat} ${pri}`, {
            id: String(n?.id || _chatMessageId("notif")),
            ts: Number(n?.ts) || 0
          });
          if (d) docs.push(d);
        }
        return docs;
      }
      function _chatCollectHistoryDocs(){
        const docs = [];
        _chatEnsureLoaded();
        for (const m of _chatState.history.slice(-80)){
          if (!m || !m.text) continue;
          const role = m.role === "user" ? "User" : "AI";
          const title = `(${role})`;
          const d = _chatCreateDoc("chat", title, String(m.text || ""), {
            id: String(m.id || _chatMessageId("chat")),
            ts: Number(m.ts) || 0
          });
          if (d) docs.push(d);
        }
        return docs;
      }
      function _chatCollectMemoryDocs(){
        const docs = [];
        const mem = _chatState.memory || {};
        const summary = String(mem.summary || "").trim();
        if (!summary) return docs;
        const d = _chatCreateDoc("memory", "", summary, {
          id: "memory-summary",
          ts: Number(mem.updatedAt) || 0
        });
        if (d) docs.push(d);
        return docs;
      }
      function _chatBuildKnowledgeIndex(){
        const docs = []
          .concat(_chatCollectHelpDocs())
          .concat(_chatCollectNotificationDocs())
          .concat(_chatCollectHistoryDocs())
          .concat(_chatCollectMemoryDocs())
          .slice(0, 500);
        _chatState.knowledge.docs = docs;
        _chatState.knowledge.ready = true;
        _chatState.knowledge.builtAt = Date.now();
      }
      function _chatScheduleKnowledgeBuild(reason = ""){
        _chatState.knowledge.reason = String(reason || "");
        if (_chatState.knowledge.pending) return;
        _chatState.knowledge.pending = true;
        const run = () => {
          _chatState.knowledge.pending = false;
          _chatBuildKnowledgeIndex();
        };
        if (typeof requestIdleCallback === "function"){
          requestIdleCallback(() => run(), { timeout: 1200 });
        } else {
          setTimeout(run, 140);
        }
      }
      function _chatEnsureKnowledgeNow(){
        const builtAt = Number(_chatState.knowledge.builtAt) || 0;
        const stale = !builtAt || (Date.now() - builtAt) > 90000;
        if (_chatState.knowledge.ready && _chatState.knowledge.docs.length && !stale) return;
        _chatBuildKnowledgeIndex();
      }
      function _chatScoreDoc(doc, qNorm, tokens, intent){
        if (!doc || !doc.norm) return 0;
        let score = 0;
        if (qNorm && doc.titleNorm.includes(qNorm)) score += 20;
        if (qNorm && doc.bodyNorm.includes(qNorm)) score += 10;
        for (const t of tokens){
          if (!t) continue;
          if (doc.titleNorm.includes(t)) score += 6;
          if (doc.bodyNorm.includes(t)) score += 2;
        }
        if (doc.type === "faq") score += 2;
        if (doc.type === "memory") score += 1.5;
        if (doc.type === "notification") score += 1;
        if (intent === "share_help" && doc.norm.includes("")) score += 8;
        if (intent === "notify_help" && (doc.type === "notification" || doc.norm.includes(""))) score += 8;
        if (intent === "tips_exam" && doc.norm.includes("exam")) score += 4;
        if (intent === "tips_write" && doc.norm.includes("write")) score += 4;
        if ((Date.now() - (Number(doc.ts) || 0)) < 14 * 86400000) score += 1;
        return score;
      }
      function _chatSourceLabel(type){
        if (type === "faq") return "FAQ";
        if (type === "notification") return "";
        if (type === "chat") return "";
        if (type === "memory") return "";
        return "";
      }
      function _chatSearchKnowledge(query, intent, limit = CHAT_RAG_TOPK){
        _chatEnsureLoaded();
        _chatEnsureKnowledgeNow();
        const qNorm = _chatNormalizeForSearch(query);
        const tokens = _chatTokenize(query);
        if (!qNorm && !tokens.length) return [];
        const docs = Array.isArray(_chatState.knowledge.docs) ? _chatState.knowledge.docs : [];
        const scored = [];
        for (const doc of docs){
          const score = _chatScoreDoc(doc, qNorm, tokens, intent);
          if (score <= 0) continue;
          scored.push({ doc, score });
        }
        scored.sort((a, b) => b.score - a.score);
        const out = [];
        for (const row of scored){
          out.push({
            id: String(row.doc.id || ""),
            type: String(row.doc.type || ""),
            label: _chatSourceLabel(row.doc.type),
            title: row.doc.title,
            snippet: row.doc.body.slice(0, 120),
            score: row.score
          });
          if (out.length >= limit) break;
        }
        return out;
      }
      function _chatClassifyIntent(text, hinted = ""){
        const src = String(text || "");
        const t = _chatNormalize(src);
        const hint = String(hinted || "").trim();
        const terms = _chatExtractTerms(src, 4);
        const hits = {
          study: _chatCountKeywordHits(t, CHAT_KEYWORDS.study) + _chatCountKeywordHits(t, CHAT_KEYWORDS.app),
          romance: _chatCountKeywordHits(t, CHAT_KEYWORDS.romance),
          game: _chatCountKeywordHits(t, CHAT_KEYWORDS.game),
          smalltalk: _chatCountKeywordHits(t, CHAT_KEYWORDS.smalltalk)
        };
        const shortHelpSignal = /|||||||/.test(t);
        const studyScore = hits.study + (shortHelpSignal ? 1 : 0);
        const offTopicScore = (hits.romance * 2) + (hits.game * 2) + hits.smalltalk;

        let intent = hint || "general_help";
        if (!hint){
          if (t.includes("") || t.includes("") || t.includes("trend") || t.includes("")) intent = "trend";
          else if (t.includes("") || t.includes("") || t.includes("") || shortHelpSignal) intent = "trend_summary";
          else if (t.includes("") || t.includes("") || t.includes("") || t.includes("") || t.includes("weak")) intent = "weak";
          else if (t.includes("") || t.includes("") || t.includes("recommend")) intent = "recommend";
          else if (t.includes("") || t.includes("") || t.includes("week") || t.includes("")) intent = "compare_week";
          else if (t.includes("exam") || t.includes("4") || t.includes("")) intent = "tips_exam";
          else if (t.includes("write") || t.includes("") || t.includes("") || t.includes("")) intent = "tips_write";
          else if (t.includes("") || t.includes("inbox") || t.includes("")) intent = "notify_help";
          else if (t.includes("") || t.includes("qr") || t.includes("") || t.includes("share")) intent = "share_help";
        }

        let scope = "study";
        let topic = "study";
        if (!hint){
          if (offTopicScore >= 3 && studyScore === 0){
            scope = "out_of_scope";
            if (hits.romance >= hits.game && hits.romance > 0) topic = "romance";
            else if (hits.game > 0) topic = "game";
            else topic = "general";
          } else {
            scope = "study";
            topic = "study";
            if (intent === "general_help") intent = "trend_summary";
          }
        }
        return { scope, topic, intent, terms, hits, studyScore, offTopicScore };
      }
      function _chatGetSessions(){
        try{
          if (typeof _insightsLoadSessions === "function"){
            const list = _insightsLoadSessions();
            if (Array.isArray(list)) return list;
          }
        }catch{}
        return [];
      }
      function _chatNormalizeSessions(rawSessions){
        const out = [];
        for (const row of (Array.isArray(rawSessions) ? rawSessions : [])){
          if (!row || typeof row !== "object") continue;
          const ts = _chatNormalizeTs(row.ts ?? row.date ?? row.createdAt ?? row.updatedAt);
          if (!ts) continue;
          const totalRaw = _chatSafeNum(row.total, 0);
          const total = Math.max(0, Math.floor(totalRaw));
          const correctRaw = _chatSafeNum(row.correct, 0);
          const correct = Math.max(0, Math.min(total, Math.floor(correctRaw)));
          const durationMsRaw = _chatSafeNum(row.durationMs, 0);
          const durationMs = Math.max(0, durationMsRaw);
          const wrongIds = (Array.isArray(row.wrongIds) ? row.wrongIds : [])
            .map((v) => Number(v))
            .filter((n) => Number.isFinite(n));
          out.push({
            ts,
            total,
            correct,
            durationMs,
            mode: String(row.mode || ""),
            wrongIds
          });
        }
        out.sort((a, b) => a.ts - b.ts);
        return out;
      }
      function _chatFilterRangeMs(sessions, fromTs, toTs){
        const from = _chatSafeNum(fromTs, 0);
        const to = _chatSafeNum(toTs, Date.now() + 1);
        return (Array.isArray(sessions) ? sessions : []).filter((s) => {
          const ts = _chatSafeNum(s?.ts, 0);
          return ts > 0 && ts >= from && ts < to;
        });
      }
      function _chatFilterRange(sessions, range = "ALL"){
        const now = Date.now();
        if (range === "7D"){
          return _chatFilterRangeMs(sessions, now - (7 * 86400000), now + 1);
        }
        if (range === "30D"){
          return _chatFilterRangeMs(sessions, now - (30 * 86400000), now + 1);
        }
        return _chatFilterRangeMs(sessions, 0, now + 1);
      }
      function _chatCalcMetrics(list){
        const src = Array.isArray(list) ? list : [];
        let total = 0;
        let correct = 0;
        let durationMs = 0;
        let lastTs = 0;
        const modeMap = new Map();
        for (const s of src){
          total += _chatSafeNum(s?.total, 0);
          correct += _chatSafeNum(s?.correct, 0);
          durationMs += _chatSafeNum(s?.durationMs, 0);
          lastTs = Math.max(lastTs, _chatSafeNum(s?.ts, 0));
          const mode = String(s?.mode || "");
          if (!mode) continue;
          modeMap.set(mode, (modeMap.get(mode) || 0) + 1);
        }
        const modeTop = Array.from(modeMap.entries()).sort((a, b) => b[1] - a[1])[0]?.[0] || "";
        const accuracy = total > 0 ? (correct / total) * 100 : null;
        const avgTimeSec = (total > 0 && durationMs > 0) ? (durationMs / 1000 / total) : null;
        return {
          list: src,
          sessions: src.length,
          total,
          correct,
          durationMs,
          accuracy,
          avgTimeSec,
          modeTop,
          lastTs
        };
      }
      function _chatDailySeries(sessions, days){
        const len = Math.max(1, Number(days) || 7);
        const now = Date.now();
        const base = new Date(now);
        base.setHours(0, 0, 0, 0);
        const map = new Map();
        for (const s of (Array.isArray(sessions) ? sessions : [])){
          const ymd = _chatDateKey(_chatSafeNum(s?.ts, 0));
          if (!ymd) continue;
          const cur = map.get(ymd) || { total: 0, correct: 0 };
          cur.total += _chatSafeNum(s?.total, 0);
          cur.correct += _chatSafeNum(s?.correct, 0);
          map.set(ymd, cur);
        }
        const out = [];
        for (let i = len - 1; i >= 0; i--){
          const d = new Date(base.getTime() - i * 86400000);
          const ymd = _chatDateKey(d.getTime());
          const v = map.get(ymd) || { total: 0, correct: 0 };
          const acc = v.total > 0 ? (v.correct / v.total) * 100 : 0;
          out.push({
            ymd,
            label: `${d.getMonth() + 1}/${d.getDate()}`,
            total: v.total,
            accuracy: Math.round(acc * 10) / 10
          });
        }
        return out;
      }
      function _chatBuildStats(){
        const sessions = _chatNormalizeSessions(_chatGetSessions());
        const now = Date.now();
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const todayStart = today.getTime();
        const range7List = _chatFilterRange(sessions, "7D");
        const range30List = _chatFilterRange(sessions, "30D");
        const rangeAllList = _chatFilterRange(sessions, "ALL");
        const thisWeekList = _chatFilterRangeMs(sessions, todayStart - 7 * 86400000, todayStart + 86400000);
        const prevWeekList = _chatFilterRangeMs(sessions, todayStart - 14 * 86400000, todayStart - 7 * 86400000);
        const range7 = _chatCalcMetrics(range7List);
        const range30 = _chatCalcMetrics(range30List);
        const rangeAll = _chatCalcMetrics(rangeAllList);
        const thisWeek = _chatCalcMetrics(thisWeekList);
        const prevWeek = _chatCalcMetrics(prevWeekList);

        const wrongFreq = new Map();
        for (const s of rangeAllList){
          const ids = Array.isArray(s?.wrongIds) ? s.wrongIds : [];
          for (const id of ids){
            const n = Number(id);
            if (!Number.isFinite(n)) continue;
            wrongFreq.set(n, (wrongFreq.get(n) || 0) + 1);
          }
        }
        const weakTop = Array.from(wrongFreq.entries())
          .sort((a, b) => b[1] - a[1])
          .slice(0, 10)
          .map(([id, count]) => {
            const word = data?.byId instanceof Map ? data.byId.get(id) : null;
            return { id, count, word: String(word?.word || "") };
          });
        const weakIds = weakTop.map((x) => x.id);
        return {
          hasData: rangeAll.sessions > 0,
          range7,
          range30,
          rangeAll,
          thisWeek,
          prevWeek,
          weakTop,
          weakIds,
          daily7: _chatDailySeries(range7List, 7),
          daily30: _chatDailySeries(range30List, 30),
          weekAnswerDelta: thisWeek.total - prevWeek.total,
          weekAccDelta: _chatSafeNum(thisWeek.accuracy, 0) - _chatSafeNum(prevWeek.accuracy, 0)
        };
      }
      function _chatBuildInsightsSummaryForApi(stats){
        if (!stats || !stats.hasData){
          return "1";
        }
        const weak = Array.isArray(stats.weakTop) ? stats.weakTop.slice(0, 5).map((w) => `No.${w.id}:${w.count}`) : [];
        return [
          `7: ${stats.range7.total} ${_chatPctText(stats.range7.correct, stats.range7.total)} ${stats.range7.sessions}`,
          `30: ${stats.range30.total} ${_chatPctText(stats.range30.correct, stats.range30.total)} ${stats.range30.sessions}`,
          `: ${stats.rangeAll.total} ${_chatPctText(stats.rangeAll.correct, stats.rangeAll.total)} ${stats.rangeAll.sessions}`,
          `:${_chatModeName(stats.range30.modeTop || stats.rangeAll.modeTop)} :${_chatFmtDate(stats.rangeAll.lastTs)}`,
          weak.length ? `:${weak.join(", ")}` : ":"
        ].join("\n");
      }
      function _chatBuildApiMessages(latestUserText){
        const list = [];
        const history = Array.isArray(_chatState.history) ? _chatState.history : [];
        for (const row of history.slice(-16)){
          if (!row || typeof row !== "object") continue;
          const role = row.role === "ai" ? "assistant" : (row.role === "user" ? "user" : "");
          if (!role) continue;
          const content = String(row.text || "").trim();
          if (!content) continue;
          list.push({ role, content: content.slice(0, 1200) });
        }
        const latest = String(latestUserText || "").trim();
        if (latest){
          const last = list[list.length - 1];
          if (!last || last.role !== "user" || last.content !== latest){
            list.push({ role: "user", content: latest.slice(0, 1200) });
          }
        }
        return list.slice(-12);
      }
      function _chatBuildApiRefs(knowledge){
        const helpIds = [];
        const notificationIds = [];
        const seenHelp = new Set();
        const seenNotif = new Set();
        for (const row of (Array.isArray(knowledge) ? knowledge : [])){
          const type = String(row?.type || "");
          const id = String(row?.id || "").trim();
          if (!id) continue;
          if ((type === "faq" || type === "help" || type === "memory") && !seenHelp.has(id)){
            seenHelp.add(id);
            helpIds.push(id);
          } else if (type === "notification" && !seenNotif.has(id)){
            seenNotif.add(id);
            notificationIds.push(id);
          }
          if (helpIds.length >= 12 && notificationIds.length >= 12) break;
        }
        return { helpIds, notificationIds };
      }
      function _chatBuildAiResponseActions(stats, selectedIntent){
        const actions = [];
        const weakIds = Array.isArray(stats?.weakIds) ? stats.weakIds.slice(0, 20) : [];
        const title = String(selectedIntent?.title || "");
        const isWrite = /write||/i.test(title);
        if (weakIds.length){
          actions.push({
            type: isWrite ? "startWriteWeak" : "startExamWeak",
            label: isWrite ? "TOPWRITE" : "TOPEXAM",
            ids: weakIds
          });
        }
        actions.push({ type: "openInsights", label: "Insights" });
        return actions.slice(0, 3);
      }
      function _chatMapWorkerAction(actionRaw, stats){
        const a = (actionRaw && typeof actionRaw === "object") ? actionRaw : {};
        const key = String(a.action || a.type || "").trim().toLowerCase();
        const label = String(a.label || "").trim();
        const weakIds = Array.isArray(stats?.weakIds) ? stats.weakIds.slice(0, 20) : [];
        if (key === "insight_recent" || key === "open_insights"){
          return { type: "openInsights", label: label || "" };
        }
        if (key === "start_weak_top" || key === "start_exam_weak"){
          return { type: "startExamWeak", label: label || "TOPEXAM", ids: weakIds };
        }
        if (key === "start_weak_write" || key === "start_write_weak"){
          return { type: "startWriteWeak", label: label || "WRITE", ids: weakIds };
        }
        if (key === "share_help" || key === "open_share"){
          return { type: "openShare", label: label || "" };
        }
        if (key === "open_inbox"){
          return { type: "openInbox", label: label || "" };
        }
        if (key === "open_settings"){
          return { type: "openSettings", label: label || "" };
        }
        if (key === "ask" || key === "ask_prompt"){
          const prompt = String(a.prompt || "").trim();
          if (!prompt) return null;
          return { type: "askPrompt", label: label || "", prompt };
        }
        return null;
      }
      async function _chatRequestWorkerAi(job, selectedIntent, cls){
        const stats = _chatBuildStats();
        const knowledge = _chatSearchKnowledge(job.text, String(selectedIntent?.title || cls.intent || ""), CHAT_RAG_TOPK);
        const mode = _chatNormalizeAiMode(_chatState.aiMode);
        const refs = _chatBuildApiRefs(knowledge);
        const presetInfo = _appCurrentPresetInfo();
        const insightFilter = (typeof _appGetInsightsFilterState === "function") ? _appGetInsightsFilterState() : null;
        const payload = {
          mode,
          text: String(job.text || "").trim(),
          message: String(job.text || "").trim(),
          messages: _chatBuildApiMessages(job.text),
          context: {
            presetId: String(presetInfo?.id || ""),
            selectedRange: String(insightFilter?.range || "ALL"),
            app: "VocabuQuiz",
            version: String(APP_VERSION || "v26"),
            insightsSummary: _chatBuildInsightsSummaryForApi(stats),
            refs
          }
        };
        const headers = { "Content-Type": "application/json" };
        const authToken = (typeof _authGetToken === "function") ? String(_authGetToken() || "").trim() : "";
        if (authToken && _chatApiAllowsAuthHeader(CHAT_AI_API_URL)){
          headers.Authorization = `Bearer ${authToken}`;
        }
        let res;
        try{
          res = await fetch(CHAT_AI_API_URL, {
            method: "POST",
            headers,
            body: JSON.stringify(payload)
          });
        }catch(err){
          const canRetryNoAuth = !!headers.Authorization;
          if (!canRetryNoAuth) throw err;
          const fallbackHeaders = { "Content-Type": "application/json" };
          res = await fetch(CHAT_AI_API_URL, {
            method: "POST",
            headers: fallbackHeaders,
            body: JSON.stringify(payload)
          });
        }
        const raw = await res.text();
        let body = null;
        try{
          body = raw ? JSON.parse(raw) : {};
        }catch{
          const err = new Error(raw ? raw.slice(0, 240) : "AI");
          err.code = "BAD_AI_RESPONSE";
          err.status = Number(res.status || 0);
          throw err;
        }
        if (!res.ok){
          const err = new Error(String(body?.message || body?.error || `HTTP_${res.status}`));
          err.code = String(body?.code || body?.error || `HTTP_${res.status}`);
          err.status = Number(res.status || 0);
          err.data = body || null;
          throw err;
        }
        const answer = String(body?.answer || body?.reply || "").trim();
        if (!answer){
          const err = new Error("AI");
          err.code = "AI_EMPTY_RESPONSE";
          err.status = 502;
          throw err;
        }
        const rawMeta = (body?.meta && typeof body.meta === "object") ? body.meta : {};
        const usage = (body?.usage && typeof body.usage === "object") ? body.usage : {};
        const modeResolved = _chatNormalizeAiMode(rawMeta.mode || mode);
        const normalLimit = Math.max(1, Number(rawMeta?.quota?.normalLimit || CHAT_AI_MODE_LIMITS.normal));
        const reasonLimit = Math.max(1, Number(rawMeta?.quota?.reasonLimit || CHAT_AI_MODE_LIMITS.reason));
        const remNormalRaw = Number(usage.remainingNormal);
        const remReasonRaw = Number(usage.remainingReasoning);
        const remainingNormal = Number.isFinite(remNormalRaw) ? Math.max(0, remNormalRaw) : null;
        const remainingReasoning = Number.isFinite(remReasonRaw) ? Math.max(0, remReasonRaw) : null;
        const resetAtMs = Number(usage.resetAtMs || rawMeta.resetAtMs || _chatState.quotaResetAtMs || _chatNextJstResetMs(Date.now()));
        const quotaNext = {
          normalUsed: remainingNormal == null ? Math.max(0, Number(_chatState.quota?.normalUsed || 0)) : Math.max(0, normalLimit - remainingNormal),
          normalLimit,
          reasonUsed: remainingReasoning == null ? Math.max(0, Number(_chatState.quota?.reasonUsed || 0)) : Math.max(0, reasonLimit - remainingReasoning),
          reasonLimit
        };
        const meta = {
          ...rawMeta,
          mode: modeResolved,
          quota: quotaNext,
          resetAtMs
        };
        const citations = Array.isArray(body?.citations) ? body.citations : [];
        const sources = citations.map((row) => ({
          label: String(row?.docId || "RAG").slice(0, 80),
          title: String(row?.title || "").slice(0, 100),
          snippet: String(row?.snippet || "").slice(0, 180)
        })).filter((x) => x.title);
        const suggested = Array.isArray(body?.suggestedActions) ? body.suggestedActions : [];
        const actions = [];
        for (const s of suggested){
          const mapped = _chatMapWorkerAction(s, stats);
          if (mapped) actions.push(mapped);
          if (actions.length >= 4) break;
        }
        if (!actions.length){
          actions.push(..._chatBuildAiResponseActions(stats, selectedIntent));
        }
        const charts = _chatBuildChartData(stats, String(job.text || ""), String(selectedIntent?.id || cls.intent || ""), String(selectedIntent?.type || ""));
        return {
          text: answer,
          actions,
          sources,
          charts,
          aiMeta: meta
        };
      }

      const CHAT_PHRASES = {
        introPhrases: [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          ""
        ],
        summaryPhrases: [
          "7: {a7} / {p7}% / {s7}",
          "30: {a30}{p30}%{m30}",
          ": {aAll}{cAll}{sAll}",
          " 7:{a7} / 30:{a30} / :{aAll} ",
          " {lastAt} {modeTop} ",
          "7{p7}%30{p30}% ",
          " {twA} {pwA}",
          " {twP}% {pwP}% ",
          "30 {s30}",
          " {aAll}",
          "7{m7}30{m30}",
          "7{a7}30{a30}"
        ],
        insightPhrases: [
          "",
          "730",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          ""
        ],
        advicePhrases: [
          "TOP1",
          "102",
          "",
          "EXAMWRITE",
          "",
          "",
          "",
          "1",
          "3",
          "",
          "",
          "1"
        ],
        closingPhrases: [
          "",
          "",
          "1",
          "",
          "",
          "TOP",
          "",
          "",
          "",
          "1",
          "",
          ""
        ],
        examTips: [
          "EXAM",
          "2",
          "",
          "1",
          "",
          "",
          "",
          "4",
          "",
          "",
          "",
          "EXAMWRITE"
        ],
        writeTips: [
          "WRITE1",
          "",
          "",
          "3",
          "WRITETURN1",
          "",
          "",
          "",
          "3",
          "WRITE",
          "1",
          ""
        ],
        fallbackPhrases: [
          "1",
          "",
          "EXAMWRITE1",
          "",
          "",
          "1",
          "",
          "1",
          "",
          ""
        ],
        shareHelpPhrases: [
          "6",
          "",
          "My Preset",
          "",
          "QR6",
          "firebaseConfig",
          "(2)(3)",
          "",
          "LibraryMy Preset",
          ""
        ],
        notifyHelpPhrases: [
          "",
          "",
          "",
          "",
          "Admin",
          "",
          "",
          "",
          "",
          ""
        ],
        echoPhrases: [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          ""
        ],
        kbLeadPhrases: [
          "/FAQ/",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          ""
        ],
        outScopePhrases: [
          "",
          "AI",
          "",
          "",
          "AI",
          "",
          "",
          "",
          "",
          ""
        ],
        enginePhrases: [
          "AIOpenAI APIAI",
          "",
          "API",
          "",
          "",
          "",
          "",
          "",
          "FAQ",
          "AI"
        ]
      };
      CHAT_PHRASES.intro = CHAT_PHRASES.introPhrases.slice(0, 12);
      CHAT_PHRASES.summary = CHAT_PHRASES.summaryPhrases.slice(0, 12);
      CHAT_PHRASES.insight = CHAT_PHRASES.insightPhrases.slice(0, 12);
      CHAT_PHRASES.advice = CHAT_PHRASES.advicePhrases.slice(0, 12);
      CHAT_PHRASES.closing = CHAT_PHRASES.closingPhrases.slice(0, 12);
      CHAT_PHRASES.examTips = CHAT_PHRASES.examTips.slice(0, 12);
      CHAT_PHRASES.writeTips = CHAT_PHRASES.writeTips.slice(0, 12);
      CHAT_PHRASES.appHelpPhrases = []
        .concat(CHAT_PHRASES.shareHelpPhrases.slice(0, 6))
        .concat(CHAT_PHRASES.notifyHelpPhrases.slice(0, 6))
        .slice(0, 12);

      function _chatBuildFactsBlock(stats){
        if (!stats.hasData){
          return _chatPick(CHAT_PHRASES.fallbackPhrases);
        }
        const weakTop = stats.weakTop.slice(0, 3)
          .map((w) => `No.${w.id}${w.word ? `(${w.word})` : ""}`)
          .join(" / ");
        return [
          `7: ${stats.range7.total} / ${_chatPctText(stats.range7.correct, stats.range7.total)} / ${stats.range7.sessions}`,
          `30: ${stats.range30.total} / ${_chatPctText(stats.range30.correct, stats.range30.total)}`,
          `: ${stats.weekAnswerDelta >= 0 ? "+" : ""}${stats.weekAnswerDelta} / ${stats.weekAccDelta >= 0 ? "+" : ""}${stats.weekAccDelta.toFixed(1)}pt`,
          `: ${_chatModeName(stats.range30.modeTop || stats.rangeAll.modeTop)} / : ${_chatFmtDate(stats.rangeAll.lastTs)}`,
          weakTop ? `TOP3: ${weakTop}` : "TOP3: "
        ].join("\n");
      }
      function _chatShouldShowCharts(userText, intent, intentType = ""){
        const t = _chatNormalize(userText);
        if (intentType === "TREND" || intentType === "COMPARE" || intentType === "WEAK") return true;
        if (intent === "trend" || intent === "trend_summary" || intent === "compare_week") return true;
        return /|||||trend|chart||/.test(t);
      }
      function _chatBuildChartData(stats, userText, intent, intentType = ""){
        if (!_chatShouldShowCharts(userText, intent, intentType)) return [];
        if (intentType === "WEAK"){
          const weak = Array.isArray(stats?.weakTop) ? stats.weakTop.slice(0, 10) : [];
          const points = weak.length
            ? weak.map((w) => ({ label: `No.${w.id}`, value: _chatSafeNum(w.count, 0), extra: 0 }))
            : [{ label: "", value: 0, extra: 0 }];
          return [{ type: "hbar", title: weak.length ? "TOP10" : "TOP10", points }];
        }
        const baseSeries = (intentType === "COMPARE" || intent === "compare_week") ? stats.daily30.slice(-14) : stats.daily7;
        const hasData = Array.isArray(baseSeries) && baseSeries.some((d) => (Number(d?.total) || 0) > 0);
        const volumePoints = (hasData ? baseSeries : [{ label: "", total: 0, accuracy: 0 }])
          .map((d) => ({ label: d.label, value: d.total, extra: 0 }));
        const accPoints = (hasData ? baseSeries : [{ label: "", total: 0, accuracy: 0 }])
          .map((d) => ({ label: d.label, value: d.accuracy, extra: 0 }));
        return [
          { type: "bar", title: hasData ? "7 " : "7 ", points: volumePoints },
          { type: "line", title: hasData ? "7 %" : "7 ", points: accPoints }
        ];
      }
      function _chatBuildOutScopeReply(cls, stats, userText){
        const terms = cls.terms.length ? cls.terms.join(" / ") : "";
        const topicLabel = cls.topic === "romance" ? "" : (cls.topic === "game" ? "" : "");
        const alreadyExplained = !!_chatState.memory?.outScopeExplained;
        const text = alreadyExplained ? [
          `${topicLabel}AI${terms}`,
          "",
          ": TOP10 /  / EXAM"
        ].join("\n") : [
          `${_chatPick(CHAT_PHRASES.outScopePhrases)}: ${topicLabel} / : ${terms}`,
          `${_chatPick(CHAT_PHRASES.enginePhrases)}\n:     //  \n: \n: /`,
          "OK\n: TOP10 /  / EXAM"
        ].join("\n\n");
        const actions = [
          { type: "askPrompt", label: "TOP", prompt: "" },
          { type: "askPrompt", label: "", prompt: "" },
          { type: "askPrompt", label: "EXAM", prompt: "EXAM" }
        ];
        return { text, actions, charts: [], sources: [], scope: "out_of_scope" };
      }
      function _chatBuildStudyReply(cls, stats, userText, knowledge, intentMeta = null){
        const intent = String(cls.intent || "general_help");
        const intentType = String(intentMeta?.type || (intent === "compare_week" ? "COMPARE" : (intent === "weak" ? "WEAK" : (intent === "tips_exam" || intent === "tips_write" ? "TIPS" : "TREND"))));
        const intentTitle = String(intentMeta?.title || "");
        const terms = cls.terms.length ? cls.terms : _chatExtractTerms(userText, 4);
        const refs = Array.isArray(knowledge) ? knowledge.slice(0, CHAT_RAG_TOPK) : [];
        const introLine = _chatPick(CHAT_PHRASES.intro);
        const echo = terms.length
          ? `${introLine} ${terms.join(" / ")}`
          : `${introLine} `;
        const summaryTpl = _chatPick(CHAT_PHRASES.summary, "7: {a7} / {p7}%");
        const summaryLine = summaryTpl
          .replaceAll("{a7}", String(stats.range7.total))
          .replaceAll("{p7}", _chatPctOrDash(stats.range7.correct, stats.range7.total))
          .replaceAll("{s7}", String(stats.range7.sessions))
          .replaceAll("{a30}", String(stats.range30.total))
          .replaceAll("{p30}", _chatPctOrDash(stats.range30.correct, stats.range30.total))
          .replaceAll("{s30}", String(stats.range30.sessions))
          .replaceAll("{m30}", String(Math.round(_chatSafeNum(stats.range30.durationMs, 0) / 60000)))
          .replaceAll("{m7}", String(Math.round(_chatSafeNum(stats.range7.durationMs, 0) / 60000)))
          .replaceAll("{aAll}", String(stats.rangeAll.total))
          .replaceAll("{cAll}", String(stats.rangeAll.correct))
          .replaceAll("{sAll}", String(stats.rangeAll.sessions))
          .replaceAll("{lastAt}", _chatFmtDate(stats.rangeAll.lastTs))
          .replaceAll("{modeTop}", _chatModeName(stats.range30.modeTop || stats.rangeAll.modeTop))
          .replaceAll("{twA}", String(stats.thisWeek.total))
          .replaceAll("{pwA}", String(stats.prevWeek.total))
          .replaceAll("{twP}", _chatPctOrDash(stats.thisWeek.correct, stats.thisWeek.total))
          .replaceAll("{pwP}", _chatPctOrDash(stats.prevWeek.correct, stats.prevWeek.total));

        const facts = [
          summaryLine,
          `7: ${stats.range7.total} / ${_chatPctText(stats.range7.correct, stats.range7.total)} / ${stats.range7.sessions}`,
          `30: ${stats.range30.total} / ${_chatPctText(stats.range30.correct, stats.range30.total)} / ${stats.range30.sessions}`,
          `: ${_chatModeName(stats.range30.modeTop || stats.rangeAll.modeTop)}`
        ];
        if (stats.weakTop.length){
          facts.push(`TOP3: ${stats.weakTop.slice(0, 3).map((w) => `No.${w.id}`).join(" / ")}`);
        } else {
          facts.push("TOP3: ");
        }

        let main = _chatPick(CHAT_PHRASES.insight);
        if (intentType === "COMPARE"){
          main = `:  ${stats.weekAnswerDelta >= 0 ? "+" : ""}${stats.weekAnswerDelta} ${stats.weekAccDelta >= 0 ? "+" : ""}${stats.weekAccDelta.toFixed(1)}pt`;
        } else if (intentType === "WEAK"){
          const weakLead = stats.weakTop.slice(0, 3).map((w) => `No.${w.id}`).join(" / ");
          main = weakLead
            ? ` ${weakLead} `
            : "1";
        } else if (intentType === "TIPS"){
          const examLike = /exam|4|/i.test(`${intentTitle} ${userText}`);
          main = examLike ? _chatPick(CHAT_PHRASES.examTips) : _chatPick(CHAT_PHRASES.writeTips);
        } else if (intentType === "APP_HELP"){
          main = _chatPick(CHAT_PHRASES.appHelpPhrases);
        } else if (intentType === "TREND"){
          if (stats.weekAnswerDelta >= 15 || stats.weekAccDelta >= 2){
            main = "";
          } else if (stats.weekAnswerDelta < 0 || stats.weekAccDelta < -2){
            main = "";
          }
        }

        let coach = `${_chatPick(CHAT_PHRASES.advice)} ${_chatPick(CHAT_PHRASES.closing)}`;
        if (intentType === "APP_HELP"){
          coach = `${_chatPick(CHAT_PHRASES.appHelpPhrases)} `;
        }
        const refLine = refs.length ? `: [${refs[0].label}] ${refs[0].title}` : "";
        const text = [echo]
          .concat(facts.slice(0, 5))
          .concat(main)
          .concat(coach)
          .concat(refLine ? [refLine] : [])
          .concat(": ")
          .join("\n");

        const actions = [];
        const metaActions = Array.isArray(intentMeta?.actions) ? intentMeta.actions : [];
        for (const a of metaActions){
          if (a && typeof a === "object" && a.type && a.label){
            actions.push(a);
          }
        }
        if (intentType === "APP_HELP"){
          if (//.test(`${intentTitle} ${userText}`)){
            actions.push({ type: "openShare", label: "" });
          } else if (//.test(`${intentTitle} ${userText}`)){
            actions.push({ type: "openInbox", label: "Inbox" });
          } else if (/admin|permission|denied|domain||config|/i.test(`${intentTitle} ${userText}`)){
            actions.push({ type: "openSettings", label: "Settings" });
          }
        }
        if (!actions.length && stats.weakIds.length){
          actions.push({ type: "startExamWeak", label: "TOP10EXAM", ids: stats.weakIds.slice(0, 10) });
          actions.push({ type: "startWriteWeak", label: "WRITE20", ids: stats.weakIds.slice(0, 20) });
        }
        if (!actions.length){
          actions.push({ type: "openInsights", label: "Insights" });
        }

        const sources = refs.slice(0, 1).map((r) => ({
          label: r.label,
          title: r.title,
          snippet: r.snippet
        }));
        const charts = _chatBuildChartData(stats, userText, intent, intentType);
        return { text, actions, charts, sources, scope: "study" };
      }
      function _chatBuildReply(cls, stats, userText, knowledge, intentMeta = null){
        if (cls.scope !== "study"){
          return _chatBuildOutScopeReply(cls, stats, userText);
        }
        return _chatBuildStudyReply(cls, stats, userText, knowledge, intentMeta);
      }
      function _chatUpdateMemorySummary(){
        _chatEnsureLoaded();
        const studyUsers = _chatState.history
          .filter((m) => m && m.role === "user" && _chatIsStudyIntent(m.intent))
          .slice(-12);
        if (studyUsers.length < 3) return;
        const prev = (_chatState.memory && typeof _chatState.memory === "object") ? _chatState.memory : {};
        const freq = new Map();
        for (const m of studyUsers){
          const key = String(m.intent || "general_help");
          freq.set(key, (freq.get(key) || 0) + 1);
        }
        const focus = Array.from(freq.entries())
          .sort((a, b) => b[1] - a[1])
          .slice(0, 3)
          .map(([k]) => k);
        const latestTerms = _chatExtractTerms(studyUsers[studyUsers.length - 1]?.text || "", 3);
        _chatState.memory = {
          ...prev,
          updatedAt: Date.now(),
          summary: `${studyUsers.length} ${focus.join(" / ")} : ${latestTerms.join(" / ") || ""}`,
          focus
        };
        _chatSaveMemory();
        _chatScheduleKnowledgeBuild("memory-update");
      }
      function _chatMarkOutScopeNotice(){
        _chatEnsureLoaded();
        const prev = (_chatState.memory && typeof _chatState.memory === "object") ? _chatState.memory : {};
        _chatState.memory = {
          ...prev,
          outScopeExplained: true,
          outScopeCount: Math.max(0, _chatSafeNum(prev.outScopeCount, 0)) + 1,
          outScopeLastAt: Date.now(),
          updatedAt: Date.now()
        };
        _chatSaveMemory();
      }
      function _chatRenderBarSvg(chart){
        const points = Array.isArray(chart?.points) ? chart.points : [];
        const w = 720;
        const h = 180;
        const padL = 34;
        const padR = 16;
        const padT = 14;
        const padB = 30;
        const cw = w - padL - padR;
        const ch = h - padT - padB;
        const maxV = Math.max(1, ...points.map((p) => Number(p.value) || 0));
        const step = cw / Math.max(1, points.length);
        const barW = Math.max(4, step * 0.58);
        const bars = [];
        const labels = [];
        points.forEach((p, i) => {
          const v = Math.max(0, Number(p.value) || 0);
          const x = padL + i * step + (step - barW) / 2;
          const bh = (v / maxV) * ch;
          const y = padT + (ch - bh);
          bars.push(`<rect x="${x.toFixed(2)}" y="${y.toFixed(2)}" width="${barW.toFixed(2)}" height="${bh.toFixed(2)}" rx="2" fill="rgba(37,99,235,.72)"></rect>`);
          if (i % Math.ceil(points.length / 4) === 0 || i === points.length - 1){
            labels.push(`<text x="${(x + barW / 2).toFixed(2)}" y="${(h - 7).toFixed(2)}" text-anchor="middle" font-size="10" fill="rgba(120,120,120,.88)">${escapeHtml(p.label || "")}</text>`);
          }
        });
        return `<svg class="app-chat-chart-svg" viewBox="0 0 ${w} ${h}" role="img" aria-label="${escapeHtml(chart.title || "chart")}"><rect x="${padL}" y="${padT}" width="${cw}" height="${ch}" fill="transparent" stroke="rgba(148,163,184,.32)" stroke-width="1"></rect>${bars.join("")}${labels.join("")}</svg>`;
      }
      function _chatRenderLineSvg(chart){
        const points = Array.isArray(chart?.points) ? chart.points : [];
        const w = 720;
        const h = 180;
        const padL = 34;
        const padR = 16;
        const padT = 14;
        const padB = 30;
        const cw = w - padL - padR;
        const ch = h - padT - padB;
        const maxV = 100;
        const minV = 0;
        const step = cw / Math.max(1, points.length - 1);
        const dots = [];
        const labels = [];
        const poly = [];
        points.forEach((p, i) => {
          const vRaw = Number(p.value) || 0;
          const v = Math.max(minV, Math.min(maxV, vRaw));
          const x = padL + i * step;
          const y = padT + ch - ((v - minV) / (maxV - minV)) * ch;
          poly.push(`${x.toFixed(2)},${y.toFixed(2)}`);
          dots.push(`<circle cx="${x.toFixed(2)}" cy="${y.toFixed(2)}" r="2.2" fill="rgba(14,165,233,.86)"></circle>`);
          if (i % Math.ceil(points.length / 4) === 0 || i === points.length - 1){
            labels.push(`<text x="${x.toFixed(2)}" y="${(h - 7).toFixed(2)}" text-anchor="middle" font-size="10" fill="rgba(120,120,120,.88)">${escapeHtml(p.label || "")}</text>`);
          }
        });
        return `<svg class="app-chat-chart-svg" viewBox="0 0 ${w} ${h}" role="img" aria-label="${escapeHtml(chart.title || "chart")}"><rect x="${padL}" y="${padT}" width="${cw}" height="${ch}" fill="transparent" stroke="rgba(148,163,184,.32)" stroke-width="1"></rect><polyline points="${poly.join(" ")}" fill="none" stroke="rgba(14,165,233,.86)" stroke-width="2"></polyline>${dots.join("")}${labels.join("")}</svg>`;
      }
      function _chatRenderHBarSvg(chart){
        const points = Array.isArray(chart?.points) ? chart.points : [];
        const list = points.slice(0, 10);
        const w = 720;
        const h = 220;
        const padL = 160;
        const padR = 20;
        const padT = 14;
        const padB = 14;
        const cw = w - padL - padR;
        const ch = h - padT - padB;
        const rowH = ch / Math.max(1, list.length);
        const maxV = Math.max(1, ...list.map((p) => Number(p.value) || 0));
        const bars = [];
        const labels = [];
        list.forEach((p, i) => {
          const v = Math.max(0, Number(p.value) || 0);
          const y = padT + i * rowH + 2;
          const barH = Math.max(12, rowH - 6);
          const bw = (v / maxV) * cw;
          bars.push(`<rect x="${padL}" y="${y.toFixed(2)}" width="${bw.toFixed(2)}" height="${barH.toFixed(2)}" rx="4" fill="rgba(37,99,235,.72)"></rect>`);
          labels.push(`<text x="${(padL - 8).toFixed(2)}" y="${(y + barH * 0.7).toFixed(2)}" text-anchor="end" font-size="11" fill="rgba(120,120,120,.92)">${escapeHtml(p.label || "")}</text>`);
          labels.push(`<text x="${(padL + bw + 6).toFixed(2)}" y="${(y + barH * 0.7).toFixed(2)}" text-anchor="start" font-size="11" fill="rgba(120,120,120,.92)">${Math.round(v)}</text>`);
        });
        return `<svg class="app-chat-chart-svg" viewBox="0 0 ${w} ${h}" role="img" aria-label="${escapeHtml(chart.title || "chart")}"><rect x="${padL}" y="${padT}" width="${cw}" height="${ch}" fill="transparent" stroke="rgba(148,163,184,.32)" stroke-width="1"></rect>${bars.join("")}${labels.join("")}</svg>`;
      }
      function _chatRenderChartSvg(chart){
        const c = _chatSanitizeChart(chart);
        if (!c) return "";
        if (c.type === "hbar") return _chatRenderHBarSvg(c);
        if (c.type === "line") return _chatRenderLineSvg(c);
        return _chatRenderBarSvg(c);
      }

      function _chatUpdateTransientText(id, nextText){
        const key = String(id || "");
        if (!key) return;
        let target = null;
        for (const item of _chatState.transient){
          if (String(item?.id || "") === key){
            target = item;
            break;
          }
        }
        if (!target) return;
        target.text = String(nextText || "");
        if (!el.appChatList) return;
        const row = el.appChatList.querySelector(`[data-chat-msg-id="${key}"] .app-chat-bubble`);
        if (row){
          row.textContent = target.text;
          _chatScrollToBottom(false);
        } else {
          _appRenderChat();
        }
      }

      function _chatTypeText(fullText, onStep, onDone){
        const text = String(fullText || "");
        if (!text){
          if (typeof onDone === "function") onDone();
          return;
        }
        if (_chatPrefersReducedMotion()){
          if (typeof onStep === "function") onStep(text);
          if (typeof onDone === "function") onDone();
          return;
        }
        let index = 0;
        let last = performance.now();
        let waitMs = _chatRand(CHAT_TYPE_CHAR_MIN_MS, CHAT_TYPE_CHAR_MAX_MS);
        const chunkBase = text.length > 620 ? 4 : text.length > 360 ? 3 : text.length > 180 ? 2 : 1;
        const tick = (now) => {
          if (now - last >= waitMs){
            const chunk = chunkBase + (Math.random() < 0.22 ? 1 : 0);
            index = Math.min(text.length, index + chunk);
            if (typeof onStep === "function") onStep(text.slice(0, index));
            last = now;
            waitMs = _chatRand(CHAT_TYPE_CHAR_MIN_MS, CHAT_TYPE_CHAR_MAX_MS);
          }
          if (index < text.length){
            _chatState.rafId = requestAnimationFrame(tick);
          } else {
            _chatState.rafId = 0;
            if (typeof onDone === "function") onDone();
          }
        };
        _chatState.rafId = requestAnimationFrame(tick);
      }

      function _chatProcessQueue(){
        if (_chatState.processing) return;
        const job = _chatState.queue.shift();
        if (!job){
          _chatSetComposerBusy(false);
          return;
        }
        _chatState.processing = true;
        _chatSetComposerBusy(true);

        const selectedIntent = CHAT_INTENT_BY_ID.get(String(job.intentId || "").trim()) || null;
        const cls = _chatClassifyIntent(job.text, job.intentHint || "");
        if (selectedIntent){
          cls.scope = "study";
          cls.topic = selectedIntent.category;
          cls.intent = selectedIntent.id;
        }
        const intent = String(selectedIntent?.id || cls.intent || "general_help");
        const typingId = _chatMessageId("typing");
        _chatPushTransient({
          id: typingId,
          ts: Date.now(),
          role: "typing",
          intent,
          text: "typing",
          actions: []
        });
        _appRenderChat();
        _chatScrollToBottom(true);

        const waitMs = _chatPrefersReducedMotion() ? 80 : _chatRand(CHAT_TYPING_MIN_MS, CHAT_TYPING_MAX_MS);
        const timerId = setTimeout(async () => {
          _chatState.timers.delete(timerId);
          _chatRemoveTransient(typingId);
          const liveId = _chatMessageId("ai-live");
          _chatPushTransient({
            id: liveId,
            ts: Date.now(),
            role: "ai",
            intent,
            scope: "",
            text: "",
            actions: [],
            sources: [],
            charts: [],
            allowEmpty: true
          });
          _appRenderChat();

          let reply = null;
          let scope = "study";
          try{
            reply = await _chatRequestWorkerAi(job, selectedIntent, cls);
            _chatUpdateQuotaFromMeta(reply?.aiMeta || {});
          }catch (err){
            const code = String(err?.code || "");
            if (code === "QUOTA_EXCEEDED" || code === "LIMIT_EXCEEDED"){
              const usage = (err?.data && typeof err.data === "object" && err.data.usage && typeof err.data.usage === "object")
                ? err.data.usage
                : {};
              const resetAtMs = Number(usage.resetAtMs || _chatState.quotaResetAtMs || _chatNextJstResetMs(Date.now()));
              const normalLimit = Math.max(1, Number(_chatState.quota?.normalLimit || CHAT_AI_MODE_LIMITS.normal));
              const reasonLimit = Math.max(1, Number(_chatState.quota?.reasonLimit || CHAT_AI_MODE_LIMITS.reason));
              const remNRaw = Number(usage.remainingNormal);
              const remRRaw = Number(usage.remainingReasoning);
              const remN = Number.isFinite(remNRaw) ? Math.max(0, remNRaw) : null;
              const remR = Number.isFinite(remRRaw) ? Math.max(0, remRRaw) : null;
              _chatUpdateQuotaFromMeta({
                mode: _chatNormalizeAiMode(_chatState.aiMode),
                resetAtMs,
                quota: {
                  normalUsed: remN == null ? Math.max(0, Number(_chatState.quota?.normalUsed || 0)) : Math.max(0, normalLimit - remN),
                  normalLimit,
                  reasonUsed: remR == null ? Math.max(0, Number(_chatState.quota?.reasonUsed || 0)) : Math.max(0, reasonLimit - remR),
                  reasonLimit
                }
              });
              _chatOpenQuotaNotice(_chatState.aiMode, resetAtMs);
              _chatRemoveTransient(liveId);
              _chatState.processing = false;
              _chatSetComposerBusy(false);
              _appRenderChat();
              _chatProcessQueue();
              return;
            } else {
              const msg = String(err?.message || "AI");
              const isAuthErr = code === "UNAUTHORIZED";
              reply = {
                text: isAuthErr ? `AI\n${msg}` : `AI\n${msg}`,
                actions: [{ type: "openSettings", label: isAuthErr ? "Settings" : "Settings" }],
                sources: [],
                charts: [],
                aiMeta: null
              };
            }
          }

          _chatTypeText(reply?.text || "", (partial) => _chatUpdateTransientText(liveId, partial), () => {
            _chatRemoveTransient(liveId);
            _chatPushHistory("ai", reply?.text || "", intent, {
              scope,
              actions: Array.isArray(reply?.actions) ? reply.actions : [],
              sources: Array.isArray(reply?.sources) ? reply.sources : [],
              charts: Array.isArray(reply?.charts) ? reply.charts : [],
              aiMeta: reply?.aiMeta || null
            });
            if (scope === "study"){
              _chatUpdateMemorySummary();
            } else if (scope === "out_of_scope"){
              _chatMarkOutScopeNotice();
            }
            _chatState.processing = false;
            _chatSetComposerBusy(false);
            _appRenderChat();
            _chatProcessQueue();
          });
        }, waitMs);
        _chatState.timers.add(timerId);
      }

      function _appChatSubmit(text, intentHint = "", forcedIntentId = ""){
        const body = String(text || "").trim();
        if (!body){
          uiToast("");
          return false;
        }
        _chatCancelPendingMatch(true);
        const cls = _chatClassifyIntent(body, intentHint);
        const intent = String(cls.intent || "general_help");
        _chatPushHistory("user", body, intent, {
          scope: String(cls.scope || "")
        });
        const forced = String(forcedIntentId || "").trim();
        _chatState.queue.push({
          text: body,
          intentHint: String(intentHint || ""),
          intent,
          scope: String(cls.scope || ""),
          intentId: forced && CHAT_INTENT_BY_ID.has(forced) ? forced : ""
        });
        if (forced && CHAT_INTENT_BY_ID.has(forced)) {
          _chatSaveLastIntent(forced);
        }
        _appRenderChat({ forceScroll: true });
        _chatScrollToBottom(true);
        _chatProcessQueue();
        return true;
      }
      function _appChatSubmitInput(){
        const input = el.appChatInput;
        if (!input){
          uiToast("ChatUI");
          return;
        }
        const text = String(input.value || "");
        const ok = _appChatSubmit(text, "");
        if (!ok) return;
        input.value = "";
        _chatAutoGrowInput();
      }
      function _appChatAsk(key){
        const q = CHAT_QUICK_MAP[String(key || "")];
        if (q){
          _appChatSubmit(q.prompt, q.intent, q.intentId || "");
          return;
        }
        const fallback = String(key || "").trim();
        if (fallback) _appChatSubmit(fallback, "");
      }
      function _appRenderChat(opts = {}){
        if (!el.appChatList || !el.appChatEmpty) return;
        _chatEnsureLoaded();
        _chatBindUiOnce();
        _chatRenderModeUi();
        _chatRenderIntentBrowser();
        const forceScroll = !!opts.forceScroll;
        const keepFollow = forceScroll ? true : _chatIsNearBottom();
        const items = _chatState.history.concat(_chatState.transient);

        if (el.appChatHistoryCount){
          el.appChatHistoryCount.textContent = `${_chatState.history.length}`;
        }
        el.appChatList.replaceChildren();
        if (!items.length){
          el.appChatEmpty.classList.remove("hidden");
          return;
        }
        el.appChatEmpty.classList.add("hidden");

        const frag = document.createDocumentFragment();
        for (const item of items){
          if (!item || typeof item !== "object") continue;
          const m = item;
          const roleVal = (m.role === "user" || m.role === "ai" || m.role === "typing") ? m.role : "";
          if (!roleVal) continue;
          const row = document.createElement("article");
          const roleClass = roleVal === "user" ? "user" : (roleVal === "typing" ? "typing" : "ai");
          row.className = `app-chat-msg is-${roleClass}`;
          if (roleVal === "ai" && String(m.intent || "") === "intent_match"){
            row.classList.add("intent-match");
          }
          row.setAttribute("data-chat-msg-id", String(m.id || _chatMessageId("row")));

          const role = document.createElement("div");
          role.className = "app-chat-role";
          if (roleVal === "user"){
            role.textContent = "You";
          } else {
            const icon = document.createElement("span");
            icon.className = "app-chat-role-icon ms";
            icon.setAttribute("aria-hidden", "true");
            icon.textContent = "smart_toy";
            const label = document.createElement("span");
            label.className = "app-chat-role-label";
            label.textContent = "AI";
            role.appendChild(icon);
            role.appendChild(label);
          }

          const bubble = document.createElement("div");
          bubble.className = "app-chat-bubble";
          if (roleVal === "typing"){
            bubble.setAttribute("aria-label", "AI");
            bubble.innerHTML = '<span class="app-chat-typing-dots" aria-hidden="true"><i></i><i></i><i></i></span>';
          } else {
            bubble.textContent = String(m.text || "");
          }

          const time = document.createElement("div");
          time.className = "app-chat-time";
          time.textContent = _chatFmtTime(m.ts);

          row.appendChild(role);
          row.appendChild(bubble);

          if (roleVal === "ai" && Array.isArray(m.charts) && m.charts.length){
            const chartGrid = document.createElement("div");
            chartGrid.className = "app-chat-chart-grid";
            for (const chart of m.charts){
              const cleanChart = _chatSanitizeChart(chart);
              if (!cleanChart) continue;
              const chartCard = document.createElement("section");
              chartCard.className = "app-chat-chart-card";
              const chartTitle = document.createElement("h5");
              chartTitle.className = "app-chat-chart-title";
              chartTitle.textContent = cleanChart.title;
              chartCard.appendChild(chartTitle);
              chartCard.insertAdjacentHTML("beforeend", _chatRenderChartSvg(cleanChart));
              chartGrid.appendChild(chartCard);
            }
            if (chartGrid.childNodes.length){
              row.appendChild(chartGrid);
            }
          }

          if (roleVal === "ai" && Array.isArray(m.sources) && m.sources.length){
            const sourceWrap = document.createElement("div");
            sourceWrap.className = "app-chat-sources";
            for (const source of m.sources){
              const cleanSource = _chatSanitizeSource(source);
              if (!cleanSource) continue;
              const line = document.createElement("div");
              line.className = "app-chat-source";
              line.textContent = `: [${cleanSource.label}] ${cleanSource.title}`;
              sourceWrap.appendChild(line);
            }
            if (sourceWrap.childNodes.length){
              row.appendChild(sourceWrap);
            }
          }
          if (roleVal === "ai" && m.aiMeta && typeof m.aiMeta === "object"){
            const meta = m.aiMeta;
            const details = document.createElement("details");
            details.className = "app-chat-meta-details";
            const summary = document.createElement("summary");
            summary.textContent = " / ";
            const grid = document.createElement("div");
            grid.className = "app-chat-meta-grid";
            const quota = meta.quota || {};
            const refs = meta.refsUsed || {};
            const helpCount = Array.isArray(refs.helpIds) ? refs.helpIds.length : 0;
            const notifCount = Array.isArray(refs.notificationIds) ? refs.notificationIds.length : 0;
            const modeLabel = _chatModeLabelFull(meta.mode || CHAT_AI_MODE_NORMAL);
            const lines = [
              `mode: ${modeLabel}`,
              `max_tokens: ${Number(meta.maxTokens || 0) || (meta.mode === CHAT_AI_MODE_REASON ? 512 : 256)}`,
              `quota:  ${Math.max(0, Number(quota.normalUsed || 0))}/${Math.max(1, Number(quota.normalLimit || CHAT_AI_MODE_LIMITS.normal))}   ${Math.max(0, Number(quota.reasonUsed || 0))}/${Math.max(1, Number(quota.reasonLimit || CHAT_AI_MODE_LIMITS.reason))}`,
              `refs: insights ${refs.insights ? "" : ""} / help ${helpCount} / notifications ${notifCount}`
            ];
            if (meta.dateJst){
              lines.push(`date: ${meta.dateJst}`);
            }
            for (const line of lines){
              const p = document.createElement("div");
              p.textContent = line;
              grid.appendChild(p);
            }
            details.appendChild(summary);
            details.appendChild(grid);
            row.appendChild(details);
          }

          row.appendChild(time);

          if (roleVal === "ai" && Array.isArray(m.actions) && m.actions.length){
            const actions = document.createElement("div");
            actions.className = "app-chat-actions";
            for (const action of m.actions){
              const clean = _chatSanitizeAction(action);
              if (!clean) continue;
              const btn = document.createElement("button");
              btn.type = "button";
              btn.className = "app-chat-action";
              btn.textContent = clean.label;
              btn.setAttribute("data-chat-action", clean.type);
              if (clean.ids.length) btn.setAttribute("data-chat-ids", clean.ids.join(","));
              if (clean.prompt) btn.setAttribute("data-chat-prompt", clean.prompt);
              if (clean.intentId) btn.setAttribute("data-chat-intent-id", clean.intentId);
              actions.appendChild(btn);
            }
            if (actions.childNodes.length) row.appendChild(actions);
          }
          frag.appendChild(row);
        }
        el.appChatList.appendChild(frag);
        if (document.body?.dataset?.appTab === "chat" || forceScroll || keepFollow || _chatState.followBottom){
          _chatState.followBottom = true;
          _chatScrollToBottom(true);
          _chatForceLatestPosition();
        }
      }
      async function _appHandleChatAction(action, idsRaw, promptRaw = "", intentIdRaw = "", modeRaw = ""){
        const type = String(action || "");
        if (type === "send"){
          _appChatSubmitInput();
          return;
        }
        if (type === "toggleModeMenu"){
          const isOpen = !!(el.appChatModeMenu && !el.appChatModeMenu.classList.contains("hidden"));
          _chatSetModeMenuOpen(!isOpen);
          return;
        }
        if (type === "setAiMode"){
          _chatSetAiMode(modeRaw);
          return;
        }
        if (type === "toggleAutoPick"){
          _chatToggleAutoPick();
          return;
        }
        if (type === "dismissQuotaNotice"){
          _chatDismissQuotaNotice();
          return;
        }
        if (type === "chooseIntent"){
          const iid = String(intentIdRaw || "").trim();
          if (!iid){
            uiToast("IntentID");
            return;
          }
          _chatResolvePendingIntent(iid, false);
          return;
        }
        if (type === "askPrompt"){
          const prompt = String(promptRaw || "").trim();
          if (!prompt){
            uiToast("");
            return;
          }
          _appChatSubmit(prompt, "");
          return;
        }
        if (type === "clearHistory"){
          const ok = await uiConfirm("", {
            title: "Chat",
            okText: "",
            cancelText: "",
            danger: true
          });
          if (!ok) return;
          _chatClearHistory();
          return;
        }
        if (type === "openInsights"){
          _appSetTab(APP_TAB_KEY.INSIGHT);
          return;
        }
        if (type === "openInbox"){
          _appSetTab("inbox");
          return;
        }
        if (type === "openHome"){
          _appSetTab("home");
          return;
        }
        if (type === "openSettings"){
          _appSetTab("settings");
          return;
        }
        if (type === "openShare"){
          openMenu();
          _setMenuView("presetShare");
          _runIdle(() => _drawerShareApplyTab("import"));
          return;
        }

        const ids = String(idsRaw || "")
          .split(",")
          .map((v) => Number(v.trim()))
          .filter((n) => Number.isFinite(n));
        if (!ids.length){
          uiToast("ID");
          return;
        }
        _setRecommendScope(ids);
        _appSetTab("home");
        if (type === "startWriteWeak"){
          if (el.startHandBtn) el.startHandBtn.click();
          else startMode("HAND");
          return;
        }
        if (el.startChoiceBtn) el.startChoiceBtn.click();
        else startChoiceMode(getChoiceDefaultTimeLimitSec());
      }

      function _appHandleSettingsShortcut(action){
        if (action === "openSettings"){
          openSettings();
          return;
        }
        if (action === "openAdmin"){
          openSettings();
          _runIdle(() => {
            try{
              _settingsPushPage("admin");
              _adminRenderUI();
            }catch{}
          });
          return;
        }
        if (action === "openPresetShare"){
          openMenu();
          _setMenuView("presetShare");
          return;
        }
        if (action === "openReport"){
          openMenu();
          _setMenuView("report");
          return;
        }
        if (action === "openHelp"){
          openMenu();
          _setMenuView("help");
          return;
        }
        if (action === "openTerms"){
          openMenu();
          _setMenuView("terms");
        }
      }

      function _appRenderCurrentTab(){
        if (state.view !== "TITLE") return;
        const tab = APP_TAB_LIST.includes(_appCurrentTab) ? _appCurrentTab : APP_TAB_KEY.HOME;
        document.body.dataset.appTab = tab;
        const btns = document.querySelectorAll(".app-tab-btn[data-app-tab]");
        btns.forEach((b) => {
          const on = b.getAttribute("data-app-tab") === tab;
          b.classList.toggle("is-active", on);
          b.setAttribute("aria-selected", String(on));
        });
        _appSetTopTitleByTab(tab);
        if (tab === APP_TAB_KEY.HOME) _appRenderHomeOverview();
        if (tab === APP_TAB_KEY.LIBRARY) _appRenderLibrary();
        if (tab === APP_TAB_KEY.INBOX) _appRenderInbox();
        if (tab === APP_TAB_KEY.INSIGHT) _appRenderInsightsCards();
        if (tab === APP_TAB_KEY.CHAT){
          _chatState.followBottom = true;
          _appRenderChat({ forceScroll: true });
          _chatStartPinLatest();
          _chatForceLatestPosition();
          setTimeout(_chatForceLatestPosition, 300);
          setTimeout(_chatForceLatestPosition, 900);
        } else {
          _chatStopPinLatest();
        }
      }

      function _appSetTab(tab){
        const raw = String(tab || "");
        if (raw === "settings"){
          if (state.view !== "TITLE"){
            goTitle();
          }
          _runIdle(() => {
            _appRenderCurrentTab();
            openMenu();
            _setMenuView("root");
          });
          return;
        }
        const t = _appNormalizeTabKey(raw);
        _appCurrentTab = t;
        if (state.view !== "TITLE"){
          goTitle();
        }
        _runIdle(() => {
          _appRenderCurrentTab();
          if (t === APP_TAB_KEY.CHAT){
            _chatState.followBottom = true;
            setTimeout(_chatForceLatestPosition, 24);
            setTimeout(_chatForceLatestPosition, 280);
            setTimeout(_chatForceLatestPosition, 760);
          }
          if (t === APP_TAB_KEY.INBOX){
            _appInboxBackToList();
            const list = loadNotifications();
            _notifMarkSeenByList(list);
            updateNotifyDot();
            _appRenderInbox();
            _refreshNotificationsFromFirestore().then(() => {
              if (_appCurrentTab === APP_TAB_KEY.INBOX) _appRenderInbox();
            }).catch(() => {});
          }
        });
      }

      async function _appHandleLibraryAction(action, id){
        if (action === "newPreset"){
          openPresetManager(true);
          return;
        }
        if (action === "useBuiltin"){
          const pid = String(id || "");
          const builtinId = pid.startsWith("builtin:") ? pid : `builtin:${pid}`;
          setDeck(deckFromBuiltinId(builtinId));
          return;
        }
        if (action === "startBuiltinExam"){
          _appStartPresetMode(id, "CHOICE");
          return;
        }
        if (action === "startBuiltinWrite"){
          _appStartPresetMode(id, "HAND");
          return;
        }
        if (action === "useCustom"){
          setActivePreset(id);
          return;
        }
        if (action === "editCustom"){
          openPresetManager(false);
          _runIdle(() => {
            try{ selectPresetForEdit(id); }catch{}
          });
          return;
        }
        if (action === "shareCustom"){
          const ok = _openPresetShareFromManager({ tab: "share", presetId: id });
          if (!ok) shareCurrentPreset(id);
          return;
        }
        if (action === "deleteCustom"){
          await _appDeleteCustomPreset(id);
          return;
        }
        if (action === "startCustomExam"){
          _appStartPresetMode(id, "CHOICE");
          return;
        }
        if (action === "startCustomWrite"){
          _appStartPresetMode(id, "HAND");
        }
      }

      async function _appHandleHomeAction(action){
        if (action === "openLibrary"){
          _appSetTab("library");
          return;
        }
        if (action === "openReport"){
          openMenu();
          _setMenuView("report");
          return;
        }
        if (action === "importShare"){
          openMenu();
          _setMenuView("presetShare");
          _runIdle(() => {
            _drawerShareApplyTab("import");
          });
          return;
        }
        if (action === "resume"){
          const r = _appLoadResume();
          if (!r){
            uiToast("");
            return;
          }
          if (r.presetId){
            _appUsePresetForStart(r.presetId);
          } else if (r.deck){
            setDeck(r.deck);
          }
          _appSetTab("home");
          if (r.mode === "HAND"){
            if (el.startHandBtn) el.startHandBtn.click();
            else startMode("HAND");
          } else {
            if (el.startChoiceBtn) el.startChoiceBtn.click();
            else startChoiceMode(getChoiceDefaultTimeLimitSec());
          }
        }
      }


	      // =========================
	      // Events
      // =========================
      el.deckABtn.addEventListener("click", () => setDeck("A"));
      el.deckBBtn.addEventListener("click", () => setDeck("B"));
      if (el.deckCBtn) el.deckCBtn.addEventListener("click", () => setDeck("C"));
      if (el.deckDBtn) el.deckDBtn.addEventListener("click", () => setDeck("D"));
      if (el.deckEBtn) el.deckEBtn.addEventListener("click", () => setDeck("E"));
      el.deckAllBtn.addEventListener("click", () => setDeck("ALL"));

      // Preset: My / Manage
      if (el.deckMyBtn){
        el.deckMyBtn.addEventListener("click", () => {
          const list = loadPresets();
          if (!list.length){
            openPresetManager(false);
            return;
          }
          const pid = getActivePresetId();
          const next = (!isBuiltinPreset(pid) && list.some(p=>p.id===pid)) ? pid : list[0].id;
          setActivePreset(next);
          if (el.customPresetSelect) el.customPresetSelect.value = next;
        });
      }
      if (el.customPresetSelect){
        el.customPresetSelect.addEventListener("change", () => {
          const id = el.customPresetSelect.value;
          if (id) setActivePreset(id);
        });
      }
      if (el.customPresetNewBtn){
        el.customPresetNewBtn.addEventListener("click", () => openPresetManager(true));
      }
      if (el.presetManageBtn){
        el.presetManageBtn.addEventListener("click", () => openPresetManager(false));
      }


      el.startSeqBtn.addEventListener("click", () => startMode("SEQ"));
      el.startRndBtn.addEventListener("click", () => startMode("RND"));
      el.startChoiceBtn.addEventListener("click", () => { void _startModeWithQuestionCountPick("CHOICE"); });
      el.startHandBtn.addEventListener("click", () => { void _startModeWithQuestionCountPick("HAND"); });

      if (el.startAppBtn){
        el.startAppBtn.addEventListener("click", () => {
          setView("TITLE");
          renderAll();
        });
      }

      if (el.topPresetBtn){
        el.topPresetBtn.addEventListener("click", () => {
          if (state.view === "TITLE"){
            _appSetTab("library");
            return;
          }
          openPresetManager(false);
        });
      }

      el.backBtn.addEventListener("click", goTitle);
      el.primaryBtn.addEventListener("click", primaryAction);
      el.nextBtn.addEventListener("click", next);
      el.prevBtn.addEventListener("click", prev);
      el.restartBtn.addEventListener("click", restart);
      el.newSetBtn.addEventListener("click", newHandSet);

      el.clearCanvasBtn.addEventListener("click", () => {
        if (state.mode === "HAND"){
          ensureCanvasReady();
          clearCanvas();
        }
      });

      el.readCanvasBtn.addEventListener("click", async () => {
        if (state.mode !== "HAND") return;
        const cur = getCurrent();
        if (!cur) return;
        await readCanvasIntoInput(cur.word);
      });
      // Choice options click (tap only)
      el.choices.addEventListener("click", (e) => {
        if (state.mode !== "CHOICE") return;
        const btn = e.target.closest("button.choice-btn");
        if (!btn) return;
        const idx = Number(btn.dataset.idx);
        if (!Number.isFinite(idx)) return;
        handleChoiceSelect(idx);
      });

      el.settingsBtn.addEventListener("click", () => {
        if (state.view === "TITLE"){
          _appSetTab("settings");
          return;
        }
        openSettings();
      });

      // Search dropdown
      if (el.searchBtn) el.searchBtn.addEventListener("click", () => {
        if (el.searchOverlay && !el.searchOverlay.classList.contains("hidden")) closeSearch();
        else openSearch();
      });
      if (el.searchCloseBtn) el.searchCloseBtn.addEventListener("click", closeSearch);
      if (el.searchOverlay) el.searchOverlay.addEventListener("click", (e) => {
        if (e.target === el.searchOverlay) closeSearch();
      });
      if (el.searchInput){
        el.searchInput.addEventListener("input", scheduleSearch);
        el.searchInput.addEventListener("keydown", (e) => {
          if (e.key === "Escape"){
            e.preventDefault();
            closeSearch();
            return;
          }
          if (e.key === "Enter"){
            e.preventDefault();
            _openSearchResultByIndex(0);
            return;
          }
        });
      }
      if (el.searchList){
        el.searchList.addEventListener("click", (e) => {
          const btn = e.target && e.target.closest ? e.target.closest(".search-item") : null;
          if (!btn) return;
          const id = Number(btn.dataset.id);
          if (!Number.isFinite(id)) return;
          const w = (_searchResults && _searchResults.find) ? (_searchResults.find(x => x && x.id === id) || null) : null;
          if (w) openWordDetailFromSearch(w);
          else{
            const words = getActiveWords();
            const ww = (words && words.find) ? words.find(x => x && x.id === id) : null;
            if (ww) openWordDetailFromSearch(ww);
          }
        });
      }


      if (el.notifyBtn) el.notifyBtn.addEventListener("click", () => {
        if (state.view === "TITLE"){
          _appSetTab("inbox");
          return;
        }
        if (el.searchOverlay && !el.searchOverlay.classList.contains("hidden")) closeSearch();
        if (el.notifyOverlay && !el.notifyOverlay.classList.contains("hidden")) closeNotify();
        else openNotify();
      });
      if (el.notifyCloseBtn) el.notifyCloseBtn.addEventListener("click", closeNotify);
      if (el.notifyCloseBtn2) el.notifyCloseBtn2.addEventListener("click", closeNotify);
      if (el.notifyDetailBackBtn) el.notifyDetailBackBtn.addEventListener("click", _notifyShowListPane);
      if (el.notifyList){
        el.notifyList.addEventListener("click", (e) => {
          const btn = e.target && e.target.closest ? e.target.closest("[data-notify-action='detail']") : null;
          if (!btn) return;
          const id = String(btn.dataset.id || "").trim();
          if (!id){
            if (el.notifyEmpty){
              el.notifyEmpty.textContent = "ID";
              el.notifyEmpty.classList.remove("hidden");
            }
            return;
          }
          _notifyOpenDetail(id);
        });
      }
      if (el.notifyOverlay) el.notifyOverlay.addEventListener("click", (e) => {
        if (e.target === el.notifyOverlay) closeNotify();
      });
      if (el.closeSettingsBtn) el.closeSettingsBtn.addEventListener("click", _settingsBack);
      if (el.closeSettingsBtn2) el.closeSettingsBtn2.addEventListener("click", closeSettings);

      el.closeTimeBtn.addEventListener("click", closeTimeSelect);
      el.cancelTimeBtn.addEventListener("click", closeTimeSelect);
      el.timeOverlay.addEventListener("click", (e) => {
        if (e.target === el.timeOverlay) closeTimeSelect();
      });

      // Per-question time (seconds). ()
      el.time5Btn.addEventListener("click", () => startChoiceMode(5));
      el.time10Btn.addEventListener("click", () => startChoiceMode(10));
      el.time30Btn.addEventListener("click", () => startChoiceMode(30));
      el.time60Btn.addEventListener("click", () => startChoiceMode(60));
      el.timeNoneBtn.addEventListener("click", () => startChoiceMode(0));
      el.settingsOverlay.addEventListener("click", (e) => {
        if (e.target === el.settingsOverlay) closeSettings();
      });

      // Update Notes
      el.updateCloseBtn?.addEventListener("click", closeUpdateNotes);
      el.updateCloseXBtn?.addEventListener("click", closeUpdateNotes);
      el.updateOverlay?.addEventListener("click", (e) => {
        if (e.target === el.updateOverlay) closeUpdateNotes();
      });

      if (el.dirEnJaBtn) el.dirEnJaBtn.addEventListener("click", () => setDirection("EN_JA"));
      if (el.dirJaEnBtn) el.dirJaEnBtn.addEventListener("click", () => setDirection("JA_EN"));
      if (el.animToggle) el.animToggle.addEventListener("change", (e) => setAnimations(e.target.checked));
      if (el.sfxToggle) el.sfxToggle.addEventListener("change", (e) => setSfx(e.target.checked));
      if (el.bgmToggle) el.bgmToggle.addEventListener("change", (e) => setBgm(e.target.checked));
      if (el.bgmVolLargeBtn) el.bgmVolLargeBtn.addEventListener("click", () => setBgmVolume("LARGE"));
      if (el.bgmVolDefaultBtn) el.bgmVolDefaultBtn.addEventListener("click", () => setBgmVolume("DEFAULT"));
      if (el.bgmVolSmallBtn) el.bgmVolSmallBtn.addEventListener("click", () => setBgmVolume("SMALL"));
      if (el.debugToggle) el.debugToggle.addEventListener("change", (e) => setDebug(e.target.checked));

      const settingsQuestionCountSelect = document.getElementById("settingsQuestionCountSelect");
      const settingsExamTimeSelect = document.getElementById("settingsExamTimeSelect");
      const settingsAutoNextToggle = document.getElementById("settingsAutoNextToggle");
      const settingsSfxVolumeSelect = document.getElementById("settingsSfxVolumeSelect");
      const settingsThemeSelect = document.getElementById("settingsThemeSelect");
      const settingsFontSizeSelect = document.getElementById("settingsFontSizeSelect");
      if (settingsQuestionCountSelect) settingsQuestionCountSelect.addEventListener("change", (e) => setQuestionCount(e.target.value));
      if (settingsExamTimeSelect) settingsExamTimeSelect.addEventListener("change", (e) => setChoiceTimeLimitSec(e.target.value));
      if (settingsAutoNextToggle) settingsAutoNextToggle.addEventListener("change", (e) => setAutoNext(e.target.checked));
      if (settingsSfxVolumeSelect) settingsSfxVolumeSelect.addEventListener("change", (e) => setSfxVolume(e.target.value));
      if (settingsThemeSelect) settingsThemeSelect.addEventListener("change", (e) => setTheme(e.target.value));
      if (settingsFontSizeSelect) settingsFontSizeSelect.addEventListener("change", (e) => setFontSize(e.target.value));
      document.addEventListener("change", (e) => {
        const t = e.target;
        if (!(t instanceof HTMLElement)) return;
        if (t.id === "appInsightsPresetSelect" || t.id === "appInsightsModeSelect" || t.id === "appInsightsRangeSelect"){
          _appRenderInsightsCards();
          return;
        }
        if (t.id === "adminMaintenanceEnabled" || t.id === "adminMaintenanceStartAt" || t.id === "adminMaintenanceEndAt"){
          _maintenanceSetAdminStatus("");
          _maintenanceRenderAdminPreview();
          return;
        }
        if (t.id === "adminAiIngestKey"){
          _adminSetAiIngestStatus("");
          return;
        }
        if (t.id === "appLibrarySubjectFilter"){
          _appLibraryFilter.subjectId = String(t.value || "ALL");
          _appRenderLibrary();
        }
      });
      document.addEventListener("input", (e) => {
        const t = e.target;
        if (!(t instanceof HTMLElement)) return;
        if (t.id === "adminMaintenanceTitle" || t.id === "adminMaintenanceMessage"){
          _maintenanceSetAdminStatus("");
          _maintenanceRenderAdminPreview();
          return;
        }
        if (t.id === "adminAiIngestJson"){
          _adminSetAiIngestStatus("");
          return;
        }
        if (t.id === "appLibrarySearchInput"){
          _appLibraryFilter.query = String(t.value || "");
          _appRenderLibrary();
        }
      });

      document.addEventListener("click", async (e) => {
        if (el.appChatModeMenu && !el.appChatModeMenu.classList.contains("hidden")){
          const picker = e.target && e.target.closest ? e.target.closest("#appChatModePicker") : null;
          if (!picker){
            _chatSetModeMenuOpen(false);
          }
        }
        const brandTitle = e.target.closest(".brand-title");
        if (brandTitle && brandTitle.closest(".topbar")){
          e.preventDefault();
          _appSetTab("home");
          return;
        }
        const appTabBtn = e.target.closest("[data-app-tab]");
        if (appTabBtn && appTabBtn.closest("#appTabBar")){
          e.preventDefault();
          _appSetTab(appTabBtn.getAttribute("data-app-tab") || "home");
          return;
        }

        const homeActionBtn = e.target.closest("[data-home-action]");
        if (homeActionBtn && homeActionBtn.closest("#viewTitle")){
          e.preventDefault();
          await _appHandleHomeAction(homeActionBtn.getAttribute("data-home-action") || "");
          return;
        }

        const libActionBtn = e.target.closest("[data-lib-action]");
        if (libActionBtn && libActionBtn.closest("#appLibraryPage")){
          e.preventDefault();
          await _appHandleLibraryAction(
            libActionBtn.getAttribute("data-lib-action") || "",
            libActionBtn.getAttribute("data-id") || ""
          );
          return;
        }
        const libTagFilterBtn = e.target.closest("[data-lib-tag-filter]");
        if (libTagFilterBtn && libTagFilterBtn.closest("#appLibraryPage")){
          e.preventDefault();
          const tid = String(libTagFilterBtn.getAttribute("data-lib-tag-filter") || "");
          if (tid){
            const cur = Array.isArray(_appLibraryFilter.tagIds) ? _appLibraryFilter.tagIds.slice() : [];
            if (cur.includes(tid)) _appLibraryFilter.tagIds = cur.filter((x) => x !== tid);
            else _appLibraryFilter.tagIds = cur.concat([tid]);
            _appRenderLibrary();
          }
          return;
        }

        const inboxActionBtn = e.target.closest("[data-inbox-action]");
        if (inboxActionBtn && inboxActionBtn.closest("#appInboxPage")){
          e.preventDefault();
          const action = inboxActionBtn.getAttribute("data-inbox-action") || "";
          if (action === "openAdminEditor"){
            if (!_adminState.isAdmin){
              uiToast("Admin");
              return;
            }
            openSettings();
            _runIdle(() => {
              try{
                _settingsPushPage("admin");
                if (_adminShowEditor(true)) _adminReloadNotifications(false);
              }catch(err){
                _adminSetStatus(`UI: ${String(err?.message || err)}`, "error");
              }
            });
            return;
          }
          if (action === "back"){
            _appInboxBackToList();
            return;
          }
          if (action === "openDetail"){
            const id = String(inboxActionBtn.getAttribute("data-id") || "").trim();
            if (!id){
              if (el.appInboxEmpty){
                el.appInboxEmpty.textContent = "ID";
                el.appInboxEmpty.classList.remove("hidden");
              } else {
                uiToast("ID");
              }
              return;
            }
            _appInboxOpenDetail(id);
            return;
          }
        }

        const insightsActionBtn = e.target.closest("[data-insights-action]");
        if (insightsActionBtn && insightsActionBtn.closest("#appInsightsPage")){
          e.preventDefault();
          const action = insightsActionBtn.getAttribute("data-insights-action") || "";
          if (action === "openOverlay"){
            _insightsOpen();
            return;
          }
        }

        const chatPromptBtn = e.target.closest("[data-chat-prompt]:not([data-chat-action])");
        if (chatPromptBtn && chatPromptBtn.closest("#appChatPage")){
          e.preventDefault();
          _appChatSubmit(
            chatPromptBtn.getAttribute("data-chat-prompt") || "",
            chatPromptBtn.getAttribute("data-chat-intent") || "",
            chatPromptBtn.getAttribute("data-chat-intent-id") || ""
          );
          return;
        }

        const chatQuestionBtn = e.target.closest("[data-chat-q]");
        if (chatQuestionBtn && chatQuestionBtn.closest("#appChatPage")){
          e.preventDefault();
          _appChatAsk(chatQuestionBtn.getAttribute("data-chat-q") || "");
          return;
        }

        const chatActionBtn = e.target.closest("[data-chat-action]");
        if (chatActionBtn && chatActionBtn.closest("#appChatPage")){
          e.preventDefault();
          await _appHandleChatAction(
            chatActionBtn.getAttribute("data-chat-action") || "",
            chatActionBtn.getAttribute("data-chat-ids") || "",
            chatActionBtn.getAttribute("data-chat-prompt") || "",
            chatActionBtn.getAttribute("data-chat-intent-id") || "",
            chatActionBtn.getAttribute("data-chat-mode") || ""
          );
          return;
        }

        const settingsShortcutBtn = e.target.closest("[data-settings-shortcut]");
        if (settingsShortcutBtn && settingsShortcutBtn.closest("#appSettingsPage")){
          e.preventDefault();
          _appHandleSettingsShortcut(settingsShortcutBtn.getAttribute("data-settings-shortcut") || "");
          return;
        }

        const settingsNavBtn = e.target.closest("[data-settings-nav]");
        if (settingsNavBtn && settingsNavBtn.closest("#settingsOverlay")){
          e.preventDefault();
          const page = settingsNavBtn.getAttribute("data-settings-nav") || "root";
          _settingsPushPage(page);
          _settingsSyncControls();
          if (page === "admin"){
            _maintenanceCheckNow("admin-open", { silent: true, force: true });
          }
          return;
        }

        const accountLoginBtn = e.target.closest("#settingsAccountOpenLoginBtn");
        if (accountLoginBtn){
          e.preventDefault();
          _authOpenGate("login");
          return;
        }
        const accountRegisterBtn = e.target.closest("#settingsAccountOpenRegisterBtn");
        if (accountRegisterBtn){
          e.preventDefault();
          _authOpenGate("register");
          return;
        }
        const accountSwitchBtn = e.target.closest("#settingsAccountSwitchFromGuestBtn");
        if (accountSwitchBtn){
          e.preventDefault();
          _authSetMode("none");
          _authRenderGuestBadge();
          _authRenderSettingsAccount();
          _settingsRefreshSummary();
          _authOpenGate("login");
          return;
        }
        const accountLogoutBtn = e.target.closest("#settingsAccountLogoutBtn");
        if (accountLogoutBtn){
          e.preventDefault();
          _authLogout();
          return;
        }
        const accountDeleteBtn = e.target.closest("#settingsAccountDeleteBtn");
        if (accountDeleteBtn){
          e.preventDefault();
          _authDeleteAccount();
          return;
        }

        const deleteLogsBtn = e.target.closest("#settingsDeleteLogsBtn");
        if (deleteLogsBtn){
          e.preventDefault();
          _settingsDeleteLogs();
          return;
        }

        const clearShareCacheBtn = e.target.closest("#settingsClearShareCacheBtn");
        if (clearShareCacheBtn){
          e.preventDefault();
          _settingsClearShareCache();
          return;
        }

        const factoryResetBtn = e.target.closest("#settingsFactoryResetBtn");
        if (factoryResetBtn){
          e.preventDefault();
          _settingsFactoryReset();
          return;
        }

        const adminHelpBtn = e.target.closest("#adminOpenHelpEditorBtn");
        if (adminHelpBtn){
          e.preventDefault();
          _adminSetStatus("", "ok");
          uiToast("");
          return;
        }
        const maintenanceSaveBtn = e.target.closest("#adminMaintenanceSaveBtn");
        if (maintenanceSaveBtn){
          e.preventDefault();
          _maintenanceSaveFromAdmin();
          return;
        }
        const maintenanceClearExpiredBtn = e.target.closest("#adminMaintenanceClearExpiredBtn");
        if (maintenanceClearExpiredBtn){
          e.preventDefault();
          _maintenanceClearExpiredFlagFromAdmin();
          return;
        }
        const adminAiIngestBtn = e.target.closest("#adminAiIngestBtn");
        if (adminAiIngestBtn){
          e.preventDefault();
          _adminIngestRagDocs();
          return;
        }
        const maintenanceReloadBtn = e.target.closest("#maintenanceReloadBtn");
        if (maintenanceReloadBtn){
          e.preventDefault();
          location.reload();
          return;
        }
        const maintenanceBypassBtn = e.target.closest("#maintenanceBypassBtn");
        if (maintenanceBypassBtn){
          e.preventDefault();
          if (!_maintenanceCanBypass()){
            _maintenanceSetOverlayStatus("", "error");
            return;
          }
          _maintenanceState.bypass = true;
          _maintenanceSetOverlayStatus("", "ok");
          _maintenanceRenderOverlay();
          return;
        }
        const maintenanceAdminLoginBtn = e.target.closest("#maintenanceAdminLoginBtn");
        if (maintenanceAdminLoginBtn){
          e.preventDefault();
          await _adminStartLoginFlow(null, _maintenanceSetOverlayStatus);
          if (_maintenanceCanBypass()){
            _maintenanceSetOverlayStatus("", "ok");
            _maintenanceRenderOverlay();
          }
          return;
        }

        const backupCreateBtn = e.target.closest("#backupCreateNowBtn");
        if (backupCreateBtn){
          e.preventDefault();
          try{
            _backupCreateNow({ updateLastRunDate: true, silentToast: false });
          }catch(err){
            _backupSetStatus(`: ${String(err?.message || err)}`, "error");
          }
          return;
        }

        const backupExportBtn = e.target.closest("#backupExportBtn");
        if (backupExportBtn){
          e.preventDefault();
          try{
            const latest = _backupReadLatest() || _backupCreateNow({ updateLastRunDate: true, silentToast: true });
            _backupDownloadJson(latest);
            _backupSetStatus("JSON", "ok");
            uiToast("JSON");
          }catch(err){
            _backupSetStatus(`: ${String(err?.message || err)}`, "error");
          }
          return;
        }

        const backupImportBtn = e.target.closest("#backupImportBtn");
        if (backupImportBtn){
          e.preventDefault();
          if (!el.backupImportFile){
            _backupSetStatus("UI", "error");
            return;
          }
          el.backupImportFile.value = "";
          el.backupImportFile.click();
          return;
        }

        const backupRestoreLatestBtn = e.target.closest("#backupRestoreLatestBtn");
        if (backupRestoreLatestBtn){
          e.preventDefault();
          const latest = _backupReadLatest();
          if (!latest){
            _backupSetStatus("", "error");
            return;
          }
          try{
            await _backupRestoreWithConfirm(latest, "");
          }catch(err){
            _backupSetStatus(`: ${String(err?.message || err)}`, "error");
          }
          return;
        }

        const loginBtn = e.target.closest("#adminLoginBtn");
        if (loginBtn){
          e.preventDefault();
          await _adminStartLoginFlow(loginBtn, _adminSetStatus);
          return;
        }

        const logoutBtn = e.target.closest("#adminLogoutBtn");
        if (logoutBtn){
          e.preventDefault();
          let auth;
          try{
            auth = _adminGetAuth();
          }catch(err){
            _adminSetStatus(`Firebase: ${String(err?.message || err)}`, "error");
            return;
          }
          try{
            logoutBtn.disabled = true;
            await auth.signOut();
            _adminSetStatus("", "ok");
          }catch(err){
            _adminSetStatus(`: ${String(err?.code || "AUTH_ERROR")} / ${String(err?.message || err)}`, "error");
          }finally{
            logoutBtn.disabled = false;
            _adminRenderUI();
          }
          return;
        }

        const openEditorBtn = e.target.closest("#adminOpenNotifEditorBtn");
        if (openEditorBtn){
          e.preventDefault();
          if (!_adminShowEditor(true)) return;
          _adminClearNotifForm();
          _adminReloadNotifications(false);
          return;
        }

        const backEditorBtn = e.target.closest("#adminNotifBackBtn");
        if (backEditorBtn){
          e.preventDefault();
          _adminShowEditor(false);
          return;
        }

        const reloadBtn = e.target.closest("#adminNotifReloadBtn");
        if (reloadBtn){
          e.preventDefault();
          _adminReloadNotifications(false);
          return;
        }

        const saveBtn = e.target.closest("#adminNotifSaveBtn");
        if (saveBtn){
          e.preventDefault();
          _adminSaveNotification();
          return;
        }

        const clearBtn = e.target.closest("#adminNotifClearBtn");
        if (clearBtn){
          e.preventDefault();
          _adminClearNotifForm();
          _adminSetNotifStatus("");
          return;
        }

        const cancelEditBtn = e.target.closest("#adminNotifCancelEditBtn");
        if (cancelEditBtn){
          e.preventDefault();
          _adminClearNotifForm();
          _adminSetNotifStatus("");
          return;
        }

        const rowActionBtn = e.target.closest("[data-admin-notif-action]");
        if (rowActionBtn){
          const action = rowActionBtn.dataset.adminNotifAction || "";
          const id = rowActionBtn.dataset.id || "";
          if (!action || !id){
            _adminSetNotifStatus("", "error");
            return;
          }
          e.preventDefault();
          if (action === "edit"){
            const hit = _adminState.notifItems.find(n => String(n?.id || "") === String(id));
            if (!hit){
              _adminSetNotifStatus("", "error");
              return;
            }
            _adminFillNotifForm(hit);
            _adminSetNotifStatus(`: ${hit.title || hit.id}`);
            return;
          }
          if (action === "delete"){
            _adminDeleteNotification(id);
            return;
          }
        }
      });
      if (el.backupImportFile){
        el.backupImportFile.addEventListener("change", async (e) => {
          const input = e.target;
          const file = input && input.files && input.files[0] ? input.files[0] : null;
          if (!file){
            _backupSetStatus("", "error");
            return;
          }
          _backupSetStatus("");
          try{
            await _backupImportFromFile(file);
          }catch(err){
            _backupSetStatus(`: ${String(err?.message || err)}`, "error");
          }finally{
            try{ input.value = ""; }catch{}
          }
        });
      }


      el.resultRestartBtn.addEventListener("click", () => {
        const kind = state.resultKind || state.mode || "HAND";

        if (kind === "CHOICE"){
          // restart same set, same time limit
          const t = state.choice.timeLimitSec || 0;
          resetChoiceSession(t);
          state.order = buildOrder("CHOICE"); // uses stored ids
          state.index = 0;
          state.showAnswer = false;
          state.done = false;

          buildChoiceOptionsForCurrent();
          renderChoiceOptions();

          setView("QUIZ");
          syncBgmToView();
          startChoiceTimer();
          animateCardSwap(renderAll);
          return;
        }

        // HAND
        state.mode = "HAND";
        state.order = buildOrder("HAND"); // uses stored ids
        state.index = 0;
        state.showAnswer = false;
        state.done = false;

        state.hand.checked = false;
        state.hand.correct = null;
        state.hand.input = "";
        state.hand.busy = false;
        state.hand.results = [];
        state.hand.scoreCorrect = 0;

        setView("QUIZ");
        resetHandPerQuestion();
        animateCardSwap(renderAll);
      });

      el.resultNewSetBtn.addEventListener("click", () => {
        const kind = state.resultKind || state.mode || "HAND";
        if (kind === "CHOICE"){
          createChoiceSetIds(getSetKey(state.deck), true);
          startChoiceMode(getChoiceDefaultTimeLimitSec());
          return;
        }
        // HAND
        createExamSetIds(getSetKey(state.deck), true);
        startMode("HAND");
      });
      el.resultTitleBtn.addEventListener("click", goTitle);
      el.resultReviewBtn.addEventListener("click", reviewWrong);

      // keyboard
      
      // keyboard
      document.addEventListener("keydown", (e) => {
        if (el.authGate && !el.authGate.classList.contains("hidden")){
          const aeAuth = document.activeElement;
          const typingAuth = aeAuth && (aeAuth.tagName === "INPUT" || aeAuth.tagName === "TEXTAREA" || aeAuth.tagName === "SELECT" || aeAuth.isContentEditable);
          if (typingAuth) return;
          if (e.key === "Escape"){
            e.preventDefault();
            _authShowPanel("entry");
          }
          return;
        }

        // If modal is open, let it handle keys (avoid accidental dropdown closes)
        if (uiModal.root && uiModal.root.classList.contains("is-open")) return;

        // scan generator open: Esc only
        if (scanGenOverlay && !scanGenOverlay.classList.contains("hidden") && scanGenOverlay.classList.contains("is-open")){
          if (e.key === "Escape"){
            e.preventDefault();
            _scanClosePanel();
            return;
          }
          const aeScan = document.activeElement;
          if (aeScan && scanGenOverlay.contains(aeScan)){
            return;
          }
          return;
        }

        // settings open: only Esc
        if (el.settingsOverlay && !el.settingsOverlay.classList.contains("hidden")){
          const aeSettings = document.activeElement;
          const typingSettings = aeSettings && (aeSettings.tagName === "INPUT" || aeSettings.tagName === "TEXTAREA" || aeSettings.tagName === "SELECT" || aeSettings.isContentEditable);
          if (typingSettings) return;
          if (e.key === "Escape"){
            e.preventDefault();
            _settingsBack();
          }
          return;
        }

        // time select open: only Esc
        if (el.timeOverlay && !el.timeOverlay.classList.contains("hidden")){
          const aeTime = document.activeElement;
          const typingTime = aeTime && (aeTime.tagName === "INPUT" || aeTime.tagName === "TEXTAREA" || aeTime.tagName === "SELECT" || aeTime.isContentEditable);
          if (typingTime) return;
          if (e.key === "Escape"){
            e.preventDefault();
            closeTimeSelect();
          }
          return;
        }

        // search dropdown open: Esc closes + do not hijack keys while focusing inside
        if (el.searchOverlay && !el.searchOverlay.classList.contains("hidden")){
          if (e.key === "Escape"){
            e.preventDefault();
            closeSearch();
            return;
          }
          const aeSearch = document.activeElement;
          if (aeSearch && el.searchOverlay.contains(aeSearch)){
            return;
          }
        }

        // notify dropdown open: Esc closes
        if (el.notifyOverlay && !el.notifyOverlay.classList.contains("hidden")){
          if (e.key === "Escape"){
            e.preventDefault();
            closeNotify();
            return;
          }
        }


        // typing focus: do not hijack keys
        const ae = document.activeElement;
        const isTyping = ae && (ae.tagName === "INPUT" || ae.tagName === "TEXTAREA" || ae.isContentEditable);

        // global escape to title
        if (e.key === "Escape"){
          if (isTyping) return;
          if (state.view !== "TITLE"){
            e.preventDefault();
            goTitle();
          }
          return;
        }

        if (state.view !== "QUIZ") return;

        // Choice mode: no keyboard answering (tap/click only), no Space toggles, no Enter actions.
        if (state.mode === "CHOICE"){
          return;
        }

        // Hand mode: only Enter triggers judge (or Enter again to go next). NO SPACE judge.
        if (state.mode === "HAND"){
          if (e.key === "Enter"){
            e.preventDefault();
            if (!state.hand.checked) checkHand();
            else next();
            return;
          }

          if (isTyping) return;

          // optional shortcut: clear canvas with C only when not typing
          if (e.key && e.key.toLowerCase() === "c"){
            e.preventDefault();
            ensureCanvasReady();
            clearCanvas();
            return;
          }

          if (e.key === "ArrowRight"){
            e.preventDefault();
            next();
            return;
          }
          if (e.key === "ArrowLeft"){
            e.preventDefault();
            prev();
            return;
          }

          return;
        }

        // Study modes
        if (isTyping) return;

        if (e.key === " "){
          e.preventDefault();
          primaryAction();
          return;
        }
        if (e.key === "ArrowRight"){
          e.preventDefault();
          next();
          return;
        }
        if (e.key === "ArrowLeft"){
          e.preventDefault();
          prev();
          return;
        }
      });


      // canvas init
      bindCanvasEvents();

      // =========================
      // Preset Manager (UI)
      // =========================
      const presetOverlay = document.getElementById("presetOverlay");
      const presetCloseBtn = document.getElementById("presetCloseBtn");
      const presetCloseBtn2 = document.getElementById("presetCloseBtn2");
      const presetListEl = document.getElementById("presetList");
      const presetNewBtn = document.getElementById("presetNewBtn");
      const presetSaveBtn = document.getElementById("presetSaveBtn");
      const presetDeleteBtn = document.getElementById("presetDeleteBtn");
      const presetExportBtn = document.getElementById("presetExportBtn");
      const presetShareBtn = document.getElementById("presetShareBtn");
      const presetShareImportBtn = document.getElementById("presetShareImportBtn");
      const presetImportBtn = document.getElementById("presetImportBtn");
      const presetImportFile = document.getElementById("presetImportFile");
      const presetScanBtn = document.getElementById("presetScanBtn");

      const scanGenOverlay = document.getElementById("scanGenOverlay");
      const scanMainImageInput = document.getElementById("scanMainImageInput");
      const scanRefImageInput = document.getElementById("scanRefImageInput");
      const scanMainThumbList = document.getElementById("scanMainThumbList");
      const scanImageMeta = document.getElementById("scanImageMeta");
      const scanRefThumbList = document.getElementById("scanRefThumbList");
      const scanRefBlock = document.getElementById("scanRefBlock");
      const scanPromptInput = document.getElementById("scanPromptInput");
      const scanCountInput = document.getElementById("scanCountInput");
      const scanMarkerInput = document.getElementById("scanMarkerInput");
      const scanExtractCharsSelect = document.getElementById("scanExtractCharsSelect");
      const scanDifficultySelect = document.getElementById("scanDifficultySelect");
      const scanStepList = document.getElementById("scanStepList");
      const scanStatus = document.getElementById("scanStatus");
      const scanDebugDetails = document.getElementById("scanDebugDetails");
      const scanDebugPre = document.getElementById("scanDebugPre");
      const scanRetryBtn = document.getElementById("scanRetryBtn");
      const scanResultCard = document.getElementById("scanResultCard");
      const scanResultMeta = document.getElementById("scanResultMeta");
      const scanReconstructedView = document.getElementById("scanReconstructedView");
      const scanQuestionList = document.getElementById("scanQuestionList");

      const presetNameInput = document.getElementById("presetNameInput");
      const presetSubjectSelect = document.getElementById("presetSubjectSelect");
      const presetTagPicker = document.getElementById("presetTagPicker");
      const presetMetaStatus = document.getElementById("presetMetaStatus");
      const presetManageSubjectsBtn = document.getElementById("presetManageSubjectsBtn");
      const presetManageTagsBtn = document.getElementById("presetManageTagsBtn");
      const presetSubjectManager = document.getElementById("presetSubjectManager");
      const presetSubjectNameInput = document.getElementById("presetSubjectNameInput");
      const presetSubjectColorInput = document.getElementById("presetSubjectColorInput");
      const presetSubjectAddBtn = document.getElementById("presetSubjectAddBtn");
      const presetSubjectManagerList = document.getElementById("presetSubjectManagerList");
      const presetTagManager = document.getElementById("presetTagManager");
      const presetTagNameInput = document.getElementById("presetTagNameInput");
      const presetTagColorInput = document.getElementById("presetTagColorInput");
      const presetTagAddBtn = document.getElementById("presetTagAddBtn");
      const presetTagManagerList = document.getElementById("presetTagManagerList");
      const presetModeSeq = document.getElementById("presetModeSeq");
      const presetModeRnd = document.getElementById("presetModeRnd");
      const presetModeHand = document.getElementById("presetModeHand");
      const presetModeChoice = document.getElementById("presetModeChoice");

      const wordIdInput = document.getElementById("wordIdInput");
      const wordWordInput = document.getElementById("wordWordInput");
      const wordMeaningInput = document.getElementById("wordMeaningInput");
      const wordFieldLabelA = document.getElementById("wordFieldLabelA");
      const wordFieldLabelB = document.getElementById("wordFieldLabelB");
      const presetSingleEditorTitle = document.getElementById("presetSingleEditorTitle");
      const presetPreviewTitle = document.getElementById("presetPreviewTitle");
      const bulkHintEnglish = document.getElementById("bulkHintEnglish");
      const bulkHintGeneric = document.getElementById("bulkHintGeneric");
      const mathFormatWrap = document.getElementById("mathFormatWrap");
      const wordFrontFormatSelect = document.getElementById("wordFrontFormatSelect");
      const wordBackFormatSelect = document.getElementById("wordBackFormatSelect");
      const mathPreviewWrap = document.getElementById("mathPreviewWrap");
      const mathFrontPreviewCard = document.getElementById("mathFrontPreviewCard");
      const mathBackPreviewCard = document.getElementById("mathBackPreviewCard");
      const mathFrontPreview = document.getElementById("mathFrontPreview");
      const mathBackPreview = document.getElementById("mathBackPreview");
      const mathSymbolPaletteWrap = document.getElementById("mathSymbolPaletteWrap");
      const mathSymbolPalette = document.getElementById("mathSymbolPalette");
      const mathDiagramOpenCurrentBtn = document.getElementById("mathDiagramOpenCurrentBtn");
      const mathDiagramBackdrop = document.getElementById("mathDiagramBackdrop");
      const mathDiagramSection = document.getElementById("mathDiagramSection");
      const mathDiagramTargetLabel = document.getElementById("mathDiagramTargetLabel");
      const mathDiagramStatus = document.getElementById("mathDiagramStatus");
      const mathDiagramCanvas = document.getElementById("mathDiagramCanvas");
      const mathDiagramSelectedInfo = document.getElementById("mathDiagramSelectedInfo");
      const mathDiagramUndoBtn = document.getElementById("mathDiagramUndoBtn");
      const mathDiagramRedoBtn = document.getElementById("mathDiagramRedoBtn");
      const mathDiagramClearBtn = document.getElementById("mathDiagramClearBtn");
      const mathDiagramTable2Btn = document.getElementById("mathDiagramTable2Btn");
      const mathDiagramTable3Btn = document.getElementById("mathDiagramTable3Btn");
      const mathDiagramTable4Btn = document.getElementById("mathDiagramTable4Btn");
      const mathDiagramTableCellEditBtn = document.getElementById("mathDiagramTableCellEditBtn");
      const mathDiagramAddImageBtn = document.getElementById("mathDiagramAddImageBtn");
      const mathDiagramImageInput = document.getElementById("mathDiagramImageInput");
      const mathDiagramBringFrontBtn = document.getElementById("mathDiagramBringFrontBtn");
      const mathDiagramSendBackBtn = document.getElementById("mathDiagramSendBackBtn");
      const mathDiagramZoomResetBtn = document.getElementById("mathDiagramZoomResetBtn");
      const mathDiagramEditTextBtn = document.getElementById("mathDiagramEditTextBtn");
      const mathDiagramMoveLeftBtn = document.getElementById("mathDiagramMoveLeftBtn");
      const mathDiagramMoveRightBtn = document.getElementById("mathDiagramMoveRightBtn");
      const mathDiagramMoveUpBtn = document.getElementById("mathDiagramMoveUpBtn");
      const mathDiagramMoveDownBtn = document.getElementById("mathDiagramMoveDownBtn");
      const mathDiagramRotateLeftBtn = document.getElementById("mathDiagramRotateLeftBtn");
      const mathDiagramRotateRightBtn = document.getElementById("mathDiagramRotateRightBtn");
      const mathDiagramDeleteBtn = document.getElementById("mathDiagramDeleteBtn");
      const mathDiagramGridToggle = document.getElementById("mathDiagramGridToggle");
      const mathDiagramAxisToggle = document.getElementById("mathDiagramAxisToggle");
      const mathDiagramSnapToggle = document.getElementById("mathDiagramSnapToggle");
      const mathDiagramBoundsDebugToggle = document.getElementById("mathDiagramBoundsDebugToggle");
      const mathDiagramFontSizeRange = document.getElementById("mathDiagramFontSizeRange");
      const mathPointLabelInput = document.getElementById("mathPointLabelInput");
      const mathDiagramSaveBtn = document.getElementById("mathDiagramSaveBtn");
      const mathDiagramCloseBtn = document.getElementById("mathDiagramCloseBtn");
      const wordUpsertBtn = document.getElementById("wordUpsertBtn");
      const wordClearBtn = document.getElementById("wordClearBtn");
      const presetMcqSection = document.getElementById("presetMcqSection");

      // Custom 4-choice config (for user presets)
      const mcqEnable = document.getElementById("mcqEnable");
      const mcqFields = document.getElementById("mcqFields");
      const mcqFillCorrectBtn = document.getElementById("mcqFillCorrectBtn");
      const mcqClearBtn = document.getElementById("mcqClearBtn");
      const mcqChoices = [
        document.getElementById("mcqChoice0"),
        document.getElementById("mcqChoice1"),
        document.getElementById("mcqChoice2"),
        document.getElementById("mcqChoice3"),
      ];
      const mcqRadios = Array.from(document.querySelectorAll('input[name="mcqCorrect"]'));

      function setMcqVisible(on){
        if (!mcqFields) return;
        mcqFields.classList.toggle("hidden", !on);
      }
      function clearMcqForm(){
        if (mcqEnable) mcqEnable.checked = false;
        setMcqVisible(false);
        for (const i of mcqChoices){ if (i) i.value = ""; }
        for (const r of mcqRadios){ r.checked = false; }
      }
      function fillMcqCorrectFromMeaning(){
        if (!mcqEnable) return;
        if (!mcqEnable.checked){
          mcqEnable.checked = true;
          setMcqVisible(true);
        }
        const meaning = (wordMeaningInput?.value ?? "").trim();
        if (!meaning){
          uiAlert("meaning");
          return;
        }
        let idx = mcqRadios.findIndex(r => r.checked);
        if (idx < 0){
          idx = 0;
          if (mcqRadios[0]) mcqRadios[0].checked = true;
        }
        if (mcqChoices[idx]) mcqChoices[idx].value = meaning;
      }
      function getMcqFromForm(meaning){
        if (!mcqEnable || !mcqEnable.checked) return null;

        const vals = mcqChoices.map(i => (i?.value ?? "").trim());
        let last = -1;
        for (let i=0;i<vals.length;i++){
          if (vals[i]) last = i;
        }
        if (last < 0) return null;

        for (let i=0;i<=last;i++){
          if (!vals[i]){
            uiAlert("");
            return { __invalid:true };
          }
        }
        const choices = vals.slice(0, last+1);

        if (choices.length < 2){
          uiAlert("2");
          return { __invalid:true };
        }
        const seen = new Set();
        for (const c of choices){
          if (seen.has(c)){
            uiAlert("");
            return { __invalid:true };
          }
          seen.add(c);
        }
        let correctIndex = mcqRadios.findIndex(r => r.checked);
        if (correctIndex < 0){
          uiAlert("AD1");
          return { __invalid:true };
        }
        if (correctIndex > last){
          uiAlert("");
          return { __invalid:true };
        }
        if (choices[correctIndex] !== meaning){
          uiAlert("meaning");
          return { __invalid:true };
        }
        return { choices, correctIndex };
      }

      mcqEnable?.addEventListener("change", ()=>{
        setMcqVisible(!!mcqEnable.checked);
      });
      mcqFillCorrectBtn?.addEventListener("click", fillMcqCorrectFromMeaning);
      mcqClearBtn?.addEventListener("click", clearMcqForm);

      function _presetEditingSubjectId(){
        const sel = String(presetSubjectSelect?.value || "").trim();
        if (sel) return _resolveSubjectId(sel, { fallback: "sub:english", allowMissingCustom: true });
        if (editingPresetId){
          const p = getPresetById(editingPresetId);
          if (p) return _resolveSubjectId(p.subjectId, { fallback: "sub:english", allowMissingCustom: true });
        }
        return "sub:english";
      }
      function _presetEditingIsEnglish(){
        return _isEnglishSubjectId(_presetEditingSubjectId());
      }
      function _presetEditingIsMath(){
        return _isMathSubjectId(_presetEditingSubjectId());
      }
      function _presetEditingEntries(presetObj){
        const p = (presetObj && typeof presetObj === "object") ? presetObj : null;
        if (!p) return [];
        const sid = _resolveSubjectId(p.subjectId, { fallback: "sub:english", allowMissingCustom: true });
        if (_isEnglishSubjectId(sid)){
          return _normalizeWordList(p.words);
        }
        let cards = _normalizeCardList(p.cards, { allowLatex: _isMathSubjectId(sid) });
        if (!cards.length){
          cards = _wordsToCardList(_normalizeWordList(p.words), { allowLatex: false });
        }
        return cards;
      }
      function _presetEditingSetEntries(presetObj, entries){
        if (!presetObj) return;
        const sid = _resolveSubjectId(presetObj.subjectId, { fallback: "sub:english", allowMissingCustom: true });
        if (_isEnglishSubjectId(sid)){
          const words = _normalizeWordList(entries);
          presetObj.words = words;
          presetObj.cards = _wordsToCardList(words, { allowLatex: false });
        } else {
          const cards = _normalizeCardList(entries, { allowLatex: _isMathSubjectId(sid) });
          presetObj.cards = cards;
          presetObj.words = _cardsToWordList(cards);
        }
      }
      function _presetEditorFrontFormatValue(){
        return _normalizeFormatMode(wordFrontFormatSelect?.value || "text", _presetEditingIsMath());
      }
      function _presetEditorBackFormatValue(){
        return _normalizeFormatMode(wordBackFormatSelect?.value || "text", _presetEditingIsMath());
      }
      function _presetEditorSetFormatValues(front, back){
        if (wordFrontFormatSelect){
          wordFrontFormatSelect.value = _normalizeFormatMode(front || "text", _presetEditingIsMath());
        }
        if (wordBackFormatSelect){
          wordBackFormatSelect.value = _normalizeFormatMode(back || "text", _presetEditingIsMath());
        }
      }
      function _renderKatexInto(node, value){
        if (!node) return;
        const text = String(value || "");
        node.textContent = "";
        const span = document.createElement("span");
        span.className = "math-rendered";
        try{
          if (window.katex && typeof window.katex.render === "function"){
            window.katex.render(text, span, { throwOnError: false, strict: "ignore", displayMode: true });
          } else {
            span.textContent = text;
          }
        }catch{
          span.textContent = text;
        }
        node.replaceChildren(span);
      }
      function _renderMathPreviewNow(){
        const isMath = _presetEditingIsMath();
        const frontFmt = _presetEditorFrontFormatValue();
        const backFmt = _presetEditorBackFormatValue();
        const frontText = String(wordWordInput?.value || "").trim();
        const backText = String(wordMeaningInput?.value || "").trim();
        if (mathPreviewWrap) mathPreviewWrap.classList.toggle("hidden", !isMath);
        const showFront = isMath && frontFmt === "latex" && !!frontText;
        const showBack = isMath && backFmt === "latex" && !!backText;
        if (mathFrontPreviewCard) mathFrontPreviewCard.classList.toggle("hidden", !showFront);
        if (mathBackPreviewCard) mathBackPreviewCard.classList.toggle("hidden", !showBack);
        if (showFront) _renderKatexInto(mathFrontPreview, frontText);
        else if (mathFrontPreview) mathFrontPreview.textContent = "";
        if (showBack) _renderKatexInto(mathBackPreview, backText);
        else if (mathBackPreview) mathBackPreview.textContent = "";
        _refreshMathEditorAuxiliaryUI();
      }
      let _mathPreviewTimer = null;
      function _scheduleMathPreview(){
        if (_mathPreviewTimer) clearTimeout(_mathPreviewTimer);
        _mathPreviewTimer = setTimeout(() => {
          _mathPreviewTimer = null;
          _renderMathPreviewNow();
        }, 100);
      }
      function _applyPresetEditorSubjectUI(subjectId){
        const sid = _resolveSubjectId(subjectId, { fallback: "sub:english", allowMissingCustom: true });
        const isEnglish = _isEnglishSubjectId(sid);
        const isMath = _isMathSubjectId(sid);
        if (wordFieldLabelA) wordFieldLabelA.textContent = isEnglish ? "" : "";
        if (wordFieldLabelB) wordFieldLabelB.textContent = isEnglish ? "" : "";
        if (wordWordInput) wordWordInput.placeholder = isEnglish ? " / " : "";
        if (wordMeaningInput) wordMeaningInput.placeholder = isEnglish ? "" : "";
        if (presetSingleEditorTitle) presetSingleEditorTitle.textContent = isEnglish ? "/1" : "/1";
        if (presetPreviewTitle) presetPreviewTitle.textContent = isEnglish ? "50" : "50";
        if (bulkHintEnglish) bulkHintEnglish.classList.toggle("hidden", !isEnglish);
        if (bulkHintGeneric) bulkHintGeneric.classList.toggle("hidden", isEnglish);
        if (presetMcqSection) presetMcqSection.classList.toggle("hidden", !isEnglish);
        if (mathFormatWrap) mathFormatWrap.classList.toggle("hidden", !isMath);
        if (mathDiagramOpenCurrentBtn) mathDiagramOpenCurrentBtn.classList.toggle("hidden", !isMath);
        if (!isMath){
          _presetEditorSetFormatValues("text", "text");
          if (mathFrontPreviewCard) mathFrontPreviewCard.classList.add("hidden");
          if (mathBackPreviewCard) mathBackPreviewCard.classList.add("hidden");
          _mathDiagramCloseEditor(true);
        }
        _scheduleMathPreview();
      }

      function _setMathEditorStatus(msg, kind = ""){
        if (!mathDiagramStatus) return;
        mathDiagramStatus.textContent = String(msg || "");
        mathDiagramStatus.classList.remove("ok", "error");
        if (kind === "ok") mathDiagramStatus.classList.add("ok");
        if (kind === "error") mathDiagramStatus.classList.add("error");
      }

      let _mathFocusedInput = null;
      function _rememberMathFocusedInput(target){
        if (target === wordWordInput || target === wordMeaningInput){
          _mathFocusedInput = target;
        }
      }

      function _mathLatexPaletteVisible(){
        if (!_presetEditingIsMath()) return false;
        return _presetEditorFrontFormatValue() === "latex" || _presetEditorBackFormatValue() === "latex";
      }

      function _refreshMathEditorAuxiliaryUI(){
        const isMath = _presetEditingIsMath();
        const showPalette = _mathLatexPaletteVisible();
        if (mathSymbolPaletteWrap){
          mathSymbolPaletteWrap.classList.toggle("hidden", !showPalette);
        }
        if (!isMath){
          _mathFocusedInput = null;
        }
      }

      function _insertTextAtSelection(inputEl, text, cursorOffset = null){
        if (!(inputEl instanceof HTMLInputElement || inputEl instanceof HTMLTextAreaElement)) return false;
        const src = String(inputEl.value || "");
        const start = Number.isFinite(inputEl.selectionStart) ? inputEl.selectionStart : src.length;
        const end = Number.isFinite(inputEl.selectionEnd) ? inputEl.selectionEnd : start;
        const ins = String(text || "");
        inputEl.value = src.slice(0, start) + ins + src.slice(end);
        const pos = cursorOffset == null ? (start + ins.length) : (start + Number(cursorOffset));
        try{
          inputEl.focus({ preventScroll: true });
          inputEl.setSelectionRange(pos, pos);
        }catch{}
        inputEl.dispatchEvent(new Event("input", { bubbles: true }));
        return true;
      }

      function _insertMathPaletteToken(token, template){
        if (!_mathLatexPaletteVisible()){
          _setPresetMetaStatus("LaTeX", "error");
          return;
        }
        const target = _mathFocusedInput;
        if (!(target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement)){
          _setPresetMetaStatus("", "error");
          return;
        }
        const normalizedToken = String(token || "").replace(/^\\{2,}/, "\\");
        let ok = false;
        if (template === "sqrt"){
          ok = _insertTextAtSelection(target, "\\sqrt{}", 6);
        } else if (template === "frac"){
          ok = _insertTextAtSelection(target, "\\frac{}{}", 6);
        } else if (template === "power"){
          ok = _insertTextAtSelection(target, "^{}", 2);
        } else if (template === "subscript"){
          ok = _insertTextAtSelection(target, "_{}", 2);
        } else {
          ok = _insertTextAtSelection(target, normalizedToken);
        }
        if (!ok){
          _setPresetMetaStatus("", "error");
          return;
        }
        _setPresetMetaStatus("");
      }

      const _mathDiagramState = {
        active: false,
        bound: false,
        ctx: null,
        tool: "select",
        drawing: false,
        pointerId: null,
        startX: 0,
        startY: 0,
        x: 0,
        y: 0,
        currentPath: null,
        pointDragIndex: -1,
        selectedIndex: -1,
        dragSelected: false,
        dragLastX: 0,
        dragLastY: 0,
        interaction: "none",
        resizeHandle: "",
        resizeBaseCmd: null,
        resizeBaseBounds: null,
        rotateBaseCenter: null,
        rotateStartAngle: 0,
        commands: [],
        history: [],
        historyMax: 10,
        redo: [],
        dirty: false,
        rafId: 0,
        savedSignature: "",
        resizeObserver: null,
        viewportRaf: 0,
        canvasCssWidth: 0,
        canvasCssHeight: 0,
        pixelRatio: 1,
        view: { tx: 0, ty: 0, scale: 1 },
        minScale: 0.25,
        maxScale: 4,
        pointers: new Map(),
        pinch: null,
        spacePan: false,
        eraseHoverIndex: -1,
        snap: false,
        debugBounds: false,
        imageCache: new Map(),
        overlayMovedToBody: false,
        _lockScrollTop: 0,
        targetId: null,
        grid: false,
        axis: false,
        baseImageUrl: "",
        baseImage: null
      };

      function _mathDiagramCloneCommands(src){
        const arr = Array.isArray(src) ? src : [];
        return JSON.parse(JSON.stringify(arr));
      }

      function _mathDiagramPushHistory(){
        const snap = _mathDiagramSnapshot();
        _mathDiagramState.history.push(snap);
        _mathDiagramState.redo = [];
        while (_mathDiagramState.history.length > 50){
          _mathDiagramState.history.shift();
        }
      }
      // DRAW_EDITOR_V2V3
      function _mathDiagramApplySnapshot(snap){
        if (!snap || typeof snap !== "object") return;
        _mathDiagramState.commands = _mathDiagramCloneCommands(snap.commands);
        _mathDiagramState.grid = !!snap.grid;
        _mathDiagramState.axis = !!snap.axis;
        _mathDiagramState.snap = !!snap.snap;
        _mathDiagramState.debugBounds = !!snap.debugBounds;
        _mathDiagramState.selectedIndex = Number.isInteger(snap.selectedIndex) ? snap.selectedIndex : -1;
        const view = snap.view && typeof snap.view === "object" ? snap.view : {};
        const nextScale = Number(view.scale);
        _mathDiagramState.view.scale = Number.isFinite(nextScale) ? Math.min(_mathDiagramState.maxScale, Math.max(_mathDiagramState.minScale, nextScale)) : 1;
        _mathDiagramState.view.tx = Number(view.tx || 0);
        _mathDiagramState.view.ty = Number(view.ty || 0);
        if (mathDiagramGridToggle) mathDiagramGridToggle.checked = _mathDiagramState.grid;
        if (mathDiagramAxisToggle) mathDiagramAxisToggle.checked = _mathDiagramState.axis;
        if (mathDiagramSnapToggle) mathDiagramSnapToggle.checked = _mathDiagramState.snap;
        if (mathDiagramBoundsDebugToggle) mathDiagramBoundsDebugToggle.checked = _mathDiagramState.debugBounds;
        const wrap = mathDiagramCanvas?.parentElement;
        if (wrap) wrap.classList.toggle("is-debug", _mathDiagramState.debugBounds);
        _mathDiagramSetBaseImage(snap.baseImageUrl || "");
        _mathDiagramUpdateSelectionUI();
      }

      // DRAW_EDITOR_V1
      function _mathDiagramSnapshot(){
        return {
          commands: _mathDiagramCloneCommands(_mathDiagramState.commands),
          baseImageUrl: String(_mathDiagramState.baseImageUrl || ""),
          grid: !!_mathDiagramState.grid,
          axis: !!_mathDiagramState.axis,
          snap: !!_mathDiagramState.snap,
          debugBounds: !!_mathDiagramState.debugBounds,
          selectedIndex: Number(_mathDiagramState.selectedIndex),
          view: {
            tx: Number(_mathDiagramState.view?.tx || 0),
            ty: Number(_mathDiagramState.view?.ty || 0),
            scale: Number(_mathDiagramState.view?.scale || 1)
          }
        };
      }

      // DRAW_EDITOR_V1
      function _mathDiagramSignatureOf(snapshot){
        const s = snapshot && typeof snapshot === "object" ? snapshot : _mathDiagramSnapshot();
        const normalized = { ...s, selectedIndex: -1 };
        return JSON.stringify(normalized);
      }

      // DRAW_EDITOR_V1
      function _mathDiagramHasUnsavedChanges(){
        return _mathDiagramSignatureOf() !== String(_mathDiagramState.savedSignature || "");
      }

      function _mathDiagramCanvasPoint(ev){
        if (!mathDiagramCanvas) return { x: 0, y: 0 };
        const rect = mathDiagramCanvas.getBoundingClientRect();
        return {
          x: ev.clientX - rect.left,
          y: ev.clientY - rect.top
        };
      }
      // DRAW_EDITOR_V2V3
      function _mathDiagramScreenToWorld(pt){
        const s = Number(_mathDiagramState.view.scale || 1) || 1;
        return {
          x: (Number(pt?.x || 0) - Number(_mathDiagramState.view.tx || 0)) / s,
          y: (Number(pt?.y || 0) - Number(_mathDiagramState.view.ty || 0)) / s
        };
      }
      // DRAW_EDITOR_V2V3
      function _mathDiagramWorldToScreen(pt){
        const s = Number(_mathDiagramState.view.scale || 1) || 1;
        return {
          x: (Number(pt?.x || 0) * s) + Number(_mathDiagramState.view.tx || 0),
          y: (Number(pt?.y || 0) * s) + Number(_mathDiagramState.view.ty || 0)
        };
      }
      // DRAW_EDITOR_V2V3
      function _mathDiagramZoomAt(screenX, screenY, nextScale){
        const s0 = Number(_mathDiagramState.view.scale || 1) || 1;
        const s1 = Math.min(_mathDiagramState.maxScale, Math.max(_mathDiagramState.minScale, Number(nextScale || s0)));
        if (!(s1 > 0)) return;
        const worldX = (screenX - _mathDiagramState.view.tx) / s0;
        const worldY = (screenY - _mathDiagramState.view.ty) / s0;
        _mathDiagramState.view.scale = s1;
        _mathDiagramState.view.tx = screenX - (worldX * s1);
        _mathDiagramState.view.ty = screenY - (worldY * s1);
        _mathDiagramRender();
      }
      // DRAW_EDITOR_V2V3
      function _mathDiagramResetView(){
        _mathDiagramState.view.tx = 0;
        _mathDiagramState.view.ty = 0;
        _mathDiagramState.view.scale = 1;
        _mathDiagramRender();
      }
      // DRAW_EDITOR_VIEWPORT_FIX
      function _mathDiagramEnsureOverlayRoot(){
        if (!mathDiagramSection) return;
        if (mathDiagramSection.parentElement !== document.body){
          document.body.appendChild(mathDiagramSection);
          _mathDiagramState.overlayMovedToBody = true;
        }
        if (mathDiagramBackdrop && mathDiagramBackdrop.parentElement !== document.body){
          document.body.appendChild(mathDiagramBackdrop);
          _mathDiagramState.overlayMovedToBody = true;
        }
      }
      // DRAW_EDITOR_VIEWPORT_FIX
      function _mathDiagramScheduleViewportLayout(){
        if (_mathDiagramState.viewportRaf) return;
        _mathDiagramState.viewportRaf = requestAnimationFrame(() => {
          _mathDiagramState.viewportRaf = 0;
          _mathDiagramResizeCanvasToViewport();
        });
      }
      // DRAW_EDITOR_VIEWPORT_FIX
      function _mathDiagramResizeCanvasToViewport(){
        if (!_mathDiagramState.active || !mathDiagramCanvas) return;
        const section = mathDiagramSection;
        if (!section) return;
        const vv = window.visualViewport;
        const vh = Math.max(280, Math.round(vv?.height || window.innerHeight || 0));
        const vw = Math.max(320, Math.round(vv?.width || window.innerWidth || 0));
        const voX = Math.round(vv?.offsetLeft || 0);
        const voY = Math.round(vv?.offsetTop || 0);
        section.style.left = `${voX}px`;
        section.style.top = `${voY}px`;
        section.style.right = "auto";
        section.style.bottom = "auto";
        section.style.width = `${vw}px`;
        section.style.height = `${vh}px`;
        const wrap = mathDiagramCanvas.parentElement;
        if (!wrap) return;
        const header = section.querySelector(".math-diagram-header");
        const toolbar = section.querySelector(".math-diagram-toolbar-wrap");
        const footer = section.querySelector(".math-diagram-footer");
        const hh = header ? Math.ceil(header.getBoundingClientRect().height) : 0;
        const th = toolbar ? Math.ceil(toolbar.getBoundingClientRect().height) : 0;
        const fh = footer ? Math.ceil(footer.getBoundingClientRect().height) : 0;
        const avail = Math.max(220, vh - hh - th - fh - 2);
        wrap.style.height = `${avail}px`;
        const rect = wrap.getBoundingClientRect();
        const cssW = Math.max(280, Math.round(rect.width - 2));
        const cssH = Math.max(180, Math.round(rect.height - 2));
        const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
        _mathDiagramState.pixelRatio = dpr;
        _mathDiagramState.canvasCssWidth = cssW;
        _mathDiagramState.canvasCssHeight = cssH;
        mathDiagramCanvas.style.width = `${cssW}px`;
        mathDiagramCanvas.style.height = `${cssH}px`;
        const pxW = Math.max(1, Math.round(cssW * dpr));
        const pxH = Math.max(1, Math.round(cssH * dpr));
        if (mathDiagramCanvas.width !== pxW || mathDiagramCanvas.height !== pxH){
          mathDiagramCanvas.width = pxW;
          mathDiagramCanvas.height = pxH;
        }
        _mathDiagramRender();
      }

      function _mathDiagramSetTool(tool){
        const next = String(tool || "pen");
        _mathDiagramState.tool = next;
        if (mathDiagramCanvas){
          mathDiagramCanvas.classList.toggle("is-tool-select", next === "select");
          mathDiagramCanvas.classList.toggle("is-tool-pan", next === "pan");
          mathDiagramCanvas.classList.toggle("is-tool-eraser", next === "eraser");
          mathDiagramCanvas.classList.toggle("is-tool-point", next === "point");
        }
        if (mathDiagramSection){
          mathDiagramSection.querySelectorAll("[data-math-tool]").forEach((btn) => {
            btn.classList.toggle("is-active", String(btn.getAttribute("data-math-tool")) === next);
          });
        }
        _mathDiagramUpdateSelectionUI();
      }
      function _mathDiagramDistancePointToSegment(px, py, x1, y1, x2, y2){
        const vx = x2 - x1;
        const vy = y2 - y1;
        const wx = px - x1;
        const wy = py - y1;
        const c1 = (wx * vx) + (wy * vy);
        if (c1 <= 0) return Math.hypot(px - x1, py - y1);
        const c2 = (vx * vx) + (vy * vy);
        if (c2 <= c1) return Math.hypot(px - x2, py - y2);
        const b = c1 / c2;
        const bx = x1 + (b * vx);
        const by = y1 + (b * vy);
        return Math.hypot(px - bx, py - by);
      }
      function _mathDiagramRotatePoint(x, y, cx, cy, rad){
        const dx = x - cx;
        const dy = y - cy;
        const c = Math.cos(rad);
        const s = Math.sin(rad);
        return {
          x: (dx * c) - (dy * s) + cx,
          y: (dx * s) + (dy * c) + cy
        };
      }
      function _mathDiagramCommandBounds(cmd){
        if (!cmd || typeof cmd !== "object") return null;
        const type = String(cmd.type || "");
        if (type === "point"){
          const x = Number(cmd.x || 0);
          const y = Number(cmd.y || 0);
          return { x, y, w: 1, h: 1 };
        }
        if (type === "text"){
          const x = Number(cmd.x || 0);
          const y = Number(cmd.y || 0);
          const w = Math.max(10, Number(cmd.w || 0));
          const h = Math.max(12, Number(cmd.h || Number(cmd.fontSize || 18)));
          const angle = Number(cmd.angle || 0);
          if (!angle) return { x, y, w, h };
          const cx = x + (w / 2);
          const cy = y + (h / 2);
          const rad = angle * Math.PI / 180;
          const pts = [
            _mathDiagramRotatePoint(x, y, cx, cy, rad),
            _mathDiagramRotatePoint(x + w, y, cx, cy, rad),
            _mathDiagramRotatePoint(x + w, y + h, cx, cy, rad),
            _mathDiagramRotatePoint(x, y + h, cx, cy, rad)
          ];
          const xs = pts.map((p) => p.x);
          const ys = pts.map((p) => p.y);
          return {
            x: Math.min(...xs),
            y: Math.min(...ys),
            w: Math.max(...xs) - Math.min(...xs),
            h: Math.max(...ys) - Math.min(...ys)
          };
        }
        if (type === "line"){
          const x1 = Number(cmd.x1 || 0);
          const y1 = Number(cmd.y1 || 0);
          const x2 = Number(cmd.x2 || 0);
          const y2 = Number(cmd.y2 || 0);
          return { x: Math.min(x1, x2), y: Math.min(y1, y2), w: Math.abs(x2 - x1), h: Math.abs(y2 - y1) };
        }
        if (type === "circle"){
          const cx = Number(cmd.cx || 0);
          const cy = Number(cmd.cy || 0);
          const r = Math.max(1, Number(cmd.r || 0));
          return { x: cx - r, y: cy - r, w: r * 2, h: r * 2 };
        }
        if (type === "rect" || type === "table"){
          const x = Number(cmd.x || 0);
          const y = Number(cmd.y || 0);
          const w = Math.max(1, Number(cmd.w || 0));
          const h = Math.max(1, Number(cmd.h || 0));
          const angle = Number(cmd.angle || 0);
          if (!angle){
            return { x, y, w, h };
          }
          const cx = x + (w / 2);
          const cy = y + (h / 2);
          const rad = angle * Math.PI / 180;
          const pts = [
            _mathDiagramRotatePoint(x, y, cx, cy, rad),
            _mathDiagramRotatePoint(x + w, y, cx, cy, rad),
            _mathDiagramRotatePoint(x + w, y + h, cx, cy, rad),
            _mathDiagramRotatePoint(x, y + h, cx, cy, rad)
          ];
          const xs = pts.map((p) => p.x);
          const ys = pts.map((p) => p.y);
          return {
            x: Math.min(...xs),
            y: Math.min(...ys),
            w: Math.max(...xs) - Math.min(...xs),
            h: Math.max(...ys) - Math.min(...ys)
          };
        }
        if (type === "image"){
          const x = Number(cmd.x || 0);
          const y = Number(cmd.y || 0);
          const w = Math.max(10, Number(cmd.w || 0));
          const h = Math.max(10, Number(cmd.h || 0));
          const angle = Number(cmd.angle || 0);
          if (!angle) return { x, y, w, h };
          const cx = x + (w / 2);
          const cy = y + (h / 2);
          const rad = angle * Math.PI / 180;
          const pts = [
            _mathDiagramRotatePoint(x, y, cx, cy, rad),
            _mathDiagramRotatePoint(x + w, y, cx, cy, rad),
            _mathDiagramRotatePoint(x + w, y + h, cx, cy, rad),
            _mathDiagramRotatePoint(x, y + h, cx, cy, rad)
          ];
          const xs = pts.map((p) => p.x);
          const ys = pts.map((p) => p.y);
          return {
            x: Math.min(...xs),
            y: Math.min(...ys),
            w: Math.max(...xs) - Math.min(...xs),
            h: Math.max(...ys) - Math.min(...ys)
          };
        }
        if (type === "path"){
          const pts = Array.isArray(cmd.points) ? cmd.points : [];
          if (!pts.length) return null;
          const xs = pts.map((p) => Number(p.x || 0));
          const ys = pts.map((p) => Number(p.y || 0));
          return {
            x: Math.min(...xs),
            y: Math.min(...ys),
            w: Math.max(...xs) - Math.min(...xs),
            h: Math.max(...ys) - Math.min(...ys)
          };
        }
        return null;
      }
      function _mathDiagramCenterOfCommand(cmd){
        const b = _mathDiagramCommandBounds(cmd);
        if (!b) return { x: 0, y: 0 };
        return { x: b.x + (b.w / 2), y: b.y + (b.h / 2) };
      }
      function _mathDiagramPointInRect(x, y, rx, ry, rw, rh){
        return x >= rx && x <= (rx + rw) && y >= ry && y <= (ry + rh);
      }
      // DRAW_EDITOR_V1
      function _mathDiagramSelectionHandles(cmd){
        const b = _mathDiagramCommandBounds(cmd);
        if (!b) return [];
        const sc = Math.max(0.25, Number(_mathDiagramState.view.scale || 1));
        const hs = 8 / sc;
        const cx = b.x + (b.w / 2);
        const cy = b.y + (b.h / 2);
        const rotOffset = 26 / sc;
        return [
          { key: "nw", x: b.x, y: b.y, size: hs },
          { key: "n", x: cx, y: b.y, size: hs },
          { key: "ne", x: b.x + b.w, y: b.y, size: hs },
          { key: "e", x: b.x + b.w, y: cy, size: hs },
          { key: "se", x: b.x + b.w, y: b.y + b.h, size: hs },
          { key: "s", x: cx, y: b.y + b.h, size: hs },
          { key: "sw", x: b.x, y: b.y + b.h, size: hs },
          { key: "w", x: b.x, y: cy, size: hs },
          { key: "rot", x: cx, y: b.y - rotOffset, size: hs }
        ];
      }
      // DRAW_EDITOR_V1
      function _mathDiagramHitHandle(px, py){
        const idx = Number(_mathDiagramState.selectedIndex);
        if (!Number.isInteger(idx) || idx < 0 || idx >= _mathDiagramState.commands.length) return "";
        const cmd = _mathDiagramState.commands[idx];
        const handles = _mathDiagramSelectionHandles(cmd);
        for (const h of handles){
          if (_mathDiagramPointInRect(px, py, h.x - h.size, h.y - h.size, h.size * 2, h.size * 2)){
            return h.key;
          }
        }
        return "";
      }
      function _mathDiagramHitCommandAt(cmd, px, py){
        if (!cmd || typeof cmd !== "object") return false;
        const type = String(cmd.type || "");
        const sc = Math.max(0.25, Number(_mathDiagramState.view.scale || 1));
        const tol = 8 / sc;
        if (type === "point"){
          return Math.hypot(px - Number(cmd.x || 0), py - Number(cmd.y || 0)) <= (10 / sc);
        }
        if (type === "line"){
          return _mathDiagramDistancePointToSegment(
            px, py,
            Number(cmd.x1 || 0), Number(cmd.y1 || 0),
            Number(cmd.x2 || 0), Number(cmd.y2 || 0)
          ) <= tol;
        }
        if (type === "circle"){
          const cx = Number(cmd.cx || 0);
          const cy = Number(cmd.cy || 0);
          const r = Math.max(1, Number(cmd.r || 0));
          const d = Math.hypot(px - cx, py - cy);
          return Math.abs(d - r) <= tol || d < r;
        }
        if (type === "text"){
          const b = _mathDiagramCommandBounds(cmd);
          if (!b) return false;
          return _mathDiagramPointInRect(px, py, b.x - 6, b.y - 6, b.w + 12, b.h + 12);
        }
        if (type === "image"){
          const x = Number(cmd.x || 0);
          const y = Number(cmd.y || 0);
          const w = Math.max(10, Number(cmd.w || 0));
          const h = Math.max(10, Number(cmd.h || 0));
          const angle = Number(cmd.angle || 0);
          if (!angle){
            return _mathDiagramPointInRect(px, py, x - 6, y - 6, w + 12, h + 12);
          }
          const cx = x + (w / 2);
          const cy = y + (h / 2);
          const rad = -(angle * Math.PI / 180);
          const pr = _mathDiagramRotatePoint(px, py, cx, cy, rad);
          return _mathDiagramPointInRect(pr.x, pr.y, x - 6, y - 6, w + 12, h + 12);
        }
        if (type === "rect" || type === "table"){
          const x = Number(cmd.x || 0);
          const y = Number(cmd.y || 0);
          const w = Math.max(1, Number(cmd.w || 0));
          const h = Math.max(1, Number(cmd.h || 0));
          const angle = Number(cmd.angle || 0);
          if (!angle){
            return _mathDiagramPointInRect(px, py, x - 6, y - 6, w + 12, h + 12);
          }
          const cx = x + (w / 2);
          const cy = y + (h / 2);
          const rad = -(angle * Math.PI / 180);
          const pr = _mathDiagramRotatePoint(px, py, cx, cy, rad);
          return _mathDiagramPointInRect(pr.x, pr.y, x - 6, y - 6, w + 12, h + 12);
        }
        if (type === "path"){
          const pts = Array.isArray(cmd.points) ? cmd.points : [];
          for (let i=1;i<pts.length;i++){
            if (_mathDiagramDistancePointToSegment(px, py, Number(pts[i-1].x||0), Number(pts[i-1].y||0), Number(pts[i].x||0), Number(pts[i].y||0)) <= tol){
              return true;
            }
          }
        }
        const b = _mathDiagramCommandBounds(cmd);
        if (!b) return false;
        return _mathDiagramPointInRect(px, py, b.x - 6, b.y - 6, b.w + 12, b.h + 12);
      }
      function _mathDiagramTranslateCommand(cmd, dx, dy){
        const x = Number(dx || 0);
        const y = Number(dy || 0);
        if (!cmd || typeof cmd !== "object") return;
        const type = String(cmd.type || "");
        if (type === "point"){
          cmd.x = Number(cmd.x || 0) + x;
          cmd.y = Number(cmd.y || 0) + y;
          return;
        }
        if (type === "line"){
          cmd.x1 = Number(cmd.x1 || 0) + x;
          cmd.y1 = Number(cmd.y1 || 0) + y;
          cmd.x2 = Number(cmd.x2 || 0) + x;
          cmd.y2 = Number(cmd.y2 || 0) + y;
          return;
        }
        if (type === "circle"){
          cmd.cx = Number(cmd.cx || 0) + x;
          cmd.cy = Number(cmd.cy || 0) + y;
          return;
        }
        if (type === "text"){
          cmd.x = Number(cmd.x || 0) + x;
          cmd.y = Number(cmd.y || 0) + y;
          return;
        }
        if (type === "image"){
          cmd.x = Number(cmd.x || 0) + x;
          cmd.y = Number(cmd.y || 0) + y;
          return;
        }
        if (type === "rect" || type === "table"){
          cmd.x = Number(cmd.x || 0) + x;
          cmd.y = Number(cmd.y || 0) + y;
          return;
        }
        if (type === "path"){
          const pts = Array.isArray(cmd.points) ? cmd.points : [];
          for (const p of pts){
            p.x = Number(p.x || 0) + x;
            p.y = Number(p.y || 0) + y;
          }
        }
      }
      function _mathDiagramRotateCommand(cmd, deg){
        if (!cmd || typeof cmd !== "object") return;
        const d = Number(deg || 0);
        if (!Number.isFinite(d) || d === 0) return;
        const type = String(cmd.type || "");
        if (type === "rect" || type === "table"){
          cmd.angle = Number(cmd.angle || 0) + d;
          return;
        }
        if (type === "image"){
          cmd.angle = Number(cmd.angle || 0) + d;
          return;
        }
        if (type === "text"){
          cmd.angle = Number(cmd.angle || 0) + d;
          return;
        }
        if (type === "line"){
          const c = _mathDiagramCenterOfCommand(cmd);
          const rad = d * Math.PI / 180;
          const p1 = _mathDiagramRotatePoint(Number(cmd.x1||0), Number(cmd.y1||0), c.x, c.y, rad);
          const p2 = _mathDiagramRotatePoint(Number(cmd.x2||0), Number(cmd.y2||0), c.x, c.y, rad);
          cmd.x1 = p1.x; cmd.y1 = p1.y; cmd.x2 = p2.x; cmd.y2 = p2.y;
          return;
        }
        if (type === "path"){
          const c = _mathDiagramCenterOfCommand(cmd);
          const rad = d * Math.PI / 180;
          const pts = Array.isArray(cmd.points) ? cmd.points : [];
          for (const p of pts){
            const r = _mathDiagramRotatePoint(Number(p.x||0), Number(p.y||0), c.x, c.y, rad);
            p.x = r.x;
            p.y = r.y;
          }
          return;
        }
        if (type === "point"){
          // point alone rotation has no visible meaning
          return;
        }
      }
      // DRAW_EDITOR_V1
      function _mathDiagramApplyScaledCommand(target, base, baseBounds, newBounds){
        if (!target || !base || !baseBounds || !newBounds) return;
        const sx = Math.max(0.0001, Number(newBounds.w || 0) / Math.max(0.0001, Number(baseBounds.w || 1)));
        const sy = Math.max(0.0001, Number(newBounds.h || 0) / Math.max(0.0001, Number(baseBounds.h || 1)));
        const tx = Number(newBounds.x || 0);
        const ty = Number(newBounds.y || 0);
        const bx = Number(baseBounds.x || 0);
        const by = Number(baseBounds.y || 0);
        const mapX = (v) => tx + ((Number(v || 0) - bx) * sx);
        const mapY = (v) => ty + ((Number(v || 0) - by) * sy);
        const type = String(base.type || target.type || "");
        if (type === "point"){
          target.x = mapX(base.x);
          target.y = mapY(base.y);
          return;
        }
        if (type === "line"){
          target.x1 = mapX(base.x1);
          target.y1 = mapY(base.y1);
          target.x2 = mapX(base.x2);
          target.y2 = mapY(base.y2);
          return;
        }
        if (type === "circle"){
          target.cx = mapX(base.cx);
          target.cy = mapY(base.cy);
          target.r = Math.max(1, Number(base.r || 1) * ((sx + sy) / 2));
          return;
        }
        if (type === "rect" || type === "table"){
          target.x = mapX(base.x);
          target.y = mapY(base.y);
          target.w = Math.max(6, Number(base.w || 1) * sx);
          target.h = Math.max(6, Number(base.h || 1) * sy);
          target.angle = Number(base.angle || 0);
          if (type === "table"){
            target.rows = Math.max(1, Number(base.rows || 2));
            target.cols = Math.max(1, Number(base.cols || 2));
            target.cellTexts = Array.isArray(base.cellTexts) ? JSON.parse(JSON.stringify(base.cellTexts)) : [];
          }
          return;
        }
        if (type === "path"){
          const pts = Array.isArray(base.points) ? base.points : [];
          target.points = pts.map((p) => ({ x: mapX(p.x), y: mapY(p.y) }));
          target.erase = !!base.erase;
          return;
        }
        if (type === "text"){
          target.x = mapX(base.x);
          target.y = mapY(base.y);
          target.w = Math.max(10, Number(base.w || 10) * sx);
          target.h = Math.max(12, Number(base.h || 12) * sy);
          target.fontSize = Math.max(10, Number(base.fontSize || 18) * ((sx + sy) / 2));
          target.text = String(base.text || "");
          target.color = String(base.color || "#18212f");
          target.angle = Number(base.angle || 0);
          return;
        }
        if (type === "image"){
          target.x = mapX(base.x);
          target.y = mapY(base.y);
          target.w = Math.max(10, Number(base.w || 10) * sx);
          target.h = Math.max(10, Number(base.h || 10) * sy);
          target.src = String(base.src || "");
          target.angle = Number(base.angle || 0);
        }
      }
      // DRAW_EDITOR_V1
      function _mathDiagramResizeSelectedFromHandle(px, py){
        const idx = Number(_mathDiagramState.selectedIndex);
        if (!Number.isInteger(idx) || idx < 0 || idx >= _mathDiagramState.commands.length) return;
        const baseCmd = _mathDiagramState.resizeBaseCmd;
        const b = _mathDiagramState.resizeBaseBounds;
        const h = String(_mathDiagramState.resizeHandle || "");
        if (!baseCmd || !b || !h) return;
        let x1 = b.x;
        let y1 = b.y;
        let x2 = b.x + b.w;
        let y2 = b.y + b.h;
        if (h === "nw"){ x1 = px; y1 = py; }
        else if (h === "n"){ y1 = py; }
        else if (h === "ne"){ x2 = px; y1 = py; }
        else if (h === "e"){ x2 = px; }
        else if (h === "se"){ x2 = px; y2 = py; }
        else if (h === "s"){ y2 = py; }
        else if (h === "sw"){ x1 = px; y2 = py; }
        else if (h === "w"){ x1 = px; }
        const nb = {
          x: Math.min(x1, x2),
          y: Math.min(y1, y2),
          w: Math.max(6, Math.abs(x2 - x1)),
          h: Math.max(6, Math.abs(y2 - y1))
        };
        if (_mathDiagramState.snap){
          const step = 14;
          nb.x = Math.round(nb.x / step) * step;
          nb.y = Math.round(nb.y / step) * step;
          nb.w = Math.max(6, Math.round(nb.w / step) * step);
          nb.h = Math.max(6, Math.round(nb.h / step) * step);
        }
        const target = _mathDiagramState.commands[idx];
        _mathDiagramApplyScaledCommand(target, baseCmd, b, nb);
      }
      // DRAW_EDITOR_V2V3
      function _mathDiagramRotateFromBase(target, base, deg){
        if (!target || !base) return;
        const d = Number(deg || 0);
        const copy = JSON.parse(JSON.stringify(base));
        _mathDiagramRotateCommand(copy, d);
        Object.keys(target).forEach((k) => { delete target[k]; });
        Object.assign(target, copy);
      }
      function _mathDiagramUpdateSelectionUI(){
        const idx = Number(_mathDiagramState.selectedIndex);
        const has = Number.isInteger(idx) && idx >= 0 && idx < _mathDiagramState.commands.length;
        const selected = has ? _mathDiagramState.commands[idx] : null;
        const selectedType = String(selected?.type || "");
        if (mathDiagramSelectedInfo){
          if (!has){
            mathDiagramSelectedInfo.textContent = "";
          } else {
            const cmd = selected;
            const labelMap = {
              table: "",
              rect: "",
              line: "",
              circle: "",
              point: "",
              image: "",
              text: "",
              path: (cmd && cmd.erase) ? "" : ""
            };
            const t = String(cmd?.type || "");
            mathDiagramSelectedInfo.textContent = `: ${labelMap[t] || t}`;
          }
        }
        const buttons = [
          mathDiagramMoveLeftBtn, mathDiagramMoveRightBtn, mathDiagramMoveUpBtn, mathDiagramMoveDownBtn,
          mathDiagramRotateLeftBtn, mathDiagramRotateRightBtn, mathDiagramDeleteBtn,
          mathDiagramBringFrontBtn, mathDiagramSendBackBtn
        ];
        for (const b of buttons){
          if (!b) continue;
          b.disabled = !has;
        }
        if (mathDiagramEditTextBtn){
          mathDiagramEditTextBtn.disabled = !(has && selectedType === "text");
        }
        if (mathDiagramTableCellEditBtn){
          mathDiagramTableCellEditBtn.disabled = !(has && selectedType === "table");
        }
        if (mathDiagramFontSizeRange){
          mathDiagramFontSizeRange.disabled = !(has && selectedType === "text");
          if (has && selectedType === "text"){
            mathDiagramFontSizeRange.value = String(Math.round(Number(selected.fontSize || 20)));
          }
        }
      }
      function _mathDiagramDeleteSelected(){
        const idx = Number(_mathDiagramState.selectedIndex);
        if (!Number.isInteger(idx) || idx < 0 || idx >= _mathDiagramState.commands.length) return;
        _mathDiagramPushHistory();
        _mathDiagramState.commands.splice(idx, 1);
        _mathDiagramState.selectedIndex = -1;
        _mathDiagramUpdateSelectionUI();
        _mathDiagramRender();
      }
      function _mathDiagramMoveSelected(dx, dy){
        const idx = Number(_mathDiagramState.selectedIndex);
        if (!Number.isInteger(idx) || idx < 0 || idx >= _mathDiagramState.commands.length) return;
        _mathDiagramPushHistory();
        _mathDiagramTranslateCommand(_mathDiagramState.commands[idx], dx, dy);
        _mathDiagramUpdateSelectionUI();
        _mathDiagramRender();
      }
      function _mathDiagramRotateSelected(deg){
        const idx = Number(_mathDiagramState.selectedIndex);
        if (!Number.isInteger(idx) || idx < 0 || idx >= _mathDiagramState.commands.length) return;
        _mathDiagramPushHistory();
        _mathDiagramRotateCommand(_mathDiagramState.commands[idx], deg);
        _mathDiagramUpdateSelectionUI();
        _mathDiagramRender();
      }
      function _mathDiagramDrawSelectionBox(ctx, cmd){
        const b = _mathDiagramCommandBounds(cmd);
        if (!b) return;
        const sc = Math.max(0.25, Number(_mathDiagramState.view.scale || 1));
        const pad = 5 / sc;
        ctx.save();
        ctx.setLineDash([6, 4]);
        ctx.strokeStyle = "rgba(31,42,68,0.82)";
        ctx.lineWidth = 1.2 / sc;
        ctx.strokeRect(b.x - pad, b.y - pad, b.w + (pad * 2), b.h + (pad * 2));
        ctx.setLineDash([]);
        ctx.fillStyle = "rgba(31,42,68,0.82)";
        const hs = _mathDiagramSelectionHandles(cmd);
        for (const h of hs){
          ctx.fillRect(h.x - h.size, h.y - h.size, h.size * 2, h.size * 2);
        }
        ctx.restore();
      }
      function _mathDiagramDrawImageContain(ctx, img, width, height){
        const iw = Number(img?.naturalWidth || img?.width || 0);
        const ih = Number(img?.naturalHeight || img?.height || 0);
        if (!(iw > 0 && ih > 0)) return false;
        const pad = 6;
        const dwMax = Math.max(1, width - (pad * 2));
        const dhMax = Math.max(1, height - (pad * 2));
        const scale = Math.min(dwMax / iw, dhMax / ih);
        const dw = iw * scale;
        const dh = ih * scale;
        const dx = (width - dw) / 2;
        const dy = (height - dh) / 2;
        ctx.drawImage(img, dx, dy, dw, dh);
        return true;
      }

      function _mathDiagramDrawGrid(ctx, worldBounds){
        ctx.save();
        ctx.strokeStyle = "rgba(0,0,0,0.08)";
        const sc = Math.max(0.25, Number(_mathDiagramState.view.scale || 1));
        ctx.lineWidth = 1 / sc;
        const step = 28;
        const minX = Math.floor(worldBounds.minX / step) * step;
        const maxX = Math.ceil(worldBounds.maxX / step) * step;
        const minY = Math.floor(worldBounds.minY / step) * step;
        const maxY = Math.ceil(worldBounds.maxY / step) * step;
        for (let x = minX; x <= maxX; x += step){
          ctx.beginPath();
          ctx.moveTo(x, minY);
          ctx.lineTo(x, maxY);
          ctx.stroke();
        }
        for (let y = minY; y <= maxY; y += step){
          ctx.beginPath();
          ctx.moveTo(minX, y);
          ctx.lineTo(maxX, y);
          ctx.stroke();
        }
        ctx.restore();
      }

      function _mathDiagramDrawAxis(ctx, worldBounds){
        const sc = Math.max(0.25, Number(_mathDiagramState.view.scale || 1));
        ctx.save();
        ctx.strokeStyle = "rgba(0,0,0,0.45)";
        ctx.fillStyle = "rgba(0,0,0,0.65)";
        ctx.lineWidth = 1.6 / sc;
        const minX = Number(worldBounds.minX);
        const maxX = Number(worldBounds.maxX);
        const minY = Number(worldBounds.minY);
        const maxY = Number(worldBounds.maxY);
        ctx.beginPath();
        ctx.moveTo(minX, 0);
        ctx.lineTo(maxX, 0);
        ctx.moveTo(0, minY);
        ctx.lineTo(0, maxY);
        ctx.stroke();
        for (let x = 28; x < maxX; x += 28){
          ctx.beginPath();
          ctx.moveTo(x, -4 / sc);
          ctx.lineTo(x, 4 / sc);
          ctx.stroke();
        }
        for (let x = -28; x > minX; x -= 28){
          ctx.beginPath();
          ctx.moveTo(x, -4 / sc);
          ctx.lineTo(x, 4 / sc);
          ctx.stroke();
        }
        for (let y = 28; y < maxY; y += 28){
          ctx.beginPath();
          ctx.moveTo(-4 / sc, y);
          ctx.lineTo(4 / sc, y);
          ctx.stroke();
        }
        for (let y = -28; y > minY; y -= 28){
          ctx.beginPath();
          ctx.moveTo(-4 / sc, y);
          ctx.lineTo(4 / sc, y);
          ctx.stroke();
        }
        ctx.restore();
      }

      function _mathDiagramDrawCommand(ctx, cmd){
        if (!cmd || typeof cmd !== "object") return;
        const type = String(cmd.type || "");
        ctx.save();
        if (type === "path"){
          const points = Array.isArray(cmd.points) ? cmd.points : [];
          if (points.length < 2){ ctx.restore(); return; }
          if (cmd.erase){
            ctx.globalCompositeOperation = "destination-out";
            ctx.lineWidth = 16;
          } else {
            ctx.strokeStyle = "#18212f";
            ctx.lineWidth = 2.2;
          }
          ctx.lineJoin = "round";
          ctx.lineCap = "round";
          ctx.beginPath();
          ctx.moveTo(points[0].x, points[0].y);
          for (let i=1;i<points.length;i++) ctx.lineTo(points[i].x, points[i].y);
          ctx.stroke();
          ctx.restore();
          return;
        }
        if (type === "line"){
          ctx.strokeStyle = "#18212f";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(cmd.x1, cmd.y1);
          ctx.lineTo(cmd.x2, cmd.y2);
          ctx.stroke();
          ctx.restore();
          return;
        }
        if (type === "rect"){
          const x = Number(cmd.x || 0);
          const y = Number(cmd.y || 0);
          const w = Math.max(1, Number(cmd.w || 0));
          const h = Math.max(1, Number(cmd.h || 0));
          const angle = Number(cmd.angle || 0);
          ctx.strokeStyle = "#18212f";
          ctx.lineWidth = 2;
          if (angle){
            const cx = x + (w / 2);
            const cy = y + (h / 2);
            ctx.translate(cx, cy);
            ctx.rotate(angle * Math.PI / 180);
            ctx.strokeRect(-(w / 2), -(h / 2), w, h);
          } else {
            ctx.strokeRect(x, y, w, h);
          }
          ctx.restore();
          return;
        }
        if (type === "circle"){
          ctx.strokeStyle = "#18212f";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(cmd.cx, cmd.cy, Math.max(2, cmd.r || 0), 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
          return;
        }
        if (type === "point"){
          const x = Number(cmd.x || 0);
          const y = Number(cmd.y || 0);
          ctx.fillStyle = "#18212f";
          ctx.beginPath();
          ctx.arc(x, y, 3.6, 0, Math.PI * 2);
          ctx.fill();
          const label = String(cmd.label || "").trim();
          if (label){
            ctx.fillStyle = "#0f1722";
            ctx.font = "600 14px ui-sans-serif, system-ui, -apple-system, sans-serif";
            ctx.fillText(label.slice(0,2).toUpperCase(), x + 6, y - 6);
          }
          ctx.restore();
          return;
        }
        if (type === "text"){
          const x = Number(cmd.x || 0);
          const y = Number(cmd.y || 0);
          const w = Math.max(10, Number(cmd.w || 10));
          const h = Math.max(12, Number(cmd.h || Number(cmd.fontSize || 18)));
          const angle = Number(cmd.angle || 0);
          const text = String(cmd.text || "").trim();
          if (!text){ ctx.restore(); return; }
          const fontSize = Math.max(10, Number(cmd.fontSize || 18));
          ctx.fillStyle = String(cmd.color || "#18212f");
          ctx.font = `600 ${fontSize}px ui-sans-serif, system-ui, -apple-system, sans-serif`;
          ctx.textBaseline = "top";
          if (angle){
            const cx = x + (w / 2);
            const cy = y + (h / 2);
            ctx.translate(cx, cy);
            ctx.rotate(angle * Math.PI / 180);
            ctx.fillText(text, -(w / 2), -(h / 2));
          } else {
            ctx.fillText(text, x, y);
          }
          const measured = Math.max(10, ctx.measureText(text).width);
          cmd.w = measured;
          cmd.h = Math.max(fontSize * 1.3, Number(cmd.h || 0), 12);
          cmd.fontSize = fontSize;
          ctx.restore();
          return;
        }
        if (type === "table"){
          const x = Number(cmd.x || 0);
          const y = Number(cmd.y || 0);
          const w = Math.max(10, Number(cmd.w || 0));
          const h = Math.max(10, Number(cmd.h || 0));
          const rows = Math.max(1, Number(cmd.rows || 2));
          const cols = Math.max(1, Number(cmd.cols || 2));
          const angle = Number(cmd.angle || 0);
          ctx.strokeStyle = "#18212f";
          ctx.lineWidth = 2;
          if (angle){
            const cx = x + (w / 2);
            const cy = y + (h / 2);
            ctx.translate(cx, cy);
            ctx.rotate(angle * Math.PI / 180);
            ctx.strokeRect(-(w / 2), -(h / 2), w, h);
            for (let i = 1; i < cols; i++){
              const xx = - (w / 2) + (w * i / cols);
              ctx.beginPath();
              ctx.moveTo(xx, - (h / 2));
              ctx.lineTo(xx, (h / 2));
              ctx.stroke();
            }
            for (let i = 1; i < rows; i++){
              const yy = - (h / 2) + (h * i / rows);
              ctx.beginPath();
              ctx.moveTo(- (w / 2), yy);
              ctx.lineTo((w / 2), yy);
              ctx.stroke();
            }
          } else {
            ctx.strokeRect(x, y, w, h);
            for (let i = 1; i < cols; i++){
              const xx = x + (w * i / cols);
              ctx.beginPath();
              ctx.moveTo(xx, y);
              ctx.lineTo(xx, y + h);
              ctx.stroke();
            }
            for (let i = 1; i < rows; i++){
              const yy = y + (h * i / rows);
              ctx.beginPath();
              ctx.moveTo(x, yy);
              ctx.lineTo(x + w, yy);
              ctx.stroke();
            }
          }
          const cellTexts = Array.isArray(cmd.cellTexts) ? cmd.cellTexts : [];
          ctx.fillStyle = "#18212f";
          ctx.font = "500 14px ui-sans-serif, system-ui, -apple-system, sans-serif";
          ctx.textBaseline = "middle";
          if (angle){
            for (let r = 0; r < rows; r++){
              for (let c = 0; c < cols; c++){
                const t = String(cellTexts?.[r]?.[c] ?? "").trim();
                if (!t) continue;
                const cx = -(w / 2) + ((c + 0.5) * (w / cols));
                const cy = -(h / 2) + ((r + 0.5) * (h / rows));
                ctx.fillText(t.slice(0, 24), cx - (ctx.measureText(t.slice(0, 24)).width / 2), cy);
              }
            }
          } else {
            for (let r = 0; r < rows; r++){
              for (let c = 0; c < cols; c++){
                const t = String(cellTexts?.[r]?.[c] ?? "").trim();
                if (!t) continue;
                const cx = x + ((c + 0.5) * (w / cols));
                const cy = y + ((r + 0.5) * (h / rows));
                ctx.fillText(t.slice(0, 24), cx - (ctx.measureText(t.slice(0, 24)).width / 2), cy);
              }
            }
          }
          ctx.restore();
          return;
        }
        if (type === "image"){
          const x = Number(cmd.x || 0);
          const y = Number(cmd.y || 0);
          const w = Math.max(10, Number(cmd.w || 10));
          const h = Math.max(10, Number(cmd.h || 10));
          const angle = Number(cmd.angle || 0);
          const src = String(cmd.src || "");
          if (!src){ ctx.restore(); return; }
          let img = _mathDiagramState.imageCache.get(src);
          if (!img){
            img = new Image();
            img.onload = () => _mathDiagramRender();
            img.onerror = () => _mathDiagramRender();
            img.src = src;
            _mathDiagramState.imageCache.set(src, img);
          }
          if (img.complete && img.naturalWidth > 0){
            if (angle){
              const cx = x + (w / 2);
              const cy = y + (h / 2);
              ctx.translate(cx, cy);
              ctx.rotate(angle * Math.PI / 180);
              ctx.drawImage(img, -(w / 2), -(h / 2), w, h);
            } else {
              ctx.drawImage(img, x, y, w, h);
            }
          } else {
            ctx.fillStyle = "rgba(24,33,47,.08)";
            ctx.strokeStyle = "rgba(24,33,47,.22)";
            ctx.lineWidth = 1;
            ctx.fillRect(x, y, w, h);
            ctx.strokeRect(x, y, w, h);
          }
        }
        ctx.restore();
      }

      // DRAW_EDITOR_V1
      function _mathDiagramRenderNow(){
        if (!_mathDiagramState.active || !mathDiagramCanvas) return;
        const ctx = _mathDiagramState.ctx || mathDiagramCanvas.getContext("2d");
        if (!ctx) return;
        _mathDiagramState.ctx = ctx;
        const dpr = Math.max(1, Number(_mathDiagramState.pixelRatio || 1));
        const width = Math.max(1, Number(_mathDiagramState.canvasCssWidth || mathDiagramCanvas.clientWidth || (mathDiagramCanvas.width / dpr)));
        const height = Math.max(1, Number(_mathDiagramState.canvasCssHeight || mathDiagramCanvas.clientHeight || (mathDiagramCanvas.height / dpr)));
        const scale = Math.max(_mathDiagramState.minScale, Math.min(_mathDiagramState.maxScale, Number(_mathDiagramState.view.scale || 1)));
        _mathDiagramState.view.scale = scale;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, mathDiagramCanvas.width, mathDiagramCanvas.height);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, width, height);
        if (_mathDiagramState.baseImage && _mathDiagramState.baseImage.complete){
          try{
            _mathDiagramDrawImageContain(ctx, _mathDiagramState.baseImage, width, height);
          }catch{}
        }
        const worldBounds = {
          minX: (0 - _mathDiagramState.view.tx) / scale,
          maxX: (width - _mathDiagramState.view.tx) / scale,
          minY: (0 - _mathDiagramState.view.ty) / scale,
          maxY: (height - _mathDiagramState.view.ty) / scale
        };
        ctx.save();
        ctx.translate(_mathDiagramState.view.tx, _mathDiagramState.view.ty);
        ctx.scale(scale, scale);
        if (_mathDiagramState.grid) _mathDiagramDrawGrid(ctx, worldBounds);
        if (_mathDiagramState.axis) _mathDiagramDrawAxis(ctx, worldBounds);
        for (let i=0;i<_mathDiagramState.commands.length;i++){
          _mathDiagramDrawCommand(ctx, _mathDiagramState.commands[i]);
        }
        const hoverIdx = Number(_mathDiagramState.eraseHoverIndex);
        if (Number.isInteger(hoverIdx) && hoverIdx >= 0 && hoverIdx < _mathDiagramState.commands.length){
          _mathDiagramDrawSelectionBox(ctx, _mathDiagramState.commands[hoverIdx]);
        }
        const sel = Number(_mathDiagramState.selectedIndex);
        if (Number.isInteger(sel) && sel >= 0 && sel < _mathDiagramState.commands.length){
          _mathDiagramDrawSelectionBox(ctx, _mathDiagramState.commands[sel]);
        }
        if (_mathDiagramState.drawing){
          const tool = _mathDiagramState.tool;
          if ((tool === "line" || tool === "rect" || tool === "circle") && Number.isFinite(_mathDiagramState.startX)){
            const x1 = _mathDiagramState.startX;
            const y1 = _mathDiagramState.startY;
            const x2 = _mathDiagramState.x;
            const y2 = _mathDiagramState.y;
            const preview = tool === "line"
              ? { type: "line", x1, y1, x2, y2 }
              : (tool === "rect"
                  ? { type: "rect", x: Math.min(x1, x2), y: Math.min(y1, y2), w: Math.abs(x2 - x1), h: Math.abs(y2 - y1) }
                  : { type: "circle", cx: x1, cy: y1, r: Math.hypot(x2 - x1, y2 - y1) });
            _mathDiagramDrawCommand(ctx, preview);
          }
        }
        ctx.restore();
      }
      // DRAW_EDITOR_V1
      function _mathDiagramRender(){
        if (!_mathDiagramState.active || !mathDiagramCanvas) return;
        _mathDiagramState.dirty = true;
        if (_mathDiagramState.rafId) return;
        _mathDiagramState.rafId = requestAnimationFrame(() => {
          _mathDiagramState.rafId = 0;
          if (!_mathDiagramState.active || !_mathDiagramState.dirty) return;
          _mathDiagramState.dirty = false;
          _mathDiagramRenderNow();
          if (_mathDiagramState.dirty){
            _mathDiagramRender();
          }
        });
      }

      function _mathDiagramSetBaseImage(dataUrl){
        const url = String(dataUrl || "").trim();
        _mathDiagramState.baseImageUrl = url;
        _mathDiagramState.baseImage = null;
        if (!url){
          _mathDiagramRender();
          return;
        }
        const img = new Image();
        img.onload = () => {
          _mathDiagramState.baseImage = img;
          _mathDiagramRender();
        };
        img.onerror = () => {
          _mathDiagramState.baseImage = null;
          _mathDiagramRender();
        };
        img.src = url;
      }

      function _mathDiagramFindPointIndex(x, y){
        const sc = Math.max(0.25, Number(_mathDiagramState.view.scale || 1));
        for (let i = _mathDiagramState.commands.length - 1; i >= 0; i--){
          const cmd = _mathDiagramState.commands[i];
          if (!cmd || cmd.type !== "point") continue;
          const dx = Number(cmd.x || 0) - x;
          const dy = Number(cmd.y || 0) - y;
          if (Math.hypot(dx, dy) <= (12 / sc)){
            return i;
          }
        }
        return -1;
      }

      function _mathDiagramFindCommandIndex(x, y){
        for (let i = _mathDiagramState.commands.length - 1; i >= 0; i--){
          const cmd = _mathDiagramState.commands[i];
          if (_mathDiagramHitCommandAt(cmd, x, y)){
            return i;
          }
        }
        return -1;
      }
      // DRAW_EDITOR_V1
      async function _mathDiagramPromptTextAt(x, y){
        const html = `
          <div style="display:grid; gap:10px;">
            <textarea id="mathDiagramTextInput" class="spell-input" rows="3" placeholder=""></textarea>
          </div>
        `;
        const ok = await uiConfirmHtml(html, {
          title: "",
          okText: "",
          cancelText: ""
        });
        if (!ok) return;
        const input = document.getElementById("mathDiagramTextInput");
        const text = String(input?.value || "").trim();
        if (!text){
          _setMathEditorStatus("", "error");
          return;
        }
        const fontSize = 20;
        const command = {
          type: "text",
          x: Math.max(4, Number(x || 0)),
          y: Math.max(4, Number(y || 0)),
          w: Math.max(10, text.length * fontSize * 0.62),
          h: Math.max(12, fontSize * 1.3),
          text: text.slice(0, 240),
          fontSize,
          color: "#18212f"
        };
        _mathDiagramPushHistory();
        _mathDiagramState.commands.push(command);
        _mathDiagramState.selectedIndex = _mathDiagramState.commands.length - 1;
        _mathDiagramUpdateSelectionUI();
        _mathDiagramRender();
      }

      function _mathDiagramOnPointerDown(ev){
        if (!_mathDiagramState.active || !mathDiagramCanvas) return;
        if (typeof ev.button === "number" && ev.button !== 0) return;
        const pScreen = _mathDiagramCanvasPoint(ev);
        const p = _mathDiagramScreenToWorld(pScreen);
        const tool = _mathDiagramState.tool;
        _mathDiagramState.pointers.set(ev.pointerId, { x: pScreen.x, y: pScreen.y });
        if (_mathDiagramState.pointers.size >= 2){
          _mathDiagramPushHistory();
          const pts = Array.from(_mathDiagramState.pointers.values());
          const a = pts[0];
          const b = pts[1];
          const center = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
          const dist = Math.max(8, Math.hypot(b.x - a.x, b.y - a.y));
          _mathDiagramState.pinch = {
            startScale: Number(_mathDiagramState.view.scale || 1),
            startDistance: dist,
            worldAtCenter: _mathDiagramScreenToWorld(center),
            centerStart: center,
            startTx: Number(_mathDiagramState.view.tx || 0),
            startTy: Number(_mathDiagramState.view.ty || 0)
          };
          _mathDiagramState.interaction = "gesture";
          _mathDiagramState.drawing = false;
          _mathDiagramState.pointerId = null;
          _mathDiagramRender();
          return;
        }
        _mathDiagramState.pointerId = ev.pointerId;
        _mathDiagramState.startX = p.x;
        _mathDiagramState.startY = p.y;
        _mathDiagramState.x = p.x;
        _mathDiagramState.y = p.y;
        _mathDiagramState.dragLastX = pScreen.x;
        _mathDiagramState.dragLastY = pScreen.y;
        _mathDiagramState.dragSelected = false;
        _mathDiagramState.pointDragIndex = -1;
        _mathDiagramState.currentPath = null;
        _mathDiagramState.interaction = "none";
        _mathDiagramState.resizeHandle = "";
        _mathDiagramState.resizeBaseCmd = null;
        _mathDiagramState.resizeBaseBounds = null;
        _mathDiagramState.eraseHoverIndex = -1;

        if (tool === "pan" || _mathDiagramState.spacePan){
          _mathDiagramPushHistory();
          _mathDiagramState.drawing = true;
          _mathDiagramState.interaction = "pan";
          try{ mathDiagramCanvas.setPointerCapture(ev.pointerId); }catch{}
          return;
        }

        if (tool === "select"){
          const handle = _mathDiagramHitHandle(p.x, p.y);
          if (handle){
            const idx = Number(_mathDiagramState.selectedIndex);
            if (Number.isInteger(idx) && idx >= 0 && idx < _mathDiagramState.commands.length){
              _mathDiagramPushHistory();
              if (handle === "rot"){
                _mathDiagramState.interaction = "rotate";
                _mathDiagramState.resizeHandle = handle;
                _mathDiagramState.resizeBaseCmd = _mathDiagramCloneCommands([_mathDiagramState.commands[idx]])[0] || null;
                _mathDiagramState.rotateBaseCenter = _mathDiagramCenterOfCommand(_mathDiagramState.commands[idx]);
                _mathDiagramState.rotateStartAngle = Math.atan2(
                  p.y - _mathDiagramState.rotateBaseCenter.y,
                  p.x - _mathDiagramState.rotateBaseCenter.x
                );
              } else {
                _mathDiagramState.interaction = "resize";
                _mathDiagramState.resizeHandle = handle;
                _mathDiagramState.resizeBaseCmd = _mathDiagramCloneCommands([_mathDiagramState.commands[idx]])[0] || null;
                _mathDiagramState.resizeBaseBounds = _mathDiagramCommandBounds(_mathDiagramState.commands[idx]);
              }
              _mathDiagramState.drawing = true;
              try{ mathDiagramCanvas.setPointerCapture(ev.pointerId); }catch{}
              _mathDiagramRender();
              return;
            }
          }
          const hit = _mathDiagramFindCommandIndex(p.x, p.y);
          _mathDiagramState.selectedIndex = hit;
          _mathDiagramState.dragSelected = hit >= 0;
          _mathDiagramState.drawing = hit >= 0;
          _mathDiagramState.interaction = hit >= 0 ? "move" : "none";
          if (hit >= 0) _mathDiagramPushHistory();
          _mathDiagramUpdateSelectionUI();
          try{ mathDiagramCanvas.setPointerCapture(ev.pointerId); }catch{}
          _mathDiagramRender();
          return;
        }

        if (tool === "eraser"){
          _mathDiagramState.drawing = true;
          _mathDiagramState.interaction = "erase";
          _mathDiagramState.eraseHoverIndex = _mathDiagramFindCommandIndex(p.x, p.y);
          _mathDiagramRender();
          try{ mathDiagramCanvas.setPointerCapture(ev.pointerId); }catch{}
          return;
        }

        if (tool === "text"){
          _mathDiagramState.drawing = false;
          _mathDiagramPromptTextAt(p.x, p.y);
          return;
        }

        _mathDiagramState.selectedIndex = -1;
        _mathDiagramUpdateSelectionUI();
        _mathDiagramState.drawing = true;
        if (tool === "pen"){
          _mathDiagramState.currentPath = [{ x: p.x, y: p.y }];
        } else if (tool === "point"){
          const hit = _mathDiagramFindPointIndex(p.x, p.y);
          if (hit >= 0){
            _mathDiagramPushHistory();
            _mathDiagramState.pointDragIndex = hit;
            _mathDiagramState.selectedIndex = hit;
          } else {
            _mathDiagramPushHistory();
            _mathDiagramState.commands.push({
              type: "point",
              x: _mathDiagramState.snap ? Math.round(p.x / 14) * 14 : p.x,
              y: _mathDiagramState.snap ? Math.round(p.y / 14) * 14 : p.y,
              label: String(mathPointLabelInput?.value || "").trim().slice(0, 2).toUpperCase()
            });
            _mathDiagramState.selectedIndex = _mathDiagramState.commands.length - 1;
            _mathDiagramState.drawing = false;
            _mathDiagramState.pointDragIndex = -1;
            _mathDiagramUpdateSelectionUI();
            _mathDiagramRender();
          }
        }
        try{ mathDiagramCanvas.setPointerCapture(ev.pointerId); }catch{}
        _mathDiagramRender();
      }

      function _mathDiagramOnPointerMove(ev){
        if (!_mathDiagramState.active || !mathDiagramCanvas) return;
        const pScreen = _mathDiagramCanvasPoint(ev);
        if (_mathDiagramState.pointers.has(ev.pointerId)){
          _mathDiagramState.pointers.set(ev.pointerId, { x: pScreen.x, y: pScreen.y });
        }
        if (_mathDiagramState.pointers.size >= 2 && _mathDiagramState.pinch){
          const pts = Array.from(_mathDiagramState.pointers.values());
          const a = pts[0];
          const b = pts[1];
          const center = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
          const dist = Math.max(8, Math.hypot(b.x - a.x, b.y - a.y));
          const ratio = dist / Math.max(8, _mathDiagramState.pinch.startDistance);
          const nextScale = _mathDiagramState.pinch.startScale * ratio;
          _mathDiagramState.view.scale = Math.min(_mathDiagramState.maxScale, Math.max(_mathDiagramState.minScale, nextScale));
          _mathDiagramState.view.tx = center.x - (_mathDiagramState.pinch.worldAtCenter.x * _mathDiagramState.view.scale);
          _mathDiagramState.view.ty = center.y - (_mathDiagramState.pinch.worldAtCenter.y * _mathDiagramState.view.scale);
          _mathDiagramRender();
          return;
        }
        if (!_mathDiagramState.drawing) return;
        if (_mathDiagramState.pointerId != null && ev.pointerId !== _mathDiagramState.pointerId) return;
        const p = _mathDiagramScreenToWorld(pScreen);
        if (_mathDiagramState.interaction === "pan"){
          const dx = pScreen.x - _mathDiagramState.dragLastX;
          const dy = pScreen.y - _mathDiagramState.dragLastY;
          _mathDiagramState.view.tx += dx;
          _mathDiagramState.view.ty += dy;
          _mathDiagramState.dragLastX = pScreen.x;
          _mathDiagramState.dragLastY = pScreen.y;
          _mathDiagramRender();
          return;
        }
        if (_mathDiagramState.tool === "select" && _mathDiagramState.interaction === "resize"){
          _mathDiagramResizeSelectedFromHandle(p.x, p.y);
          _mathDiagramState.dragLastX = pScreen.x;
          _mathDiagramState.dragLastY = pScreen.y;
          _mathDiagramState.x = p.x;
          _mathDiagramState.y = p.y;
          _mathDiagramRender();
          return;
        }
        if (_mathDiagramState.tool === "select" && _mathDiagramState.interaction === "rotate"){
          const idx = Number(_mathDiagramState.selectedIndex);
          if (Number.isInteger(idx) && idx >= 0 && idx < _mathDiagramState.commands.length && _mathDiagramState.resizeBaseCmd && _mathDiagramState.rotateBaseCenter){
            const now = Math.atan2(p.y - _mathDiagramState.rotateBaseCenter.y, p.x - _mathDiagramState.rotateBaseCenter.x);
            let deg = (now - _mathDiagramState.rotateStartAngle) * 180 / Math.PI;
            if (ev.shiftKey){
              deg = Math.round(deg / 15) * 15;
            }
            _mathDiagramRotateFromBase(_mathDiagramState.commands[idx], _mathDiagramState.resizeBaseCmd, deg);
            _mathDiagramRender();
          }
          return;
        }
        if (_mathDiagramState.tool === "select" && _mathDiagramState.interaction === "move" && _mathDiagramState.dragSelected){
          const idx = Number(_mathDiagramState.selectedIndex);
          if (Number.isInteger(idx) && idx >= 0 && idx < _mathDiagramState.commands.length){
            const dx = p.x - _mathDiagramState.x;
            const dy = p.y - _mathDiagramState.y;
            if (Math.abs(dx) > 0 || Math.abs(dy) > 0){
              const tx = _mathDiagramState.snap ? (Math.round(dx / 14) * 14) : dx;
              const ty = _mathDiagramState.snap ? (Math.round(dy / 14) * 14) : dy;
              _mathDiagramTranslateCommand(_mathDiagramState.commands[idx], tx, ty);
            }
          }
          _mathDiagramState.dragLastX = pScreen.x;
          _mathDiagramState.dragLastY = pScreen.y;
          _mathDiagramState.x = p.x;
          _mathDiagramState.y = p.y;
          _mathDiagramRender();
          return;
        }
        if (_mathDiagramState.interaction === "erase"){
          _mathDiagramState.eraseHoverIndex = _mathDiagramFindCommandIndex(p.x, p.y);
          _mathDiagramRender();
          return;
        }
        _mathDiagramState.x = p.x;
        _mathDiagramState.y = p.y;
        if (_mathDiagramState.pointDragIndex >= 0){
          const cmd = _mathDiagramState.commands[_mathDiagramState.pointDragIndex];
          if (cmd && cmd.type === "point"){
            cmd.x = _mathDiagramState.snap ? Math.round(p.x / 14) * 14 : p.x;
            cmd.y = _mathDiagramState.snap ? Math.round(p.y / 14) * 14 : p.y;
          }
        } else if (_mathDiagramState.currentPath){
          _mathDiagramState.currentPath.push({ x: p.x, y: p.y });
        }
        _mathDiagramRender();
      }

      function _mathDiagramCommitCurrent(){
        const tool = _mathDiagramState.tool;
        if (tool === "select"){
          return;
        }
        const x1 = _mathDiagramState.startX;
        const y1 = _mathDiagramState.startY;
        const x2 = _mathDiagramState.x;
        const y2 = _mathDiagramState.y;

        if (_mathDiagramState.pointDragIndex >= 0){
          _mathDiagramState.pointDragIndex = -1;
          _mathDiagramUpdateSelectionUI();
          return;
        }
        if (tool === "pen"){
          const points = Array.isArray(_mathDiagramState.currentPath) ? _mathDiagramState.currentPath.slice() : [];
          _mathDiagramState.currentPath = null;
          if (points.length < 2) return;
          _mathDiagramPushHistory();
          _mathDiagramState.commands.push({ type: "path", points, erase: false });
          _mathDiagramState.selectedIndex = _mathDiagramState.commands.length - 1;
          _mathDiagramUpdateSelectionUI();
          return;
        }
        if (tool === "line"){
          if (Math.hypot(x2 - x1, y2 - y1) < 2) return;
          const sx1 = _mathDiagramState.snap ? Math.round(x1 / 14) * 14 : x1;
          const sy1 = _mathDiagramState.snap ? Math.round(y1 / 14) * 14 : y1;
          const sx2 = _mathDiagramState.snap ? Math.round(x2 / 14) * 14 : x2;
          const sy2 = _mathDiagramState.snap ? Math.round(y2 / 14) * 14 : y2;
          _mathDiagramPushHistory();
          _mathDiagramState.commands.push({ type: "line", x1: sx1, y1: sy1, x2: sx2, y2: sy2 });
          _mathDiagramState.selectedIndex = _mathDiagramState.commands.length - 1;
          _mathDiagramUpdateSelectionUI();
          return;
        }
        if (tool === "rect"){
          if (Math.abs(x2 - x1) < 2 || Math.abs(y2 - y1) < 2) return;
          const rx1 = _mathDiagramState.snap ? Math.round(x1 / 14) * 14 : x1;
          const ry1 = _mathDiagramState.snap ? Math.round(y1 / 14) * 14 : y1;
          const rx2 = _mathDiagramState.snap ? Math.round(x2 / 14) * 14 : x2;
          const ry2 = _mathDiagramState.snap ? Math.round(y2 / 14) * 14 : y2;
          _mathDiagramPushHistory();
          _mathDiagramState.commands.push({
            type: "rect",
            x: Math.min(rx1, rx2),
            y: Math.min(ry1, ry2),
            w: Math.abs(rx2 - rx1),
            h: Math.abs(ry2 - ry1)
          });
          _mathDiagramState.selectedIndex = _mathDiagramState.commands.length - 1;
          _mathDiagramUpdateSelectionUI();
          return;
        }
        if (tool === "circle"){
          const r = Math.hypot(x2 - x1, y2 - y1);
          if (r < 2) return;
          const cx = _mathDiagramState.snap ? Math.round(x1 / 14) * 14 : x1;
          const cy = _mathDiagramState.snap ? Math.round(y1 / 14) * 14 : y1;
          const cr = _mathDiagramState.snap ? Math.max(2, Math.round(r / 14) * 14) : r;
          _mathDiagramPushHistory();
          _mathDiagramState.commands.push({
            type: "circle",
            cx,
            cy,
            r: cr
          });
          _mathDiagramState.selectedIndex = _mathDiagramState.commands.length - 1;
          _mathDiagramUpdateSelectionUI();
        }
      }

      function _mathDiagramOnPointerUp(ev){
        if (!_mathDiagramState.active || !mathDiagramCanvas) return;
        _mathDiagramState.pointers.delete(ev.pointerId);
        if (_mathDiagramState.pointers.size < 2){
          _mathDiagramState.pinch = null;
        }
        if (_mathDiagramState.pointerId != null && ev.pointerId !== _mathDiagramState.pointerId){
          return;
        }
        try{ mathDiagramCanvas.releasePointerCapture(ev.pointerId); }catch{}
        _mathDiagramState.pointerId = null;
        if (_mathDiagramState.interaction === "erase"){
          const hit = Number(_mathDiagramState.eraseHoverIndex);
          if (Number.isInteger(hit) && hit >= 0 && hit < _mathDiagramState.commands.length){
            _mathDiagramPushHistory();
            _mathDiagramState.commands.splice(hit, 1);
            _mathDiagramState.selectedIndex = -1;
          }
        } else if (_mathDiagramState.drawing && _mathDiagramState.tool !== "select" && _mathDiagramState.tool !== "pan"){
          _mathDiagramCommitCurrent();
        }
        _mathDiagramState.drawing = false;
        _mathDiagramState.currentPath = null;
        _mathDiagramState.dragSelected = false;
        _mathDiagramState.pointDragIndex = -1;
        _mathDiagramState.interaction = "none";
        _mathDiagramState.resizeHandle = "";
        _mathDiagramState.resizeBaseCmd = null;
        _mathDiagramState.resizeBaseBounds = null;
        _mathDiagramState.rotateBaseCenter = null;
        _mathDiagramState.rotateStartAngle = 0;
        _mathDiagramState.eraseHoverIndex = -1;
        _mathDiagramUpdateSelectionUI();
        _mathDiagramRender();
      }
      // DRAW_EDITOR_V2V3
      function _mathDiagramOnWheel(ev){
        if (!_mathDiagramState.active || !mathDiagramCanvas) return;
        ev.preventDefault();
        _mathDiagramPushHistory();
        const p = _mathDiagramCanvasPoint(ev);
        const factor = Math.exp((-Number(ev.deltaY || 0)) * 0.0015);
        _mathDiagramZoomAt(p.x, p.y, _mathDiagramState.view.scale * factor);
      }

      function _mathDiagramBindCanvas(){
        if (_mathDiagramState.bound || !mathDiagramCanvas) return;
        _mathDiagramState.bound = true;
        mathDiagramCanvas.addEventListener("pointerdown", _mathDiagramOnPointerDown);
        mathDiagramCanvas.addEventListener("pointermove", _mathDiagramOnPointerMove);
        mathDiagramCanvas.addEventListener("pointerup", _mathDiagramOnPointerUp);
        mathDiagramCanvas.addEventListener("pointercancel", _mathDiagramOnPointerUp);
        mathDiagramCanvas.addEventListener("pointerleave", _mathDiagramOnPointerUp);
        mathDiagramCanvas.addEventListener("wheel", _mathDiagramOnWheel, { passive: false });
        window.addEventListener("resize", _mathDiagramScheduleViewportLayout);
        if (window.visualViewport){
          window.visualViewport.addEventListener("resize", _mathDiagramScheduleViewportLayout); // DRAW_EDITOR_VIEWPORT_FIX
          window.visualViewport.addEventListener("scroll", _mathDiagramScheduleViewportLayout); // DRAW_EDITOR_VIEWPORT_FIX
        }
        const wrap = mathDiagramCanvas.parentElement;
        if (wrap && window.ResizeObserver){
          const ro = new ResizeObserver(() => _mathDiagramScheduleViewportLayout());
          ro.observe(wrap);
          _mathDiagramState.resizeObserver = ro;
        }
      }

      function _mathDiagramUnbindCanvas(){
        if (!_mathDiagramState.bound || !mathDiagramCanvas) return;
        _mathDiagramState.bound = false;
        mathDiagramCanvas.removeEventListener("pointerdown", _mathDiagramOnPointerDown);
        mathDiagramCanvas.removeEventListener("pointermove", _mathDiagramOnPointerMove);
        mathDiagramCanvas.removeEventListener("pointerup", _mathDiagramOnPointerUp);
        mathDiagramCanvas.removeEventListener("pointercancel", _mathDiagramOnPointerUp);
        mathDiagramCanvas.removeEventListener("pointerleave", _mathDiagramOnPointerUp);
        mathDiagramCanvas.removeEventListener("wheel", _mathDiagramOnWheel);
        window.removeEventListener("resize", _mathDiagramScheduleViewportLayout);
        if (window.visualViewport){
          window.visualViewport.removeEventListener("resize", _mathDiagramScheduleViewportLayout);
          window.visualViewport.removeEventListener("scroll", _mathDiagramScheduleViewportLayout);
        }
        if (_mathDiagramState.resizeObserver){
          try{ _mathDiagramState.resizeObserver.disconnect(); }catch{}
          _mathDiagramState.resizeObserver = null;
        }
      }

      function _mathDiagramOpenForCard(cardId){
        if (!_presetEditingIsMath()){
          _setPresetMetaStatus("Math", "error");
          return;
        }
        if (!editingPresetId){
          _setPresetMetaStatus("", "error");
          return;
        }
        const id = Number(cardId);
        if (!Number.isFinite(id)){
          _setPresetMetaStatus("", "error");
          return;
        }
        const p = getPresetById(editingPresetId);
        const entries = _presetEditingEntries(p);
        const map = new Map(entries.map((x) => [Number(x.id), x]));
        const item = map.get(id);
        if (!item){
          _setPresetMetaStatus("", "error");
          return;
        }
        const normalizedDiagram = _normalizeCardDiagram(item?.diagram);
        const model = normalizedDiagram && normalizedDiagram.model && typeof normalizedDiagram.model === "object"
          ? normalizedDiagram.model
          : null;
        const initGrid = model ? !!model.grid : false;
        const initAxis = model ? !!model.axis : false;
        const initSnap = model ? !!model.snap : false;
        const initDebug = model ? !!model.debugBounds : false;
        const initView = model && model.view && typeof model.view === "object"
          ? model.view
          : { tx: 0, ty: 0, scale: 1 };
        _mathDiagramEnsureOverlayRoot(); // DRAW_EDITOR_VIEWPORT_FIX
        _mathDiagramState.active = true;
        _mathDiagramState.targetId = id;
        _mathDiagramState.commands = model ? _mathDiagramCloneCommands(model.commands) : [];
        _mathDiagramState.history = [];
        _mathDiagramState.redo = [];
        _mathDiagramState.dirty = false;
        if (_mathDiagramState.rafId){
          cancelAnimationFrame(_mathDiagramState.rafId);
          _mathDiagramState.rafId = 0;
        }
        _mathDiagramState.selectedIndex = -1;
        _mathDiagramState.pointDragIndex = -1;
        _mathDiagramState.currentPath = null;
        _mathDiagramState.dragSelected = false;
        _mathDiagramState.interaction = "none";
        _mathDiagramState.resizeHandle = "";
        _mathDiagramState.resizeBaseCmd = null;
        _mathDiagramState.resizeBaseBounds = null;
        _mathDiagramState.rotateBaseCenter = null;
        _mathDiagramState.rotateStartAngle = 0;
        _mathDiagramState.eraseHoverIndex = -1;
        _mathDiagramState.pointers.clear();
        _mathDiagramState.pinch = null;
        _mathDiagramState.pointerId = null;
        _mathDiagramState.grid = initGrid;
        _mathDiagramState.axis = initAxis;
        _mathDiagramState.snap = initSnap;
        _mathDiagramState.debugBounds = initDebug;
        _mathDiagramState.view.tx = Number(initView.tx || 0);
        _mathDiagramState.view.ty = Number(initView.ty || 0);
        _mathDiagramState.view.scale = Math.min(_mathDiagramState.maxScale, Math.max(_mathDiagramState.minScale, Number(initView.scale || 1)));
        if (mathDiagramGridToggle) mathDiagramGridToggle.checked = initGrid;
        if (mathDiagramAxisToggle) mathDiagramAxisToggle.checked = initAxis;
        if (mathDiagramSnapToggle) mathDiagramSnapToggle.checked = initSnap;
        if (mathDiagramBoundsDebugToggle) mathDiagramBoundsDebugToggle.checked = initDebug;
        const wrap = mathDiagramCanvas?.parentElement;
        if (wrap) wrap.classList.toggle("is-debug", initDebug);
        if (mathDiagramBackdrop) mathDiagramBackdrop.classList.remove("hidden");
        if (mathDiagramSection){
          mathDiagramSection.classList.remove("hidden");
          mathDiagramSection.setAttribute("aria-hidden", "false");
        }
        document.body.classList.add("math-diagram-open"); // DRAW_EDITOR_V1
        _mathDiagramState._lockScrollTop = window.scrollY || window.pageYOffset || 0;
        document.body.style.top = `-${_mathDiagramState._lockScrollTop}px`; // DRAW_EDITOR_VIEWPORT_FIX
        document.body.style.position = "fixed"; // DRAW_EDITOR_VIEWPORT_FIX
        document.body.style.width = "100%"; // DRAW_EDITOR_VIEWPORT_FIX
        if (mathDiagramTargetLabel){
          mathDiagramTargetLabel.textContent = `: No.${id}`;
        }
        _mathDiagramSetTool("select");
        _mathDiagramUpdateSelectionUI();
        _mathDiagramBindCanvas();
        _mathDiagramScheduleViewportLayout();
        _mathDiagramSetBaseImage(model ? "" : (normalizedDiagram?.dataUrl || ""));
        _mathDiagramState.savedSignature = _mathDiagramSignatureOf();
        _mathDiagramRender();
        _setMathEditorStatus("");
      }

      async function _mathDiagramCloseEditor(force = false, keepStatus = false){
        const shouldForce = !!force;
        const shouldKeepStatus = !!keepStatus || shouldForce;
        if (!shouldForce && _mathDiagramHasUnsavedChanges()){
          const ok = await uiConfirm("", {
            title: "",
            okText: "",
            cancelText: "",
            danger: true
          });
          if (!ok) return false;
        }
        _mathDiagramState.active = false;
        _mathDiagramState.targetId = null;
        _mathDiagramState.drawing = false;
        _mathDiagramState.currentPath = null;
        _mathDiagramState.pointDragIndex = -1;
        _mathDiagramState.selectedIndex = -1;
        _mathDiagramState.dragSelected = false;
        _mathDiagramState.interaction = "none";
        _mathDiagramState.resizeHandle = "";
        _mathDiagramState.resizeBaseCmd = null;
        _mathDiagramState.resizeBaseBounds = null;
        _mathDiagramState.rotateBaseCenter = null;
        _mathDiagramState.rotateStartAngle = 0;
        _mathDiagramState.eraseHoverIndex = -1;
        _mathDiagramState.pointers.clear();
        _mathDiagramState.pinch = null;
        _mathDiagramState.spacePan = false;
        _mathDiagramState.pointerId = null;
        _mathDiagramState.savedSignature = "";
        _mathDiagramState.redo = [];
        _mathDiagramState.dirty = false;
        if (_mathDiagramState.rafId){
          cancelAnimationFrame(_mathDiagramState.rafId);
          _mathDiagramState.rafId = 0;
        }
        if (_mathDiagramState.viewportRaf){
          cancelAnimationFrame(_mathDiagramState.viewportRaf);
          _mathDiagramState.viewportRaf = 0;
        }
        _mathDiagramUnbindCanvas();
        if (mathDiagramBackdrop) mathDiagramBackdrop.classList.add("hidden");
        if (mathDiagramSection){
          mathDiagramSection.classList.add("hidden");
          mathDiagramSection.setAttribute("aria-hidden", "true");
        }
        document.body.classList.remove("math-diagram-open"); // DRAW_EDITOR_V1
        document.body.style.position = "";
        document.body.style.top = "";
        document.body.style.width = "";
        try{ window.scrollTo(0, Number(_mathDiagramState._lockScrollTop || 0)); }catch{}
        if (mathDiagramTargetLabel) mathDiagramTargetLabel.textContent = ": ";
        _mathDiagramUpdateSelectionUI();
        if (!shouldKeepStatus) _setMathEditorStatus("");
        return true;
      }

      function _mathDiagramUndo(){
        const last = _mathDiagramState.history.pop();
        if (!last) return;
        _mathDiagramState.redo.push(_mathDiagramSnapshot());
        while (_mathDiagramState.redo.length > 50){
          _mathDiagramState.redo.shift();
        }
        _mathDiagramApplySnapshot(last);
        _mathDiagramRender();
      }
      // DRAW_EDITOR_V2V3
      function _mathDiagramRedo(){
        const next = _mathDiagramState.redo.pop();
        if (!next) return;
        _mathDiagramState.history.push(_mathDiagramSnapshot());
        while (_mathDiagramState.history.length > 50){
          _mathDiagramState.history.shift();
        }
        _mathDiagramApplySnapshot(next);
        _mathDiagramRender();
      }

      async function _mathDiagramClear(){
        const ok = await uiConfirm("", {
          title: "",
          okText: "",
          cancelText: "",
          danger: true
        });
        if (!ok) return;
        _mathDiagramPushHistory();
        _mathDiagramState.commands = [];
        _mathDiagramState.selectedIndex = -1;
        _mathDiagramSetBaseImage("");
        _mathDiagramUpdateSelectionUI();
        _mathDiagramRender();
      }

      function _mathDiagramAddTable(rows, cols){
        if (!_mathDiagramState.active || !mathDiagramCanvas) return;
        const vw = Math.max(220, Number(_mathDiagramState.canvasCssWidth || 900));
        const vh = Math.max(180, Number(_mathDiagramState.canvasCssHeight || 280));
        const centerWorld = _mathDiagramScreenToWorld({ x: vw / 2, y: vh / 2 });
        const w = Math.min(280, vw * 0.42) / Math.max(0.25, _mathDiagramState.view.scale);
        const h = Math.min(180, vh * 0.42) / Math.max(0.25, _mathDiagramState.view.scale);
        const x = centerWorld.x - (w / 2);
        const y = centerWorld.y - (h / 2);
        _mathDiagramPushHistory();
        const r = Math.max(1, Number(rows) || 2);
        const c = Math.max(1, Number(cols) || 2);
        const cellTexts = Array.from({ length: r }, () => Array.from({ length: c }, () => ""));
        _mathDiagramState.commands.push({
          type: "table",
          x,
          y,
          w,
          h,
          rows: r,
          cols: c,
          cellTexts
        });
        _mathDiagramState.selectedIndex = _mathDiagramState.commands.length - 1;
        _mathDiagramUpdateSelectionUI();
        _mathDiagramRender();
      }
      // DRAW_EDITOR_V2V3
      function _mathDiagramBringForward(){
        const idx = Number(_mathDiagramState.selectedIndex);
        if (!Number.isInteger(idx) || idx < 0 || idx >= (_mathDiagramState.commands.length - 1)) return;
        _mathDiagramPushHistory();
        const arr = _mathDiagramState.commands;
        [arr[idx], arr[idx + 1]] = [arr[idx + 1], arr[idx]];
        _mathDiagramState.selectedIndex = idx + 1;
        _mathDiagramUpdateSelectionUI();
        _mathDiagramRender();
        _setMathEditorStatus("", "ok");
      }
      // DRAW_EDITOR_V2V3
      function _mathDiagramSendBackward(){
        const idx = Number(_mathDiagramState.selectedIndex);
        if (!Number.isInteger(idx) || idx <= 0 || idx >= _mathDiagramState.commands.length) return;
        _mathDiagramPushHistory();
        const arr = _mathDiagramState.commands;
        [arr[idx], arr[idx - 1]] = [arr[idx - 1], arr[idx]];
        _mathDiagramState.selectedIndex = idx - 1;
        _mathDiagramUpdateSelectionUI();
        _mathDiagramRender();
        _setMathEditorStatus("", "ok");
      }
      // DRAW_EDITOR_V2V3
      async function _mathDiagramEditSelectedText(){
        const idx = Number(_mathDiagramState.selectedIndex);
        if (!Number.isInteger(idx) || idx < 0 || idx >= _mathDiagramState.commands.length) return;
        const cmd = _mathDiagramState.commands[idx];
        if (!cmd || cmd.type !== "text") return;
        const html = `
          <div style="display:grid; gap:10px;">
            <textarea id="mathDiagramEditTextInput" class="spell-input" rows="4">${escapeHtml(String(cmd.text || ""))}</textarea>
            <label style="display:grid; gap:4px;">
              <span class="note"></span>
              <input id="mathDiagramEditTextSize" type="range" min="10" max="64" step="1" value="${Math.max(10, Math.round(Number(cmd.fontSize || 20)))}" />
            </label>
          </div>
        `;
        const ok = await uiConfirmHtml(html, { title: "", okText: "", cancelText: "" });
        if (!ok) return;
        const nextText = String(document.getElementById("mathDiagramEditTextInput")?.value || "").trim();
        const nextSize = Math.max(10, Math.min(64, Number(document.getElementById("mathDiagramEditTextSize")?.value || cmd.fontSize || 20)));
        if (!nextText){
          _setMathEditorStatus("", "error");
          return;
        }
        _mathDiagramPushHistory();
        cmd.text = nextText.slice(0, 240);
        cmd.fontSize = nextSize;
        cmd.h = Math.max(12, nextSize * 1.3);
        cmd.w = Math.max(10, String(cmd.text).length * nextSize * 0.62);
        _mathDiagramUpdateSelectionUI();
        _mathDiagramRender();
      }
      // DRAW_EDITOR_V2V3
      async function _mathDiagramEditSelectedTableCell(){
        const idx = Number(_mathDiagramState.selectedIndex);
        if (!Number.isInteger(idx) || idx < 0 || idx >= _mathDiagramState.commands.length) return;
        const cmd = _mathDiagramState.commands[idx];
        if (!cmd || cmd.type !== "table") return;
        const rows = Math.max(1, Number(cmd.rows || 2));
        const cols = Math.max(1, Number(cmd.cols || 2));
        const rowOpts = Array.from({ length: rows }, (_, i) => `<option value="${i}">${i + 1}</option>`).join("");
        const colOpts = Array.from({ length: cols }, (_, i) => `<option value="${i}">${i + 1}</option>`).join("");
        const html = `
          <div style="display:grid; gap:10px;">
            <div style="display:flex; gap:8px; flex-wrap:wrap;">
              <label style="display:grid; gap:4px;"><span class="note"></span><select id="mathCellRow" class="select">${rowOpts}</select></label>
              <label style="display:grid; gap:4px;"><span class="note"></span><select id="mathCellCol" class="select">${colOpts}</select></label>
            </div>
            <textarea id="mathCellText" class="spell-input" rows="3" placeholder=""></textarea>
          </div>
        `;
        const ok = await uiConfirmHtml(html, { title: "", okText: "", cancelText: "" });
        if (!ok) return;
        const r = Math.max(0, Math.min(rows - 1, Number(document.getElementById("mathCellRow")?.value || 0)));
        const c = Math.max(0, Math.min(cols - 1, Number(document.getElementById("mathCellCol")?.value || 0)));
        const t = String(document.getElementById("mathCellText")?.value || "").slice(0, 64);
        _mathDiagramPushHistory();
        if (!Array.isArray(cmd.cellTexts)) cmd.cellTexts = [];
        if (!Array.isArray(cmd.cellTexts[r])) cmd.cellTexts[r] = [];
        cmd.cellTexts[r][c] = t;
        _mathDiagramRender();
      }
      // DRAW_EDITOR_V2V3
      function _mathDiagramLoadImageFromFile(file){
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          const src = String(reader.result || "");
          if (!src) return;
          const img = new Image();
          img.onload = () => {
            const maxSide = 1280;
            const iw = Math.max(1, Number(img.naturalWidth || 1));
            const ih = Math.max(1, Number(img.naturalHeight || 1));
            const scale = Math.min(1, maxSide / Math.max(iw, ih));
            const tw = Math.max(1, Math.round(iw * scale));
            const th = Math.max(1, Math.round(ih * scale));
            const c = document.createElement("canvas");
            c.width = tw;
            c.height = th;
            const cctx = c.getContext("2d");
            if (!cctx){
              _setMathEditorStatus("", "error");
              return;
            }
            cctx.drawImage(img, 0, 0, tw, th);
            const dataUrl = c.toDataURL("image/png");
            const vw = Math.max(220, Number(_mathDiagramState.canvasCssWidth || 900));
            const vh = Math.max(180, Number(_mathDiagramState.canvasCssHeight || 280));
            const center = _mathDiagramScreenToWorld({ x: vw / 2, y: vh / 2 });
            const displayW = Math.min(320, tw / Math.max(0.25, _mathDiagramState.view.scale));
            const displayH = Math.max(30, (displayW * th) / Math.max(1, tw));
            _mathDiagramPushHistory();
            _mathDiagramState.commands.push({
              type: "image",
              x: center.x - (displayW / 2),
              y: center.y - (displayH / 2),
              w: displayW,
              h: displayH,
              src: dataUrl,
              angle: 0
            });
            _mathDiagramState.selectedIndex = _mathDiagramState.commands.length - 1;
            _mathDiagramUpdateSelectionUI();
            _mathDiagramRender();
          };
          img.onerror = () => _setMathEditorStatus("", "error");
          img.src = src;
        };
        reader.onerror = () => _setMathEditorStatus("", "error");
        reader.readAsDataURL(file);
      }

      function _mathDiagramExportDataUrl(){
        if (!mathDiagramCanvas) return "";
        const src = mathDiagramCanvas;
        const maxWidth = 960;
        const scale = src.width > maxWidth ? (maxWidth / src.width) : 1;
        let outCanvas = src;
        if (scale < 1){
          const c = document.createElement("canvas");
          c.width = Math.max(1, Math.round(src.width * scale));
          c.height = Math.max(1, Math.round(src.height * scale));
          const cctx = c.getContext("2d");
          if (cctx){
            cctx.fillStyle = "#ffffff";
            cctx.fillRect(0, 0, c.width, c.height);
            cctx.drawImage(src, 0, 0, c.width, c.height);
            outCanvas = c;
          }
        }
        return outCanvas.toDataURL("image/png");
      }

      function _mathDiagramSaveToCard(){
        if (!_mathDiagramState.active){
          _setMathEditorStatus("", "error");
          return;
        }
        if (!editingPresetId || !Number.isFinite(_mathDiagramState.targetId)){
          _setMathEditorStatus("", "error");
          return;
        }
        const png = _mathDiagramExportDataUrl();
        if (!png){
          _setMathEditorStatus("", "error");
          return;
        }
        const sizeEstimate = Math.ceil((Math.max(0, png.length - "data:image/png;base64,".length) * 3) / 4);
        const maxBytes = 1_900_000;
        if (sizeEstimate > maxBytes){
          _setMathEditorStatus("", "error");
          return;
        }
        const list = loadPresets();
        const p = list.find((x) => x.id === editingPresetId);
        if (!p){
          _setMathEditorStatus("", "error");
          return;
        }
        const entries = _presetEditingEntries(p);
        const map = new Map(entries.map((x) => [Number(x.id), { ...x }]));
        const row = map.get(Number(_mathDiagramState.targetId));
        if (!row){
          _setMathEditorStatus("", "error");
          return;
        }
        const model = {
          schemaVersion: 2,
          commands: _mathDiagramCloneCommands(_mathDiagramState.commands),
          grid: !!_mathDiagramState.grid,
          axis: !!_mathDiagramState.axis,
          snap: !!_mathDiagramState.snap,
          debugBounds: !!_mathDiagramState.debugBounds,
          view: {
            tx: Number(_mathDiagramState.view?.tx || 0),
            ty: Number(_mathDiagramState.view?.ty || 0),
            scale: Number(_mathDiagramState.view?.scale || 1)
          }
        };
        row.diagram = { type: "png", dataUrl: png, model };
        map.set(Number(row.id), row);
        _presetEditingSetEntries(p, Array.from(map.values()).sort((a, b) => Number(a.id) - Number(b.id)));
        savePresets(list);
        renderWordsPreview(_presetEditingEntries(p));
        refreshPresetList();
        _mathDiagramState.savedSignature = _mathDiagramSignatureOf();
        _setMathEditorStatus("", "ok");
        _setPresetMetaStatus("", "ok");
      }

      mathSymbolPalette?.addEventListener("click", (ev) => {
        const btn = ev.target && ev.target.closest ? ev.target.closest("button[data-math-insert], button[data-math-template]") : null;
        if (!btn) return;
        const token = String(btn.getAttribute("data-math-insert") || "");
        const template = String(btn.getAttribute("data-math-template") || "");
        _insertMathPaletteToken(token, template);
      });

      mathDiagramSection?.addEventListener("click", (ev) => {
        const btn = ev.target && ev.target.closest ? ev.target.closest("[data-math-tool]") : null;
        if (!btn) return;
        _mathDiagramSetTool(btn.getAttribute("data-math-tool") || "pen");
      });
      mathDiagramUndoBtn?.addEventListener("click", _mathDiagramUndo);
      mathDiagramRedoBtn?.addEventListener("click", _mathDiagramRedo);
      mathDiagramClearBtn?.addEventListener("click", _mathDiagramClear);
      mathDiagramTable2Btn?.addEventListener("click", () => _mathDiagramAddTable(2, 2));
      mathDiagramTable3Btn?.addEventListener("click", () => _mathDiagramAddTable(3, 3));
      mathDiagramTable4Btn?.addEventListener("click", () => _mathDiagramAddTable(4, 4));
      mathDiagramTableCellEditBtn?.addEventListener("click", _mathDiagramEditSelectedTableCell);
      mathDiagramAddImageBtn?.addEventListener("click", () => mathDiagramImageInput?.click());
      mathDiagramImageInput?.addEventListener("change", () => {
        const f = mathDiagramImageInput.files && mathDiagramImageInput.files[0] ? mathDiagramImageInput.files[0] : null;
        if (!f) return;
        _mathDiagramLoadImageFromFile(f);
        mathDiagramImageInput.value = "";
      });
      mathDiagramBringFrontBtn?.addEventListener("click", _mathDiagramBringForward);
      mathDiagramSendBackBtn?.addEventListener("click", _mathDiagramSendBackward);
      mathDiagramZoomResetBtn?.addEventListener("click", _mathDiagramResetView);
      mathDiagramEditTextBtn?.addEventListener("click", _mathDiagramEditSelectedText);
      mathDiagramMoveLeftBtn?.addEventListener("click", () => _mathDiagramMoveSelected(-8, 0));
      mathDiagramMoveRightBtn?.addEventListener("click", () => _mathDiagramMoveSelected(8, 0));
      mathDiagramMoveUpBtn?.addEventListener("click", () => _mathDiagramMoveSelected(0, -8));
      mathDiagramMoveDownBtn?.addEventListener("click", () => _mathDiagramMoveSelected(0, 8));
      mathDiagramRotateLeftBtn?.addEventListener("click", () => _mathDiagramRotateSelected(-15));
      mathDiagramRotateRightBtn?.addEventListener("click", () => _mathDiagramRotateSelected(15));
      mathDiagramDeleteBtn?.addEventListener("click", _mathDiagramDeleteSelected);
      mathDiagramGridToggle?.addEventListener("change", () => {
        _mathDiagramState.grid = !!mathDiagramGridToggle.checked;
        _mathDiagramRender();
      });
      mathDiagramAxisToggle?.addEventListener("change", () => {
        _mathDiagramState.axis = !!mathDiagramAxisToggle.checked;
        _mathDiagramRender();
      });
      mathDiagramSnapToggle?.addEventListener("change", () => {
        _mathDiagramState.snap = !!mathDiagramSnapToggle.checked;
      });
      mathDiagramBoundsDebugToggle?.addEventListener("change", () => {
        _mathDiagramState.debugBounds = !!mathDiagramBoundsDebugToggle.checked;
        const wrap = mathDiagramCanvas?.parentElement;
        if (wrap) wrap.classList.toggle("is-debug", _mathDiagramState.debugBounds);
      });
      mathDiagramFontSizeRange?.addEventListener("input", () => {
        const idx = Number(_mathDiagramState.selectedIndex);
        if (!Number.isInteger(idx) || idx < 0 || idx >= _mathDiagramState.commands.length) return;
        const cmd = _mathDiagramState.commands[idx];
        if (!cmd || cmd.type !== "text") return;
        cmd.fontSize = Math.max(10, Math.min(64, Number(mathDiagramFontSizeRange.value || 20)));
        cmd.h = Math.max(12, cmd.fontSize * 1.3);
        _mathDiagramRender();
      });
      mathDiagramSaveBtn?.addEventListener("click", _mathDiagramSaveToCard);
      mathDiagramCloseBtn?.addEventListener("click", () => _mathDiagramCloseEditor());
      mathDiagramBackdrop?.addEventListener("click", () => _mathDiagramCloseEditor());
      mathDiagramOpenCurrentBtn?.addEventListener("click", () => {
        const id = Number(wordIdInput?.value || "");
        if (!Number.isFinite(id)){
          _setPresetMetaStatus("ID", "error");
          return;
        }
        _mathDiagramOpenForCard(id);
      });
      // DRAW_EDITOR_V1
      document.addEventListener("keydown", (ev) => {
        if (!_mathDiagramState.active) return;
        const ae = document.activeElement;
        const tag = ae ? String(ae.tagName || "").toUpperCase() : "";
        if (tag === "INPUT" || tag === "TEXTAREA" || (ae && ae.isContentEditable)) return;
        if (ev.key === " "){
          _mathDiagramState.spacePan = true;
          ev.preventDefault();
          return;
        }
        if (ev.key === "Delete" || ev.key === "Backspace"){
          ev.preventDefault();
          _mathDiagramDeleteSelected();
          return;
        }
        if ((ev.metaKey || ev.ctrlKey) && !ev.altKey && !ev.shiftKey && String(ev.key).toLowerCase() === "z"){
          ev.preventDefault();
          _mathDiagramUndo();
          return;
        }
        if ((ev.metaKey || ev.ctrlKey) && ((ev.shiftKey && String(ev.key).toLowerCase() === "z") || String(ev.key).toLowerCase() === "y")){
          ev.preventDefault();
          _mathDiagramRedo();
        }
      });
      // DRAW_EDITOR_V2V3
      document.addEventListener("keyup", (ev) => {
        if (!_mathDiagramState.active) return;
        if (ev.key === " "){
          _mathDiagramState.spacePan = false;
        }
      });
      _mathDiagramUpdateSelectionUI();

      wordWordInput?.addEventListener("focus", () => _rememberMathFocusedInput(wordWordInput));
      wordMeaningInput?.addEventListener("focus", () => _rememberMathFocusedInput(wordMeaningInput));
      wordWordInput?.addEventListener("click", () => _rememberMathFocusedInput(wordWordInput));
      wordMeaningInput?.addEventListener("click", () => _rememberMathFocusedInput(wordMeaningInput));

      wordWordInput?.addEventListener("input", _scheduleMathPreview);
      wordMeaningInput?.addEventListener("input", _scheduleMathPreview);
      wordFrontFormatSelect?.addEventListener("change", _scheduleMathPreview);
      wordBackFormatSelect?.addEventListener("change", _scheduleMathPreview);

      const bulkTextarea = document.getElementById("bulkTextarea");
      const bulkAddBtn = document.getElementById("bulkAddBtn");
      const bulkClearBtn = document.getElementById("bulkClearBtn");
      const presetClearWordsBtn = document.getElementById("presetClearWordsBtn");
      const presetWordsPreview = document.getElementById("presetWordsPreview");
      // DRAW_EDITOR_V1
      presetWordsPreview?.addEventListener("click", (ev) => {
        const btn = ev.target && ev.target.closest ? ev.target.closest("button[data-editdiagram]") : null;
        if (!btn) return;
        if (!editingPresetId){
          _setPresetMetaStatus("", "error");
          return;
        }
        const id = Number(btn.getAttribute("data-editdiagram"));
        if (!Number.isFinite(id)){
          _setPresetMetaStatus("ID", "error");
          return;
        }
        _mathDiagramOpenForCard(id);
      });

      let editingPresetId = null;
      let editingPresetTagIds = [];
      const scanState = {
        type: "single",
        mainFile: null,
        refFile: null,
        mainSourceFile: null,
        refSourceFile: null,
        mainMeta: null,
        refMeta: null,
        mainUrl: "",
        refUrl: "",
        running: false,
        abortCtl: null,
        progressIndex: -1,
        progressTimer: null,
        statusKind: "",
        statusText: "",
        imageMetaText: "",
        autoRetryCount: 0,
        debug: null,
        result: null
      };
      const SCAN_UPLOAD_MAX_BYTES = 700 * 1024;
      const SCAN_COMPRESS_DIMS = Object.freeze([1280, 1024, 896]);
      const SCAN_COMPRESS_QUALITIES = Object.freeze([0.72, 0.62, 0.52, 0.42, 0.35]);
      const SCAN_FETCH_TIMEOUT_MS = 30000;
      const SCAN_AUTO_RETRY_LIMIT = 2;

      function _scanRevokeUrl(kind){
        if (kind === "main"){
          if (scanState.mainUrl){ try{ URL.revokeObjectURL(scanState.mainUrl); }catch{} }
          scanState.mainUrl = "";
          return;
        }
        if (kind === "ref"){
          if (scanState.refUrl){ try{ URL.revokeObjectURL(scanState.refUrl); }catch{} }
          scanState.refUrl = "";
        }
      }

      function _scanSetStatus(msg, kind = ""){
        scanState.statusText = String(msg || "");
        scanState.statusKind = String(kind || "");
        if (!scanStatus) return;
        scanStatus.textContent = scanState.statusText;
        scanStatus.classList.remove("ok", "error");
        if (scanState.statusKind === "ok") scanStatus.classList.add("ok");
        if (scanState.statusKind === "error") scanStatus.classList.add("error");
      }

      function _scanSetImageMeta(text){
        scanState.imageMetaText = String(text || "");
        if (scanImageMeta) scanImageMeta.textContent = scanState.imageMetaText;
      }

      function _scanSetDebug(data){
        scanState.debug = data && typeof data === "object" ? data : null;
        if (!scanDebugDetails || !scanDebugPre) return;
        if (!scanState.debug){
          scanDebugDetails.classList.add("hidden");
          scanDebugPre.textContent = "";
          scanDebugDetails.open = false;
          return;
        }
        scanDebugPre.textContent = JSON.stringify(scanState.debug, null, 2);
        scanDebugDetails.classList.remove("hidden");
      }

      function _scanIsSupportedMime(mimeRaw){
        const mime = String(mimeRaw || "").toLowerCase();
        if (!mime) return false;
        return mime === "image/jpeg" || mime === "image/jpg" || mime === "image/png" || mime === "image/webp";
      }

      function _scanLooksLikeHeic(file){
        const mime = String(file?.type || "").toLowerCase();
        const name = String(file?.name || "").toLowerCase();
        return mime.includes("heic") || mime.includes("heif") || /\.(heic|heif)$/i.test(name);
      }

      function _scanSetProgress(idx){
        scanState.progressIndex = Number(idx);
        if (!scanStepList) return;
        const rows = scanStepList.querySelectorAll(".scan-step");
        rows.forEach((row) => {
          const i = Number(row.getAttribute("data-step-index") || -1);
          row.classList.remove("is-active", "is-done");
          if (i < scanState.progressIndex) row.classList.add("is-done");
          else if (i === scanState.progressIndex) row.classList.add("is-active");
        });
      }

      function _scanStartProgressTicker(){
        _scanStopProgressTicker();
        _scanSetProgress(0);
        scanState.progressTimer = setInterval(() => {
          if (!scanState.running) return;
          if (scanState.progressIndex >= 5) return;
          _scanSetProgress(scanState.progressIndex + 1);
        }, 1100);
      }

      function _scanStopProgressTicker(){
        if (scanState.progressTimer){
          clearInterval(scanState.progressTimer);
          scanState.progressTimer = null;
        }
      }

      function _scanExtByMime(mime){
        const m = String(mime || "").toLowerCase();
        if (m.includes("png")) return "png";
        if (m.includes("webp")) return "webp";
        return "jpg";
      }

      function _scanBlobToFile(blob, baseName = "scan"){
        const ext = _scanExtByMime(blob?.type || "image/jpeg");
        const safeBase = String(baseName || "scan").replace(/\.[A-Za-z0-9]+$/, "");
        return new File([blob], `${safeBase}.${ext}`, { type: blob?.type || "image/jpeg", lastModified: Date.now() });
      }

      function _scanToBlob(canvas, mime, quality){
        return new Promise((resolve) => {
          try {
            canvas.toBlob((b) => resolve(b || null), mime, quality);
          } catch {
            resolve(null);
          }
        });
      }

      async function _scanDecodeImage(file){
        if (typeof createImageBitmap === "function"){
          try {
            const bmp = await createImageBitmap(file);
            return { width: bmp.width, height: bmp.height, draw: (ctx, w, h) => ctx.drawImage(bmp, 0, 0, w, h), close: () => { try { bmp.close(); } catch {} } };
          } catch {}
        }
        const url = URL.createObjectURL(file);
        try {
          const img = await new Promise((resolve, reject) => {
            const el = new Image();
            el.onload = () => resolve(el);
            el.onerror = reject;
            el.src = url;
          });
          return { width: img.naturalWidth || img.width, height: img.naturalHeight || img.height, draw: (ctx, w, h) => ctx.drawImage(img, 0, 0, w, h), close: () => {} };
        } finally {
          try { URL.revokeObjectURL(url); } catch {}
        }
      }

      async function _scanNormalizeImageFile(file, profile = null){
        if (!file || !/^image\//i.test(String(file.type || ""))) {
          return {
            file,
            mime: String(file?.type || ""),
            sourceWidth: 0,
            sourceHeight: 0,
            outputWidth: 0,
            outputHeight: 0,
            inputBytes: Number(file?.size || 0),
            outputBytes: Number(file?.size || 0),
            converted: false
          };
        }
        if (_scanLooksLikeHeic(file)) {
          return {
            file: null,
            mime: String(file?.type || ""),
            sourceWidth: 0,
            sourceHeight: 0,
            outputWidth: 0,
            outputHeight: 0,
            inputBytes: Number(file?.size || 0),
            outputBytes: 0,
            converted: false,
            error: "UNSUPPORTED_IMAGE_HEIC",
            errorMessage: "HEIC/HEIF JPEG/PNG/WebP"
          };
        }
        const dimCandidates = Array.isArray(profile?.dims) && profile.dims.length
          ? Array.from(new Set(profile.dims.map((v) => Math.trunc(Number(v || 0))).filter((v) => v >= 320))).sort((a, b) => b - a)
          : [...SCAN_COMPRESS_DIMS];
        const qualityCandidates = Array.isArray(profile?.qualities) && profile.qualities.length
          ? Array.from(new Set(profile.qualities.map((v) => Number(v || 0)).filter((v) => v > 0 && v <= 1))).sort((a, b) => b - a)
          : [...SCAN_COMPRESS_QUALITIES];
        if (!dimCandidates.length) dimCandidates.push(1280);
        if (!qualityCandidates.length) qualityCandidates.push(0.72, 0.52, 0.35);
        const targetMaxBytes = Math.max(120 * 1024, Number(profile?.targetMaxBytes || SCAN_UPLOAD_MAX_BYTES));
        let decoder = null;
        try {
          decoder = await _scanDecodeImage(file);
          const srcW = Math.max(1, Number(decoder.width || 1));
          const srcH = Math.max(1, Number(decoder.height || 1));
          const build = async (maxDim) => {
            const scale = Math.min(1, maxDim / Math.max(srcW, srcH));
            const w = Math.max(1, Math.round(srcW * scale));
            const h = Math.max(1, Math.round(srcH * scale));
            const canvas = document.createElement("canvas");
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext("2d", { alpha: false });
            if (!ctx) return null;
            decoder.draw(ctx, w, h);
            let best = null;
            for (const quality of qualityCandidates) {
              const q = Math.max(0.35, Math.min(0.95, Number(quality || 0.72)));
              const blob = await _scanToBlob(canvas, "image/jpeg", q);
              if (!blob) continue;
              if (!best || Number(blob.size || 0) < Number(best.blob?.size || Infinity)) {
                best = { blob, w, h, quality: q, maxDim };
              }
              if (blob.size <= targetMaxBytes) {
                return { blob, w, h, quality: q, maxDim, overLimit: false };
              }
            }
            if (best) {
              return { ...best, overLimit: Number(best.blob?.size || 0) > targetMaxBytes };
            }
            return null;
          };
          let out = null;
          let best = null;
          for (const maxDim of dimCandidates) {
            const current = await build(maxDim);
            if (!current?.blob) continue;
            if (!best || Number(current.blob.size || 0) < Number(best.blob?.size || Infinity)) {
              best = current;
            }
            if (!current.overLimit) {
              out = current;
              break;
            }
          }
          if (!out && best) {
            out = best;
          }
          if (!out?.blob) {
            return {
              file,
              mime: String(file.type || ""),
              sourceWidth: srcW,
              sourceHeight: srcH,
              outputWidth: srcW,
              outputHeight: srcH,
              inputBytes: Number(file.size || 0),
              outputBytes: Number(file.size || 0),
              converted: false
            };
          }
          const convertedFile = _scanBlobToFile(out.blob, file.name || "scan");
          return {
            file: convertedFile,
            mime: String(convertedFile?.type || file?.type || "image/jpeg"),
            sourceWidth: srcW,
            sourceHeight: srcH,
            outputWidth: out.w || srcW,
            outputHeight: out.h || srcH,
            inputBytes: Number(file.size || 0),
            outputBytes: Number(convertedFile.size || 0),
            converted: true,
            outputQuality: Number(out.quality || 0),
            targetMaxBytes,
            maxDimUsed: Number(out.maxDim || 0),
            overLimit: Number(convertedFile.size || 0) > targetMaxBytes
          };
        } catch {
          return {
            file,
            mime: String(file.type || ""),
            sourceWidth: 0,
            sourceHeight: 0,
            outputWidth: 0,
            outputHeight: 0,
            inputBytes: Number(file.size || 0),
            outputBytes: Number(file.size || 0),
            converted: false
          };
        } finally {
          try { decoder?.close?.(); } catch {}
        }
      }

      function _scanFileToDataUrl(file){
        return new Promise((resolve, reject) => {
          if (!file) {
            reject(new Error("IMAGE_REQUIRED"));
            return;
          }
          const reader = new FileReader();
          reader.onerror = () => reject(new Error("READ_AS_DATAURL_FAILED"));
          reader.onload = () => resolve(String(reader.result || ""));
          try {
            reader.readAsDataURL(file);
          } catch (err) {
            reject(err);
          }
        });
      }

      function _scanRenderThumb(targetEl, file, kind){
        if (!targetEl) return;
        targetEl.replaceChildren();
        if (!file) return;
        const wrap = document.createElement("div");
        wrap.className = "scan-thumb";
        const img = document.createElement("img");
        const url = URL.createObjectURL(file);
        if (kind === "main"){
          _scanRevokeUrl("main");
          scanState.mainUrl = url;
        } else {
          _scanRevokeUrl("ref");
          scanState.refUrl = url;
        }
        img.src = url;
        img.alt = kind === "main" ? "" : "";
        const rm = document.createElement("button");
        rm.type = "button";
        rm.textContent = "";
        rm.setAttribute("data-scan-action", kind === "main" ? "removeMainImage" : "removeRefImage");
        wrap.appendChild(img);
        wrap.appendChild(rm);
        targetEl.appendChild(wrap);
      }

      function _scanUpdateTypeUI(){
        const showRef = scanState.type === "double";
        if (scanRefBlock) scanRefBlock.classList.toggle("hidden", !showRef);
      }

      function _scanCollectFormats(){
        if (!scanGenOverlay) return [];
        const out = [];
        scanGenOverlay.querySelectorAll("input[data-scan-format]").forEach((elx) => {
          if (!elx.checked) return;
          const v = String(elx.getAttribute("data-scan-format") || "").trim();
          if (!v) return;
          out.push(v);
        });
        return Array.from(new Set(out));
      }

      function _scanCollectSettings(){
        return {
          count: Math.trunc(clamp(Number(scanCountInput?.value || 24), 12, 60)),
          markerCount: Math.trunc(clamp(Number(scanMarkerInput?.value || 4), 1, 60)),
          extractChars: Math.trunc(clamp(Number(scanExtractCharsSelect?.value || 15), 5, 80)),
          difficulty: String(scanDifficultySelect?.value || "normal")
        };
      }

      function _scanResetResultView(){
        scanState.result = null;
        if (scanResultCard) scanResultCard.classList.add("hidden");
        if (scanResultMeta) scanResultMeta.textContent = "";
        if (scanReconstructedView) scanReconstructedView.textContent = "";
        if (scanQuestionList) scanQuestionList.textContent = "";
        _scanSetDebug(null);
      }

      function _scanSetRunning(on){
        scanState.running = !!on;
        if (scanRetryBtn) scanRetryBtn.classList.toggle("hidden", scanState.running || !scanState.statusText || scanState.statusKind !== "error");
      }

      function _scanSanitizeGeneratedHtml(raw){
        const src = String(raw || "");
        if (!src) return "";
        const template = document.createElement("template");
        template.innerHTML = src;
        const allowTags = new Set(["H1", "H3", "P", "DIV", "SPAN", "STRONG", "BR"]);
        const allowClasses = new Set(["author", "m", "u", "box", "badge", "blank"]);
        const walk = (node) => {
          if (!node) return;
          const children = Array.from(node.childNodes || []);
          for (const child of children){
            if (child.nodeType === Node.ELEMENT_NODE){
              const tag = child.tagName;
              if (!allowTags.has(tag)){
                const txt = document.createTextNode(child.textContent || "");
                child.replaceWith(txt);
                continue;
              }
              const attrs = Array.from(child.attributes || []);
              for (const at of attrs){
                const nm = String(at.name || "").toLowerCase();
                if (nm === "class"){
                  const cls = String(at.value || "")
                    .split(/\s+/)
                    .filter((c) => allowClasses.has(c))
                    .join(" ");
                  if (cls) child.setAttribute("class", cls);
                  else child.removeAttribute("class");
                  continue;
                }
                if (nm === "data-qid" || nm === "data-p") continue;
                child.removeAttribute(at.name);
              }
              walk(child);
            } else if (child.nodeType === Node.COMMENT_NODE){
              child.remove();
            }
          }
        };
        walk(template.content);
        return template.innerHTML;
      }

      function _scanRenderQuestionsPreview(questions){
        if (!scanQuestionList) return;
        scanQuestionList.replaceChildren();
        const list = Array.isArray(questions) ? questions : [];
        if (!list.length){
          const empty = document.createElement("div");
          empty.className = "scan-question-item";
          empty.textContent = "";
          scanQuestionList.appendChild(empty);
          return;
        }
        const top = list.slice(0, 10);
        for (const q of top){
          const row = document.createElement("article");
          row.className = "scan-question-item";
          const type = document.createElement("div");
          type.className = "scan-question-type";
          type.textContent = `No.${Number(q.no || 0)} / ${String(q.type || "")} / ${String(q.qid || "")}`;
          const qq = document.createElement("div");
          qq.className = "scan-question-q";
          qq.textContent = String(q.q || "");
          const aa = document.createElement("div");
          aa.className = "scan-question-a";
          const ans = Array.isArray(q.a) ? q.a.join(" / ") : String(q.a || "");
          aa.textContent = `: ${ans}`;
          row.appendChild(type);
          row.appendChild(qq);
          aa && row.appendChild(aa);
          if (Array.isArray(q.choices) && q.choices.length){
            const cc = document.createElement("div");
            cc.className = "scan-question-a";
            cc.textContent = `: ${q.choices.join(" | ")}`;
            row.appendChild(cc);
          }
          scanQuestionList.appendChild(row);
        }
        if (list.length > 10){
          const rest = document.createElement("details");
          rest.className = "scan-question-rest";
          const sum = document.createElement("summary");
          sum.textContent = ` ${list.length - 10} `;
          rest.appendChild(sum);
          const pre = document.createElement("pre");
          pre.style.whiteSpace = "pre-wrap";
          pre.style.margin = "8px 0 0";
          pre.style.fontSize = "11px";
          pre.style.lineHeight = "1.5";
          pre.textContent = JSON.stringify(list.slice(10), null, 2);
          rest.appendChild(pre);
          scanQuestionList.appendChild(rest);
        }
      }

      function _scanRenderResult(payload){
        const result = payload && typeof payload === "object" ? payload : null;
        scanState.result = result;
        if (!result){
          _scanResetResultView();
          return;
        }
        if (scanResultCard) scanResultCard.classList.remove("hidden");
        const meta = result.meta || {};
        if (scanResultMeta){
          const tags = [];
          tags.push(`: ${meta.title || ""}`);
          tags.push(`: ${meta.author || ""}`);
          tags.push(`: ${meta.lang || ""}`);
          tags.push(`: ${meta.subjectGuess || ""}`);
          scanResultMeta.textContent = tags.join(" / ");
        }
        if (scanReconstructedView){
          const html = _scanSanitizeGeneratedHtml(result.reconstructed?.html || "");
          if (html) {
            scanReconstructedView.innerHTML = html;
          } else if (result.partial && result.ocrText) {
            const pre = document.createElement("pre");
            pre.style.whiteSpace = "pre-wrap";
            pre.style.margin = "0";
            pre.style.fontSize = "12px";
            pre.style.lineHeight = "1.55";
            pre.textContent = String(result.ocrText || "");
            scanReconstructedView.replaceChildren(pre);
          } else {
            scanReconstructedView.innerHTML = "<div class='scan-sub'></div>";
          }
        }
        _scanRenderQuestionsPreview(result.questions || []);
        _scanSetDebug(result.debug || null);
      }

      function _scanPresetFromResult(result){
        const srcPreset = result && result.preset && typeof result.preset === "object" ? result.preset : {};
        const srcWords = Array.isArray(srcPreset.words) ? srcPreset.words : [];
        const words = [];
        for (const row of srcWords){
          const id = Number(row?.id || words.length + 1);
          const word = String(row?.word || "").trim();
          const meaning = String(row?.meaning || "").trim();
          if (!word || !meaning) continue;
          const item = normalizeWordEntry({ id, word, meaning });
          if (!item) continue;
          if (row && row.mcq && Array.isArray(row.mcq.choices) && row.mcq.choices.length >= 2){
            const choices = row.mcq.choices.map((x) => String(x || "").trim()).filter(Boolean).slice(0, 4);
            if (choices.length >= 2){
              let correctIndex = Number(row.mcq.correctIndex || 0);
              if (!Number.isFinite(correctIndex) || correctIndex < 0 || correctIndex >= choices.length){
                correctIndex = Math.max(0, choices.findIndex((c) => c === meaning));
              }
              item.mcq = { choices, correctIndex };
            }
          }
          words.push(item);
        }
        const nameBase = String(srcPreset.name || "").trim() || "";
        const modesRaw = srcPreset.modes && typeof srcPreset.modes === "object" ? srcPreset.modes : {};
        const preset = {
          id: newId(),
          name: nameBase,
          builtin: false,
          modes: {
            SEQ: modesRaw.SEQ !== false,
            RND: modesRaw.RND !== false,
            HAND: modesRaw.HAND !== false,
            CHOICE: modesRaw.CHOICE !== false
          },
          words,
          subjectId: "sub:other",
          tagIds: []
        };
        return _normalizePresetMeta(preset, { allowMissingCustomSubject: false, allowUnknownTagIds: false });
      }

      async function _scanAddPresetFromResult(){
        if (!scanState.result){
          _scanSetStatus("", "error");
          return;
        }
        const preset = _scanPresetFromResult(scanState.result);
        if (!Array.isArray(preset.words) || !preset.words.length){
          _scanSetStatus("0", "error");
          return;
        }
        const list = loadPresets();
        const existingNames = new Set(list.map((p) => String(p?.name || "")));
        let name = String(preset.name || "");
        if (existingNames.has(name)){
          let i = 2;
          while (existingNames.has(`${name} (${i})`)) i += 1;
          name = `${name} (${i})`;
        }
        preset.name = name;
        list.unshift(preset);
        savePresets(list);
        refreshPresetList();
        selectPresetForEdit(preset.id);
        setActivePreset(preset.id);
        _appRenderLibrary();
        _scanSetStatus(`: ${preset.name}`, "ok");
      }

      function _scanApiBase(){
        const b = (typeof _shareApiBase === "function") ? _shareApiBase() : "";
        return String(b || "").replace(/\/+$/, "");
      }

      async function _scanBuildMultipartPayload(){
        const prompt = String(scanPromptInput?.value || "").trim();
        const formats = _scanCollectFormats();
        const settings = _scanCollectSettings();
        const params = {
          prompt,
          formats,
          settings,
          markerCount: settings.markerCount,
          extractChars: settings.extractChars,
          difficulty: settings.difficulty,
          count: settings.count,
          clientMeta: {
            original: {
              mime: String(scanState.mainSourceFile?.type || scanState.mainMeta?.mime || ""),
              size: Number(scanState.mainSourceFile?.size || scanState.mainMeta?.inputBytes || 0),
              dims: `${Number(scanState.mainMeta?.sourceWidth || 0)}x${Number(scanState.mainMeta?.sourceHeight || 0)}`
            },
            compressed: {
              mime: String(scanState.mainMeta?.mime || scanState.mainFile?.type || ""),
              size: Number(scanState.mainMeta?.outputBytes || scanState.mainFile?.size || 0),
              dims: `${Number(scanState.mainMeta?.outputWidth || 0)}x${Number(scanState.mainMeta?.outputHeight || 0)}`,
              quality: Number(scanState.mainMeta?.outputQuality || 0),
              maxDimUsed: Number(scanState.mainMeta?.maxDimUsed || 0),
              targetMaxBytes: Number(scanState.mainMeta?.targetMaxBytes || SCAN_UPLOAD_MAX_BYTES)
            },
            reference: scanState.refFile ? {
              original: {
                mime: String(scanState.refSourceFile?.type || scanState.refMeta?.mime || ""),
                size: Number(scanState.refSourceFile?.size || scanState.refMeta?.inputBytes || 0),
                dims: `${Number(scanState.refMeta?.sourceWidth || 0)}x${Number(scanState.refMeta?.sourceHeight || 0)}`
              },
              mime: String(scanState.refMeta?.mime || scanState.refFile?.type || ""),
              size: Number(scanState.refMeta?.outputBytes || scanState.refFile?.size || 0),
              dims: `${Number(scanState.refMeta?.outputWidth || 0)}x${Number(scanState.refMeta?.outputHeight || 0)}`,
              quality: Number(scanState.refMeta?.outputQuality || 0),
              maxDimUsed: Number(scanState.refMeta?.maxDimUsed || 0),
              targetMaxBytes: Number(scanState.refMeta?.targetMaxBytes || SCAN_UPLOAD_MAX_BYTES)
            } : null
          }
        };
        const formData = new FormData();
        if (scanState.mainFile) {
          formData.append("image", scanState.mainFile, scanState.mainFile.name || "scan.jpg");
        }
        if (scanState.type === "double" && scanState.refFile) {
          formData.append("refImage", scanState.refFile, scanState.refFile.name || "scan-ref.jpg");
        }
        formData.append("prompt", prompt);
        formData.append("formats", formats.join(","));
        formData.append("settings", JSON.stringify(settings));
        formData.append("params", JSON.stringify(params));
        formData.append("options", JSON.stringify(params));
        const requestPayloadBytes = Number(scanState.mainFile?.size || 0)
          + Number(scanState.refFile?.size || 0)
          + new Blob([JSON.stringify(params)]).size;
        return {
          formData,
          params,
          settings,
          formats,
          prompt,
          requestPayloadBytes
        };
      }

      function _scanRetryProfile(attempt){
        if (attempt <= 1) {
          return {
            dims: [1024, 896],
            qualities: [0.52, 0.42, 0.35],
            targetMaxBytes: 560 * 1024
          };
        }
        return {
          dims: [896],
          qualities: [0.42, 0.35],
          targetMaxBytes: 480 * 1024
        };
      }

      async function _scanApplyRetryCompression(attempt){
        const profile = _scanRetryProfile(attempt);
        const mainBase = scanState.mainSourceFile || scanState.mainFile;
        if (!mainBase) return false;
        const nextMain = await _scanNormalizeImageFile(mainBase, profile);
        if (!nextMain?.file || nextMain?.error) return false;
        scanState.mainFile = nextMain.file;
        scanState.mainMeta = nextMain;
        _scanRenderThumb(scanMainThumbList, scanState.mainFile, "main");
        if (scanState.type === "double" && (scanState.refSourceFile || scanState.refFile)) {
          const refBase = scanState.refSourceFile || scanState.refFile;
          const nextRef = await _scanNormalizeImageFile(refBase, profile);
          if (nextRef?.file && !nextRef?.error) {
            scanState.refFile = nextRef.file;
            scanState.refMeta = nextRef;
            _scanRenderThumb(scanRefThumbList, scanState.refFile, "ref");
          }
        }
        _scanSetImageMeta(
          `: ${Number(nextMain.sourceWidth || 0)}x${Number(nextMain.sourceHeight || 0)} -> ${Number(nextMain.outputWidth || 0)}x${Number(nextMain.outputHeight || 0)} / ${Math.round(Number(nextMain.inputBytes || 0) / 1024)}KB -> ${Math.round(Number(nextMain.outputBytes || 0) / 1024)}KB`
        );
        return true;
      }

      function _scanShouldRetryVisionError(data, attempt){
        if (attempt >= SCAN_AUTO_RETRY_LIMIT) return false;
        const stage = String(data?.stage || data?.debug?.failedStage || "").toLowerCase();
        if (stage !== "vision_ocr" && stage !== "request_parse") return false;
        const code = String(data?.code || "").toUpperCase();
        return code === "SCAN_AI_INVALID_INPUT"
          || code === "SCAN_AI_CONTEXT_LIMIT"
          || code === "SCAN_VISION_INPUT_TOO_LARGE"
          || code === "SCAN_VISION_TIMEOUT"
          || code === "SCAN_VISION_TRY_TIMEOUT"
          || code === "SCAN_AI_UPSTREAM_TIMEOUT"
          || code === "SCAN_AI_RUN_FAILED"
          || code === "IMAGE_TOO_LARGE"
          || code === "PARTIAL_OCR_RETRY";
      }

      function _scanMessageForFailure(data, stage, detail){
        const code = String(data?.code || "").toUpperCase();
        if (code === "IMAGE_TOO_LARGE") return "";
        if (code === "SCAN_TOO_LARGE_FOR_MODEL" || code === "SCAN_AI_CONTEXT_LIMIT" || code === "SCAN_VISION_INPUT_TOO_LARGE") {
          return "";
        }
        if (code === "SCAN_AI_INVALID_INPUT") return "JPEG/PNG/WebP";
        if (code === "SCAN_AI_RUN_FAILED" || code === "SCAN_AI_UPSTREAM_TIMEOUT" || code === "SCAN_VISION_TIMEOUT") {
          return "";
        }
        const msg = String(data?.message || data?.detail || "");
        if (detail) return `${msg} / ${detail}`;
        return stage ? `${stage}: ${msg}` : msg;
      }

      async function _scanGenerateRun(){
        if (scanState.running) return;
        const apiBase = _scanApiBase();
        if (!apiBase){
          _scanSetStatus("API", "error");
          return;
        }
        if (!scanState.mainFile){
          _scanSetStatus("", "error");
          return;
        }
        const prompt = String(scanPromptInput?.value || "").trim();
        if (!prompt){
          _scanSetStatus("", "error");
          return;
        }
        if (!_scanCollectFormats().length){
          _scanSetStatus("1", "error");
          return;
        }
        _scanResetResultView();
        _scanSetRunning(true);
        scanState.autoRetryCount = 0;
        _scanSetStatus("", "");
        _scanStartProgressTicker();
        try{
          let attempt = 0;
          while (attempt <= SCAN_AUTO_RETRY_LIMIT) {
            const payload = await _scanBuildMultipartPayload();
            const ctl = new AbortController();
            scanState.abortCtl = ctl;
            let timeoutId = null;
            let timedOut = false;
            timeoutId = setTimeout(() => {
              timedOut = true;
              try { ctl.abort(); } catch {}
            }, SCAN_FETCH_TIMEOUT_MS);
            let res = null;
            let data = null;
            try {
              res = await fetch(`${apiBase}/api/scan/generate`, {
                method: "POST",
                body: payload.formData,
                signal: ctl.signal
              });
              const raw = await res.text().catch(() => "");
              try { data = raw ? JSON.parse(raw) : null; } catch {}
              if (!data) {
                throw new Error(raw || `HTTP ${res.status}`);
              }
            } catch (err) {
              if (timeoutId) clearTimeout(timeoutId);
              scanState.abortCtl = null;
              _scanStopProgressTicker();
              _scanSetDebug({
                failedStage: "client_fetch",
                errorMessage: String(err?.message || err || ""),
                timeout: timedOut,
                client: {
                  attempt: attempt + 1,
                  payloadBytes: payload.requestPayloadBytes,
                  original: payload?.params?.clientMeta?.original || null,
                  compressed: payload?.params?.clientMeta?.compressed || null
                },
                status: "error"
              });
              if (err && err.name === "AbortError") {
                _scanSetStatus(
                  timedOut
                    ? "30"
                    : "",
                  timedOut ? "error" : ""
                );
              } else {
                _scanSetStatus(`: ${String(err?.message || err)}`, "error");
              }
              return;
            } finally {
              if (timeoutId) clearTimeout(timeoutId);
            }
            if (res.ok && data && data.ok === true) {
              _scanStopProgressTicker();
              if (data?.partial) {
                _scanSetProgress(2);
              } else {
                _scanSetProgress(6);
              }
              _scanRenderResult(data);
              if (data?.partial) {
                _scanSetStatus(String(data?.message || "OCR"), "ok");
              } else {
                _scanSetStatus(`: ${Array.isArray(data.questions) ? data.questions.length : 0}`, "ok");
              }
              scanState.abortCtl = null;
              return;
            }
            const stage = String(data?.stage || data?.debug?.failedStage || data?.error || data?.code || "unknown");
            const detail = String(data?.detail || data?.debug?.errorMessage || "").trim();
            try {
              console.error("[scan.generate] failed", {
                status: res.status,
                stage,
                code: data?.code,
                detail,
                debug: data?.debug || null
              });
            } catch {}
            if (_scanShouldRetryVisionError(data, attempt)) {
              const nextAttempt = attempt + 1;
              const retryOk = await _scanApplyRetryCompression(nextAttempt);
              if (retryOk) {
                scanState.autoRetryCount = nextAttempt;
                _scanSetStatus(`OCR (${nextAttempt}/${SCAN_AUTO_RETRY_LIMIT})`, "");
                _scanSetDebug({
                  ...(data?.debug || {}),
                  response: {
                    status: res.status,
                    code: data?.code || "",
                    detail,
                    failedStage: stage
                  },
                  client: {
                    attempt: nextAttempt,
                    payloadBytes: payload.requestPayloadBytes,
                    original: payload?.params?.clientMeta?.original || null,
                    compressed: payload?.params?.clientMeta?.compressed || null
                  }
                });
                attempt = nextAttempt;
                scanState.abortCtl = null;
                continue;
              }
            }
            if (data?.partial) {
              _scanRenderResult(data);
            } else {
              _scanSetDebug({
                ...(data?.debug || {}),
                client: {
                  attempt: attempt + 1,
                  payloadBytes: payload.requestPayloadBytes,
                  original: payload?.params?.clientMeta?.original || null,
                  compressed: payload?.params?.clientMeta?.compressed || null
                },
                response: {
                  status: res.status,
                  code: data?.code || "",
                  detail: detail || "",
                  failedStage: stage
                }
              });
            }
            _scanStopProgressTicker();
            _scanSetStatus(_scanMessageForFailure(data, stage, detail), "error");
            scanState.abortCtl = null;
            return;
          }
          _scanStopProgressTicker();
          _scanSetStatus("", "error");
        }catch(err){
          _scanStopProgressTicker();
          _scanSetDebug({
            failedStage: "client_fetch",
            errorMessage: String(err?.message || err || ""),
            client: {
              payloadBytes: Number(scanState.mainFile?.size || 0) + Number(scanState.refFile?.size || 0),
              sent: {
                mime: String(scanState.mainMeta?.mime || scanState.mainFile?.type || ""),
                size: Number(scanState.mainMeta?.outputBytes || scanState.mainFile?.size || 0),
                dims: `${Number(scanState.mainMeta?.outputWidth || 0)}x${Number(scanState.mainMeta?.outputHeight || 0)}`
              }
            },
            status: "error"
          });
          _scanSetStatus(`: ${String(err?.message || err)}`, "error");
        }finally{
          scanState.abortCtl = null;
          _scanSetRunning(false);
        }
      }

      async function _scanCopyJson(){
        if (!scanState.result){
          _scanSetStatus("", "error");
          return;
        }
        const text = JSON.stringify(scanState.result, null, 2);
        const ok = await _copyText(text);
        _scanSetStatus(ok ? "JSON" : "", ok ? "ok" : "error");
      }

      function _scanClearImages(){
        scanState.mainFile = null;
        scanState.refFile = null;
        scanState.mainSourceFile = null;
        scanState.refSourceFile = null;
        scanState.mainMeta = null;
        scanState.refMeta = null;
        scanState.autoRetryCount = 0;
        if (scanMainImageInput) scanMainImageInput.value = "";
        if (scanRefImageInput) scanRefImageInput.value = "";
        _scanRevokeUrl("main");
        _scanRevokeUrl("ref");
        if (scanMainThumbList) scanMainThumbList.replaceChildren();
        if (scanRefThumbList) scanRefThumbList.replaceChildren();
        _scanSetImageMeta("");
      }

      function _scanOpenPanel(){
        if (!scanGenOverlay) return;
        scanGenOverlay.classList.remove("hidden");
        requestAnimationFrame(() => scanGenOverlay.classList.add("is-open"));
        const picked = scanGenOverlay.querySelector('input[name="scanGenType"]:checked');
        scanState.type = String(picked?.value || "single");
        _scanSetRunning(false);
        _scanResetResultView();
        _scanSetStatus("");
        _scanSetProgress(-1);
        scanState.autoRetryCount = 0;
        _scanUpdateTypeUI();
      }

      function _scanClosePanel(){
        if (!scanGenOverlay) return;
        if (scanState.running && scanState.abortCtl){
          try{ scanState.abortCtl.abort(); }catch{}
        }
        scanState.running = false;
        _scanStopProgressTicker();
        _scanClearImages();
        scanGenOverlay.classList.remove("is-open");
        setTimeout(() => {
          if (scanGenOverlay.classList.contains("is-open")) return;
          scanGenOverlay.classList.add("hidden");
        }, 260);
      }

      presetScanBtn?.addEventListener("click", () => {
        _scanOpenPanel();
      });

      let _scanMainPickSeq = 0;
      let _scanRefPickSeq = 0;

      scanMainImageInput?.addEventListener("change", async () => {
        const picked = scanMainImageInput.files && scanMainImageInput.files[0];
        const seq = ++_scanMainPickSeq;
        if (!picked){
          scanState.mainFile = null;
          scanState.mainSourceFile = null;
          scanState.mainMeta = null;
          _scanRenderThumb(scanMainThumbList, null, "main");
          _scanSetStatus("", "error");
          return;
        }
        scanState.mainSourceFile = picked;
        _scanSetStatus("", "");
        const normalized = await _scanNormalizeImageFile(picked);
        if (seq !== _scanMainPickSeq) return;
        if (normalized?.error){
          scanState.mainFile = null;
          scanState.mainSourceFile = null;
          scanState.mainMeta = null;
          _scanRenderThumb(scanMainThumbList, null, "main");
          _scanSetImageMeta("");
          _scanSetDebug({
            failedStage: "client_precheck",
            code: normalized.error,
            detail: normalized.errorMessage || ""
          });
          _scanSetStatus(normalized.errorMessage || "", "error");
          return;
        }
        scanState.mainFile = normalized?.file || picked || null;
        scanState.mainMeta = normalized && typeof normalized === "object" ? normalized : null;
        _scanRenderThumb(scanMainThumbList, scanState.mainFile, "main");
        if (!scanState.mainFile) {
          _scanSetStatus("", "error");
          return;
        }
        const w0 = Number(normalized?.sourceWidth || 0);
        const h0 = Number(normalized?.sourceHeight || 0);
        const w1 = Number(normalized?.outputWidth || w0);
        const h1 = Number(normalized?.outputHeight || h0);
        _scanSetImageMeta(
          `: ${w0 > 0 ? `${w0}x${h0}` : "?"} -> ${w1 > 0 ? `${w1}x${h1}` : "?"} / ${Math.round((normalized?.inputBytes || picked.size || 0) / 1024)}KB -> ${Math.round((normalized?.outputBytes || scanState.mainFile.size || 0) / 1024)}KB`
        );
        if (normalized?.overLimit){
          _scanSetStatus("", "error");
        } else if (normalized?.converted){
          _scanSetStatus(` (${Math.round((normalized?.inputBytes || picked.size) / 1024)}KB  ${Math.round((normalized?.outputBytes || scanState.mainFile.size) / 1024)}KB)`, "");
        } else {
          _scanSetStatus("", "");
        }
      });

      scanRefImageInput?.addEventListener("change", async () => {
        const picked = scanRefImageInput.files && scanRefImageInput.files[0];
        const seq = ++_scanRefPickSeq;
        if (!picked){
          scanState.refFile = null;
          scanState.refSourceFile = null;
          scanState.refMeta = null;
          _scanRenderThumb(scanRefThumbList, null, "ref");
          return;
        }
        scanState.refSourceFile = picked;
        _scanSetStatus("", "");
        const normalized = await _scanNormalizeImageFile(picked);
        if (seq !== _scanRefPickSeq) return;
        if (normalized?.error){
          scanState.refFile = null;
          scanState.refSourceFile = null;
          scanState.refMeta = null;
          _scanRenderThumb(scanRefThumbList, null, "ref");
          _scanSetDebug({
            failedStage: "client_precheck_ref",
            code: normalized.error,
            detail: normalized.errorMessage || ""
          });
          _scanSetStatus(normalized.errorMessage || "", "error");
          return;
        }
        scanState.refFile = normalized?.file || picked || null;
        scanState.refMeta = normalized && typeof normalized === "object" ? normalized : null;
        _scanRenderThumb(scanRefThumbList, scanState.refFile, "ref");
        if (normalized?.overLimit){
          _scanSetStatus("", "error");
        } else if (normalized?.converted){
          _scanSetStatus(` (${Math.round((normalized?.inputBytes || picked.size) / 1024)}KB  ${Math.round((normalized?.outputBytes || scanState.refFile?.size || 0) / 1024)}KB)`, "");
        } else {
          _scanSetStatus("", "");
        }
      });

      scanGenOverlay?.addEventListener("change", (e) => {
        const t = e.target;
        if (!t) return;
        if (t.name === "scanGenType"){
          scanState.type = String(t.value || "single");
          _scanUpdateTypeUI();
          if (scanState.type !== "double"){
            scanState.refFile = null;
            scanState.refSourceFile = null;
            scanState.refMeta = null;
            if (scanRefImageInput) scanRefImageInput.value = "";
            _scanRevokeUrl("ref");
            if (scanRefThumbList) scanRefThumbList.replaceChildren();
          }
        }
      });

      scanGenOverlay?.addEventListener("click", async (e) => {
        const btn = e.target && e.target.closest ? e.target.closest("[data-scan-action]") : null;
        if (!btn) return;
        const action = String(btn.getAttribute("data-scan-action") || "");
        if (!action) return;
        if (action === "close"){
          _scanClosePanel();
          return;
        }
        if (action === "cancel"){
          if (scanState.abortCtl){
            try{ scanState.abortCtl.abort(); }catch{}
          } else {
            _scanClosePanel();
          }
          return;
        }
        if (action === "run"){
          _scanGenerateRun();
          return;
        }
        if (action === "retry"){
          _scanGenerateRun();
          return;
        }
        if (action === "copyJson"){
          _scanCopyJson();
          return;
        }
        if (action === "addPreset"){
          _scanAddPresetFromResult();
          return;
        }
        if (action === "removeMainImage"){
          scanState.mainFile = null;
          scanState.mainSourceFile = null;
          scanState.mainMeta = null;
          if (scanMainImageInput) scanMainImageInput.value = "";
          _scanRevokeUrl("main");
          if (scanMainThumbList) scanMainThumbList.replaceChildren();
          _scanSetImageMeta("");
          return;
        }
        if (action === "removeRefImage"){
          scanState.refFile = null;
          scanState.refSourceFile = null;
          scanState.refMeta = null;
          if (scanRefImageInput) scanRefImageInput.value = "";
          _scanRevokeUrl("ref");
          if (scanRefThumbList) scanRefThumbList.replaceChildren();
          return;
        }
      });


      // =========================
      // Preset Share (Code + QR) via bundled Worker API (10 min TTL)
      // =========================
      const API_BASE = "https://vocabuquiz-api.rintyblog.workers.dev";
      const AUTH_API_BASE = "https://vocabuquiz-api.rintyblog.workers.dev";
      const AUTH_API_FALLBACK_BASE = "";
      const SHARE_API_BASE = "https://vocabuquiz-api.rintyblog.workers.dev";
      const CHAT_AI_BASE = String(API_BASE || "").trim().replace(/\/+$/, "");
      const CHAT_AI_API_URL = `${CHAT_AI_BASE}/api/ai/chat`;
      const CHAT_AI_INGEST_URL = `${CHAT_AI_BASE}/api/ai/ingest`;
      console.log("API_BASE", API_BASE);
      console.log("AUTH_API_BASE", AUTH_API_BASE);
      console.log("SHARE_API_BASE", SHARE_API_BASE);
      console.log("CHAT_AI_BASE", CHAT_AI_BASE);
      const APP_VERSION = "v26";
      const SHARE_VALID_MS = 10 * 60 * 1000;
      const SHARE_CACHE_KEY = "app.share.cache.v1";
      const SHARE_QR_IMG = "https://api.qrserver.com/v1/create-qr-code/?size=240x240&data=";

      function _shareApiBase(){
        return String(SHARE_API_BASE || "").trim().replace(/\/+$/, "");
      }
      function _shareApiReady(){
        const b = _shareApiBase();
        return !!b && /^https?:\/\//i.test(String(b));
      }
      function _shareUrlFromCode(code){
        return `${_shareApiBase()}/s/${encodeURIComponent(String(code || "").toUpperCase())}`;
      }
      function fetchWithTimeout(url, opts, ms){
        showLoading("");
        const ctrl = new AbortController();
        const id = setTimeout(()=>ctrl.abort(), ms||5000);
        const o = Object.assign({}, opts||{}, { signal: ctrl.signal });
        return fetch(url, o).finally(()=>{
          clearTimeout(id);
          hideLoading();
        });
      }
      async function safeJson(res){
        const ct = (res.headers.get("content-type") || "").toLowerCase();
        const text = await res.text();
        if (!ct.includes("application/json")){
          throw new Error("NON_JSON_RESPONSE: " + text.slice(0,200));
        }
        try { return JSON.parse(text); } catch (e) { throw new Error("JSON_PARSE_FAILED: " + text.slice(0,200)); }
      }
      function _shareCreateUrl(){
        return `${_shareApiBase()}/api/share/create`;
      }

      function _shareGetUrl(code){
        return `${_shareApiBase()}/api/share/get?code=${encodeURIComponent(String(code || "").toUpperCase())}&appVersion=${encodeURIComponent(APP_VERSION)}`;
      }

      function _extractShareCode(raw){
        const s = String(raw || "").trim().toUpperCase();
        if (!s) return "";
        let m = s.match(/\/S\/([A-Z0-9]{6})(?:\b|\/|$)/);
        if (m) return m[1];
        m = s.match(/[?&]CODE=([A-Z0-9]{6})\b/);
        if (m) return m[1];
        m = s.match(/\b([A-Z0-9]{6})\b/);
        if (m) return m[1];
        return s.replace(/[^A-Z0-9]/g,"").slice(0,6);
      }

      async function _copyText(text){
        const t = String(text || "");
        try{
          if (navigator.clipboard && navigator.clipboard.writeText){
            await navigator.clipboard.writeText(t);
            return true;
          }
        }catch{}
        try{
          const ta = document.createElement("textarea");
          ta.value = t;
          ta.setAttribute("readonly","");
          ta.style.position = "fixed";
          ta.style.left = "-9999px";
          ta.style.top = "-9999px";
          document.body.appendChild(ta);
          ta.select();
          document.execCommand("copy");
          ta.remove();
          return true;
        }catch{
          return false;
        }
      }

      function _runIdle(fn){
        if (typeof requestIdleCallback === "function"){
          requestIdleCallback(() => { try{ fn(); }catch{} }, { timeout: 900 });
        }else{
          setTimeout(() => { try{ fn(); }catch{} }, 120);
        }
      }

      async function _fetchJsonWithTimeout(url, opts = {}, ms = 12000){
        showLoading("");
        const ctrl = new AbortController();
        const t = setTimeout(() => ctrl.abort(), ms);
        try{
          const res = await fetch(url, { ...opts, signal: ctrl.signal });
          const txt = await res.text();
          let data = null;
          try{ data = txt ? JSON.parse(txt) : null; }catch{}
          if (!res.ok){
            const msg = (data && (data.message || data.error)) || `${res.status} ${res.statusText}`;
            throw new Error(msg);
          }
          return data;
        }finally{
          clearTimeout(t);
          hideLoading();
        }
      }

      function _shareCacheLoad(){
        try{
          const raw = window.localStorage.getItem(SHARE_CACHE_KEY);
          const obj = raw ? JSON.parse(raw) : {};
          return obj && typeof obj === "object" ? obj : {};
        }catch{ return {}; }
      }
      function _shareCacheSave(obj){
        try{ window.localStorage.setItem(SHARE_CACHE_KEY, JSON.stringify(obj || {})); }catch{}
      }
      function _shareCacheGet(presetId){
        const c = _shareCacheLoad();
        const e = c && c[presetId];
        if (!e || !e.code || !e.shareUrl || typeof e.expiresAt !== "number") return null;
        return e;
      }
      function _shareCacheSet(presetId, entry){
        const c = _shareCacheLoad();
        c[presetId] = entry;
        _shareCacheSave(c);
      }
      function _shareCacheDelete(presetId){
        const c = _shareCacheLoad();
        if (presetId in c){
          delete c[presetId];
          _shareCacheSave(c);
        }
      }

      function _uniquePresetName(base, existing){
        const names = new Set(existing.map(p => String(p.name || "")));
        if (!names.has(base)) return base;
        let i = 2;
        while (names.has(`${base} (${i})`)) i++;
        return `${base} (${i})`;
      }

      function _formatMMSS(ms){
        const s = Math.max(0, Math.floor((ms || 0) / 1000));
        const mm = String(Math.floor(s / 60)).padStart(2, "0");
        const ss = String(s % 60).padStart(2, "0");
        return `${mm}:${ss}`;
      }

      function _shareModalHtml(presetName){
        const today = (() => {
          try{
            const d = new Date();
            const y = d.getFullYear();
            const m = String(d.getMonth()+1).padStart(2,"0");
            const da = String(d.getDate()).padStart(2,"0");
            return `${y}-${m}-${da}`;
          }catch{ return ""; }
        })();

        return `
          <div style="display:grid; gap:12px;">
            <div style="color:var(--muted); font-size:12px; display:flex; gap:10px; flex-wrap:wrap;">
              <div>${today}</div>
              <div style="opacity:.7;">${_escHtml(presetName)}</div>
            </div>

            <div style="text-align:center; padding:10px 0 2px;">
              <div id="shareCode" style="font-weight:800; font-size:44px; letter-spacing:.14em; font-variant-numeric:tabular-nums; color:var(--text);"></div>
              <div id="shareCodeSub" style="margin-top:6px; font-size:12px; color:var(--muted);"><div class="note" id="shareStatusMsg"></div></div>
            </div>

            <div style="display:flex; gap:10px; flex-wrap:wrap; justify-content:center;">
              <button class="navbtn" id="shareCopyCodeBtn" type="button" disabled></button>
              <button class="textbtn" id="shareCopyUrlBtn" type="button" disabled>URL</button>
            </div>

            <div style="display:grid; gap:8px; justify-items:center; padding-top:6px;">
              <div id="shareQrStatus" style="font-size:12px; color:var(--muted);">QR</div>
              <img id="shareQrImg" alt="QR" style="width:240px; height:240px; border-radius:16px; border:1px solid var(--border); box-shadow:var(--shadow); display:none;" />
              <div id="shareUrlText" style="font-size:12px; color:var(--muted); max-width: 520px; word-break: break-all; text-align:center;"></div>
              <div id="shareTtl" style="font-size:12px; color:var(--muted);"><span id="shareExpires">Expires in --:--</span></div>
            </div>

            <div id="shareErr" style="display:none; font-size:12px; color:#b42318; background:rgba(180,35,24,.08); border:1px solid rgba(180,35,24,.18); padding:10px 12px; border-radius:12px;"></div>
            <div id="shareDebug" style="margin-top:10px; padding:8px 10px; border-radius:12px; border:1px dashed var(--border); background:var(--panel2); color:var(--muted); font-size:12px; line-height:1.35; white-space:pre-wrap; word-break:break-word;">Debug: -</div>

            <div style="font-size:12px; color:var(--muted); line-height:1.55; text-align:center; padding-top:4px;">
              QR
            </div>
          </div>
        `;
      }

      function _importModalHtml(){
        const canCam = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
        const canDecode = ("BarcodeDetector" in window) || (typeof window.jsQR === "function");
        return `
          <div style="display:grid; gap:12px;">
            <div style="font-size:12px; color:var(--muted); line-height:1.6;">
              QRURL/s/XXXXXX6
            </div>

            <div>
              <div class="note" style="margin-bottom:6px;">6</div>
              <input id="shareImportCode" class="spell-input" type="text"
                placeholder="4K7X2Q"
                inputmode="text" autocomplete="one-time-code" autocapitalize="characters" spellcheck="false" />
            </div>

            <div style="display:flex; gap:10px; flex-wrap:wrap;">
              <button class="navbtn" id="shareImportFetchBtn" type="button"></button>
              <button class="textbtn" id="shareImportCamBtn" type="button" ${canCam ? "" : "disabled"}>${canCam ? (canDecode ? "" : "") : ""}</button>
              <button class="textbtn hidden" id="shareImportCamStopBtn" type="button"></button>
            </div>

            <div id="shareImportStatus" style="font-size:12px; color:var(--muted);"></div>

            <div id="shareCamWrap" class="hidden" style="margin-top:6px; border-radius:16px; overflow:hidden; border:1px solid var(--border); box-shadow:var(--shadow);">
              <video id="shareCamVideo" playsinline muted style="width:100%; height:240px; object-fit:cover; display:block;"></video>
            </div>

            <div style="font-size:12px; color:var(--muted); line-height:1.55;">
               QRURL/
            </div>
          </div>
        `;
      }

      function _escHtml(s){
        return String(s ?? "")
          .replaceAll("&","&amp;")
          .replaceAll("<","&lt;")
          .replaceAll(">","&gt;")
          .replaceAll('"',"&quot;")
          .replaceAll("'","&#39;");
      }

      function _setShareError(msg){
        const elErr = document.getElementById("shareErr");
        if (!elErr) return;
        elErr.textContent = String(msg || "");
        elErr.style.display = msg ? "block" : "none";
      }

      function _setShareStatus(txt){
        const sub = document.getElementById("shareStatusMsg");
        if (sub) sub.textContent = String(txt || "");
      }

      let _shareTimerId = null;

      async function shareCurrentPreset(presetId){
        // Accept being used as an event handler
        if (presetId && typeof presetId === "object") presetId = null;

        // Resolve preset
        let presetObj = presetId ? getPresetById(presetId) : null;
        if (!presetId){
          const fallbackId = (typeof getActivePresetId === "function") ? getActivePresetId() : (state.activePresetId || state.presetId || state.preset);
          if (fallbackId){
            presetId = fallbackId;
            presetObj = getPresetById(presetId);
          }
        }

        // Always open UI first (no silent failures)
        const nameForUi = (presetObj && presetObj.name) ? presetObj.name : "My Preset";
        uiHtml(_shareModalHtml(nameForUi, _isoDate()), { title: "Share Preset", wide: true });
        uiModalOnClose(() => {
          _stopShareTimer();
        });

        // Elements
        const codeEl = document.getElementById("shareCode");
        const expiresEl = document.getElementById("shareExpires");
        const qrImgEl = document.getElementById("shareQrImg");
        const qrStatusEl = document.getElementById("shareQrStatus");
        const errEl = document.getElementById("shareErr");
        const statusEl = document.getElementById("shareStatusMsg");
        const copyCodeBtn = document.getElementById("shareCopyCodeBtn");
        const copyUrlBtn = document.getElementById("shareCopyUrlBtn");
        const debugEl = document.getElementById("shareDebug");

        const setErr = (msg) => {
          if (!errEl) return;
          const m = (msg || "").trim();
          if (!m){
            errEl.style.display = "none";
            errEl.textContent = "";
            return;
          }
          errEl.style.display = "block";
          errEl.textContent = m;
        };
        const setStatus = (msg) => {
          if (!statusEl) return;
          statusEl.textContent = msg || "";
        };

        const dbg = {
          endpoint: _shareCreateUrl(),
          status: "-",
          responseHead: "",
          rendered: false,
        };
        const dbgRender = () => {
          if (!debugEl) return;
          debugEl.textContent =
            "Debug\n" +
            "endpoint: " + (dbg.endpoint || "-") + "\n" +
            "status: " + dbg.status + "\n" +
            "responseHead: " + (dbg.responseHead || "-") + "\n" +
            "rendered: " + (dbg.rendered ? "true" : "false");
        };
        dbgRender();

        // Bind copy buttons (overwrite each open)
        if (copyCodeBtn){
          copyCodeBtn.onclick = async () => {
            const code = (codeEl && codeEl.textContent) ? codeEl.textContent.trim() : "";
            if (!code || code.includes("") || code.includes("") || code.includes("")){
              uiToast("");
              return;
            }
            const ok = await _copyText(code);
            uiToast(ok ? "" : "");
          };
        }
        if (copyUrlBtn){
          copyUrlBtn.onclick = async () => {
            const url = (window.__shareCurrentUrl || "").trim();
            if (!url){
              uiToast("URL");
              return;
            }
            const ok = await _copyText(url);
            uiToast(ok ? "" : "");
          };
        }

        // Reset UI state
        setStatus("");
        setErr("");
        if (codeEl) codeEl.textContent = " ";
        if (expiresEl) expiresEl.textContent = "Expires in --:--";
        if (qrStatusEl) qrStatusEl.style.display = "block";
        if (qrImgEl) qrImgEl.style.display = "none";
        window.__shareCurrentUrl = "";
        if (copyCodeBtn) copyCodeBtn.disabled = true;
        if (copyUrlBtn) copyUrlBtn.disabled = true;

        try {
          // Validate preset
          if (!presetId || !presetObj){
            throw new Error("");
          }
          if (presetObj.builtin){
            throw new Error(" My Preset ");
          }
          // Cache
          const cached = _shareCacheGet(presetId);
          if (cached && cached.code && cached.shareUrl && cached.expiresAt && cached.expiresAt > Date.now() + 2000){
            dbg.status = "cached";
            dbg.responseHead = JSON.stringify({ code: cached.code, expiresAt: cached.expiresAt }).slice(0, 160);
            window.__shareCurrentUrl = cached.shareUrl;
            _renderShareResult(cached.code, cached.shareUrl, cached.expiresAt);
            if (copyCodeBtn) copyCodeBtn.disabled = false;
            if (copyUrlBtn) copyUrlBtn.disabled = false;
            dbg.rendered = true;
            dbgRender();
            _startShareTimer(presetId);
            return;
          }

          // Create
          dbg.status = "requesting";
          dbgRender();
          const presetPayload = _drawerSharePresetPayload(presetObj);
          const payload = {
            schemaVersion: 1,
            appVersion: APP_VERSION,
            createdAt: Date.now(),
            preset: presetPayload
          };

          const res = await fetchWithTimeout(_shareCreateUrl(), {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          }, 5000);

          const text = await res.text();
          dbg.status = String(res.status);
          dbg.responseHead = text.slice(0, 160);
          dbgRender();

          if (!res.ok){
            throw new Error(`HTTP ${res.status}: ${text.slice(0, 200)}`);
          }

          let resp;
          try { resp = JSON.parse(text); } catch (e) { throw new Error("JSON parse failed: " + text.slice(0, 200)); }
          if (!resp || !resp.code || !resp.shareUrl || !resp.expiresAt){
            throw new Error("Invalid response: " + text.slice(0, 200));
          }

          _shareCacheSet(presetId, { code: resp.code, shareUrl: resp.shareUrl, expiresAt: resp.expiresAt, createdAt: Date.now() });
          window.__shareCurrentUrl = resp.shareUrl;
          _renderShareResult(resp.code, resp.shareUrl, resp.expiresAt);
          if (copyCodeBtn) copyCodeBtn.disabled = false;
          if (copyUrlBtn) copyUrlBtn.disabled = false;

          dbg.status = "ok";
          dbg.rendered = true;
          dbgRender();
          _startShareTimer(presetId);
        } catch (e){
          dbg.status = "failed";
          dbg.responseHead = String((e && (e.message || e)) || "error").slice(0, 160);
          dbgRender();
          setStatus("");
          setErr(String((e && (e.message || e)) || e));
        }
      }

      function _renderShareResult(code, shareUrl, expiresAt){
        const codeEl = document.getElementById("shareCode");
        if (codeEl){
          const c = String(code).toUpperCase();
          codeEl.textContent = (c.slice(0,3) + " " + c.slice(3));
        }
        window.__shareExpiresAt = Number(expiresAt) || 0;
        _setShareStatus("");
        _updateShareCountdown();
        _renderShareQR(shareUrl);
      }

      function _renderShareQR(shareUrl){
        const img = document.getElementById("shareQrImg");
        const status = document.getElementById("shareQrStatus");
        if (!img) return;
        if (status) status.textContent = "QR";
        img.style.display = "none";
        const url = "https://api.qrserver.com/v1/create-qr-code/?size=240x240&data=" + encodeURIComponent(String(shareUrl));
        let done = false;
        const to = setTimeout(() => {
          if (done) return;
          done = true;
          img.style.display = "none";
          if (status) status.textContent = "QR";
        }, 5000);
        img.onload = () => {
          if (done) return;
          done = true;
          clearTimeout(to);
          img.style.display = "";
          if (status) status.textContent = "";
        };
        img.onerror = () => {
          if (done) return;
          done = true;
          clearTimeout(to);
          img.style.display = "none";
          if (status) status.textContent = "QR";
        };
        img.src = url;
      }

      function _updateShareCountdown(expiresAt){
        if (Number.isFinite(Number(expiresAt))){
          window.__shareExpiresAt = Number(expiresAt);
        }
        const expEl = document.getElementById("shareExpires");
        if (!expEl) return;
        const exp = Number(window.__shareExpiresAt) || 0;
        if (!exp){ expEl.textContent = "Expires in --:--"; return; }
        const ms = exp - Date.now();
        if (ms <= 0){ expEl.textContent = "Expires in 00:00"; return; }
        const s = Math.floor(ms/1000);
        const mm = String(Math.floor(s/60)).padStart(2,"0");
        const ss = String(s%60).padStart(2,"0");
        expEl.textContent = "Expires in " + mm + ":" + ss;
      }

      function _startShareTimer(presetId){
        _stopShareTimer();
        if (!presetId) return;

        const tick = () => {
          try {
            if (!(uiModal && uiModal.root && uiModal.root.classList.contains("is-open"))){
              _stopShareTimer();
              return;
            }
            const entry = _shareCacheGet(presetId);
            if (!entry || !entry.expiresAt){
              _stopShareTimer();
              return;
            }
            _updateShareCountdown(entry.expiresAt);
            if (entry.expiresAt <= Date.now()){
              _shareCacheDelete(presetId);
              _stopShareTimer();
              // Auto regenerate while the panel is open
              shareCurrentPreset(presetId);
            }
          } catch (e){
            _stopShareTimer();
          }
        };

        tick();
        _shareTimerId = setInterval(tick, 1000);
      }

      function _stopShareTimer(){
        if (_shareTimerId){
          clearInterval(_shareTimerId);
          _shareTimerId = null;
        }
      }

      async function importPresetByCode(codeRaw){
        const code = _extractShareCode(codeRaw);
        if (!/^[A-Z0-9]{6}$/.test(code)){
          throw new Error("6");
        }
        const data = await _fetchJsonWithTimeout(_shareGetUrl(code), { method:"GET" }, 12000);
        if (data && data.error){
          const err = String(data.error || "");
          if (err === "VERSION_MISMATCH") throw new Error("");
          if (err === "EXPIRED") throw new Error("");
          if (err === "NOT_FOUND") throw new Error("");
          throw new Error("");
        }
        const preset = data?.preset;
        if (!preset || typeof preset !== "object") throw new Error("");

        const list = loadPresets();
        const nameBase = String(preset.name || "Shared Preset");
        const name = _uniquePresetName(nameBase, list);

        const subjectId = _resolveSubjectId(preset.subjectId, { fallback: "sub:english", allowMissingCustom: false });
        const isEnglish = _isEnglishSubjectId(subjectId);
        const isMath = _isMathSubjectId(subjectId);
        let words = _normalizeWordList(preset.words);
        if (!words.length){
          words = _cardsToWordList(_normalizeCardList(preset.cards, { allowLatex: isMath }));
        }
        let cards = _normalizeCardList(preset.cards, { allowLatex: isMath });
        if (!cards.length && !isEnglish){
          cards = _wordsToCardList(words, { allowLatex: false });
        }

        const modes = preset.modes && typeof preset.modes === "object" ? preset.modes : { SEQ:true, RND:true, HAND:true, CHOICE:true };
        const srcSubject = (preset.subject && typeof preset.subject === "object") ? preset.subject : null;
        if (srcSubject && /^subc:[a-z0-9_-]{4,}$/i.test(String(srcSubject.id || "")) && String(srcSubject.name || "").trim()){
          const custom = loadCustomSubjects();
          if (!custom.some((s) => s.id === srcSubject.id)){
            custom.unshift({
              id: String(srcSubject.id),
              name: String(srcSubject.name || "").trim(),
              color: _normalizeMetaColor(srcSubject.color || ""),
              builtin: false
            });
            saveCustomSubjects(custom);
          }
        }
        const srcTags = Array.isArray(preset.tags) ? preset.tags : [];
        if (srcTags.length){
          const customTags = loadCustomTags();
          let changed = false;
          for (const row of srcTags){
            const n = _normalizeTagItem(row);
            if (!n) continue;
            if (!customTags.some((t) => t.id === n.id)){
              customTags.unshift(n);
              changed = true;
            }
          }
          if (changed) saveCustomTags(customTags);
        }

        const newPreset = {
          id: newId(),
          name,
          builtin: false,
          modes: { SEQ:!!modes.SEQ, RND:!!modes.RND, HAND:!!modes.HAND, CHOICE:!!modes.CHOICE },
          words,
          cards,
          subjectId,
          tagIds: _normalizeTagIds(preset.tagIds, { allowUnknown: false })
        };
        list.unshift(newPreset);
        savePresets(list);
        refreshPresetList();
        selectPresetForEdit(newPreset.id);
        setActivePreset(newPreset.id);
        return newPreset;
      }

      function openShareImport(){
        uiHtml(_importModalHtml(), { title:"Import Preset", okText:"" });

        _runIdle(() => {
          const input = document.getElementById("shareImportCode");
          const fetchBtn = document.getElementById("shareImportFetchBtn");
          const camBtn = document.getElementById("shareImportCamBtn");
          const camStopBtn = document.getElementById("shareImportCamStopBtn");
          const status = document.getElementById("shareImportStatus");
          const camWrap = document.getElementById("shareCamWrap");
          const video = document.getElementById("shareCamVideo");

          let stream = null;
          let loopTimer = null;
          let camTimeout = null;

          const stopCam = () => {
            try{ if (loopTimer) clearInterval(loopTimer); }catch{}
            loopTimer = null;
            try{ if (camTimeout) clearTimeout(camTimeout); }catch{}
            camTimeout = null;
            try{
              if (stream){
                for (const t of stream.getTracks()) t.stop();
              }
            }catch{}
            stream = null;
            if (camWrap) camWrap.classList.add("hidden");
            if (camStopBtn) camStopBtn.classList.add("hidden");
            if (camBtn) camBtn.classList.remove("hidden");
            if (status) status.textContent = "";
          };

          uiModalOnClose(stopCam);

          if (input){
            input.addEventListener("input", () => {
              const raw = input.value;
              input.value = _extractShareCode(raw);
            });
            setTimeout(()=>{ try{ input.focus(); }catch{} }, 0);
          }

          const doImport = async () => {
            if (!status) return;
            const raw = input ? input.value : "";
            const code = _extractShareCode(raw);
            status.textContent = "";
            try{
              const p = await importPresetByCode(code);
              status.textContent = `${p.name}`;
            }catch(err){
              status.textContent = "";
              uiAlert((err && err.message) ? err.message : "", { title:"Import Preset" });
            }
          };

          if (fetchBtn){
            fetchBtn.onclick = () => { doImport(); };
          }

          if (camBtn && camWrap && video && camStopBtn){
            camBtn.onclick = async () => {
              try{
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
                  uiAlert("", { title:"Import Preset" });
                  return;
                }
                if (status) status.textContent = "";
                stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio: false });
                video.srcObject = stream;
                await video.play();

                camWrap.classList.remove("hidden");
                camBtn.classList.add("hidden");
                camStopBtn.classList.remove("hidden");
                if (status) status.textContent = "";

                const hasBd = ("BarcodeDetector" in window);
                const hasJsqr = (typeof window.jsQR === "function");
                let detector = null;
                if (hasBd){
                  try{ detector = new BarcodeDetector({ formats: ["qr_code"] }); }catch{}
                }
                if (!detector && !hasJsqr){
                  stopCam();
                  uiAlert("QR", { title:"Import Preset" });
                  return;
                }

                const cv = document.createElement("canvas");
                const ctx = cv.getContext("2d", { willReadFrequently:true });

                loopTimer = setInterval(async () => {
                  if (!video || video.readyState < 2) return;
                  try{
                    let rawVal = "";
                    if (detector){
                      const codes = await detector.detect(video);
                      if (codes && codes.length) rawVal = codes[0].rawValue || "";
                    } else if (hasJsqr && ctx){
                      const w = video.videoWidth || 0;
                      const h = video.videoHeight || 0;
                      if (!w || !h) return;
                      cv.width = w;
                      cv.height = h;
                      ctx.drawImage(video, 0, 0, w, h);
                      const img = ctx.getImageData(0, 0, w, h);
                      const qr = window.jsQR(img.data, w, h, { inversionAttempts: "dontInvert" });
                      if (qr && qr.data) rawVal = qr.data;
                    }
                    const code = _extractShareCode(rawVal);
                    if (code){
                      if (input) input.value = code;
                      stopCam();
                      if (status) status.textContent = "";
                      doImport();
                    }
                  }catch{}
                }, detector ? 320 : 420);

                camTimeout = setTimeout(() => {
                  stopCam();
                  uiAlert("", { title:"Import Preset" });
                }, 20000);

              }catch(err){
                stopCam();
                uiAlert("", { title:"Import Preset" });
              }
            };

            camStopBtn.onclick = () => stopCam();
          }
        });
      }


      function openPresetManager(createNew){
        presetOverlay.classList.remove("hidden");
        refreshPresetList();

        const list = loadPresets();

        // If no user presets exist yet, create one immediately so the editor is usable.
        if (!list.length){
          createNewPreset();
          return;
        }

        if (createNew){
          createNewPreset();
          return;
        }

        const pid = getActivePresetId();
        if (!isBuiltinPreset(pid) && list.some(p => p.id === pid)){
          selectPresetForEdit(pid);
        } else {
          selectPresetForEdit(list[0].id);
        }
      }
      function closePresetManager(){
        _mathDiagramCloseEditor(true);
        presetOverlay.classList.add("hidden");
        if (presetSubjectManager) presetSubjectManager.classList.add("hidden");
        if (presetTagManager) presetTagManager.classList.add("hidden");
        if (scanGenOverlay && !scanGenOverlay.classList.contains("hidden")){
          _scanClosePanel();
        }
      }

      presetCloseBtn?.addEventListener("click", closePresetManager);
      presetCloseBtn2?.addEventListener("click", closePresetManager);
      presetOverlay?.addEventListener("click", (e)=>{ if (e.target === presetOverlay) closePresetManager(); });

      function newId(){
        return "custom:" + Math.random().toString(36).slice(2,10) + Date.now().toString(36).slice(-4);
      }
      function _metaNewId(prefix){
        return `${prefix}:${Math.random().toString(36).slice(2,8)}${Date.now().toString(36).slice(-4)}`;
      }
      function _setPresetMetaStatus(msg, kind){
        if (!presetMetaStatus) return;
        presetMetaStatus.textContent = String(msg || "");
        presetMetaStatus.classList.remove("ok", "error");
        if (kind === "ok") presetMetaStatus.classList.add("ok");
        if (kind === "error") presetMetaStatus.classList.add("error");
      }
      function _presetSubjectBadgeHtml(subjectId){
        const s = getSubjectById(subjectId || "sub:other");
        const nm = s?.name || "Other";
        const border = s?.color ? ` style="border-color:${escapeHtml(s.color)}"` : "";
        return `<span class="subject-badge"${border}>${escapeHtml(nm)}</span>`;
      }
      function _presetTagChipsHtml(tagIds){
        const ids = _normalizeTagIds(tagIds, { allowUnknown: false });
        if (!ids.length) return "";
        const chips = [];
        for (const id of ids.slice(0, 4)){
          const t = getTagById(id);
          if (!t) continue;
          const border = t.color ? ` style="border-color:${escapeHtml(t.color)}"` : "";
          chips.push(`<span class="tag-chip is-muted"${border}>${escapeHtml(t.name)}</span>`);
        }
        return chips.join("");
      }
      function _renderPresetSubjectOptions(selectedId){
        if (!presetSubjectSelect) return;
        const all = getAllSubjects();
        presetSubjectSelect.innerHTML = "";
        for (const s of all){
          const o = document.createElement("option");
          o.value = s.id;
          o.textContent = s.name;
          presetSubjectSelect.appendChild(o);
        }
        const picked = String(selectedId || "sub:english");
        presetSubjectSelect.value = all.some((s) => s.id === picked) ? picked : "sub:english";
        _applyPresetEditorSubjectUI(presetSubjectSelect.value || "sub:english");
      }
      function _renderPresetTagPicker(selectedIds){
        if (!presetTagPicker) return;
        const all = getAllTags();
        const picked = Array.isArray(selectedIds) ? selectedIds.slice() : [];
        presetTagPicker.replaceChildren();
        if (!all.length){
          const n = document.createElement("span");
          n.className = "note";
          n.textContent = "";
          presetTagPicker.appendChild(n);
          return;
        }
        for (const t of all){
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "tag-chip" + (picked.includes(t.id) ? " is-selected" : "");
          btn.textContent = t.name;
          btn.dataset.presetTagId = t.id;
          if (t.color) btn.style.borderColor = t.color;
          presetTagPicker.appendChild(btn);
        }
      }
      function _renderSubjectManagerList(){
        if (!presetSubjectManagerList) return;
        const list = loadCustomSubjects();
        presetSubjectManagerList.innerHTML = "";
        if (!list.length){
          presetSubjectManagerList.innerHTML = `<div class="note"></div>`;
          return;
        }
        for (const s of list){
          const row = document.createElement("div");
          row.className = "preset-item";
          row.innerHTML = `
            <div class="left">
              <div class="title">${escapeHtml(s.name)}</div>
              <p class="meta">${escapeHtml(s.id)}</p>
            </div>
            <div style="display:flex; gap:8px; align-items:center;">
              <button class="textbtn" type="button" data-subject-action="rename" data-id="${escapeHtml(s.id)}"></button>
              <button class="textbtn" type="button" data-subject-action="delete" data-id="${escapeHtml(s.id)}"></button>
            </div>
          `;
          presetSubjectManagerList.appendChild(row);
        }
      }
      function _renderTagManagerList(){
        if (!presetTagManagerList) return;
        const list = loadCustomTags();
        presetTagManagerList.innerHTML = "";
        if (!list.length){
          presetTagManagerList.innerHTML = `<div class="note"></div>`;
          return;
        }
        for (const t of list){
          const row = document.createElement("div");
          row.className = "preset-item";
          row.innerHTML = `
            <div class="left">
              <div class="title">${escapeHtml(t.name)}</div>
              <p class="meta">${escapeHtml(t.id)}</p>
            </div>
            <div style="display:flex; gap:8px; align-items:center;">
              <button class="textbtn" type="button" data-tag-action="rename" data-id="${escapeHtml(t.id)}"></button>
              <button class="textbtn" type="button" data-tag-action="delete" data-id="${escapeHtml(t.id)}"></button>
            </div>
          `;
          presetTagManagerList.appendChild(row);
        }
      }
      function _refreshPresetMetaEditor(preset){
        const sid = _resolveSubjectId(preset?.subjectId, { fallback: "sub:english", allowMissingCustom: true });
        _renderPresetSubjectOptions(sid);
        editingPresetTagIds = _normalizeTagIds(preset?.tagIds, { allowUnknown: false });
        _renderPresetTagPicker(editingPresetTagIds);
        _renderSubjectManagerList();
        _renderTagManagerList();
        _applyPresetEditorSubjectUI(sid);
      }

      function presetMetaText(p){
        const m = p.modes || {};
        const parts = [];
        if (m.SEQ) parts.push("");
        if (m.RND) parts.push("");
        if (m.HAND) parts.push("");
        if (m.CHOICE) parts.push("");
        return parts.length ? parts.join(" / ") : "";
      }

      function refreshPresetList(){
        const list = loadPresets();
        presetListEl.innerHTML = "";

        const builtins = [
          {id:"builtin:A", name:"0200"},
          {id:"builtin:B", name:"200400"},
          {id:"builtin:C", name:"400600"},
          {id:"builtin:D", name:"600800"},
          {id:"builtin:E", name:"80010008011000"},
          {id:"builtin:ALL", name:"ALL"}
        ];
        for (const b of builtins){
          const row = document.createElement("div");
          row.className = "preset-item";
          row.innerHTML = `
            <div class="left">
              <div class="title">${escapeHtml(b.name)}</div>
              <p class="meta"></p>
              <div class="preset-meta-row">${_presetSubjectBadgeHtml("sub:english")}</div>
            </div>
            <div style="display:flex; gap:8px;">
              <button class="textbtn" data-use="${b.id}"></button>
            </div>`;
          presetListEl.appendChild(row);
        }

        if (!list.length){
          const empty = document.createElement("div");
          empty.className = "preset-item";
          empty.innerHTML = `<div class="left"><div class="title">My Preset </div><p class="meta"></p></div></div>`;
          presetListEl.appendChild(empty);
        } else {
          for (const p of list){
            const wc = _presetEntryCount(p);
            const unit = _isEnglishSubjectId(p.subjectId || "sub:english") ? "" : "";
            const row = document.createElement("div");
            row.className = "preset-item";
            row.innerHTML = `
              <div class="left">
                <div class="title">${escapeHtml(p.name || "My Preset")}</div>
                <p class="meta">: ${wc}${unit} / : ${escapeHtml(presetMetaText(p))}</p>
                <div class="preset-meta-row">
                  ${_presetSubjectBadgeHtml(p.subjectId || "sub:english")}
                  ${_presetTagChipsHtml(p.tagIds)}
                </div>
              </div>
              <div style="display:flex; gap:8px; align-items:center;">
                <button class="textbtn" data-use="${p.id}"></button>
                <button class="textbtn" data-edit="${p.id}"></button>
              </div>`;
            presetListEl.appendChild(row);
          }
        }

        presetListEl.querySelectorAll("button[data-use]").forEach(btn=>{
          btn.addEventListener("click", ()=>{
            const id = btn.getAttribute("data-use");
            if (id === "builtin:A") setDeck("A");
            else if (id === "builtin:B") setDeck("B");
            else if (id === "builtin:C") setDeck("C");
            else if (id === "builtin:D") setDeck("D");
            else if (id === "builtin:E") setDeck("E");
            else if (id === "builtin:ALL") setDeck("ALL");
            else setActivePreset(id);
            closePresetManager();
          });
        });
        presetListEl.querySelectorAll("button[data-edit]").forEach(btn=>{
          btn.addEventListener("click", ()=> selectPresetForEdit(btn.getAttribute("data-edit")));
        });

        syncPresetUI();
        try{ _appRenderLibrary(); }catch{}
      }

      function createNewPreset(){
        const list = loadPresets();
        const id = newId();
        const p = {
          id,
          name: "My Preset",
          builtin: false,
          modes: { SEQ:true, RND:true, HAND:true, CHOICE:true },
          words: [],
          cards: [],
          subjectId: "sub:english",
          tagIds: []
        };
        list.unshift(p);
        savePresets(list);
        refreshPresetList();
        selectPresetForEdit(id);
      }

      presetNewBtn?.addEventListener("click", createNewPreset);

      function selectPresetForEdit(pid){
        _mathDiagramCloseEditor(true);
        const list = loadPresets();
        const p = list.find(x=>x.id===pid) || null;
        editingPresetId = p ? p.id : null;

        presetNameInput.value = p ? (p.name || "") : "";
        const m = p?.modes || {SEQ:true,RND:true,HAND:true,CHOICE:true};
        presetModeSeq.checked = !!m.SEQ;
        presetModeRnd.checked = !!m.RND;
        presetModeHand.checked = !!m.HAND;
        presetModeChoice.checked = !!m.CHOICE;

        wordIdInput.value = "";
        wordWordInput.value = "";
        wordMeaningInput.value = "";
        _presetEditorSetFormatValues("text", "text");
        clearMcqForm();
        bulkTextarea.value = "";

        const disabled = !p;
        presetSaveBtn.disabled = disabled;
        presetDeleteBtn.disabled = disabled;
        presetExportBtn.disabled = disabled;
        presetClearWordsBtn.disabled = disabled;
        bulkAddBtn.disabled = disabled;
        wordUpsertBtn.disabled = disabled;
        if (wordFrontFormatSelect) wordFrontFormatSelect.disabled = disabled;
        if (wordBackFormatSelect) wordBackFormatSelect.disabled = disabled;
        if (presetSubjectSelect) presetSubjectSelect.disabled = disabled;
        if (presetManageSubjectsBtn) presetManageSubjectsBtn.disabled = disabled;
        if (presetManageTagsBtn) presetManageTagsBtn.disabled = disabled;

        renderWordsPreview(_presetEditingEntries(p));
        _refreshPresetMetaEditor(p);
        _setPresetMetaStatus("");

        if (presetShareBtn) presetShareBtn.disabled = !p || !!p.builtin;
      }

      presetSubjectSelect?.addEventListener("change", () => {
        if (!editingPresetId) return;
        const sid = presetSubjectSelect.value || "sub:english";
        _applyPresetEditorSubjectUI(sid);
        const p = getPresetById(editingPresetId);
        if (p){
          const mock = { ...p, subjectId: sid };
          renderWordsPreview(_presetEditingEntries(mock));
        }
        _setPresetMetaStatus("");
      });
      presetTagPicker?.addEventListener("click", (e) => {
        const btn = e.target && e.target.closest ? e.target.closest("[data-preset-tag-id]") : null;
        if (!btn || !editingPresetId) return;
        const tid = String(btn.getAttribute("data-preset-tag-id") || "");
        if (!tid) return;
        if (editingPresetTagIds.includes(tid)){
          editingPresetTagIds = editingPresetTagIds.filter((x) => x !== tid);
        } else {
          editingPresetTagIds = editingPresetTagIds.concat([tid]);
        }
        _renderPresetTagPicker(editingPresetTagIds);
        _setPresetMetaStatus("");
      });
      presetManageSubjectsBtn?.addEventListener("click", () => {
        if (presetSubjectManager) presetSubjectManager.classList.toggle("hidden");
        if (presetSubjectManager && !presetSubjectManager.classList.contains("hidden")){
          _renderSubjectManagerList();
        }
      });
      presetManageTagsBtn?.addEventListener("click", () => {
        if (presetTagManager) presetTagManager.classList.toggle("hidden");
        if (presetTagManager && !presetTagManager.classList.contains("hidden")){
          _renderTagManagerList();
        }
      });
      presetSubjectAddBtn?.addEventListener("click", () => {
        const name = String(presetSubjectNameInput?.value || "").trim();
        const color = _normalizeMetaColor(String(presetSubjectColorInput?.value || "").trim());
        if (!name){
          _setPresetMetaStatus("", "error");
          return;
        }
        const list = loadCustomSubjects();
        if (list.some((s) => String(s.name || "").toLowerCase() === name.toLowerCase())){
          _setPresetMetaStatus("", "error");
          return;
        }
        list.unshift({ id: _metaNewId("subc"), name, color, builtin: false });
        saveCustomSubjects(list);
        if (presetSubjectNameInput) presetSubjectNameInput.value = "";
        if (presetSubjectColorInput) presetSubjectColorInput.value = "";
        _renderSubjectManagerList();
        _renderPresetSubjectOptions(presetSubjectSelect?.value || "sub:english");
        _setPresetMetaStatus("", "ok");
        _appRenderLibrary();
      });
      presetTagAddBtn?.addEventListener("click", () => {
        const name = String(presetTagNameInput?.value || "").trim();
        const color = _normalizeMetaColor(String(presetTagColorInput?.value || "").trim());
        if (!name){
          _setPresetMetaStatus("", "error");
          return;
        }
        const list = loadCustomTags();
        if (list.some((t) => String(t.name || "").toLowerCase() === name.toLowerCase())){
          _setPresetMetaStatus("", "error");
          return;
        }
        list.unshift({ id: _metaNewId("tagc"), name, color });
        saveCustomTags(list);
        if (presetTagNameInput) presetTagNameInput.value = "";
        if (presetTagColorInput) presetTagColorInput.value = "";
        _renderTagManagerList();
        _renderPresetTagPicker(editingPresetTagIds);
        _setPresetMetaStatus("", "ok");
        _appRenderLibrary();
      });
      presetSubjectManagerList?.addEventListener("click", async (e) => {
        const btn = e.target && e.target.closest ? e.target.closest("[data-subject-action]") : null;
        if (!btn) return;
        const id = String(btn.getAttribute("data-id") || "");
        const action = String(btn.getAttribute("data-subject-action") || "");
        if (!id || !action) return;
        if (action === "rename"){
          const cur = loadCustomSubjects().find((s) => s.id === id);
          if (!cur) return;
          const html = `
            <div style="display:grid; gap:10px;">
              <input id="subjectRenameInput" class="spell-input" type="text" value="${escapeHtml(cur.name)}" />
              <input id="subjectRenameColorInput" class="spell-input" type="text" value="${escapeHtml(cur.color || "")}" placeholder="#aabbcc" />
            </div>
          `;
          const ok = await uiConfirmHtml(html, { title: "", okText: "", cancelText: "" });
          if (!ok) return;
          const nm = String(document.getElementById("subjectRenameInput")?.value || "").trim();
          const col = _normalizeMetaColor(String(document.getElementById("subjectRenameColorInput")?.value || "").trim());
          if (!nm){
            _setPresetMetaStatus("", "error");
            return;
          }
          const list = loadCustomSubjects();
          const hit = list.find((s) => s.id === id);
          if (!hit) return;
          hit.name = nm;
          hit.color = col;
          saveCustomSubjects(list);
          _renderSubjectManagerList();
          _renderPresetSubjectOptions(presetSubjectSelect?.value || "sub:english");
          _setPresetMetaStatus("", "ok");
          _appRenderLibrary();
          return;
        }
        if (action === "delete"){
          const used = loadPresets().filter((p) => String(p.subjectId || "") === id).length;
          const ok = await uiConfirm(
            used > 0
              ? ` ${used} Other`
              : "",
            { title: "", okText: "", cancelText: "", danger: true }
          );
          if (!ok) return;
          const subjects = loadCustomSubjects().filter((s) => s.id !== id);
          saveCustomSubjects(subjects);
          if (used > 0){
            const presets = loadPresets();
            for (const p of presets){
              if (String(p.subjectId || "") === id) p.subjectId = "sub:other";
            }
            savePresets(presets);
            if (String(presetSubjectSelect?.value || "") === id){
              presetSubjectSelect.value = "sub:other";
            }
          }
          _renderSubjectManagerList();
          _renderPresetSubjectOptions(presetSubjectSelect?.value || "sub:english");
          _setPresetMetaStatus("", "ok");
          _appRenderLibrary();
        }
      });
      presetTagManagerList?.addEventListener("click", async (e) => {
        const btn = e.target && e.target.closest ? e.target.closest("[data-tag-action]") : null;
        if (!btn) return;
        const id = String(btn.getAttribute("data-id") || "");
        const action = String(btn.getAttribute("data-tag-action") || "");
        if (!id || !action) return;
        if (action === "rename"){
          const cur = loadCustomTags().find((t) => t.id === id);
          if (!cur) return;
          const html = `
            <div style="display:grid; gap:10px;">
              <input id="tagRenameInput" class="spell-input" type="text" value="${escapeHtml(cur.name)}" />
              <input id="tagRenameColorInput" class="spell-input" type="text" value="${escapeHtml(cur.color || "")}" placeholder="#aabbcc" />
            </div>
          `;
          const ok = await uiConfirmHtml(html, { title: "", okText: "", cancelText: "" });
          if (!ok) return;
          const nm = String(document.getElementById("tagRenameInput")?.value || "").trim();
          const col = _normalizeMetaColor(String(document.getElementById("tagRenameColorInput")?.value || "").trim());
          if (!nm){
            _setPresetMetaStatus("", "error");
            return;
          }
          const list = loadCustomTags();
          const hit = list.find((t) => t.id === id);
          if (!hit) return;
          hit.name = nm;
          hit.color = col;
          saveCustomTags(list);
          _renderTagManagerList();
          _renderPresetTagPicker(editingPresetTagIds);
          _setPresetMetaStatus("", "ok");
          _appRenderLibrary();
          return;
        }
        if (action === "delete"){
          const ok = await uiConfirm(" ", {
            title: "",
            okText: "",
            cancelText: "",
            danger: true
          });
          if (!ok) return;
          const tags = loadCustomTags().filter((t) => t.id !== id);
          saveCustomTags(tags);
          const presets = loadPresets();
          for (const p of presets){
            p.tagIds = _normalizeTagIds((p.tagIds || []).filter((x) => String(x) !== id), { allowUnknown: true });
          }
          savePresets(presets);
          editingPresetTagIds = editingPresetTagIds.filter((x) => x !== id);
          _renderTagManagerList();
          _renderPresetTagPicker(editingPresetTagIds);
          _setPresetMetaStatus("", "ok");
          _appRenderLibrary();
        }
      });

      function renderWordsPreview(words){
        const list = Array.isArray(words) ? words : [];
        const sid = _presetEditingSubjectId();
        const isEnglish = _isEnglishSubjectId(sid);
        const isMath = _isMathSubjectId(sid);
        const arr = isEnglish
          ? _normalizeWordList(list)
          : _normalizeCardList(list, { allowLatex: isMath });
        presetWordsPreview.innerHTML = "";
        if (!arr.length){
          presetWordsPreview.innerHTML = `<div class="note"></div>`;
          return;
        }
        for (const w of arr.slice(0,50)){
          const row = document.createElement("div");
          row.className = "preset-item";
          if (isEnglish){
            row.innerHTML = `
              <div class="left">
                <div class="title">No.${w.id}  ${escapeHtml(w.word)}</div>
                <p class="meta">${escapeHtml(w.meaning)}</p>
              </div>
              <div style="display:flex; gap:8px; flex-wrap:wrap;">
                <button class="textbtn" data-editword="${w.id}"></button>
                <button class="textbtn" data-delword="${w.id}"></button>
              </div>`;
          } else {
            const frontFmt = isMath ? _normalizeFormatMode(w.frontFormat, true) : "text";
            const backFmt = isMath ? _normalizeFormatMode(w.backFormat, true) : "text";
            const fmtMeta = isMath ? ` / :${frontFmt.toUpperCase()} :${backFmt.toUpperCase()}` : "";
            const hasDiagram = !!_normalizeCardDiagram(w.diagram);
            row.innerHTML = `
              <div class="left">
                <div class="title">No.${w.id}  ${escapeHtml(w.front)}</div>
                <p class="meta">: ${escapeHtml(w.back)}${escapeHtml(fmtMeta)}${hasDiagram ? ` <span class="badge"></span>` : ""}</p>
              </div>
              <div style="display:flex; gap:8px; flex-wrap:wrap;">
                ${isMath ? `<button class="textbtn" data-editdiagram="${w.id}"></button>` : ""}
                <button class="textbtn" data-editword="${w.id}"></button>
                <button class="textbtn" data-delword="${w.id}"></button>
              </div>`;
          }
          presetWordsPreview.appendChild(row);
        }

        presetWordsPreview.querySelectorAll("button[data-delword]").forEach(btn=>{
          btn.addEventListener("click", ()=>{
            if (!editingPresetId) return;
            const delId = Number(btn.getAttribute("data-delword"));
            if (!Number.isFinite(delId)) return;
            const list = loadPresets();
            const p = list.find(x=>x.id===editingPresetId);
            if (!p) return;
            const entries = _presetEditingEntries(p).filter((x) => Number(x.id) !== delId);
            if (Number(_mathDiagramState.targetId) === delId){
              _mathDiagramCloseEditor(true);
            }
            _presetEditingSetEntries(p, entries);
            savePresets(list);
            selectPresetForEdit(editingPresetId);
            refreshPresetList();
          });
        });
        presetWordsPreview.querySelectorAll("button[data-editword]").forEach(btn=>{
          btn.addEventListener("click", ()=>{
            if (!editingPresetId) return;
            const id = Number(btn.getAttribute("data-editword"));
            const list = loadPresets();
            const p = list.find(x=>x.id===editingPresetId);
            if (!p) return;
            const sid = _resolveSubjectId(p.subjectId, { fallback: "sub:english", allowMissingCustom: true });
            const isEnglish = _isEnglishSubjectId(sid);
            const entries = _presetEditingEntries(p);
            const map = new Map(entries.map((x) => [Number(x.id), x]));
            const w = map.get(id);
            if (!w) return;
            wordIdInput.value = String(w.id);
            if (isEnglish){
              wordWordInput.value = w.word;
              wordMeaningInput.value = w.meaning;
              _presetEditorSetFormatValues("text", "text");
              clearMcqForm();
              if (w.mcq && Array.isArray(w.mcq.choices) && w.mcq.choices.length){
                if (mcqEnable) mcqEnable.checked = true;
                setMcqVisible(true);
                for (let i=0;i<mcqChoices.length;i++){
                  const v = w.mcq.choices?.[i];
                  if (mcqChoices[i]) mcqChoices[i].value = (v == null ? "" : String(v));
                }
                const ci = Number(w.mcq.correctIndex);
                if (Number.isInteger(ci) && mcqRadios[ci]) mcqRadios[ci].checked = true;
              }
            } else {
              wordWordInput.value = w.front;
              wordMeaningInput.value = w.back;
              _presetEditorSetFormatValues(w.frontFormat || "text", w.backFormat || "text");
              clearMcqForm();
            }
            _scheduleMathPreview();
          });
        });
      }

      presetSaveBtn?.addEventListener("click", ()=>{
        if (!editingPresetId) return;
        const list = loadPresets();
        const p = list.find(x=>x.id===editingPresetId);
        if (!p) return;
        p.name = presetNameInput.value.trim() || "My Preset";
        p.modes = {
          SEQ: !!presetModeSeq.checked,
          RND: !!presetModeRnd.checked,
          HAND: !!presetModeHand.checked,
          CHOICE: !!presetModeChoice.checked
        };
        p.subjectId = _resolveSubjectId(presetSubjectSelect?.value || "sub:english", {
          fallback: "sub:english",
          allowMissingCustom: false
        });
        p.tagIds = _normalizeTagIds(editingPresetTagIds, { allowUnknown: false });
        savePresets(list);
        refreshPresetList();
        if (getActivePresetId() === editingPresetId) renderAll();
        _setPresetMetaStatus("", "ok");
      });

      presetDeleteBtn?.addEventListener("click", async ()=>{
        if (!editingPresetId) return;
        const ok = await uiConfirm("", { title: "", okText: "", cancelText: "", danger: true });
        if (!ok) return;
        const list = loadPresets().filter(x => x.id !== editingPresetId);
        savePresets(list);
        if (getActivePresetId() === editingPresetId){
          setDeck("A");
        }
        editingPresetId = null;
        selectPresetForEdit(null);
        refreshPresetList();
      });

      presetExportBtn?.addEventListener("click", ()=>{
        if (!editingPresetId) return;
        const list = loadPresets();
        const p = list.find(x=>x.id===editingPresetId);
        if (!p) return;
        const blob = new Blob([JSON.stringify(p, null, 2)], {type:"application/json"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = (p.name || "preset").replace(/[^\w\-]+/g,"_") + ".json";
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      });

      function _openPresetShareFromManager(opts = {}){
        const tab = (opts && opts.tab === "import") ? "import" : "share";
        const presetId = String(opts?.presetId || "");
        const hasPreset = !!presetId && !isBuiltinPreset(presetId);
        try{ closePresetManager(); }catch{}
        try{
          if (typeof _menuState === "object" && _menuState && _menuState.presetShare){
            _menuState.presetShare.tab = tab;
            if (hasPreset){
              _menuState.presetShare.selectedPresetId = presetId;
            }
          }
          if (typeof openMenu === "function") openMenu();
          if (typeof _setMenuView === "function") _setMenuView("presetShare");
          if (typeof _drawerShareApplyTab === "function") _drawerShareApplyTab(tab);
          if (hasPreset && typeof _drawerShareRefreshBySelection === "function"){
            _drawerShareRefreshBySelection();
          }
          return true;
        }catch(err){
          console.warn("[PresetManager] share drawer open failed:", err);
          return false;
        }
      }

      presetImportBtn?.addEventListener("click", ()=> presetImportFile?.click());
      presetShareBtn?.addEventListener("click", ()=>{
        const pid = String(editingPresetId || "");
        const p = getPresetById(pid);
        if (!p || p.builtin){
          uiAlert(" My Preset ", { title: "Preset Share" });
          return;
        }
        const ok = _openPresetShareFromManager({ tab: "share", presetId: pid });
        if (!ok) shareCurrentPreset(editingPresetId);
      });
      presetShareImportBtn?.addEventListener("click", ()=>{
        const ok = _openPresetShareFromManager({ tab: "import" });
        if (!ok) openShareImport();
      });
      presetImportFile?.addEventListener("change", async ()=>{
        const file = presetImportFile.files && presetImportFile.files[0];
        if (!file) return;
        try{
          const text = await file.text();
          const obj = JSON.parse(text);
          const list = loadPresets();
          let p = null;
          if (Array.isArray(obj)){
            p = {
              id:newId(),
              name:"Imported Preset",
              builtin:false,
              modes:{SEQ:true,RND:true,HAND:true,CHOICE:true},
              words:obj,
              cards: [],
              subjectId: "sub:english",
              tagIds: []
            };
          } else if (obj && typeof obj === "object"){
            const importedWords = Array.isArray(obj.words) ? obj.words : [];
            const importedCards = Array.isArray(obj.cards) ? obj.cards : [];
            const fallbackSubject = importedCards.length && !importedWords.length ? "sub:other" : "sub:english";
            p = {
              id: newId(),
              name: String(obj.name || "Imported Preset"),
              builtin: false,
              modes: obj.modes && typeof obj.modes === "object" ? {
                SEQ: !!obj.modes.SEQ, RND: !!obj.modes.RND, HAND: !!obj.modes.HAND, CHOICE: !!obj.modes.CHOICE
              } : {SEQ:true,RND:true,HAND:true,CHOICE:true},
              words: importedWords,
              cards: importedCards,
              subjectId: _resolveSubjectId(obj.subjectId, { fallback: fallbackSubject, allowMissingCustom: false }),
              tagIds: _normalizeTagIds(obj.tagIds, { allowUnknown: false })
            };
          }
          if (!p) throw new Error("invalid");
          p = _normalizePresetMeta(p, { allowMissingCustomSubject: false, allowUnknownTagIds: false });
          list.unshift(p);
          savePresets(list);
          refreshPresetList();
          selectPresetForEdit(p.id);
        }catch{
          uiAlert("JSON");
        }finally{
          presetImportFile.value = "";
        }
      });

      function parseLineToWord(line){
        const s = String(line||"").trim();
        if (!s) return null;
        const m = s.match(/^(\d+)\s+(.+)$/);
        if (!m) return null;
        const id = Number(m[1]);
        const rest = m[2];

        // Split at the earliest likely start of meaning:
        // - first Japanese character, OR
        // - the '' marker (commonly used at the beginning of meanings like "")
        const jp = rest.search(PRESET_JP_REGEX);
        const tilde = rest.indexOf("");
        let idx = jp;
        if (tilde !== -1 && (idx === -1 || tilde < idx)) idx = tilde;

        if (idx <= 0) return null;
        const word = rest.slice(0, idx).trim();
        const meaning = rest.slice(idx).trim();
        return normalizeWordEntry({id, word, meaning});
      }
      function parseLineToCard(line, opts = {}){
        const s = String(line || "").trim();
        if (!s) return null;
        const m = s.match(/^(\d+)\s+(.+)$/);
        if (!m) return null;
        const id = Number(m[1]);
        const rest = String(m[2] || "").trim();
        if (!Number.isFinite(id) || id <= 0 || !rest) return null;

        let front = "";
        let back = "";
        const byTab = rest.split(/\t+/).map((x) => x.trim()).filter(Boolean);
        if (byTab.length >= 2){
          front = byTab[0];
          back = byTab.slice(1).join(" ");
        } else {
          const pipePos = rest.indexOf(" | ");
          if (pipePos > 0){
            front = rest.slice(0, pipePos).trim();
            back = rest.slice(pipePos + 3).trim();
          } else {
            const dbl = rest.match(/^(.+?)\s{2,}(.+)$/);
            if (dbl){
              front = String(dbl[1] || "").trim();
              back = String(dbl[2] || "").trim();
            } else {
              const jp = rest.search(PRESET_JP_REGEX);
              if (jp > 0){
                front = rest.slice(0, jp).trim();
                back = rest.slice(jp).trim();
              } else {
                const last = rest.lastIndexOf(" ");
                if (last > 0){
                  front = rest.slice(0, last).trim();
                  back = rest.slice(last + 1).trim();
                }
              }
            }
          }
        }
        if (!front || !back) return null;
        return normalizeCardEntry({
          id,
          front,
          back,
          frontFormat: opts.frontFormat || "text",
          backFormat: opts.backFormat || "text"
        }, { allowLatex: !!opts.allowLatex });
      }

      bulkAddBtn?.addEventListener("click", ()=>{
        if (!editingPresetId) return;
        const subjectId = _presetEditingSubjectId();
        const isEnglish = _isEnglishSubjectId(subjectId);
        const isMath = _isMathSubjectId(subjectId);
        const lines = bulkTextarea.value.split(/\r?\n/);
        const adds = [];
        for (const ln of lines){
          if (isEnglish){
            const w = parseLineToWord(ln);
            if (w) adds.push(w);
          } else {
            const c = parseLineToCard(ln, {
              allowLatex: isMath,
              frontFormat: _presetEditorFrontFormatValue(),
              backFormat: _presetEditorBackFormatValue()
            });
            if (c) adds.push(c);
          }
        }
        if (!adds.length) return;
        const list = loadPresets();
        const p = list.find(x=>x.id===editingPresetId);
        if (!p) return;
        const map = new Map();
        for (const it of _presetEditingEntries(p)){
          map.set(Number(it.id), it);
        }
        for (const a of adds){
          const prev = map.get(Number(a.id));
          if (prev && !_isEnglishSubjectId(subjectId)){
            const keepDiagram = _normalizeCardDiagram(prev.diagram);
            map.set(Number(a.id), keepDiagram ? { ...a, diagram: keepDiagram } : a);
          } else {
            map.set(Number(a.id), a);
          }
        }
        _presetEditingSetEntries(p, Array.from(map.values()).sort((a,b)=>a.id-b.id));
        savePresets(list);
        selectPresetForEdit(editingPresetId);
        refreshPresetList();
      });

      bulkClearBtn?.addEventListener("click", ()=>{ bulkTextarea.value=""; });

      presetClearWordsBtn?.addEventListener("click", async ()=>{
        if (!editingPresetId) return;
        const ok = await uiConfirm("", { title: "", okText: "", cancelText: "", danger: true });
        if (!ok) return;
        const list = loadPresets();
        const p = list.find(x=>x.id===editingPresetId);
        if (!p) return;
        p.words = [];
        p.cards = [];
        savePresets(list);
        selectPresetForEdit(editingPresetId);
        refreshPresetList();
      });

      wordClearBtn?.addEventListener("click", ()=>{
        wordIdInput.value = "";
        wordWordInput.value = "";
        wordMeaningInput.value = "";
        _presetEditorSetFormatValues("text", "text");
        clearMcqForm();
        _scheduleMathPreview();
      });

      wordUpsertBtn?.addEventListener("click", ()=>{
        if (!editingPresetId) return;
        const subjectId = _presetEditingSubjectId();
        const isEnglish = _isEnglishSubjectId(subjectId);
        const isMath = _isMathSubjectId(subjectId);
        const id = Number(wordIdInput.value.trim());
        const word = wordWordInput.value.trim();
        const meaning = wordMeaningInput.value.trim();
        let n = null;
        if (isEnglish){
          const mcq = getMcqFromForm(meaning);
          if (mcq && mcq.__invalid) return;
          n = normalizeWordEntry({id, word, meaning, mcq});
          if (!n){ uiAlert("id//"); return; }
        } else {
          n = normalizeCardEntry({
            id,
            front: word,
            back: meaning,
            frontFormat: _presetEditorFrontFormatValue(),
            backFormat: _presetEditorBackFormatValue()
          }, { allowLatex: isMath });
          if (!n){ uiAlert("id//"); return; }
        }
        const list = loadPresets();
        const p = list.find(x=>x.id===editingPresetId);
        if (!p) return;
        const map = new Map();
        for (const it of _presetEditingEntries(p)){
          map.set(Number(it.id), it);
        }
        const prev = map.get(Number(n.id));
        if (!isEnglish && prev && _normalizeCardDiagram(prev.diagram)){
          n.diagram = _normalizeCardDiagram(prev.diagram);
        }
        map.set(n.id, n);
        _presetEditingSetEntries(p, Array.from(map.values()).sort((a,b)=>a.id-b.id));
        savePresets(list);
        wordIdInput.value = "";
        wordWordInput.value = "";
        wordMeaningInput.value = "";
        _presetEditorSetFormatValues("text", "text");
        clearMcqForm();
        _scheduleMathPreview();
        selectPresetForEdit(editingPresetId);
        refreshPresetList();
      });

      // =========================
      // Insights (analytics + dashboard)
      // =========================
      const INSIGHTS_SESSIONS_KEY = "wordPractice.analytics.sessions.v1";
      const INSIGHTS_MAX = 500;

      const insights = {
        open: false,
        preset: "CURRENT",
        mode: "ALL",
        range: "30D",
        currentPresetId: null,
        reduceMotion: _isMotionReduced()
      };

      let _insightsSessionsCache = null;
      let _insightsSessionsRev = 0;
      let _insightsFilteredCacheKey = "";
      let _insightsFilteredCache = null;
      const _insightsFilterCacheMap = new Map();

      function _insightsLoadSessions(){
        if (_insightsSessionsCache) return _insightsSessionsCache;
        try{
          const raw = window.localStorage.getItem(INSIGHTS_SESSIONS_KEY);
          const arr = raw ? JSON.parse(raw) : [];
          const list = Array.isArray(arr) ? arr : [];
          list.sort((a,b)=>(Number(a?.ts)||0)-(Number(b?.ts)||0));
          _insightsSessionsCache = list.slice(-INSIGHTS_MAX);
          _insightsSessionsRev++;
          return _insightsSessionsCache;
        }catch{
          _insightsSessionsCache = [];
          _insightsSessionsRev++;
          return _insightsSessionsCache;
        }
      }
      function _insightsSaveSessions(arr){
        try{
          const list = Array.isArray(arr) ? arr.slice(-INSIGHTS_MAX) : [];
          list.sort((a,b)=>(Number(a?.ts)||0)-(Number(b?.ts)||0));
          _insightsSessionsCache = list;
          _insightsSessionsRev++;
          _insightsFilteredCacheKey = "";
          _insightsFilteredCache = null;
          _insightsFilterCacheMap.clear();
          window.localStorage.setItem(INSIGHTS_SESSIONS_KEY, JSON.stringify(list));
        }catch{}
      }
      function _insightsMakeId(){
        return Math.random().toString(36).slice(2, 10);
      }
      function _insightsYmd(ts){
        try{
          const d = new Date(ts);
          const y = d.getFullYear();
          const m = String(d.getMonth()+1).padStart(2,"0");
          const da = String(d.getDate()).padStart(2,"0");
          return `${y}-${m}-${da}`;
        }catch{ return ""; }
      }
      function _insightsFormatTs(ts){
        try{
          const d = new Date(ts);
          const ymd = _insightsYmd(ts);
          const hh = String(d.getHours()).padStart(2,"0");
          const mm = String(d.getMinutes()).padStart(2,"0");
          return `${ymd} ${hh}:${mm}`;
        }catch{ return ""; }
      }
      function _insightsClamp(n,min,max){ return Math.max(min, Math.min(max, n)); }

      function _insightsGetPresetMeta(){
        let presetId = null;
        try{
          presetId = (typeof getActivePresetId === "function") ? getActivePresetId() : (state.presetId || `builtin:${state.deck}`);
        }catch{
          presetId = state.presetId || `builtin:${state.deck}`;
        }
        let presetName = "";
        try{
          if (typeof getPresetById === "function"){
            presetName = getPresetById(presetId)?.name || "";
          }
        }catch{}
        if (!presetName){
          try{ presetName = deckLabel(state.deck); }catch{}
        }
        return { presetId, presetName };
      }

      function _insightsAppendSession(session){
        const sessions = _insightsLoadSessions();
        sessions.push(session);
        while (sessions.length > INSIGHTS_MAX) sessions.shift();
        _insightsSaveSessions(sessions);
      }

      function _insightsStartSession(mode){
        state._insightsStartTs = Date.now();
        state._insightsLogged = false;
        state._insightsStartMode = mode;
        const meta = _insightsGetPresetMeta();
        state._insightsStartPresetId = meta.presetId;
        state._insightsStartPresetName = meta.presetName;
      }

      function _insightsTryLogResult(kind){
        const mode = kind || state.mode;
        if (mode !== "HAND" && mode !== "CHOICE") return;
        if (state._insightsLogged) return;

        let total = 0;
        let correct = 0;
        let wrongIds = [];

        if (mode === "CHOICE"){
          total = state.choice?.results?.length || 0;
          correct = state.choice?.correctCount || 0;
          const wrong = (state.choice?.results || []).filter(r => !r.correct);
          wrongIds = wrong.map(r => Number(r.id)).filter(n => Number.isFinite(n));
        } else {
          total = state.hand?.results?.length || 0;
          correct = state.hand?.scoreCorrect || 0;
          const wrong = (state.hand?.results || []).filter(r => !r.correct);
          wrongIds = wrong.map(r => Number(r.id)).filter(n => Number.isFinite(n));
        }

        const startTs = Number(state._insightsStartTs);
        const durationMs = Number.isFinite(startTs) ? Math.max(0, Date.now() - startTs) : null;

        const presetId = state._insightsStartPresetId || _insightsGetPresetMeta().presetId;
        const presetName = state._insightsStartPresetName || _insightsGetPresetMeta().presetName;

        const accuracy = total > 0 ? (correct / total) : null;

        const sess = {
          id: _insightsMakeId(),
          ts: Date.now(),
          date: _insightsYmd(Date.now()),
          presetId: String(presetId || ""),
          presetName: String(presetName || ""),
          mode: String(mode),
          total: Number(total) || 0,
          correct: Number(correct) || 0,
          accuracy: (accuracy == null ? null : Number(accuracy)),
          durationMs: (durationMs == null ? null : Number(durationMs)),
          wrongIds: Array.isArray(wrongIds) ? wrongIds : [],
          timedOutCount: (mode === "CHOICE")
            ? (state.choice?.results || []).filter(r => !!r && r.timedOut === true).length
            : null
        };

        _insightsAppendSession(sess);
        state._insightsLogged = true;
      }

      // Hook: start timestamps
      const _startModeOrig = startMode;
      startMode = function(mode){
        if (mode === "HAND") _insightsStartSession("HAND");
        return _startModeOrig(mode);
      };
      const _startChoiceModeOrig = startChoiceMode;
      startChoiceMode = function(timeLimitSec){
        _insightsStartSession("CHOICE");
        return _startChoiceModeOrig(timeLimitSec);
      };

      // Hook: log at result transition
      const _goResultOrig = goResult;
      goResult = function(kind){
        try{ _insightsTryLogResult(kind || state.mode); }catch{}
        return _goResultOrig(kind);
      };

      // Dashboard elements
      const insightsEl = {
        btn: document.getElementById("insightsBtn"),
        overlay: document.getElementById("insightsOverlay"),
        close: document.getElementById("insightsCloseBtn"),
        presetSel: document.getElementById("insightsPresetSelect"),
        modeSel: document.getElementById("insightsModeSelect"),
        rangeSel: document.getElementById("insightsRangeSelect"),
        summary: document.getElementById("insightsSummary"),
        trend: document.getElementById("chartAccuracyTrend"),
        trendNote: document.getElementById("trendNote"),
        modeCard: document.getElementById("modeAccuracyCard"),
        modeChart: document.getElementById("chartModeAccuracy"),
        weak: document.getElementById("chartWeakTop10"),
        dailyVolume: document.getElementById("chartDailyVolume"),
        dailyAccuracy: document.getElementById("chartDailyAccuracy"),
        modeDistribution: document.getElementById("tableModeDistribution"),
        avgTimeTrend: document.getElementById("chartAvgTimeTrend"),
        timeoutByMode: document.getElementById("tableTimeoutByMode"),
        weekCompare: document.getElementById("tableWeekCompare"),
        monthCompare: document.getElementById("tableMonthCompare"),
        exportBtn: document.getElementById("insightsExportBtn"),
        deleteBtn: document.getElementById("insightsDeleteBtn"),
      };

      function _insightsIsOpen(){ return insightsEl.overlay && !insightsEl.overlay.classList.contains("hidden"); }

      function _insightsOpen(){
        if (!insightsEl.overlay) return;
        insights.open = true;

        insights.preset = "CURRENT";
        insights.mode = "ALL";
        insights.range = "30D";

        insights.currentPresetId = _insightsGetPresetMeta().presetId;

        _insightsBuildPresetOptions();
        if (insightsEl.modeSel) insightsEl.modeSel.value = "ALL";
        if (insightsEl.rangeSel) insightsEl.rangeSel.value = "30D";

        insightsEl.overlay.classList.remove("hidden");
        insightsEl.overlay.setAttribute("aria-hidden", "false");
        _customSelectEnhance(insightsEl.overlay);

        _insightsRenderAll();
      }

      function _insightsClose(){
        if (!insightsEl.overlay) return;
        insights.open = false;
        insightsEl.overlay.classList.add("hidden");
        insightsEl.overlay.setAttribute("aria-hidden", "true");
      }

      function _insightsBuildPresetOptions(){
        if (!insightsEl.presetSel) return;
        const sessions = _insightsLoadSessions();

        const ids = new Map();
        for (const s of sessions){
          if (s && typeof s.presetId === "string") ids.set(s.presetId, s.presetName || s.presetId);
        }

        const cur = insights.currentPresetId || _insightsGetPresetMeta().presetId;
        if (cur) ids.set(cur, _insightsGetPresetMeta().presetName || cur);

        const builtins = ["builtin:A","builtin:B","builtin:C","builtin:D","builtin:E","builtin:ALL"];
        for (const b of builtins){
          if (!ids.has(b)){
            try{
              const name = (typeof getPresetById === "function") ? (getPresetById(b)?.name || "") : "";
              if (name) ids.set(b, name);
            }catch{}
          }
        }

        insightsEl.presetSel.innerHTML = "";
        const optCur = document.createElement("option");
        optCur.value = "CURRENT";
        optCur.textContent = "CURRENT";
        insightsEl.presetSel.appendChild(optCur);

        const optAll = document.createElement("option");
        optAll.value = "ALL";
        optAll.textContent = "ALL";
        insightsEl.presetSel.appendChild(optAll);

        const sep = document.createElement("option");
        sep.disabled = true;
        sep.textContent = "";
        insightsEl.presetSel.appendChild(sep);

        const arr = Array.from(ids.entries()).map(([id,name]) => ({id, name}));
        arr.sort((a,b)=>{
          const ab = a.id.startsWith("builtin:");
          const bb = b.id.startsWith("builtin:");
          if (ab && !bb) return -1;
          if (!ab && bb) return 1;
          return String(a.name).localeCompare(String(b.name), "ja");
        });

        for (const it of arr){
          const o = document.createElement("option");
          o.value = it.id;
          o.textContent = it.name || it.id;
          insightsEl.presetSel.appendChild(o);
        }

        insightsEl.presetSel.value = "CURRENT";
        _customSelectEnhance(insightsEl.overlay || document);
      }

      function _insightsGetFilteredSessions(){
        const opts = {
          preset: insights.preset,
          mode: insights.mode,
          range: insights.range,
          currentPresetId: insights.currentPresetId || _insightsGetPresetMeta().presetId
        };
        return _insightsGetFilteredSessionsBy(opts);
      }

      function _insightsGetFilteredSessionsBy(opts = {}){
        const preset = String(opts.preset || "ALL");
        const mode = String(opts.mode || "ALL");
        const range = String(opts.range || "30D");
        const currentPresetId = String(opts.currentPresetId || _insightsGetPresetMeta().presetId || "");
        const pid = (preset === "CURRENT") ? currentPresetId : preset;
        const key = `${_insightsSessionsRev}|${range}|${pid}|${mode}`;
        if (_insightsFilterCacheMap.has(key)) return _insightsFilterCacheMap.get(key);

        let sessions = _insightsLoadSessions();
        const now = Date.now();
        let cutoff = null;
        if (range === "7D") cutoff = now - 7*86400000;
        if (range === "30D") cutoff = now - 30*86400000;
        if (cutoff != null) sessions = sessions.filter(s => (s?.ts ?? 0) >= cutoff);

        if (preset && preset !== "ALL"){
          sessions = sessions.filter(s => String(s?.presetId || "") === String(pid || ""));
        }
        if (mode && mode !== "ALL"){
          sessions = sessions.filter(s => String(s?.mode || "") === mode);
        }

        _insightsFilterCacheMap.set(key, sessions);
        _insightsFilteredCacheKey = key;
        _insightsFilteredCache = sessions;
        return sessions;
      }
      function _insightsRenderSummary(sessions){
        if (!insightsEl.summary) return;

        const count = sessions.length;
        const totalAnswers = sessions.reduce((acc,s)=>acc+(Number(s.total)||0),0);
        const totalCorrect = sessions.reduce((acc,s)=>acc+(Number(s.correct)||0),0);

        let avgAcc = null;
        if (totalAnswers > 0) avgAcc = totalCorrect / totalAnswers;

        const modeCounts = new Map();
        for (const s of sessions){
          const m = String(s.mode||"");
          if (!m) continue;
          modeCounts.set(m, (modeCounts.get(m)||0)+1);
        }
        let topMode = "";
        let topN = 0;
        for (const [m,n] of modeCounts.entries()){
          if (n > topN){ topN = n; topMode = m; }
        }

        const lastTs = sessions.reduce((mx,s)=>Math.max(mx, Number(s.ts)||0), 0);
        const lastText = lastTs ? _insightsFormatTs(lastTs) : "";

        const avgPct = (avgAcc == null) ? "" : `${Math.round(avgAcc*1000)/10}%`;

        insightsEl.summary.innerHTML = `
          <div class="summary-card"><div class="summary-k">Sessions</div><div class="summary-v">${count}</div></div>
          <div class="summary-card"><div class="summary-k">Answers</div><div class="summary-v">${totalAnswers}</div></div>
          <div class="summary-card"><div class="summary-k">Accuracy</div><div class="summary-v">${avgPct}</div></div>
          <div class="summary-card"><div class="summary-k">Top mode</div><div class="summary-v">${escapeHtml(topMode || "")}</div></div>
          <div class="summary-card"><div class="summary-k">Last</div><div class="summary-v">${escapeHtml(lastText)}</div></div>
        `;
      }

      function _svg(tag){ return document.createElementNS("http://www.w3.org/2000/svg", tag); }
      function _insModeName(m){
        if (m === "SEQ") return "TURN MODE";
        if (m === "RND") return "RUNDOM MODE";
        if (m === "CHOICE") return "EXAM MODE";
        if (m === "HAND") return "WRITE MODE";
        return String(m || "");
      }
      function _insNum(n){ return Number.isFinite(Number(n)) ? Number(n) : 0; }
      function _insFmtPct(num, den){
        if (!den) return "";
        return `${Math.round((num/den)*1000)/10}%`;
      }
      function _insFmtSec(v){
        if (!Number.isFinite(v)) return "";
        return `${Math.round(v*10)/10}`;
      }
      function _insBuildDaily(sessions){
        const map = new Map();
        for (const s of sessions){
          const ymd = String(s?.date || _insightsYmd(s?.ts || Date.now()));
          if (!ymd) continue;
          const b = map.get(ymd) || { ymd, sessions:0, total:0, correct:0, durationMs:0, durationAnswers:0, measuredTimeCount:0 };
          const t = _insNum(s?.total);
          const c = _insNum(s?.correct);
          b.sessions += 1;
          b.total += t;
          b.correct += c;
          const d = Number(s?.durationMs);
          if (Number.isFinite(d) && d > 0 && t > 0){
            b.durationMs += d;
            b.durationAnswers += t;
            b.measuredTimeCount += 1;
          }
          map.set(ymd, b);
        }
        return Array.from(map.values()).sort((a,b)=>String(a.ymd).localeCompare(String(b.ymd)));
      }
      function _insRenderLineChart(container, points, opts = {}){
        if (!container) return;
        container.innerHTML = "";
        if (!Array.isArray(points) || !points.length){
          container.innerHTML = `<div class="insight-empty">${escapeHtml(opts.emptyText || "")}</div>`;
          return;
        }
        const w=600, h=220;
        const padL=44, padR=14, padT=16, padB=34;
        const plotW = w - padL - padR;
        const plotH = h - padT - padB;
        const minY = Number.isFinite(opts.minY) ? opts.minY : 0;
        const maxY = Number.isFinite(opts.maxY) ? opts.maxY : 100;
        const svg = _svg("svg");
        svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
        for (const gv of (opts.gridValues || [minY, (minY+maxY)/2, maxY])){
          const y = padT + (1 - ((gv-minY)/(maxY-minY||1)))*plotH;
          const line = _svg("line");
          line.setAttribute("x1", padL); line.setAttribute("x2", w-padR);
          line.setAttribute("y1", y); line.setAttribute("y2", y);
          line.setAttribute("class", "grid");
          svg.appendChild(line);
          const t = _svg("text");
          t.setAttribute("x", 10); t.setAttribute("y", y+4); t.setAttribute("class", "label");
          t.textContent = (typeof opts.yLabel === "function") ? opts.yLabel(gv) : String(Math.round(gv));
          svg.appendChild(t);
        }
        const ax = _svg("line");
        ax.setAttribute("x1", padL); ax.setAttribute("x2", padL);
        ax.setAttribute("y1", padT); ax.setAttribute("y2", h-padB); ax.setAttribute("class","axis");
        svg.appendChild(ax);
        const bx = _svg("line");
        bx.setAttribute("x1", padL); bx.setAttribute("x2", w-padR);
        bx.setAttribute("y1", h-padB); bx.setAttribute("y2", h-padB); bx.setAttribute("class","axis");
        svg.appendChild(bx);
        const n = points.length;
        const xFor = (idx)=> padL + (n===1 ? plotW/2 : (idx/(n-1))*plotW);
        const yFor = (v)=> padT + (1 - ((v-minY)/(maxY-minY||1)))*plotH;
        let d = "";
        for (let i=0;i<n;i++){
          const x = xFor(i);
          const y = yFor(points[i].v);
          d += (i===0 ? `M ${x} ${y}` : ` L ${x} ${y}`);
        }
        const path = _svg("path");
        path.setAttribute("d", d);
        path.setAttribute("class", "line");
        svg.appendChild(path);
        for (let i=0;i<n;i++){
          const c = _svg("circle");
          c.setAttribute("cx", xFor(i)); c.setAttribute("cy", yFor(points[i].v));
          c.setAttribute("r", 3); c.setAttribute("class", "dot");
          svg.appendChild(c);
        }
        const left = _svg("text");
        left.setAttribute("x", padL); left.setAttribute("y", h-10); left.setAttribute("class","label");
        left.textContent = points[0].label || "";
        svg.appendChild(left);
        const right = _svg("text");
        right.setAttribute("x", w-padR); right.setAttribute("y", h-10);
        right.setAttribute("text-anchor","end"); right.setAttribute("class","label");
        right.textContent = points[n-1].label || "";
        svg.appendChild(right);
        container.appendChild(svg);
      }
      function _insRenderBarChart(container, bars, opts = {}){
        if (!container) return;
        container.innerHTML = "";
        if (!Array.isArray(bars) || !bars.length){
          container.innerHTML = `<div class="insight-empty">${escapeHtml(opts.emptyText || "")}</div>`;
          return;
        }
        const maxV = Math.max(1, ...bars.map(x => Number(x.v) || 0));
        const w=600, h=220;
        const padL=44, padR=14, padT=16, padB=34;
        const plotW = w - padL - padR;
        const plotH = h - padT - padB;
        const svg = _svg("svg");
        svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
        for (const gv of [0, Math.round(maxV/2), maxV]){
          const y = padT + (1 - (gv/maxV))*plotH;
          const line = _svg("line");
          line.setAttribute("x1", padL); line.setAttribute("x2", w-padR);
          line.setAttribute("y1", y); line.setAttribute("y2", y);
          line.setAttribute("class", "grid");
          svg.appendChild(line);
        }
        const cnt = bars.length;
        const gap = 8;
        const bw = Math.max(8, (plotW - gap*(cnt-1)) / cnt);
        for (let i=0;i<cnt;i++){
          const x = padL + i*(bw+gap);
          const v = Number(bars[i].v) || 0;
          const bh = (v/maxV) * plotH;
          const y = padT + (plotH - bh);
          const rect = _svg("rect");
          rect.setAttribute("x", x); rect.setAttribute("y", y);
          rect.setAttribute("width", bw); rect.setAttribute("height", bh);
          rect.setAttribute("rx", 8); rect.setAttribute("class", "bar");
          svg.appendChild(rect);
          const lbl = _svg("text");
          lbl.setAttribute("x", x+bw/2); lbl.setAttribute("y", h-10);
          lbl.setAttribute("text-anchor","middle"); lbl.setAttribute("class","label");
          lbl.textContent = bars[i].label || "";
          svg.appendChild(lbl);
        }
        container.appendChild(svg);
      }
      function _insRenderTable(container, headers, rows, emptyText){
        if (!container) return;
        if (!Array.isArray(rows) || !rows.length){
          container.innerHTML = `<div class="insight-empty">${escapeHtml(emptyText || "")}</div>`;
          return;
        }
        const _td = (cell) => {
          let text = cell;
          let className = "";
          if (cell && typeof cell === "object" && !Array.isArray(cell)){
            text = ("text" in cell) ? cell.text : "";
            className = String(cell.className || "");
          }
          const safeClass = className
            .split(/\s+/)
            .filter(t => /^[a-zA-Z0-9_-]+$/.test(t))
            .join(" ");
          const clsAttr = safeClass ? ` class="${safeClass}"` : "";
          return `<td${clsAttr}>${escapeHtml(String(text ?? ""))}</td>`;
        };
        const thead = `<thead><tr>${headers.map(h => `<th>${escapeHtml(h)}</th>`).join("")}</tr></thead>`;
        const tbody = `<tbody>${rows.map(r => `<tr>${r.map(c => _td(c)).join("")}</tr>`).join("")}</tbody>`;
        container.innerHTML = `<table class="insight-table">${thead}${tbody}</table>`;
      }

      function _insightsRenderTrend(sessions){
        if (!insightsEl.trend) return;
        const points = sessions
          .filter(s => typeof s.accuracy === "number" && isFinite(s.accuracy))
          .map((s,i)=>({i, pct: _insightsClamp(s.accuracy*100, 0, 100), date: s.date || ""}));

        insightsEl.trend.innerHTML = "";

        if (!points.length){
          insightsEl.trend.innerHTML = `<div class="note"></div>`;
          if (insightsEl.trendNote) insightsEl.trendNote.textContent = "";
          return;
        }

        if (insightsEl.trendNote){
          const last = points[points.length-1];
          insightsEl.trendNote.textContent = `latest ${Math.round(last.pct*10)/10}%`;
        }

        const w=600, h=220;
        const padL=44, padR=14, padT=16, padB=34;
        const plotW = w - padL - padR;
        const plotH = h - padT - padB;

        const svg = _svg("svg");
        svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
        svg.setAttribute("aria-label", "Accuracy trend");

        for (const v of [0,25,50,75,100]){
          const y = padT + (1 - v/100)*plotH;
          const line = _svg("line");
          line.setAttribute("x1", padL);
          line.setAttribute("x2", w - padR);
          line.setAttribute("y1", y);
          line.setAttribute("y2", y);
          line.setAttribute("class", "grid");
          svg.appendChild(line);

          const t = _svg("text");
          t.setAttribute("x", 10);
          t.setAttribute("y", y+4);
          t.setAttribute("class", "label");
          t.textContent = `${v}%`;
          svg.appendChild(t);
        }

        const ax = _svg("line");
        ax.setAttribute("x1", padL);
        ax.setAttribute("x2", padL);
        ax.setAttribute("y1", padT);
        ax.setAttribute("y2", h-padB);
        ax.setAttribute("class", "axis");
        svg.appendChild(ax);

        const ax2 = _svg("line");
        ax2.setAttribute("x1", padL);
        ax2.setAttribute("x2", w-padR);
        ax2.setAttribute("y1", h-padB);
        ax2.setAttribute("y2", h-padB);
        ax2.setAttribute("class", "axis");
        svg.appendChild(ax2);

        const n = points.length;
        const xFor = (idx) => padL + (n===1 ? plotW/2 : (idx/(n-1))*plotW);
        const yFor = (pct) => padT + (1 - pct/100)*plotH;

        let d = "";
        for (let i=0;i<n;i++){
          const x = xFor(i);
          const y = yFor(points[i].pct);
          d += (i===0 ? `M ${x} ${y}` : ` L ${x} ${y}`);
        }

        const path = _svg("path");
        path.setAttribute("d", d);
        path.setAttribute("class", "line");
        svg.appendChild(path);

        for (let i=0;i<n;i++){
          const c = _svg("circle");
          c.setAttribute("cx", xFor(i));
          c.setAttribute("cy", yFor(points[i].pct));
          c.setAttribute("r", 3.2);
          c.setAttribute("class", "dot");
          svg.appendChild(c);
        }

        const first = points[0].date || "";
        const last = points[n-1].date || "";
        const tx1 = _svg("text");
        tx1.setAttribute("x", padL);
        tx1.setAttribute("y", h-10);
        tx1.setAttribute("class", "label");
        tx1.textContent = first;
        svg.appendChild(tx1);

        const tx2 = _svg("text");
        tx2.setAttribute("x", w-padR);
        tx2.setAttribute("y", h-10);
        tx2.setAttribute("text-anchor", "end");
        tx2.setAttribute("class", "label");
        tx2.textContent = last;
        svg.appendChild(tx2);

        insightsEl.trend.appendChild(svg);

        try{
          if (!insights.reduceMotion){
            const len = path.getTotalLength();
            path.style.setProperty("--dash", String(Math.ceil(len)));
            path.classList.add("draw-line");
          }
        }catch{}
      }

      function _insightsRenderModeBars(sessions){
        if (!insightsEl.modeChart || !insightsEl.modeCard) return;

        if (insights.mode !== "ALL"){
          insightsEl.modeCard.style.display = "none";
          return;
        }
        insightsEl.modeCard.style.display = "";

        const modes = ["HAND","CHOICE","RND","SEQ"];
        const sums = new Map(modes.map(m=>[m,{c:0,t:0}]));
        for (const s of sessions){
          const m = String(s.mode||"");
          if (!sums.has(m)) continue;
          const t = Number(s.total)||0;
          const c = Number(s.correct)||0;
          if (t<=0) continue;
          const bucket = sums.get(m);
          bucket.t += t;
          bucket.c += c;
        }
        const vals = modes.map(m=>{
          const b = sums.get(m);
          const pct = (b && b.t>0) ? (b.c/b.t)*100 : 0;
          return {m, pct: _insightsClamp(pct,0,100)};
        });

        insightsEl.modeChart.innerHTML = "";

        const w=600, h=220;
        const padL=44, padR=14, padT=16, padB=34;
        const plotW = w - padL - padR;
        const plotH = h - padT - padB;

        const svg = _svg("svg");
        svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
        svg.setAttribute("aria-label", "Accuracy by mode");

        for (const v of [0,50,100]){
          const y = padT + (1 - v/100)*plotH;
          const line = _svg("line");
          line.setAttribute("x1", padL);
          line.setAttribute("x2", w - padR);
          line.setAttribute("y1", y);
          line.setAttribute("y2", y);
          line.setAttribute("class", "grid");
          svg.appendChild(line);

          const t = _svg("text");
          t.setAttribute("x", 10);
          t.setAttribute("y", y+4);
          t.setAttribute("class", "label");
          t.textContent = `${v}%`;
          svg.appendChild(t);
        }

        const ax = _svg("line");
        ax.setAttribute("x1", padL);
        ax.setAttribute("x2", w-padR);
        ax.setAttribute("y1", h-padB);
        ax.setAttribute("y2", h-padB);
        ax.setAttribute("class", "axis");
        svg.appendChild(ax);

        const gap = 14;
        const bw = (plotW - gap*(vals.length-1)) / vals.length;
        const x0 = padL;
        for (let i=0;i<vals.length;i++){
          const x = x0 + i*(bw+gap);
          const barH = (vals[i].pct/100)*plotH;
          const y = padT + (plotH - barH);

          const bg = _svg("rect");
          bg.setAttribute("x", x);
          bg.setAttribute("y", padT);
          bg.setAttribute("width", bw);
          bg.setAttribute("height", plotH);
          bg.setAttribute("rx", 10);
          bg.setAttribute("class", "barBg");
          svg.appendChild(bg);

          const rect = _svg("rect");
          rect.setAttribute("x", x);
          rect.setAttribute("y", y);
          rect.setAttribute("width", bw);
          rect.setAttribute("height", barH);
          rect.setAttribute("rx", 10);
          rect.setAttribute("class", "bar");
          if (!insights.reduceMotion){
            rect.style.transformOrigin = `${x + bw/2}px ${h-padB}px`;
            rect.style.transform = "scaleY(0)";
            rect.style.transition = "transform .55s cubic-bezier(0.22, 1, 0.36, 1)";
            requestAnimationFrame(()=>{ rect.style.transform = "scaleY(1)"; });
          }
          svg.appendChild(rect);

          const lbl = _svg("text");
          lbl.setAttribute("x", x + bw/2);
          lbl.setAttribute("y", h-10);
          lbl.setAttribute("text-anchor", "middle");
          lbl.setAttribute("class", "label");
          lbl.textContent = vals[i].m;
          svg.appendChild(lbl);

          const val = _svg("text");
          val.setAttribute("x", x + bw/2);
          val.setAttribute("y", y - 6);
          val.setAttribute("text-anchor", "middle");
          val.setAttribute("class", "label");
          val.textContent = `${Math.round(vals[i].pct)}%`;
          svg.appendChild(val);
        }

        insightsEl.modeChart.appendChild(svg);
      }

      function _insightsRenderWeakTop10(sessions){
        if (!insightsEl.weak) return;
        insightsEl.weak.innerHTML = "";

        const freq = new Map();
        for (const s of sessions){
          const ids = Array.isArray(s.wrongIds) ? s.wrongIds : [];
          for (const id of ids){
            const n = Number(id);
            if (!Number.isFinite(n)) continue;
            freq.set(n, (freq.get(n)||0)+1);
          }
        }

        const arr = Array.from(freq.entries()).map(([id,c])=>({id, c}));
        arr.sort((a,b)=>b.c-a.c);
        const top = arr.slice(0,10);

        if (!top.length){
          insightsEl.weak.innerHTML = `<div class="note">ID</div>`;
          return;
        }

        const maxC = top.reduce((m,x)=>Math.max(m,x.c),1);
        const byId = (data && data.byId) ? data.byId : null;

        for (const it of top){
          let word = "";
          try{
            const w = byId ? byId.get(it.id) : null;
            word = w ? w.word : "";
          }catch{}
          if (!word) word = "(unknown)";

          const row = document.createElement("div");
          row.className = "weak-item";
          row.innerHTML = `
            <div class="weak-left">
              <div class="weak-top">
                <div class="weak-word">${escapeHtml(word)}</div>
                <div class="weak-no">No.${it.id}</div>
              </div>
              <div class="weak-bar"><i style="width:${Math.round((it.c/maxC)*100)}%"></i></div>
            </div>
            <div class="weak-count">${it.c}</div>
          `;
          insightsEl.weak.appendChild(row);
        }

        if (!insights.reduceMotion){
          requestAnimationFrame(()=>{
            insightsEl.weak.querySelectorAll(".weak-bar > i").forEach((el)=>{ /* transition kicks in */ });
          });
        }
      }

      function _insightsRenderDailyVolume(sessions, container){
        const daily = _insBuildDaily(sessions);
        const bars = daily.map(d => ({ label: d.ymd.slice(5), v: d.total || d.sessions }));
        _insRenderBarChart(container || insightsEl.dailyVolume, bars, { emptyText: "" });
      }
      function _insightsRenderDailyAccuracy(sessions, container){
        const daily = _insBuildDaily(sessions)
          .filter(d => d.total > 0)
          .map(d => ({ label: d.ymd.slice(5), v: (d.correct/d.total) * 100 }));
        _insRenderLineChart(container || insightsEl.dailyAccuracy, daily, {
          minY: 0, maxY: 100, gridValues:[0,25,50,75,100], yLabel:(v)=>`${Math.round(v)}%`,
          emptyText: ""
        });
      }
      function _insightsRenderModeDistribution(sessions, container){
        const modes = ["SEQ","RND","CHOICE","HAND"];
        const rows = [];
        for (const m of modes){
          const arr = sessions.filter(s => String(s?.mode || "") === m);
          const ses = arr.length;
          const total = arr.reduce((a,s)=>a+_insNum(s?.total),0);
          const correct = arr.reduce((a,s)=>a+_insNum(s?.correct),0);
          const dur = arr.filter(s => Number.isFinite(Number(s?.durationMs)) && _insNum(s?.total) > 0);
          const durMs = dur.reduce((a,s)=>a+Number(s.durationMs||0),0);
          const durAns = dur.reduce((a,s)=>a+_insNum(s.total),0);
          rows.push([
            _insModeName(m),
            String(ses),
            String(total),
            _insFmtPct(correct, total),
            durAns > 0 ? _insFmtSec((durMs/1000)/durAns) : ""
          ]);
        }
        _insRenderTable(
          container || insightsEl.modeDistribution,
          ["Mode","","","","(/)"],
          rows
        );
      }
      function _insightsRenderAvgTimeTrend(sessions, container){
        const daily = _insBuildDaily(sessions)
          .filter(d => d.durationAnswers > 0)
          .map(d => ({ label: d.ymd.slice(5), v: (d.durationMs/1000)/d.durationAnswers }));
        if (daily.length < 2){
          _insRenderLineChart(container || insightsEl.avgTimeTrend, [], { emptyText: "durationMs " });
          return;
        }
        const maxY = Math.max(5, ...daily.map(x => x.v)) * 1.1;
        _insRenderLineChart(container || insightsEl.avgTimeTrend, daily, {
          minY:0, maxY, gridValues:[0, maxY/2, maxY], yLabel:(v)=>`${Math.round(v*10)/10}s`
        });
      }
      function _insightsRenderTimeoutByMode(sessions, container){
        const modes = ["SEQ","RND","CHOICE","HAND"];
        const rows = [];
        for (const m of modes){
          const arr = sessions.filter(s => String(s?.mode || "") === m);
          const answers = arr.reduce((a,s)=>a+_insNum(s?.total),0);
          const measured = arr.filter(s => Number.isFinite(Number(s?.timedOutCount)));
          const timeoutCount = measured.reduce((a,s)=>a+_insNum(s?.timedOutCount),0);
          const measuredAnswers = measured.reduce((a,s)=>a+_insNum(s?.total),0);
          rows.push([
            _insModeName(m),
            measured.length ? String(timeoutCount) : "",
            String(answers),
            measuredAnswers > 0 ? _insFmtPct(timeoutCount, measuredAnswers) : ""
          ]);
        }
        _insRenderTable(container || insightsEl.timeoutByMode, ["Mode","","",""], rows);
      }
      function _insightsRangeMetrics(sessions, fromTs, toTs){
        const f = sessions.filter(s => {
          const ts = Number(s?.ts) || 0;
          return ts >= fromTs && ts < toTs;
        });
        const answers = f.reduce((a,s)=>a+_insNum(s?.total),0);
        const correct = f.reduce((a,s)=>a+_insNum(s?.correct),0);
        const durationMs = f.reduce((a,s)=>a+(Number(s?.durationMs)||0),0);
        return { sessions: f.length, answers, correct, durationMs };
      }
      function _insightsRenderCompareTable(container, titleCurrent, cur, prev){
        const _deltaCell = (v, suffix = "", digits = 0) => {
          if (!Number.isFinite(v)){
            return { text: "", className: "is-delta delta-zero" };
          }
          const p = Math.pow(10, Math.max(0, digits));
          const rounded = Math.round(v * p) / p;
          const text = `${rounded > 0 ? "+" : ""}${rounded}${suffix}`;
          const cls = rounded > 0 ? "is-delta delta-pos" : (rounded < 0 ? "is-delta delta-neg" : "is-delta delta-zero");
          return { text, className: cls };
        };
        const curAcc = cur.answers ? (cur.correct / cur.answers) * 100 : null;
        const prevAcc = prev.answers ? (prev.correct / prev.answers) * 100 : null;
        const accDelta = (curAcc == null || prevAcc == null) ? null : (curAcc - prevAcc);
        const rows = [
          ["", cur.answers, prev.answers, _deltaCell(cur.answers - prev.answers)],
          ["", _insFmtPct(cur.correct, cur.answers), _insFmtPct(prev.correct, prev.answers), _deltaCell(accDelta, "%", 1)],
          ["", cur.sessions, prev.sessions, _deltaCell(cur.sessions - prev.sessions)],
          ["", `${Math.round(cur.durationMs/60000)}`, `${Math.round(prev.durationMs/60000)}`,
            _deltaCell((cur.durationMs - prev.durationMs) / 60000, "")]
        ];
        _insRenderTable(container, ["", titleCurrent, "", ""], rows);
      }
      function _insightsRenderComparisons(sessions, weekContainer, monthContainer){
        const now = new Date();
        const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
        const weekStart = todayStart - 7*86400000;
        const prevWeekStart = todayStart - 14*86400000;
        const curWeek = _insightsRangeMetrics(sessions, weekStart, todayStart + 86400000);
        const prevWeek = _insightsRangeMetrics(sessions, prevWeekStart, weekStart);
        _insightsRenderCompareTable(weekContainer || insightsEl.weekCompare, "", curWeek, prevWeek);

        const d30Start = todayStart - 30*86400000;
        const prev30Start = todayStart - 60*86400000;
        const cur30 = _insightsRangeMetrics(sessions, d30Start, todayStart + 86400000);
        const prev30 = _insightsRangeMetrics(sessions, prev30Start, d30Start);
        _insightsRenderCompareTable(monthContainer || insightsEl.monthCompare, "30", cur30, prev30);
      }
      function _insightsRenderACE(sessions, targets = {}){
        _insightsRenderDailyVolume(sessions, targets.dailyVolume || insightsEl.dailyVolume);
        _insightsRenderDailyAccuracy(sessions, targets.dailyAccuracy || insightsEl.dailyAccuracy);
        _insightsRenderModeDistribution(sessions, targets.modeDistribution || insightsEl.modeDistribution);
        _insightsRenderAvgTimeTrend(sessions, targets.avgTimeTrend || insightsEl.avgTimeTrend);
        _insightsRenderTimeoutByMode(sessions, targets.timeoutByMode || insightsEl.timeoutByMode);
        _insightsRenderComparisons(sessions, targets.weekCompare || insightsEl.weekCompare, targets.monthCompare || insightsEl.monthCompare);
      }

      let _insightsRenderQueued = false;
      function _insightsRenderAll(){
        if (!_insightsIsOpen()) return;
        if (_insightsRenderQueued) return;
        _insightsRenderQueued = true;
        requestAnimationFrame(() => {
          _insightsRenderQueued = false;
          if (!_insightsIsOpen()) return;
          const sessions = _insightsGetFilteredSessions();
          _insightsRenderSummary(sessions);
          _insightsRenderTrend(sessions);
          _insightsRenderACE(sessions);
          _insightsRenderModeBars(sessions);
          _insightsRenderWeakTop10(sessions);
        });
      }
      // Events
      insightsEl.btn?.addEventListener("click", () => {
        if (state.view === "TITLE"){
          _appSetTab(APP_TAB_KEY.INSIGHT);
          return;
        }
        _insightsOpen();
      });
      insightsEl.close?.addEventListener("click", () => _insightsClose());

      document.addEventListener("keydown", (e) => {
        if (!_insightsIsOpen()) return;
        const ae = document.activeElement;
        const typing = ae && (ae.tagName === "INPUT" || ae.tagName === "TEXTAREA" || ae.tagName === "SELECT" || ae.isContentEditable);
        if (typing) return;
        if (e.key === "Escape"){
          e.preventDefault();
          _insightsClose();
        }
      });

      insightsEl.presetSel?.addEventListener("change", () => {
        insights.preset = insightsEl.presetSel.value;
        _insightsRenderAll();
      });
      insightsEl.modeSel?.addEventListener("change", () => {
        insights.mode = insightsEl.modeSel.value;
        _insightsRenderAll();
      });
      insightsEl.rangeSel?.addEventListener("change", () => {
        insights.range = insightsEl.rangeSel.value;
        _insightsRenderAll();
      });

      insightsEl.exportBtn?.addEventListener("click", async () => {
        try{
          const sessions = _insightsLoadSessions();
          const blob = new Blob([JSON.stringify(sessions, null, 2)], {type:"application/json"});
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          const d = new Date();
          const y = d.getFullYear();
          const m = String(d.getMonth()+1).padStart(2,"0");
          const da = String(d.getDate()).padStart(2,"0");
          a.download = `wordpractice_sessions_${y}${m}${da}.json`;
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
          uiAlert("", {title:"Insights"});
        }catch{
          uiAlert("", {title:"Insights"});
        }
      });

      insightsEl.deleteBtn?.addEventListener("click", async () => {
        const ok = await uiConfirm("", {
          title: "Insights",
          okText: "",
          cancelText: "",
          danger: true
        });
        if (!ok) return;
        try{
          window.localStorage.removeItem(INSIGHTS_SESSIONS_KEY);
          _insightsSessionsCache = [];
          _insightsSessionsRev++;
          _insightsFilteredCacheKey = "";
          _insightsFilteredCache = null;
          _insightsFilterCacheMap.clear();
          _insightsRenderAll();
          uiAlert("", {title:"Insights"});
        }catch{
          uiAlert("", {title:"Insights"});
        }
      });

      // Boot
      ensureDemoNotification();
      updateNotifyDot();
      setView("TITLE");
      _appSetTab("home");
      renderAll();
      if (el.updateOverlay) el.updateOverlay.classList.add("hidden");
      _backupScheduleAuto();
      _authBindEvents();
      _authBootstrap();
    
      // =========================
      // Hamburger Menu (stable navigation)
      // =========================
      const REPORT_ENDPOINT = ""; // Optional (e.g.) "https://formspree.io/f/xxxxxx"
      const REPORT_TO_EMAIL = ""; // Optional mailto fallback (e.g.) "your@email.com"

      const _menu = { open:false, inited:false };

      function _isTyping(el){
        if (!el) el = document.activeElement;
        if (!el) return false;
        const tag = (el.tagName || "").toLowerCase();
        if (tag === "input" || tag === "textarea" || tag === "select") return true;
        if (el.isContentEditable) return true;
        return false;
      }

      
      function _menuEls(){
        return {
          btn: document.getElementById("menuBtn"),
          overlay: document.getElementById("menuOverlay"),
          panel: document.getElementById("menuPanel"),
          title: document.getElementById("menuTitle"),
          content: document.getElementById("menuContent"),
        };
      }

      const EMAILJS_SERVICE_ID = PUBLIC_RUNTIME_CONFIG.emailjs.serviceId;
      const EMAILJS_TEMPLATE_ID = PUBLIC_RUNTIME_CONFIG.emailjs.templateId;
      const EMAILJS_PUBLIC_KEY = PUBLIC_RUNTIME_CONFIG.emailjs.publicKey;

      const _menuState = {
        inited: false,
        view: "root",
        rootHtml: "",
        reportDraft: { email: "", subject: "", message: "" },
        sending: false,
        emailjsReady: false,
        memoCheck: {
          currentDate: "",
          monthBaseTs: Date.now(),
          selectedBlock: "",
          draftBlocks: []
        },
        presetShare: {
          tab: "share", // share | import
          selectedPresetId: "",
          entry: null,
          creating: false,
          importing: false,
          hashCode: "",
          hashTried: false,
          timerId: null
        }
      };
      const MEMO_CHECK_KEY = "app.memoCheck.v1";
      const MEMO_DEFAULT_BLOCKS = [
        "EXAM",
        "EXAM",
        "EXAM",
        "WRITE",
        "WRITE",
        "WRITE/",
        "WRITE",
        ""
      ];

      function _escapeHtml(s){
        return String(s ?? "")
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function _fmtLocalSentAt(){
        const d = new Date();
        const pad = (n)=> String(n).padStart(2,"0");
        return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
      }

      function _isValidEmail(email){
        // Simple but practical
        return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(String(email || "").trim());
      }

      function _ensureEmailJSInit(){
        if(_menuState.emailjsReady) return true;
        if(!EMAILJS_PUBLIC_KEY || !EMAILJS_SERVICE_ID || !EMAILJS_TEMPLATE_ID){
          return false;
        }
        if(!window.emailjs || typeof window.emailjs.init !== "function") return false;
        try{
          window.emailjs.init(EMAILJS_PUBLIC_KEY);
          _menuState.emailjsReady = true;
          return true;
        }catch(err){
          console.warn("[EmailJS] init failed:", err);
          return false;
        }
      }

      function _setReportStatus(msg, isError){
        const el = document.getElementById("reportStatus");
        if(!el) return;
        el.textContent = msg || "";
        el.classList.toggle("error", !!isError);
      }

      function _renderHelpHTML(){
        return `
<div class="menu-article">
  <h2>VocabuQuiz  + FAQ</h2>
  <p class="mini">
    1
    <code>TURN MODE / RUNDOM MODE / EXAM MODE / WRITE MODE</code> 
    My PresetAdminReport 
  </p>

  <h3></h3>
  <ol>
    <li></li>
    <li></li>
    <li>Preset  Mode  </li>
    <li>TURN MODE</li>
    <li>RUNDOM MODE</li>
    <li>EXAM MODE4</li>
    <li>WRITE MODE</li>
    <li>My Preset</li>
    <li>QR/6</li>
    <li></li>
    <li>Admin</li>
    <li>Report</li>
    <li></li>
    <li></li>
  </ol>

  <hr>

  <h3>1. </h3>
  <p>
    VocabuQuiz     
    My Preset
    My Preset6QR
  </p>
  <ul>
    <li> <code>TURN MODE / RUNDOM MODE / EXAM MODE / WRITE MODE</code> 4</li>
    <li></li>
    <li>Report</li>
  </ul>

  <h3>2. </h3>
  <p></p>
  <ol>
    <li></li>
    <li> / </li>
    <li><code>TURN MODE</code> 1</li>
    <li> <code>EXAM MODE</code>  <code>WRITE MODE</code> </li>
  </ol>
  <p class="mini">
    
  </p>

  <h3>3. Preset  Mode  </h3>
  <ol>
    <li>Preset</li>
    <li><code>TURN MODE</code><code>EXAM MODE</code></li>
    <li></li>
    <li></li>
  </ol>

  <hr>

  <h3>4. TURN MODE</h3>
  <p>
    <code>TURN MODE</code>  No
    
  </p>
  <ol>
    <li> <code>TURN MODE</code> </li>
    <li></li>
    <li></li>
    <li>1</li>
  </ol>
  <p class="mini"></p>

  <h3>5. RUNDOM MODE1</h3>
  <p>
    <code>RUNDOM MODE</code> 
    1
  </p>
  <ol>
    <li> <code>RUNDOM MODE</code> </li>
    <li></li>
    <li>100%</li>
    <li>2</li>
  </ol>

  <h3>6. EXAM MODE4</h3>
  <p>
    <code>EXAM MODE</code> 4
    
  </p>
  <ol>
    <li><code>EXAM MODE</code> </li>
    <li>1</li>
    <li>ON</li>
    <li></li>
  </ol>

  <h3>7. WRITE MODEEnter</h3>
  <p>
    <code>WRITE MODE</code> 
    /Enter
  </p>
  <ol>
    <li><code>WRITE MODE</code> </li>
    <li></li>
    <li><code>Enter</code> </li>
    <li></li>
  </ol>

  <hr>

  <h3>8. My Preset</h3>
  <p>
    My Preset
  </p>
  <ol>
    <li></li>
    <li>3</li>
    <li>No</li>
  </ol>
  <h4>11</h4>
  <pre class="codeblock">1201 adapt 
1202 achieve 
1203 accurate </pre>
  <p class="mini">
    <code>TURN MODE</code> 
  </p>

  <h3>9. QR/6/</h3>
  <p>My Preset</p>
  <ol>
    <li>My Preset</li>
    <li>6QR</li>
    <li>6</li>
    <li></li>
  </ol>
  <p class="mini">
    QR
  </p>

  <h3>10. /</h3>
  <p>
    
    
  </p>
  <ul>
    <li></li>
    <li></li>
    <li></li>
  </ul>
  <p class="mini">
    
  </p>

  <h3>11. Admin</h3>
  <p>
    Admin
    
  </p>
  <ol>
    <li>SettingsAdminGoogle</li>
    <li></li>
    <li></li>
    <li><code>permission-denied</code> <code>unauthorized-domain</code> </li>
  </ol>

  <h3>12. Report</h3>
  <p>
    Report
  </p>
  <ol>
    <li>Report</li>
    <li></li>
    <li></li>
    <li></li>
  </ol>
  <p class="mini"></p>

  <h3>13. </h3>
  <ul>
    <li></li>
    <li>6</li>
    <li></li>
    <li></li>
  </ul>

  <h3>14. </h3>
  <p></p>
  <ol>
    <li><code>TURN MODE</code> 1 + <code>EXAM MODE</code> 11520</li>
    <li> <code>WRITE MODE</code> 2030</li>
    <li>My Preset</li>
  </ol>

  <hr>

  <h2>FAQ / Q&A</h2>
  <p class="mini">Q</p>

  <div class="faq-tools" id="faqTools">
    <label class="faq-search-wrap" for="faqSearchInput">
      <input id="faqSearchInput" class="faq-search" type="search" placeholder="FAQ" autocomplete="off" />
    </label>
    <div class="faq-chip-row" id="faqCategoryRow" role="tablist" aria-label="FAQ">
      <button type="button" class="faq-chip is-active" data-faq-cat="ALL" aria-pressed="true">ALL</button>
      <button type="button" class="faq-chip" data-faq-cat="" aria-pressed="false"></button>
      <button type="button" class="faq-chip" data-faq-cat="" aria-pressed="false"></button>
      <button type="button" class="faq-chip" data-faq-cat="" aria-pressed="false"></button>
      <button type="button" class="faq-chip" data-faq-cat="" aria-pressed="false"></button>
      <button type="button" class="faq-chip" data-faq-cat="" aria-pressed="false"></button>
      <button type="button" class="faq-chip" data-faq-cat="" aria-pressed="false"></button>
    </div>
    <div class="faq-meta">
      <span id="faqResultCount">0</span>
      <span></span>
    </div>
    <div class="faq-empty hidden" id="faqNoResult"></div>
  </div>

  <div class="faq-list">
    <details class="faq">
      <summary>Q. </summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li>My Preset</li>
          <li></li>
          <li>create statusfailed</li>
          <li>Reportstatus</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. </summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li>6O/0I/1</li>
          <li></li>
          <li></li>
          <li>NOT_FOUND</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. Expires</summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li></li>
          <li></li>
          <li></li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. QR / </summary>
      <div class="faq-body">
        <p>A. QR</p>
        <ol>
          <li>6</li>
          <li></li>
          <li>QR</li>
          <li>100%</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. PC</summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li></li>
          <li></li>
          <li>Wi-Fi</li>
          <li>Report</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. permission-denied</summary>
      <div class="faq-body">
        <p>A. Firestore</p>
        <ol>
          <li>Admin</li>
          <li></li>
          <li></li>
          <li></li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. unauthorized-domain </summary>
      <div class="faq-body">
        <p>A. Firebase AuthURL</p>
        <ol>
          <li></li>
          <li>Firebase ConsoleAuth</li>
          <li></li>
          <li>URLwww</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q.  / </summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li></li>
          <li></li>
          <li>Admin</li>
          <li></li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q.  / </summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li></li>
          <li></li>
          <li></li>
          <li>/</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. My Preset</summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li></li>
          <li></li>
          <li></li>
          <li>Report</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. </summary>
      <div class="faq-body">
        <p>A. No</p>
        <ol>
          <li>No <code>No.123</code>  <code>#123</code> </li>
          <li></li>
          <li></li>
          <li></li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. EXAM/WRITE</summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li></li>
          <li></li>
          <li></li>
          <li></li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. </summary>
      <div class="faq-body">
        <p>A. 10</p>
        <ol>
          <li>SettingsEXAM</li>
          <li>1030</li>
          <li>ONOFF</li>
          <li></li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. </summary>
      <div class="faq-body">
        <p>A. BGM/OFF</p>
        <ol>
          <li>SettingsBGMON</li>
          <li>BGM</li>
          <li></li>
          <li>iOS</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. </summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li>Settings   </li>
          <li></li>
          <li>JSONJSON</li>
          <li>My Preset</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. </summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li></li>
          <li></li>
          <li></li>
          <li>JSON</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. </summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li></li>
          <li></li>
          <li></li>
          <li></li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. </summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li> <code>#share=XXXXXX</code> </li>
          <li>Import</li>
          <li></li>
          <li>My Preset</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. </summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li></li>
          <li></li>
          <li></li>
          <li>PC</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. </summary>
      <div class="faq-body">
        <p>A. Report</p>
        <ol>
          <li>Report</li>
          <li></li>
          <li></li>
          <li></li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. </summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li></li>
          <li></li>
          <li>1</li>
          <li></li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. </summary>
      <div class="faq-body">
        <p>A. Insights</p>
        <ol>
          <li><code>EXAM MODE</code>  <code>WRITE MODE</code> 1</li>
          <li>My Preset</li>
          <li> <code>TURN MODE</code>  <code>WRITE MODE</code> </li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. </summary>
      <div class="faq-body">
        <p>A. My Preset</p>
        <ol>
          <li>UI</li>
          <li>My Preset</li>
          <li></li>
          <li>(2)</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. </summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li></li>
          <li></li>
          <li></li>
          <li> <code>TURN MODE</code> </li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. firebaseConfig Admin</summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li><code>config.public.js</code> meta <code>apiKey</code>  <code>projectId</code> </li>
          <li>URL <code>?v=1</code> </li>
          <li>DevTools <code>window.__FIREBASE_CONFIG__</code> </li>
          <li>Admin</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. EXAM MODE  WRITE MODE </summary>
      <div class="faq-body">
        <p>A. EXAMWRITE</p>
        <ol>
          <li><code>EXAM MODE</code> 4</li>
          <li><code>WRITE MODE</code> </li>
          <li>TURN/RUNDOM  EXAM  WRITE</li>
          <li>WRITEEXAM</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. </summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li></li>
          <li> <code>![alt](URL)</code> </li>
          <li><code>[video](URL)</code> </li>
          <li>URL <code>http/https</code> URL</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. </summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li>URL <code>?v=1</code> </li>
          <li></li>
          <li></li>
          <li></li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. Home</summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li>Preset</li>
          <li></li>
          <li></li>
          <li>Library</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. Insights / </summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li>Preset/Mode/</li>
          <li>100%</li>
          <li>Insights</li>
          <li>Report</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. My Preset</summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li>20501</li>
          <li></li>
          <li>EXAM/WRITE1</li>
          <li></li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. Report</summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li></li>
          <li></li>
          <li>Wi-Fi</li>
          <li>Report</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. Chat</summary>
      <div class="faq-body">
        <p>A.  <code>VQ AI mini-1</code> </p>
        <ol>
          <li><code>instant</code> 15</li>
          <li><code>deep</code> 12</li>
          <li></li>
          <li>JST</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. instant  deep </summary>
      <div class="faq-body">
        <p>A. instantdeep</p>
        <ol>
          <li>instant</li>
          <li>deep</li>
          <li>instantdeep</li>
          <li>instant</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. Chat</summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li></li>
          <li></li>
          <li>AI</li>
          <li></li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. </summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li></li>
          <li></li>
          <li></li>
          <li>deepinstant</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. Chat</summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li></li>
          <li></li>
          <li>1</li>
          <li>/Report</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. 400 (Bad Request) </summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li></li>
          <li></li>
          <li></li>
          <li></li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. 404 (Not Found) </summary>
      <div class="faq-body">
        <p>A. Chat APIURL</p>
        <ol>
          <li>DevToolsRequest URLWorker</li>
          <li> <code>?v=1</code> </li>
          <li>API</li>
          <li>404URLReport</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. CORSChat</summary>
      <div class="faq-body">
        <p>A. API</p>
        <ol>
          <li>URLGitHub Pages</li>
          <li> <code>origin null</code> </li>
          <li>WorkerCORS</li>
          <li>NetworkOPTIONS/POSTReport</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. typing</summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li></li>
          <li>Wi-Fi</li>
          <li>OFF</li>
          <li></li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. Chat</summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li></li>
          <li></li>
          <li></li>
          <li>EnterCtrl/Cmd+Enter</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. Chat</summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li></li>
          <li></li>
          <li></li>
          <li></li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. Chat</summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li>/</li>
          <li></li>
          <li>TOP</li>
          <li></li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. Chat / </summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li>instant</li>
          <li>deep</li>
          <li>7</li>
          <li>3</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. Chat</summary>
      <div class="faq-body">
        <p>A.  <code>VQ AI mini-1</code> </p>
        <ol>
          <li></li>
          <li></li>
          <li></li>
          <li></li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. deep</summary>
      <div class="faq-body">
        <p>A. deepinstant</p>
        <ol>
          <li>instant</li>
          <li></li>
          <li>deep</li>
          <li>deep</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. Chat</summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li>TOP</li>
          <li>EXAM/WRITE1</li>
          <li>My Preset</li>
          <li></li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. VQ AI mini-1 instant  deep </summary>
      <div class="faq-body">
        <p>A. instant deep </p>
        <ol>
          <li> instant </li>
          <li> deep </li>
          <li> mode </li>
          <li> mode </li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. instant/deep </summary>
      <div class="faq-body">
        <p>A. 1 instant 5deep 2</p>
        <ol>
          <li> mode </li>
          <li></li>
          <li></li>
          <li> mode </li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. </summary>
      <div class="faq-body">
        <p>A. JST</p>
        <ol>
          <li>:</li>
          <li></li>
          <li></li>
          <li></li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. </summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li></li>
          <li></li>
          <li></li>
          <li></li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. Chat</summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li></li>
          <li></li>
          <li></li>
          <li>OSReport</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. mode</summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li>100%</li>
          <li></li>
          <li></li>
          <li>CSS</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. Enter</summary>
      <div class="faq-body">
        <p>A. Enter Ctrl+EnterMac Cmd+Enter</p>
        <ol>
          <li>Enter</li>
          <li> Ctrl/Cmd+Enter </li>
          <li></li>
          <li>IME</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. 3</summary>
      <div class="faq-body">
        <p>A. AI</p>
        <ol>
          <li></li>
          <li></li>
          <li></li>
          <li></li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. AI</summary>
      <div class="faq-body">
        <p>A. AI</p>
        <ol>
          <li>AI</li>
          <li></li>
          <li></li>
          <li></li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. </summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li>1</li>
          <li></li>
          <li></li>
          <li>Report</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. Workers AI / </summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li></li>
          <li>modeinstantdeep</li>
          <li></li>
          <li></li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. </summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li></li>
          <li></li>
          <li>mode</li>
          <li></li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. Chat</summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li></li>
          <li>UI</li>
          <li></li>
          <li></li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. </summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li></li>
          <li></li>
          <li>1</li>
          <li></li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. </summary>
      <div class="faq-body">
        <p>A. </p>
        <ol>
          <li></li>
          <li></li>
          <li>CSS</li>
          <li>Report</li>
        </ol>
      </div>
    </details>

    <details class="faq">
      <summary>Q. VQ AI mini-1 </summary>
      <div class="faq-body">
        <p>A. instantdeep</p>
        <ol>
          <li>instant</li>
          <li>deep</li>
          <li>EXAM/WRITE</li>
          <li>instant</li>
        </ol>
      </div>
    </details>
  </div>

  <hr>

  <h2>    </h2>

  <h4></h4>
  <p>
    My Preset<br>
    My Presetcreate status
  </p>

  <h4>Admin</h4>
  <p>
    Web Storage<br>
    
  </p>

  <h4></h4>
  <p>
    <br>
    
  </p>

  <h4></h4>
  <p>
    <br>
    JSON
  </p>

  <h4></h4>
  <p>
    <br>
    Settings
  </p>

  <p class="mini">
    Report
    
  </p>
</div>

        `;
      }

      function _renderTermsHTML(){
        return `
          <div class="menu-article">
            <h2></h2>
            <p class="mini">2026218 / 2026218</p>
            <h3></h3>
            <p>
              
              
              
            </p>
            <p>
              
              
            </p>

            <h3>1</h3>
            <p>
              
              
            </p>

            <h3>2</h3>
            <p>
              WebPC
              FAQ
            </p>
            <ul>
              <li></li>
              <li></li>
              <li></li>
            </ul>

            <h3>3</h3>
            <ul>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li>QR</li>
              <li>FirebaseEmailJS</li>
              <li>localStorage</li>
            </ul>

            <h3>4</h3>
            <p>
              
              
              
            </p>

            <h3>5</h3>
            <p>
              
              
            </p>
            <ul>
              <li></li>
              <li></li>
              <li>API</li>
            </ul>

            <h3>6</h3>
            <p>
              TURN MODE / RUNDOM MODE / EXAM MODE / WRITE MODE
              
            </p>
            <p>
              UI
            </p>

            <h3>7</h3>
            <p>
              OS
              
              
            </p>
            <ul>
              <li></li>
              <li></li>
              <li></li>
            </ul>

            <h3>8</h3>
            <p>
              Google
              
            </p>
            <p>
              
              
            </p>

            <h3>9</h3>
            <p>
              
              JSON
            </p>
            <ul>
              <li></li>
              <li>OS</li>
              <li></li>
            </ul>

            <h3>10</h3>
            <p>
              QR
              
            </p>
            <ul>
              <li></li>
              <li></li>
              <li></li>
            </ul>

            <h3>11</h3>
            <p>
              
              
            </p>
            <ul>
              <li>URL</li>
              <li></li>
              <li></li>
            </ul>

            <h3>12</h3>
            <p>
              Report / 
              
            </p>
            <p>
              
            </p>

            <h3>13AI</h3>
            <p>
              
              
            </p>
            <ul>
              <li></li>
              <li></li>
              <li></li>
            </ul>

            <h3>14</h3>
            <p>
              
              
            </p>
            <p>
              
            </p>

            <h3>15</h3>
            <p>
              UI
              
            </p>
            <p>
              
              
            </p>

            <h3>16</h3>
            <p></p>
            <ul>
              <li></li>
              <li></li>
              <li>BotDoS</li>
              <li></li>
              <li>XSS/SQLi</li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
            </ul>

            <h3>17</h3>
            <p>
              
              
            </p>
            <p>
              
            </p>

            <h3>18</h3>
            <p>
              
              
            </p>

            <h3>19</h3>
            <p>
              UI
              
            </p>
            <ul>
              <li></li>
              <li></li>
              <li></li>
            </ul>

            <h3>20</h3>
            <p>
              
              
            </p>

            <h3>21</h3>
            <p>
              API
              
            </p>
            <p>
              
            </p>

            <h3>22</h3>
            <p>
              
              
            </p>
            <ul>
              <li></li>
              <li></li>
              <li></li>
            </ul>

            <h3>23</h3>
            <p>
              
              OS
            </p>
            <ul>
              <li></li>
              <li>Wi-Fi</li>
              <li>Report</li>
            </ul>

            <h3>24</h3>
            <p>
              
              
            </p>

            <h3>25</h3>
            <p>
              
              
            </p>

            <h3>26</h3>
            <p>
              
              
            </p>

            <h3>27</h3>
            <p>
              
              
            </p>

            <h3>28</h3>
            <p>
              
              Report
            </p>

            <h3>29</h3>
            <p>
              
            </p>

            <h3>30</h3>
            <p>
              
              
            </p>

            <h3>31</h3>
            <p>
              
            </p>

            <h3>32</h3>
            <p>
              
            </p>

            <h3>33</h3>
            <p>
              
              
            </p>

            <h3>34</h3>
            <p>
              
              
            </p>
            <p>
              
            </p>

            <h3>35</h3>
            <p>
              
            </p>

            <h3>36</h3>
            <p>
              2026218
            </p>

            <hr>
            <h3>A</h3>
            <p>
              
              
            </p>
            <ul>
              <li></li>
              <li></li>
              <li></li>
              <li>OS</li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
            </ul>

            <h3>B</h3>
            <p>
              
            </p>
            <ul>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
            </ul>

            <h3>C</h3>
            <p>
              
              
            </p>
            <ol>
              <li></li>
              <li>URL</li>
              <li></li>
              <li></li>
              <li>Report</li>
            </ol>

            <h3>D</h3>
            <p>
              
            </p>
            <ul>
              <li>1</li>
              <li></li>
              <li></li>
              <li></li>
              <li>TOP</li>
              <li></li>
              <li></li>
            </ul>

            <h3>E</h3>
            <p>
              
              
            </p>
            <ul>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
            </ul>

            <h3>F</h3>
            <p>
              
              
            </p>
            <ul>
              <li></li>
              <li></li>
              <li></li>
            </ul>

            <h3>G</h3>
            <p>
              
              
            </p>
            <ul>
              <li></li>
              <li></li>
              <li></li>
            </ul>

            <h3>H</h3>
            <p>
              
              
            </p>

            <h3>I</h3>
            <p>
              
              
            </p>
            <ol>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li>JSON</li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li>subjecttag</li>
              <li></li>
              <li></li>
              <li></li>
              <li>QR</li>
              <li>QR</li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li>TOP</li>
              <li></li>
              <li></li>
              <li>API</li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li>UI</li>
            </ol>

            <h3>J</h3>
            <p>
              
              
            </p>
            <ol>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li>FAQ</li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
            </ol>

            <h3>K</h3>
            <p>
              
              
            </p>
            <ol>
              <li></li>
              <li></li>
              <li>My Preset</li>
              <li>QR</li>
              <li></li>
              <li>Admin</li>
              <li>permission-denied</li>
              <li>unauthorized-domain</li>
              <li></li>
              <li></li>
              <li></li>
              <li>Report</li>
              <li></li>
              <li>EXAM MODEWRITE MODE</li>
              <li></li>
              <li>730</li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li>FAQ</li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li>Auto</li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
            </ol>

            <h3>L</h3>
            <p>
              AK
              
              
            </p>
            <p>
              
              
            </p>
          </div>
        `;
      }

      function _renderReportFormHTML(){
        const d = _menuState.reportDraft || { email:"", subject:"", message:"" };
        return `
          <div class="menu-article">
            <h2> / </h2>
            <p class="mini"></p>

            <div id="reportStatus" class="status" aria-live="polite"></div>

            <div class="form-grid">
              <div>
                <label for="reportEmail"></label>
                <input id="reportEmail" class="spell-input" type="email" inputmode="email" autocomplete="email" spellcheck="false"
                  placeholder="you@example.com" value="${_escapeHtml(d.email)}">
              </div>

              <div>
                <label for="reportSubject"></label>
                <input id="reportSubject" class="spell-input" type="text" autocomplete="off" spellcheck="false"
                  placeholder="" value="${_escapeHtml(d.subject)}">
              </div>

              <div>
                <label for="reportMessage"></label>
                <textarea id="reportMessage" class="spell-input" autocomplete="off" spellcheck="false"
                  placeholder="">${_escapeHtml(d.message)}</textarea>
              </div>
            </div>

            <div class="row-actions">
              <button class="btn" type="button" data-report-action="goConfirm"></button>
            </div>
          </div>
        `;
      }

      function _renderReportConfirmHTML(){
        const d = _menuState.reportDraft || { email:"", subject:"", message:"" };
        return `
          <div class="menu-article">
            <h2></h2>
            <p class="mini"></p>

            <div id="reportStatus" class="status" aria-live="polite"></div>

            <h3></h3>
            <pre>${_escapeHtml(d.email)}</pre>

            <h3></h3>
            <pre>${_escapeHtml(d.subject)}</pre>

            <h3></h3>
            <pre>${_escapeHtml(d.message)}</pre>

            <div class="row-actions">
              <button class="btn" type="button" data-report-action="backEdit"></button>
              <button class="btn" type="button" data-report-action="sendConfirm"></button>
            </div>
          </div>
        `;
      }

      function _renderReportDoneHTML(){
        return `
          <div class="menu-article">
            <div class="report-done">
              <svg class="check" viewBox="0 0 96 96" aria-hidden="true">
                <circle cx="48" cy="48" r="38" fill="none" stroke="rgba(34,197,94,.95)" stroke-width="8"></circle>
                <path d="M30 50 L42 62 L68 36" fill="none" stroke="rgba(34,197,94,.95)" stroke-width="8" stroke-linecap="round" stroke-linejoin="round"></path>
              </svg>
              <h2></h2>
              <p></p>

              <div class="row-actions" style="justify-content:center;">
                <button class="btn" type="button" data-report-action="doneClose"></button>
              </div>
            </div>
          </div>
        `;
      }

      function _renderPresetShareHTML(){
        return `
          <div class="menu-article drawer-share">
            <h2></h2>
            <p class="mini">My Preset 6</p>

            <div class="drawer-share-tabs">
              <button class="drawer-share-tab" type="button" id="drawerShareTabSend" data-share-tab="share"></button>
              <button class="drawer-share-tab" type="button" id="drawerShareTabImport" data-share-tab="import"></button>
            </div>

            <section class="drawer-share-panel" id="drawerShareSendPanel">
              <div>
                <div class="note" style="margin-bottom:6px;"> My Preset</div>
                <select id="drawerSharePresetSelect" class="select" aria-label=""></select>
              </div>

              <div class="drawer-share-row">
                <button class="btn" type="button" id="drawerShareCreateBtn" data-share-action="create"></button>
              </div>
              <div id="drawerShareCreateState" class="drawer-share-status">create status: idle</div>

              <div id="drawerShareSendStatus" class="drawer-share-status" aria-live="polite"></div>

              <div class="drawer-share-code" id="drawerShareCode">---</div>
              <div class="drawer-share-sub" id="drawerShareExpires">Expires in --:--</div>

              <div class="drawer-share-actions">
                <button class="textbtn" type="button" id="drawerShareCopyCodeBtn" data-share-action="copyCode" disabled></button>
                <button class="textbtn" type="button" id="drawerShareCopyLinkBtn" data-share-action="copyLink" disabled></button>
              </div>

              <div id="drawerShareQrStatus" class="drawer-share-status">QR</div>
              <img id="drawerShareQrImg" class="drawer-share-qr" alt="Share QR" />
              <div id="drawerShareLinkText" class="drawer-share-link"></div>
            </section>

            <section class="drawer-share-panel hidden" id="drawerShareImportPanel">
              <div>
                <div class="note" style="margin-bottom:6px;">6</div>
                <input id="drawerShareImportCode" class="spell-input" type="text"
                  placeholder="ABC123"
                  inputmode="latin" autocomplete="one-time-code" autocapitalize="characters" spellcheck="false" />
              </div>

              <div class="drawer-share-row">
                <button class="btn" type="button" id="drawerShareImportBtn" data-share-action="import"></button>
              </div>
              <div id="drawerShareImportStatus" class="drawer-share-status" aria-live="polite"></div>
            </section>
          </div>
        `;
      }

      function _memoLoadAll(){
        try{
          const raw = window.localStorage.getItem(MEMO_CHECK_KEY);
          const obj = raw ? JSON.parse(raw) : {};
          return (obj && typeof obj === "object") ? obj : {};
        }catch{ return {}; }
      }
      function _memoSaveAll(obj){
        try{ window.localStorage.setItem(MEMO_CHECK_KEY, JSON.stringify(obj || {})); }catch{}
      }
      function _memoToYmd(ts){
        const d = new Date(ts);
        const y = d.getFullYear();
        const m = String(d.getMonth()+1).padStart(2,"0");
        const da = String(d.getDate()).padStart(2,"0");
        return `${y}-${m}-${da}`;
      }
      function _memoGetDailyStudyCountMap(){
        const map = new Map();
        const sessions = _insightsLoadSessions();
        for (const s of sessions){
          const ymd = String(s?.date || _memoToYmd(s?.ts || Date.now()));
          const v = _insNum(s?.total);
          map.set(ymd, (map.get(ymd) || 0) + v);
        }
        return map;
      }
      function _memoRenderInsightsTop(){
        const presetSel = document.getElementById("memoInsightsPresetSelect");
        const modeSel = document.getElementById("memoInsightsModeSelect");
        const rangeSel = document.getElementById("memoInsightsRangeSelect");
        const currentPresetId = _insightsGetPresetMeta().presetId;
        const opts = {
          preset: (presetSel && presetSel.value) || "CURRENT",
          mode: (modeSel && modeSel.value) || "ALL",
          range: (rangeSel && rangeSel.value) || "30D",
          currentPresetId
        };
        const sessions = _insightsGetFilteredSessionsBy(opts);
        _insightsRenderACE(sessions, {
          dailyVolume: document.getElementById("memoChartDailyVolume"),
          dailyAccuracy: document.getElementById("memoChartDailyAccuracy"),
          modeDistribution: document.getElementById("memoTableModeDistribution"),
          avgTimeTrend: document.getElementById("memoChartAvgTimeTrend"),
          timeoutByMode: document.getElementById("memoTableTimeout"),
          weekCompare: document.getElementById("memoTableWeekCompare"),
          monthCompare: document.getElementById("memoTableMonthCompare"),
        });
      }
      function _renderMemoCheckHTML(){
        const base = new Date(_menuState.memoCheck.monthBaseTs || Date.now());
        const ym = `${base.getFullYear()}-${String(base.getMonth()+1).padStart(2,"0")}`;
        return `
          <div class="memo-check">
            <section class="insight-card">
              <div class="insight-head">
                <div class="insight-title"> Insights</div>
                <div class="insight-note">A / C / E</div>
              </div>
              <div class="insights-filters" style="position:static; padding:10px;">
                <div class="filter-item">
                  <div class="filter-label"></div>
                  <select id="memoInsightsPresetSelect" class="select"></select>
                </div>
                <div class="filter-item">
                  <div class="filter-label"></div>
                  <select id="memoInsightsModeSelect" class="select">
                    <option value="ALL">ALL</option>
                    <option value="HAND">WRITE MODE</option>
                    <option value="CHOICE">EXAM MODE</option>
                    <option value="RND">RANDOM MODE</option>
                    <option value="SEQ">TURN MODE</option>
                  </select>
                </div>
                <div class="filter-item">
                  <div class="filter-label">Range</div>
                  <select id="memoInsightsRangeSelect" class="select">
                    <option value="7D">7D</option>
                    <option value="30D" selected>30D</option>
                    <option value="ALL">ALL</option>
                  </select>
                </div>
              </div>
              <div class="insights-grid" style="margin-top:10px;">
                <section class="insight-card"><div class="insight-head"><div class="insight-title"> </div></div><div class="chart" id="memoChartDailyVolume"></div></section>
                <section class="insight-card"><div class="insight-head"><div class="insight-title"> </div></div><div class="chart" id="memoChartDailyAccuracy"></div></section>
                <section class="insight-card"><div class="insight-head"><div class="insight-title"> </div></div><div class="table-wrap" id="memoTableModeDistribution"></div></section>
                <section class="insight-card"><div class="insight-head"><div class="insight-title"> </div></div><div class="chart" id="memoChartAvgTimeTrend"></div></section>
                <section class="insight-card"><div class="insight-head"><div class="insight-title"></div></div><div class="table-wrap" id="memoTableTimeout"></div></section>
                <section class="insight-card"><div class="insight-head"><div class="insight-title"> vs </div></div><div class="table-wrap" id="memoTableWeekCompare"></div></section>
                <section class="insight-card"><div class="insight-head"><div class="insight-title">30 vs 30</div></div><div class="table-wrap" id="memoTableMonthCompare"></div></section>
              </div>
            </section>
            <section class="memo-calendar">
              <div class="memo-cal-head">
                <button class="textbtn" type="button" data-memo-action="monthPrev"></button>
                <div id="memoMonthLabel">${_escapeHtml(ym)}</div>
                <button class="textbtn" type="button" data-memo-action="monthNext"></button>
              </div>
              <div class="memo-cal-grid" id="memoWeekHeader"></div>
              <div class="memo-cal-grid" id="memoCalendarGrid"></div>
            </section>
          </div>
        `;
      }
      function _memoRenderCalendar(){
        const header = document.getElementById("memoWeekHeader");
        const grid = document.getElementById("memoCalendarGrid");
        const label = document.getElementById("memoMonthLabel");
        if (!grid || !header || !label) return;
        const w = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
        header.innerHTML = w.map(x => `<div class="memo-cal-week">${x}</div>`).join("");
        const base = new Date(_menuState.memoCheck.monthBaseTs || Date.now());
        const y = base.getFullYear();
        const m = base.getMonth();
        label.textContent = `${y}-${String(m+1).padStart(2,"0")}`;
        const first = new Date(y,m,1);
        const start = new Date(y,m,1-first.getDay());
        const daily = _memoGetDailyStudyCountMap();
        const allMemo = _memoLoadAll();
        const maxCount = Math.max(1, ...Array.from(daily.values()));
        const frag = document.createDocumentFragment();
        for (let i=0;i<42;i++){
          const d = new Date(start.getFullYear(), start.getMonth(), start.getDate()+i);
          const ymd = _memoToYmd(d.getTime());
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "memo-day" + (d.getMonth() !== m ? " is-out" : "");
          btn.dataset.memoDate = ymd;
          const c = daily.get(ymd) || 0;
          const alpha = c > 0 ? (0.08 + (c/maxCount)*0.36) : 0.03;
          btn.style.background = `rgba(31,42,68,${alpha.toFixed(3)})`;
          btn.innerHTML = `<div class="d">${d.getDate()}</div>${allMemo[ymd] ? `<div class="dot"></div>` : ``}`;
          frag.appendChild(btn);
        }
        grid.innerHTML = "";
        grid.appendChild(frag);
      }
      function _renderMemoDayHTML(dateYmd){
        const all = _memoLoadAll();
        const rec = all[dateYmd] || {};
        const slots = rec.slots || {};
        const blocks = Array.isArray(rec.blocks) ? rec.blocks : [];
        _menuState.memoCheck.draftBlocks = blocks.slice();
        return `
          <div class="memo-check">
            <section class="insight-card">
              <div class="insight-head">
                <div class="insight-title"></div>
                <div class="insight-note">${_escapeHtml(dateYmd)}</div>
              </div>
              <div class="row-actions" style="justify-content:space-between;">
                <button class="textbtn" type="button" data-memo-action="backCalendar"></button>
                <div class="mini">PC: DnD / Mobile: </div>
              </div>
              <div class="memo-block-pool" id="memoBlockPool">
                ${MEMO_DEFAULT_BLOCKS.map(t => `<button class="memo-block" draggable="true" type="button" data-memo-block="${_escapeHtml(t)}">${_escapeHtml(t)}</button>`).join("")}
              </div>
              <div style="display:flex; gap:8px; margin-top:8px;">
                <input id="memoCustomBlockInput" class="spell-input" type="text" placeholder="" />
                <button class="textbtn" type="button" data-memo-action="addCustomBlock"></button>
              </div>
              <div class="memo-picked" id="memoPickedBlocks">
                ${blocks.map(t => `<span class="memo-tag">${_escapeHtml(t)}</span>`).join("")}
              </div>
              <div class="memo-slots" style="margin-top:10px;">
                <div class="memo-slot" data-memo-slot="rangeText"><label>1) /</label><textarea id="memoRangeText">${_escapeHtml(slots.rangeText || "")}</textarea></div>
                <div class="memo-slot" data-memo-slot="weakText"><label>2) /</label><textarea id="memoWeakText">${_escapeHtml(slots.weakText || "")}</textarea></div>
                <div class="memo-slot" data-memo-slot="reasonText"><label>3) </label><textarea id="memoReasonText">${_escapeHtml(slots.reasonText || "")}</textarea></div>
                <div class="memo-slot" data-memo-slot="memoText"><label>4) </label><textarea id="memoMemoText">${_escapeHtml(slots.memoText || "")}</textarea></div>
              </div>
              <div class="row-actions">
                <button class="btn" type="button" data-memo-action="saveDay"></button>
                <button class="textbtn" type="button" data-memo-action="clearDay"></button>
                <button class="textbtn" type="button" data-memo-action="analyzeDay"></button>
              </div>
            </section>
            <section class="insight-card">
              <div class="insight-head">
                <div class="insight-title"></div>
                <div class="insight-note" id="memoRecommendedNote">${rec.recommended?.ids?.length ? `${rec.recommended.ids.length}` : ""}</div>
              </div>
              <div style="display:flex; gap:8px; margin-bottom:8px;">
                <select id="memoRecommendedMode" class="select" style="max-width:180px;">
                  <option value="AUTO"></option>
                  <option value="CHOICE">EXAM</option>
                  <option value="HAND">WRITE</option>
                </select>
                <button class="btn" type="button" data-memo-action="startRecommended"></button>
              </div>
              <div class="memo-reco-list" id="memoRecoList"></div>
            </section>
          </div>
        `;
      }
      function _memoCollectDayDraft(){
        return {
          rangeText: (document.getElementById("memoRangeText")?.value || "").trim(),
          weakText: (document.getElementById("memoWeakText")?.value || "").trim(),
          reasonText: (document.getElementById("memoReasonText")?.value || "").trim(),
          memoText: (document.getElementById("memoMemoText")?.value || "").trim(),
        };
      }
      function _memoAddPickedBlock(text){
        const t = String(text || "").trim();
        if (!t) return;
        if (!_menuState.memoCheck.draftBlocks.includes(t)){
          _menuState.memoCheck.draftBlocks.push(t);
          const p = document.getElementById("memoPickedBlocks");
          if (p){
            const tag = document.createElement("span");
            tag.className = "memo-tag";
            tag.textContent = t;
            p.appendChild(tag);
          }
        }
      }
      function _memoInsertToSlot(slotName, text){
        const map = { rangeText:"memoRangeText", weakText:"memoWeakText", reasonText:"memoReasonText", memoText:"memoMemoText" };
        const ta = document.getElementById(map[slotName] || "");
        if (!ta) return;
        const cur = ta.value.trim();
        ta.value = cur ? `${cur}\n${text}` : text;
      }
      function _memoAnalyze(dateYmd){
        const all = _memoLoadAll();
        const rec = all[dateYmd] || {};
        const slots = _memoCollectDayDraft();
        const joined = [slots.rangeText, slots.weakText, slots.reasonText, slots.memoText, (_menuState.memoCheck.draftBlocks || []).join(" ")].join("\n");
        const idSet = new Set();
        for (const m of joined.matchAll(/(?:No\.?|#)?\s*(\d{1,4})/gi)){
          const n = Number(m[1]);
          if (Number.isFinite(n)) idSet.add(n);
        }
        const enSet = new Set((joined.match(/\b[a-zA-Z][a-zA-Z'-]{1,}\b/g) || []).map(x => x.toLowerCase()));
        const jpSet = new Set(joined.match(/[---]{2,}/g) || []);
        const words = Array.isArray(data?.words) ? data.words : [];
        const score = new Map();
        const addScore = (id, v) => score.set(id, (score.get(id) || 0) + v);
        for (const w of words){
          const id = Number(w?.id);
          if (!Number.isFinite(id)) continue;
          const word = String(w?.word || "").toLowerCase();
          const meaning = String(w?.meaning || "");
          if (idSet.has(id)) addScore(id, 6);
          for (const t of enSet){ if (t && (word.includes(t) || String(w?.word || "").toLowerCase() === t)) addScore(id, 2); }
          for (const t of jpSet){ if (t && meaning.includes(t)) addScore(id, 2); }
        }
        const sessions = _insightsLoadSessions();
        const wrongFreq = new Map();
        for (const s of sessions){
          const ids = Array.isArray(s?.wrongIds) ? s.wrongIds : [];
          for (const id of ids){
            const n = Number(id);
            if (Number.isFinite(n)) wrongFreq.set(n, (wrongFreq.get(n) || 0) + 1);
          }
        }
        const hasReason = !!(slots.weakText || slots.reasonText);
        if (hasReason){
          for (const [id,c] of wrongFreq.entries()){
            addScore(id, c * 1.8);
          }
        }
        const list = Array.from(score.entries()).map(([id,s])=>({id, score:s})).sort((a,b)=>b.score-a.score).slice(0,50);
        const ids = list.map(x => x.id);
        const reasonText = `${slots.reasonText} ${_menuState.memoCheck.draftBlocks.join(" ")}`;
        let mode = "CHOICE";
        if (/|||||write/i.test(reasonText)) mode = "HAND";
        if (/|||exam/i.test(reasonText)) mode = "CHOICE";
        const recommended = { ids, mode, computedAt: Date.now() };
        all[dateYmd] = {
          blocks: _menuState.memoCheck.draftBlocks.slice(),
          slots,
          recommended,
          updatedAt: Date.now()
        };
        _memoSaveAll(all);
        _memoRenderRecoList(dateYmd);
        const note = document.getElementById("memoRecommendedNote");
        if (note) note.textContent = `${ids.length}`;
      }
      function _memoRenderRecoList(dateYmd){
        const listEl = document.getElementById("memoRecoList");
        if (!listEl) return;
        const all = _memoLoadAll();
        const rec = all[dateYmd]?.recommended || { ids: [] };
        const ids = Array.isArray(rec.ids) ? rec.ids : [];
        if (!ids.length){
          listEl.innerHTML = `<div class="insight-empty"></div>`;
          return;
        }
        const byId = data?.byId || new Map();
        listEl.innerHTML = "";
        const frag = document.createDocumentFragment();
        for (const id of ids.slice(0,50)){
          const w = byId.get(id);
          const row = document.createElement("div");
          row.className = "memo-reco-item";
          row.textContent = `No.${id} ${w?.word || "(unknown)"} / ${w?.meaning || ""}`;
          frag.appendChild(row);
        }
        listEl.appendChild(frag);
      }
      function _memoStartRecommended(dateYmd){
        const all = _memoLoadAll();
        const rec = all[dateYmd]?.recommended;
        const ids = Array.isArray(rec?.ids) ? rec.ids.slice(0, 50) : [];
        if (!ids.length){
          uiAlert("", { title: "" });
          return;
        }
        const sel = document.getElementById("memoRecommendedMode");
        const selected = (sel?.value || "AUTO");
        const mode = (selected === "AUTO") ? (rec.mode || "CHOICE") : selected;
        closeMenu();
        _setRecommendScope(ids);
        if (mode === "HAND") startMode("HAND");
        else startChoiceMode(getChoiceDefaultTimeLimitSec());
      }
      function _battleState(){
        if (!_menuState.battle || typeof _menuState.battle !== "object"){
          _menuState.battle = {
            mode: "EXAM",
            presetId: "builtin:ALL",
            count: 10,
            queueId: "",
            matchId: "",
            match: null,
            result: null,
            statusMsg: "",
            errorMsg: "",
            busy: false,
            polling: false,
            pollTimerId: null,
            questionShownIndex: -1,
            questionShownAt: 0,
            writeDraft: ""
          };
        }
        return _menuState.battle;
      }
      function _battleStopPolling(){
        try{
          const st = _battleState();
          if (st.pollTimerId){
            clearInterval(st.pollTimerId);
            st.pollTimerId = null;
          }
          st.polling = false;
        }catch(_){}
      }
      function _battleRerender(){
        if (_menuState.view !== "onlineBattle") return;
        const content = document.getElementById("menuContent");
        if (!content) return;
        content.innerHTML = _renderOnlineBattleHTML();
        _customSelectEnhance(content);
        _battleInitView();
      }
      function _battleResetProgress(keepPrefs = true){
        const st = _battleState();
        const mode = st.mode;
        const presetId = st.presetId;
        const count = st.count;
        _battleStopPolling();
        st.queueId = "";
        st.matchId = "";
        st.match = null;
        st.result = null;
        st.statusMsg = "";
        st.errorMsg = "";
        st.busy = false;
        st.questionShownIndex = -1;
        st.questionShownAt = 0;
        st.writeDraft = "";
        if (!keepPrefs){
          st.mode = "EXAM";
          st.presetId = "builtin:ALL";
          st.count = 10;
        } else {
          st.mode = mode;
          st.presetId = presetId;
          st.count = count;
        }
      }
      function _battleAuthHeaders(){
        const token = _authGetToken();
        if (!token){
          const err = new Error("");
          err.code = "UNAUTHORIZED";
          throw err;
        }
        return { Authorization: `Bearer ${token}` };
      }
      function _battleQuestionStartIfNeeded(){
        const st = _battleState();
        const you = st.match?.you;
        const idx = Math.max(0, Number(you?.progress || 0));
        if (st.questionShownIndex !== idx){
          st.questionShownIndex = idx;
          st.questionShownAt = Date.now();
          st.writeDraft = "";
        }
      }
      function _battleElapsedMs(){
        const st = _battleState();
        const base = Math.max(0, Number(st.questionShownAt || 0));
        if (!base) return 0;
        return Math.max(0, Date.now() - base);
      }
      function _battleModeLabel(mode){
        return String(mode || "").toUpperCase() === "WRITE" ? "WRITE" : "EXAM";
      }
      function _battleStatusLabel(){
        const st = _battleState();
        if (st.errorMsg) return st.errorMsg;
        if (st.statusMsg) return st.statusMsg;
        if (st.busy) return "";
        if (st.result) return "";
        if (st.matchId && st.match) return "";
        if (st.queueId) return "";
        return "";
      }
      function _battleApplyFormFromDom(){
        const st = _battleState();
        const modeEl = document.getElementById("battleModeSelect");
        const presetEl = document.getElementById("battlePresetSelect");
        const countEl = document.getElementById("battleCountSelect");
        if (modeEl) st.mode = String(modeEl.value || "EXAM").toUpperCase() === "WRITE" ? "WRITE" : "EXAM";
        if (presetEl) st.presetId = String(presetEl.value || "builtin:ALL");
        if (countEl) st.count = Math.max(3, Math.min(20, Number(countEl.value || 10) || 10));
      }
      function _battleRenderPlayerRows(){
        const st = _battleState();
        const players = Array.isArray(st.match?.players) ? st.match.players : [];
        const count = Math.max(1, Number(st.match?.count || st.count || 10));
        if (!players.length) return `<div class="mini"></div>`;
        return players.map((p) => {
          const uid = Number(p?.userId || 0);
          const me = uid === Number(st.match?.you?.userId || 0);
          const progress = Math.max(0, Number(p?.progress || 0));
          const correct = Math.max(0, Number(p?.correct || 0));
          const finished = !!p?.finished;
          return `<div class="insight-card" style="padding:10px; margin-top:8px;">
            <div style="display:flex; justify-content:space-between; gap:8px;">
              <div><strong>${_escapeHtml(String(p?.nickname || `user-${uid}`))}</strong>${me ? ` <span class="mini">()</span>` : ``}</div>
              <div class="mini">${finished ? "" : ""}</div>
            </div>
            <div class="mini" style="margin-top:4px;"> ${progress}/${count}   ${correct}</div>
          </div>`;
        }).join("");
      }
      function _battleRenderQuestionBlock(){
        const st = _battleState();
        if (!st.match) return "";
        const mode = String(st.match.mode || st.mode || "EXAM").toUpperCase();
        const questions = Array.isArray(st.match.questions) ? st.match.questions : [];
        const you = st.match.you || {};
        const idx = Math.max(0, Number(you.progress || 0));
        const count = Math.max(1, Number(st.match.count || questions.length || st.count || 10));
        if (idx >= count){
          return `<div class="insight-card" style="padding:12px; margin-top:10px;">
            <div style="font-weight:700;"></div>
            <div class="mini" style="margin-top:4px;"></div>
            <div class="row-actions" style="margin-top:10px;">
              <button class="btn" type="button" data-battle-action="refreshMatch"></button>
              <button class="textbtn" type="button" data-battle-action="showResult"></button>
            </div>
          </div>`;
        }
        const q = questions[idx];
        if (!q) return `<div class="insight-empty" style="margin-top:10px;"></div>`;
        const header = `<div class="mini"> ${idx + 1}/${count}  No.${Number(q.no || 0)}</div>`;
        const prompt = `<div style="font-weight:700; font-size:16px; margin-top:6px; white-space:pre-wrap;">${_escapeHtml(String(q.prompt || ""))}</div>`;
        if (mode === "WRITE"){
          return `<div class="insight-card" style="padding:12px; margin-top:10px;">
            ${header}
            ${prompt}
            <div style="margin-top:10px;">
              <input id="battleWriteInput" class="spell-input" type="text" placeholder="" value="${_escapeHtml(_battleState().writeDraft || "")}" />
            </div>
            <div class="row-actions" style="margin-top:10px;">
              <button class="btn" type="button" data-battle-action="submitWrite"${st.busy ? " disabled" : ""}></button>
              <button class="textbtn" type="button" data-battle-action="refreshMatch"></button>
            </div>
          </div>`;
        }
        const choices = Array.isArray(q.choices) ? q.choices : [];
        return `<div class="insight-card" style="padding:12px; margin-top:10px;">
          ${header}
          ${prompt}
          <div style="display:grid; gap:8px; margin-top:10px;">
            ${choices.map((c) => `<button class="btn" type="button" data-battle-action="chooseAnswer" data-battle-answer="${_escapeHtml(String(c || ""))}"${st.busy ? " disabled" : ""}>${_escapeHtml(String(c || ""))}</button>`).join("")}
          </div>
          <div class="row-actions" style="margin-top:10px;">
            <button class="textbtn" type="button" data-battle-action="refreshMatch"></button>
          </div>
        </div>`;
      }
      function _renderOnlineBattleHTML(){
        const st = _battleState();
        const token = _authGetToken();
        const mode = _battleModeLabel(st.mode);
        const result = st.result;
        let resultHtml = "";
        if (result){
          const players = Array.isArray(result.players) ? result.players : [];
          resultHtml = `
            <section class="insight-card" style="padding:12px; margin-top:10px;">
              <div class="insight-head"><div class="insight-title"></div><div class="insight-note">${_escapeHtml(_battleModeLabel(result.mode || st.mode))}</div></div>
              <div class="mini">state: ${_escapeHtml(String(result.state || ""))}</div>
              <div style="margin-top:8px;">${players.map((p)=>`<div class="mini">${_escapeHtml(String(p.nickname||""))} /  ${Number(p.correct||0)} /  ${Math.round(Number(p.totalTimeMs||0)/1000)}s${Number(result.winnerUserId||0)===Number(p.userId||0) ? " / " : ""}</div>`).join("")}</div>
              <div class="row-actions" style="margin-top:10px;">
                <button class="btn" type="button" data-battle-action="leaveBattle"></button>
                <button class="textbtn" type="button" data-battle-action="refreshMatch"></button>
              </div>
            </section>`;
        }
        return `
          <div class="menu-article">
            <h3></h3>
            <p class="mini"></p>
            ${!token ? `<div class="insight-empty"></div>` : `
              <section class="insight-card" style="padding:12px;">
                <div class="row-actions" style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:8px; align-items:end;">
                  <div style="min-width:0;">
                    <div class="mini">Mode</div>
                    <select id="battleModeSelect" class="select">
                      <option value="EXAM"${mode==="EXAM"?" selected":""}>EXAM</option>
                      <option value="WRITE"${mode==="WRITE"?" selected":""}>WRITE</option>
                    </select>
                  </div>
                  <div style="min-width:0;">
                    <div class="mini">Preset</div>
                    <select id="battlePresetSelect" class="select">
                      <option value="builtin:ALL"${String(st.presetId)==="builtin:ALL"?" selected":""}>builtin:ALL</option>
                      <option value="builtin:standard_all"${String(st.presetId)==="builtin:standard_all"?" selected":""}>standard_all</option>
                    </select>
                  </div>
                  <div style="min-width:0;">
                    <div class="mini">Count</div>
                    <select id="battleCountSelect" class="select">
                      <option value="5"${Number(st.count)===5?" selected":""}>5</option>
                      <option value="10"${Number(st.count)===10?" selected":""}>10</option>
                      <option value="20"${Number(st.count)===20?" selected":""}>20</option>
                    </select>
                  </div>
                </div>
                <div class="row-actions" style="margin-top:10px;">
                  <button class="btn" type="button" data-battle-action="startQueue"${st.busy || !!st.queueId || !!st.matchId ? " disabled" : ""}></button>
                  <button class="textbtn" type="button" data-battle-action="cancelQueue"${!st.queueId ? " disabled" : ""}></button>
                  <button class="textbtn" type="button" data-battle-action="refreshMatch"${(!st.queueId && !st.matchId) ? " disabled" : ""}></button>
                </div>
                <div class="mini" id="battleStatusLine" style="margin-top:8px;">${_escapeHtml(_battleStatusLabel())}</div>
              </section>
              ${st.queueId ? `<section class="insight-card" style="padding:12px; margin-top:10px;"><div class="mini">queueId: ${_escapeHtml(st.queueId)}</div><div class="mini" style="margin-top:4px;"> 2</div></section>` : ``}
              ${st.match ? `<section class="insight-card" style="padding:12px; margin-top:10px;">
                <div class="insight-head"><div class="insight-title"></div><div class="insight-note">${_escapeHtml(String(st.match.matchId || st.matchId || ""))}</div></div>
                <div class="mini">Preset: ${_escapeHtml(String(st.match.presetId || st.presetId))} / Mode: ${_escapeHtml(_battleModeLabel(st.match.mode || st.mode))}</div>
                ${_battleRenderPlayerRows()}
              </section>${_battleRenderQuestionBlock()}` : ``}
              ${resultHtml}
            `}
          </div>
        `;
      }
      async function _battleQueueStart(){
        const st = _battleState();
        if (st.busy) return;
        try{
          _battleApplyFormFromDom();
          st.busy = true;
          st.errorMsg = "";
          st.statusMsg = "";
          _battleRerender();
          const body = await _authFetch("/api/battle/queue", {
            method: "POST",
            headers: _battleAuthHeaders(),
            body: JSON.stringify({
              presetId: st.presetId,
              mode: st.mode,
              count: st.count
            })
          });
          if (String(body?.status || "") === "MATCHED" && body?.matchId){
            st.queueId = "";
            st.matchId = String(body.matchId);
            st.statusMsg = "";
            await _battleLoadMatch();
          } else {
            st.queueId = String(body?.queueId || "");
            st.matchId = "";
            st.match = null;
            st.result = null;
            st.statusMsg = "";
            _battleBeginPolling();
            _battleRerender();
          }
        }catch(err){
          st.errorMsg = String(err?.message || "");
          uiToast(st.errorMsg);
        }finally{
          st.busy = false;
          _battleRerender();
        }
      }
      async function _battleCancelQueue(){
        const st = _battleState();
        if (!st.queueId || st.busy) return;
        try{
          st.busy = true;
          st.errorMsg = "";
          await _authFetch("/api/battle/cancel", {
            method: "POST",
            headers: _battleAuthHeaders(),
            body: JSON.stringify({ queueId: st.queueId })
          });
          _battleResetProgress(true);
          st.statusMsg = "";
        }catch(err){
          st.errorMsg = String(err?.message || "");
          uiToast(st.errorMsg);
        }finally{
          st.busy = false;
          _battleRerender();
        }
      }
      async function _battlePollStatusOnce(){
        const st = _battleState();
        if (!st.queueId || st.busy) return;
        try{
          const body = await _authFetch(`/api/battle/status?queueId=${encodeURIComponent(st.queueId)}`, {
            method: "GET",
            headers: _battleAuthHeaders()
          });
          const status = String(body?.status || "");
          if (status === "MATCHED" && body?.matchId){
            st.queueId = "";
            st.matchId = String(body.matchId);
            st.statusMsg = "";
            _battleStopPolling();
            await _battleLoadMatch();
            return;
          }
          if (status === "EXPIRED" || status === "NOT_FOUND"){
            _battleStopPolling();
            st.queueId = "";
            st.statusMsg = "";
            _battleRerender();
            return;
          }
          st.statusMsg = "";
          const line = document.getElementById("battleStatusLine");
          if (line) line.textContent = _battleStatusLabel();
        }catch(err){
          st.errorMsg = String(err?.message || "status");
          const line = document.getElementById("battleStatusLine");
          if (line) line.textContent = _battleStatusLabel();
        }
      }
      function _battleBeginPolling(){
        const st = _battleState();
        _battleStopPolling();
        if (!st.queueId) return;
        st.polling = true;
        st.pollTimerId = setInterval(() => {
          if (_menuState.view !== "onlineBattle"){
            _battleStopPolling();
            return;
          }
          _battlePollStatusOnce().catch(() => {});
        }, 2000);
      }
      async function _battleLoadMatch(){
        const st = _battleState();
        if (!st.matchId) return;
        try{
          st.busy = true;
          st.errorMsg = "";
          const body = await _authFetch(`/api/battle/match?matchId=${encodeURIComponent(st.matchId)}`, {
            method: "GET",
            headers: _battleAuthHeaders()
          });
          st.match = body || null;
          st.statusMsg = "";
          st.result = null;
          _battleQuestionStartIfNeeded();
        }catch(err){
          st.errorMsg = String(err?.message || "");
          uiToast(st.errorMsg);
        }finally{
          st.busy = false;
          _battleRerender();
        }
      }
      async function _battleSubmitAnswer(answerText){
        const st = _battleState();
        if (!st.matchId || !st.match || st.busy) return;
        const you = st.match.you || {};
        const index = Math.max(0, Number(you.progress || 0));
        const text = String(answerText || "").trim();
        if (!text){
          uiToast("");
          return;
        }
        try{
          st.busy = true;
          st.errorMsg = "";
          const elapsedMs = _battleElapsedMs();
          const body = await _authFetch("/api/battle/submit", {
            method: "POST",
            headers: _battleAuthHeaders(),
            body: JSON.stringify({
              matchId: st.matchId,
              index,
              answerText: text,
              elapsedMs
            })
          });
          st.statusMsg = body?.correct ? "" : "";
          if (!body?.correct && body?.correctAnswerPreview){
            st.statusMsg += `: ${String(body.correctAnswerPreview)})`;
          }
          st.writeDraft = "";
          if (body?.matchFinished || body?.finished){
            await _battleLoadMatch();
            await _battleFetchResult(false);
          } else {
            await _battleLoadMatch();
          }
        }catch(err){
          st.errorMsg = String(err?.message || "");
          uiToast(st.errorMsg);
        }finally{
          st.busy = false;
          _battleRerender();
        }
      }
      async function _battleFetchResult(rerender = true){
        const st = _battleState();
        if (!st.matchId) return;
        try{
          const body = await _authFetch(`/api/battle/result?matchId=${encodeURIComponent(st.matchId)}`, {
            method: "GET",
            headers: _battleAuthHeaders()
          });
          st.result = body || null;
          st.statusMsg = "";
        }catch(err){
          st.errorMsg = String(err?.message || "");
          uiToast(st.errorMsg);
        }finally{
          if (rerender) _battleRerender();
        }
      }
      function _battleLeave(){
        _battleResetProgress(true);
        _battleRerender();
      }
      function _battleInitView(){
        if (_menuState.view !== "onlineBattle") return;
        const st = _battleState();
        _customSelectEnhance(document.getElementById("menuContent") || document);
        const modeEl = document.getElementById("battleModeSelect");
        const presetEl = document.getElementById("battlePresetSelect");
        const countEl = document.getElementById("battleCountSelect");
        if (modeEl) modeEl.value = _battleModeLabel(st.mode);
        if (presetEl) presetEl.value = String(st.presetId || "builtin:ALL");
        if (countEl) countEl.value = String(Number(st.count || 10));
        if (st.match) _battleQuestionStartIfNeeded();
        if (st.queueId) _battleBeginPolling();
      }
      function _rtBattleState(){
        if (!_menuState.rtBattle || typeof _menuState.rtBattle !== "object"){
          _menuState.rtBattle = {
            mode: "EXAM",
            presetId: "builtin:ALL",
            count: 10,
            roomId: "",
            wsUrl: "",
            socket: null,
            connecting: false,
            connected: false,
            busy: false,
            phase: "IDLE",
            countdown: 0,
            serverState: null,
            result: null,
            statusMsg: "",
            errorMsg: "",
            writeDraft: "",
            questionShownIndex: -1,
            questionShownAt: 0,
            pingTimerId: null
          };
        }
        return _menuState.rtBattle;
      }
      function _rtBattleStopPing(){
        const st = _rtBattleState();
        if (st.pingTimerId){
          clearInterval(st.pingTimerId);
          st.pingTimerId = null;
        }
      }
      function _rtBattleSafeCloseSocket(){
        const st = _rtBattleState();
        const ws = st.socket;
        st.socket = null;
        if (ws){
          try{ ws.onopen = ws.onclose = ws.onerror = ws.onmessage = null; }catch(_){}
          try{ ws.close(); }catch(_){}
        }
      }
      function _rtBattleDisconnect(silent = false){
        const st = _rtBattleState();
        _rtBattleStopPing();
        _rtBattleSafeCloseSocket();
        st.connecting = false;
        st.connected = false;
        if (!silent){
          st.statusMsg = st.statusMsg || "";
        }
      }
      function _rtBattleReset(keepPrefs = true){
        const st = _rtBattleState();
        const mode = st.mode;
        const presetId = st.presetId;
        const count = st.count;
        _rtBattleDisconnect(true);
        st.roomId = "";
        st.wsUrl = "";
        st.busy = false;
        st.phase = "IDLE";
        st.countdown = 0;
        st.serverState = null;
        st.result = null;
        st.statusMsg = "";
        st.errorMsg = "";
        st.writeDraft = "";
        st.questionShownIndex = -1;
        st.questionShownAt = 0;
        if (!keepPrefs){
          st.mode = "EXAM";
          st.presetId = "builtin:ALL";
          st.count = 10;
        } else {
          st.mode = mode;
          st.presetId = presetId;
          st.count = count;
        }
      }
      function _rtBattleAuthTokenRequired(){
        const token = _authGetToken();
        if (!token){
          const err = new Error("");
          err.code = "UNAUTHORIZED";
          throw err;
        }
        return token;
      }
      function _rtBattleApplyFormFromDom(){
        const st = _rtBattleState();
        const modeEl = document.getElementById("rtBattleModeSelect");
        const presetEl = document.getElementById("rtBattlePresetSelect");
        const countEl = document.getElementById("rtBattleCountSelect");
        if (modeEl) st.mode = String(modeEl.value || "EXAM").toUpperCase() === "WRITE" ? "WRITE" : "EXAM";
        if (presetEl) st.presetId = String(presetEl.value || "builtin:ALL");
        if (countEl) st.count = Math.max(3, Math.min(20, Number(countEl.value || 10) || 10));
      }
      function _rtBattleMyUserId(){
        const raw = authState?.user?.id ?? authState?.user?.userId ?? 0;
        return Math.max(0, Number(raw || 0));
      }
      function _rtBattlePlayers(){
        const list = Array.isArray(_rtBattleState().serverState?.players) ? _rtBattleState().serverState.players : [];
        return list.map((p) => ({
          userId: Math.max(0, Number(p?.userId || 0)),
          nickname: String(p?.nickname || ""),
          connected: !!p?.connected,
          ready: !!p?.ready,
          correct: Math.max(0, Number(p?.correct || 0)),
          totalTimeMs: Math.max(0, Number(p?.totalTimeMs || 0)),
          progressIndex: Math.max(0, Number(p?.progressIndex || 0)),
          finished: !!p?.finished
        }));
      }
      function _rtBattleMe(){
        const uid = _rtBattleMyUserId();
        return _rtBattlePlayers().find((p) => p.userId === uid) || null;
      }
      function _rtBattleCurrentQuestion(){
        const st = _rtBattleState();
        const me = _rtBattleMe();
        const idx = Math.max(0, Number(me?.progressIndex || 0));
        const qs = Array.isArray(st.serverState?.questions) ? st.serverState.questions : [];
        const count = Math.max(1, Number(st.serverState?.count || st.count || qs.length || 1));
        return { index: idx, count, done: idx >= count, q: qs[idx] || null };
      }
      function _rtBattleQuestionStartIfNeeded(){
        const st = _rtBattleState();
        const cur = _rtBattleCurrentQuestion();
        if (st.questionShownIndex !== cur.index){
          st.questionShownIndex = cur.index;
          st.questionShownAt = Date.now();
          st.writeDraft = "";
        }
      }
      function _rtBattleElapsedMs(){
        const st = _rtBattleState();
        const base = Math.max(0, Number(st.questionShownAt || 0));
        if (!base) return 0;
        return Math.max(0, Date.now() - base);
      }
      function _rtBattleStatusLabel(){
        const st = _rtBattleState();
        if (st.errorMsg) return st.errorMsg;
        if (st.statusMsg) return st.statusMsg;
        if (st.connecting) return "";
        if (!st.roomId) return "";
        if (st.countdown > 0) return ` ${st.countdown} `;
        if (st.phase === "WAITING") return "";
        if (st.phase === "COUNTDOWN") return "";
        if (st.phase === "RUNNING") return "";
        if (st.phase === "FINISHED") return "";
        return st.connected ? "" : "";
      }
      function _rtBattleModeLabel(mode){
        return String(mode || "").toUpperCase() === "WRITE" ? "WRITE" : "EXAM";
      }
      function _rtBattleSafeSend(payload){
        const st = _rtBattleState();
        const ws = st.socket;
        if (!ws || ws.readyState !== WebSocket.OPEN) return false;
        try{ ws.send(JSON.stringify(payload || {})); return true; }catch{ return false; }
      }
      function _rtBattleRerender(){
        if (_menuState.view !== "onlineBattleRealtime") return;
        const content = document.getElementById("menuContent");
        if (!content) return;
        content.innerHTML = _renderOnlineBattleRealtimeHTML();
        _customSelectEnhance(content);
        _rtBattleInitView();
      }
      function _rtBattleHandleMessage(msg){
        const st = _rtBattleState();
        const type = String(msg?.type || "").toUpperCase();
        if (!type) return;
        if (type === "STATE"){
          st.serverState = (msg && typeof msg.state === "object") ? msg.state : null;
          st.phase = String(st.serverState?.phase || st.phase || "WAITING");
          if (st.phase !== "COUNTDOWN") st.countdown = 0;
          _rtBattleQuestionStartIfNeeded();
          _rtBattleRerender();
          return;
        }
        if (type === "COUNTDOWN"){
          st.phase = "COUNTDOWN";
          st.countdown = Math.max(0, Number(msg?.t || 0));
          st.statusMsg = st.countdown > 0 ? ` ${st.countdown} ` : "";
          _rtBattleRerender();
          return;
        }
        if (type === "RESULT"){
          st.busy = false;
          const correct = !!msg?.correct;
          st.statusMsg = correct ? "" : "";
          const preview = String(msg?.correctAnswerPreview || "");
          if (!correct && preview) st.statusMsg += `: ${preview}`;
          st.writeDraft = "";
          _rtBattleRerender();
          return;
        }
        if (type === "FINISH"){
          st.busy = false;
          st.phase = "FINISHED";
          st.result = msg || null;
          st.statusMsg = "";
          _rtBattleRerender();
          return;
        }
        if (type === "ERROR"){
          st.busy = false;
          st.errorMsg = String(msg?.message || msg?.code || "");
          uiToast(st.errorMsg);
          _rtBattleRerender();
          return;
        }
        if (type === "OPPONENT"){
          _rtBattleRerender();
          return;
        }
      }
      function _rtBattleConnect(wsUrlRaw){
        const st = _rtBattleState();
        const token = _rtBattleAuthTokenRequired();
        const wsUrlSafe = String(wsUrlRaw || st.wsUrl || "").trim();
        if (!wsUrlSafe){ uiToast("WebSocket URL"); return; }
        if (typeof WebSocket !== "function"){ uiToast("WebSocket"); return; }
        _rtBattleDisconnect(true);
        st.errorMsg = "";
        st.statusMsg = "";
        st.connecting = true;
        st.connected = false;
        st.wsUrl = wsUrlSafe;
        _rtBattleRerender();
        let finalUrl = wsUrlSafe;
        try{
          const u = new URL(wsUrlSafe, location.href);
          u.searchParams.set("token", token);
          finalUrl = u.toString();
        }catch{
          finalUrl = wsUrlSafe + (wsUrlSafe.includes("?") ? "&" : "?") + "token=" + encodeURIComponent(token);
        }
        const ws = new WebSocket(finalUrl);
        st.socket = ws;
        ws.onopen = () => {
          if (_rtBattleState().socket !== ws) return;
          st.connecting = false;
          st.connected = true;
          st.statusMsg = "";
          st.errorMsg = "";
          _rtBattleSafeSend({ type: "READY" });
          _rtBattleStopPing();
          st.pingTimerId = setInterval(() => {
            if (!_rtBattleSafeSend({ type: "PING" })) _rtBattleStopPing();
          }, 15000);
          _rtBattleRerender();
        };
        ws.onmessage = (ev) => {
          let msg = null;
          try{ msg = JSON.parse(String(ev?.data || "")); }catch{ msg = null; }
          if (!msg) return;
          _rtBattleHandleMessage(msg);
        };
        ws.onerror = () => {
          if (_rtBattleState().socket !== ws) return;
          st.errorMsg = "";
          st.connecting = false;
          st.connected = false;
          st.busy = false;
          _rtBattleRerender();
        };
        ws.onclose = () => {
          if (_rtBattleState().socket === ws) st.socket = null;
          _rtBattleStopPing();
          st.connecting = false;
          st.connected = false;
          st.busy = false;
          if (_menuState.view === "onlineBattleRealtime" && st.roomId && st.phase !== "FINISHED"){
            st.statusMsg = "";
          }
          _rtBattleRerender();
        };
      }
      async function _rtBattleStart(){
        const st = _rtBattleState();
        if (st.busy || st.connecting) return;
        try{
          _rtBattleApplyFormFromDom();
          st.busy = true;
          st.errorMsg = "";
          st.statusMsg = "";
          _rtBattleRerender();
          const body = await _authFetch("/api/rt/matchmake", {
            method: "POST",
            headers: { Authorization: `Bearer ${_rtBattleAuthTokenRequired()}` },
            body: JSON.stringify({
              presetId: st.presetId,
              mode: st.mode,
              count: st.count
            })
          });
          st.roomId = String(body?.roomId || "");
          st.wsUrl = String(body?.wsUrl || "");
          st.phase = "WAITING";
          st.result = null;
          st.serverState = null;
          st.statusMsg = String(body?.status || "") === "MATCHED" ? "" : "";
          if (!st.wsUrl || !st.roomId) throw new Error("");
          _rtBattleConnect(st.wsUrl);
        }catch(err){
          st.errorMsg = String(err?.message || "");
          st.busy = false;
          uiToast(st.errorMsg);
          _rtBattleRerender();
          return;
        }finally{
          st.busy = false;
          _rtBattleRerender();
        }
      }
      function _rtBattleReconnect(){
        const st = _rtBattleState();
        if (!st.wsUrl){ uiToast(""); return; }
        _rtBattleConnect(st.wsUrl);
      }
      function _rtBattleLeave(){
        _rtBattleSafeSend({ type: "LEAVE" });
        _rtBattleReset(true);
        _rtBattleRerender();
      }
      function _rtBattleSubmitAnswer(answerText){
        const st = _rtBattleState();
        if (!st.connected || st.busy) return;
        const cur = _rtBattleCurrentQuestion();
        if (!cur.q || cur.done){ uiToast(""); return; }
        const text = String(answerText || "").trim();
        if (!text){ uiToast(""); return; }
        const ok = _rtBattleSafeSend({
          type: "ANSWER",
          index: cur.index,
          answerText: text,
          elapsedMs: _rtBattleElapsedMs()
        });
        if (!ok){ uiToast(""); return; }
        st.busy = true;
        st.errorMsg = "";
        st.statusMsg = "";
        _rtBattleRerender();
      }
      function _rtBattleRenderPlayers(){
        const st = _rtBattleState();
        const players = _rtBattlePlayers();
        const myUid = _rtBattleMyUserId();
        const count = Math.max(1, Number(st.serverState?.count || st.count || 10));
        if (!players.length) return `<div class="mini"></div>`;
        return players.map((p) => `<div class="insight-card" style="padding:10px; margin-top:8px;">
          <div style="display:flex; justify-content:space-between; gap:8px;">
            <div><strong>${_escapeHtml(p.nickname || `user-${p.userId}`)}</strong>${p.userId === myUid ? ` <span class="mini">()</span>` : ``}</div>
            <div class="mini">${p.connected ? (p.ready ? "" : "") : ""}</div>
          </div>
          <div class="mini" style="margin-top:4px;"> ${p.progressIndex}/${count}   ${p.correct}  ${Math.round(p.totalTimeMs/1000)}s</div>
        </div>`).join("");
      }
      function _rtBattleRenderQuestionBlock(){
        const st = _rtBattleState();
        const cur = _rtBattleCurrentQuestion();
        const phase = String(st.serverState?.phase || st.phase || "WAITING");
        if (!st.serverState) return "";
        if (phase === "WAITING"){
          return `<div class="insight-card" style="padding:12px; margin-top:10px;"><div class="mini"></div></div>`;
        }
        if (phase === "COUNTDOWN"){
          return `<div class="insight-card" style="padding:12px; margin-top:10px;"><div style="font-weight:700;"> ${Math.max(0, Number(st.countdown || 0))} </div></div>`;
        }
        if (cur.done){
          return `<div class="insight-card" style="padding:12px; margin-top:10px;"><div style="font-weight:700;"></div><div class="mini" style="margin-top:4px;"></div></div>`;
        }
        const q = cur.q;
        if (!q) return `<div class="insight-empty" style="margin-top:10px;"></div>`;
        const mode = _rtBattleModeLabel(st.serverState?.mode || st.mode);
        const header = `<div class="mini"> ${cur.index + 1}/${cur.count}  No.${Number(q.no || 0)}</div>`;
        const prompt = `<div style="font-weight:700; font-size:16px; margin-top:6px; white-space:pre-wrap;">${_escapeHtml(String(q.prompt || ""))}</div>`;
        if (mode === "WRITE"){
          return `<div class="insight-card" style="padding:12px; margin-top:10px;">
            ${header}${prompt}
            <div style="margin-top:10px;"><input id="rtBattleWriteInput" class="spell-input" type="text" placeholder="" value="${_escapeHtml(st.writeDraft || "")}" /></div>
            <div class="row-actions" style="margin-top:10px;">
              <button class="btn" type="button" data-rt-battle-action="submitWrite"${(!st.connected || st.busy) ? " disabled" : ""}></button>
              <button class="textbtn" type="button" data-rt-battle-action="reconnect"></button>
            </div>
          </div>`;
        }
        const choices = Array.isArray(q.choices) ? q.choices : [];
        return `<div class="insight-card" style="padding:12px; margin-top:10px;">
          ${header}${prompt}
          <div style="display:grid; gap:8px; margin-top:10px;">
            ${choices.map((c) => `<button class="btn" type="button" data-rt-battle-action="chooseAnswer" data-rt-battle-answer="${_escapeHtml(String(c || ""))}"${(!st.connected || st.busy) ? " disabled" : ""}>${_escapeHtml(String(c || ""))}</button>`).join("")}
          </div>
          <div class="row-actions" style="margin-top:10px;"><button class="textbtn" type="button" data-rt-battle-action="reconnect"></button></div>
        </div>`;
      }
      function _renderOnlineBattleRealtimeHTML(){
        const st = _rtBattleState();
        const token = _authGetToken();
        const state = st.serverState || {};
        const mode = _rtBattleModeLabel(st.mode);
        const result = st.result;
        const resultHtml = result ? `<section class="insight-card" style="padding:12px; margin-top:10px;">
            <div class="insight-head"><div class="insight-title"></div><div class="insight-note">${_escapeHtml(_rtBattleModeLabel(state.mode || st.mode))}</div></div>
            <div class="mini">: ${_escapeHtml(String(result?.winner?.nickname || ""))}</div>
            <div style="margin-top:8px;">${_rtBattlePlayers().map((p)=>`<div class="mini">${_escapeHtml(p.nickname)} /  ${p.correct} / ${Math.round(p.totalTimeMs/1000)}s</div>`).join("")}</div>
          </section>` : ``;
        return `
          <div class="menu-article">
            <h3></h3>
            <p class="mini">Durable Object + WebSocket</p>
            ${!token ? `<div class="insight-empty"></div>` : `
              <section class="insight-card" style="padding:12px;">
                <div class="row-actions" style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:8px; align-items:end;">
                  <div style="min-width:0;"><div class="mini">Mode</div><select id="rtBattleModeSelect" class="select"><option value="EXAM"${mode==="EXAM"?" selected":""}>EXAM</option><option value="WRITE"${mode==="WRITE"?" selected":""}>WRITE</option></select></div>
                  <div style="min-width:0;"><div class="mini">Preset</div><select id="rtBattlePresetSelect" class="select"><option value="builtin:ALL"${String(st.presetId)==="builtin:ALL"?" selected":""}>builtin:ALL</option><option value="builtin:0-200"${String(st.presetId)==="builtin:0-200"?" selected":""}>builtin:0-200</option></select></div>
                  <div style="min-width:0;"><div class="mini">Count</div><select id="rtBattleCountSelect" class="select"><option value="5"${Number(st.count)===5?" selected":""}>5</option><option value="10"${Number(st.count)===10?" selected":""}>10</option><option value="20"${Number(st.count)===20?" selected":""}>20</option></select></div>
                </div>
                <div class="row-actions" style="margin-top:10px;">
                  <button class="btn" type="button" data-rt-battle-action="start"${st.busy || st.connecting ? " disabled" : ""}></button>
                  <button class="textbtn" type="button" data-rt-battle-action="reconnect"${!st.wsUrl ? " disabled" : ""}></button>
                  <button class="textbtn" type="button" data-rt-battle-action="disconnect"${(!st.roomId && !st.connected && !st.connecting) ? " disabled" : ""}></button>
                </div>
                <div class="mini" id="rtBattleStatusLine" style="margin-top:8px;">${_escapeHtml(_rtBattleStatusLabel())}</div>
                ${st.roomId ? `<div class="mini" style="margin-top:4px;">roomId: ${_escapeHtml(st.roomId)}</div>` : ``}
              </section>
              ${(st.serverState || st.roomId) ? `<section class="insight-card" style="padding:12px; margin-top:10px;">
                <div class="insight-head"><div class="insight-title"></div><div class="insight-note">${_escapeHtml(String(state.phase || st.phase || "WAITING"))}</div></div>
                <div class="mini">Preset: ${_escapeHtml(String(state.presetId || st.presetId || ""))} / Mode: ${_escapeHtml(_rtBattleModeLabel(state.mode || st.mode))}</div>
                ${_rtBattleRenderPlayers()}
              </section>` : ``}
              ${_rtBattleRenderQuestionBlock()}
              ${resultHtml}
            `}
          </div>
        `;
      }
      function _rtBattleInitView(){
        if (_menuState.view !== "onlineBattleRealtime") return;
        const st = _rtBattleState();
        const content = document.getElementById("menuContent") || document;
        _customSelectEnhance(content);
        const modeEl = document.getElementById("rtBattleModeSelect");
        const presetEl = document.getElementById("rtBattlePresetSelect");
        const countEl = document.getElementById("rtBattleCountSelect");
        if (modeEl) modeEl.value = _rtBattleModeLabel(st.mode);
        if (presetEl) presetEl.value = String(st.presetId || "builtin:ALL");
        if (countEl) countEl.value = String(Number(st.count || 10));
        if (st.serverState) _rtBattleQuestionStartIfNeeded();
      }
      const DRAWER_SHARE_TTL_MS = 10 * 60 * 1000;
      let _drawerShareDb = null;

      function _drawerShareSanitizeCode(raw){
        return String(raw || "").toUpperCase().replace(/[^A-Z0-9]/g, "").slice(0, 6);
      }
      function _drawerShareMakeLink(code){
        const c = _drawerShareSanitizeCode(code);
        try{
          if (location && location.origin && location.pathname){
            return `${location.origin}${location.pathname}#share=${encodeURIComponent(c)}`;
          }
        }catch{
          // fall through
        }
        return `#share=${encodeURIComponent(c)}`;
      }
      function _drawerShareCodeFromHash(){
        try{
          const h = String(location.hash || "");
          const m = h.match(/(?:^#|[?&#])share=([A-Za-z0-9]+)/i);
          if (!m) return "";
          return _drawerShareSanitizeCode(m[1]);
        }catch{ return ""; }
      }
      function _drawerShareClearHash(){
        try{
          const clean = `${location.pathname}${location.search || ""}`;
          history.replaceState(null, "", clean);
        }catch{}
      }
      function _drawerShareSetStatus(elId, msg, kind){
        const elx = document.getElementById(elId);
        if (!elx) return;
        elx.textContent = String(msg || "");
        elx.classList.remove("ok","error");
        if (kind === "ok") elx.classList.add("ok");
        if (kind === "error") elx.classList.add("error");
      }
      function _drawerShareSetCreateState(state, detail, isError){
        const elx = document.getElementById("drawerShareCreateState");
        if (!elx) return;
        const base = `create status: ${String(state || "idle")}`;
        elx.textContent = detail ? `${base} / ${String(detail)}` : base;
        elx.classList.remove("ok","error");
        if (isError) elx.classList.add("error");
        else if (state === "saved" || state === "ui-updated") elx.classList.add("ok");
      }
      function _drawerShareCacheGet(presetId){
        const pid = String(presetId || "");
        if (!pid) return null;
        const cache = _shareCacheLoad();
        const e = cache && cache[pid];
        if (!e || typeof e !== "object") return null;
        const code = _drawerShareSanitizeCode(e.code || "");
        const shareLink = String(e.shareLink || e.shareUrl || "");
        const expiresAt = Number(e.expiresAt) || 0;
        if (!/^[A-Z0-9]{6}$/.test(code) || !shareLink || !expiresAt) return null;
        const remain = expiresAt - Date.now();
        if (remain > (DRAWER_SHARE_TTL_MS + 30000)) return null;
        return { code, shareLink, expiresAt };
      }
      function _drawerShareCacheSet(presetId, entry){
        const pid = String(presetId || "");
        if (!pid) return;
        const cache = _shareCacheLoad();
        if (!entry){
          delete cache[pid];
          _shareCacheSave(cache);
          return;
        }
        cache[pid] = {
          code: _drawerShareSanitizeCode(entry.code || ""),
          shareLink: String(entry.shareLink || ""),
          shareUrl: String(entry.shareLink || ""),
          expiresAt: Number(entry.expiresAt) || 0
        };
        _shareCacheSave(cache);
      }
      function _drawerShareGetDb(){
        if (_drawerShareDb) return _drawerShareDb;
        if (!window.firebase || typeof window.firebase.initializeApp !== "function" || !window.firebase.firestore){
          throw new Error("Firebase SDK ");
        }
        // If Firebase app is already initialized elsewhere, reuse it without re-checking config fields.
        if (window.firebase.apps && window.firebase.apps.length){
          _drawerShareDb = window.firebase.app().firestore();
          return _drawerShareDb;
        }
        const cfg = _resolveFirebaseConfigNow();
        if (!cfg || typeof cfg !== "object" || !cfg.apiKey || !cfg.projectId){
          const configured = _normalizeFirebaseConfig(window.__FIREBASE_CONFIG__);
          const missing = [];
          if (!configured.apiKey) missing.push("apiKey");
          if (!configured.projectId) missing.push("projectId");
          const hasPublicRoot = !!(window.__PUBLIC_CONFIG__ && typeof window.__PUBLIC_CONFIG__ === "object");
          throw new Error(`firebaseConfig config.public.js  meta missing=${missing.join(",") || "unknown"} hasPublicConfig=${hasPublicRoot ? "yes" : "no"}`);
        }
        window.firebase.initializeApp(cfg);
        _drawerShareDb = window.firebase.firestore();
        return _drawerShareDb;
      }
      function _drawerShareGenerateCode(){
        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        let out = "";
        for (let i=0;i<6;i++){
          out += chars[Math.floor(Math.random() * chars.length)];
        }
        return out;
      }
      function _drawerSharePresetPayload(preset){
        const modesRaw = (preset && preset.modes && typeof preset.modes === "object")
          ? preset.modes
          : { SEQ:true, RND:true, HAND:true, CHOICE:true };
        const modes = {
          SEQ: !!modesRaw.SEQ,
          RND: !!modesRaw.RND,
          HAND: !!modesRaw.HAND,
          CHOICE: !!modesRaw.CHOICE
        };
        const subjectId = _resolveSubjectId(preset?.subjectId, { fallback: "sub:english", allowMissingCustom: true });
        const isEnglish = _isEnglishSubjectId(subjectId);
        const isMath = _isMathSubjectId(subjectId);
        let words = _normalizeWordList(preset?.words);
        if (!words.length){
          words = _cardsToWordList(_normalizeCardList(preset?.cards, { allowLatex: isMath }));
        }
        words = words.map((w) => ({
          id: w.id,
          word: w.word,
          meaning: w.meaning
        }));
        let cards = _normalizeCardList(preset?.cards, { allowLatex: isMath });
        if (!cards.length && !isEnglish){
          cards = _wordsToCardList(words, { allowLatex: false });
        }
        cards = cards.map((c) => ({
          id: c.id,
          front: c.front,
          back: c.back,
          frontFormat: c.frontFormat,
          backFormat: c.backFormat,
          diagram: _normalizeCardDiagram(c.diagram)
        }));
        const subjectObj = getSubjectById(subjectId);
        const tagIds = _normalizeTagIds(preset?.tagIds, { allowUnknown: true });
        const tagDefs = [];
        for (const tid of tagIds){
          const t = getTagById(tid);
          if (!t) continue;
          tagDefs.push({ id: t.id, name: t.name, color: t.color || "" });
        }
        return {
          name: String(preset?.name || "My Preset"),
          modes,
          words,
          cards,
          subjectId,
          tagIds,
          subject: subjectObj ? { id: subjectObj.id, name: subjectObj.name, color: subjectObj.color || "", builtin: !!subjectObj.builtin } : null,
          tags: tagDefs
        };
      }
      async function _drawerShareCreateEntry(presetId){
        const pid = String(presetId || "");
        const preset = getPresetById(pid);
        if (!preset || preset.builtin){
          throw new Error(" My Preset ");
        }

        const cached = _drawerShareCacheGet(pid);
        if (cached && cached.expiresAt > Date.now() + 1000){
          return { ...cached, reused: true };
        }

        const db = _drawerShareGetDb();
        const payloadPreset = _drawerSharePresetPayload(preset);
        const appVersion = (typeof APP_VERSION === "string" && APP_VERSION) ? APP_VERSION : "v26";
        const expiresAtMs = Date.now() + DRAWER_SHARE_TTL_MS;
        const expiresAtTs = window.firebase.firestore.Timestamp.fromMillis(expiresAtMs);
        const createdAtTs = window.firebase.firestore.FieldValue.serverTimestamp();

        for (let i=0;i<10;i++){
          const code = _drawerShareGenerateCode();
          const ref = db.collection("shares").doc(code);
          try{
            const exists = await ref.get();
            if (exists && exists.exists){
              _drawerShareSetCreateState("collision", `retry ${i+1}/10`);
              continue;
            }
            await ref.set({
              appVersion,
              schemaVersion: 1,
              createdAt: createdAtTs,
              expiresAt: expiresAtTs,
              preset: payloadPreset
            });
            const entry = {
              code,
              shareLink: _drawerShareMakeLink(code),
              shareUrl: _drawerShareMakeLink(code),
              expiresAt: expiresAtMs
            };
            _drawerShareCacheSet(pid, entry);
            _drawerShareSetCreateState("saved");
            return { ...entry, reused: false };
          }catch(err){
            const s = String(err?.code || err?.message || "").toLowerCase();
            if (/already[-_ ]exists|alread[y_ -]?exists/.test(s)){
              _drawerShareSetCreateState("collision", `retry ${i+1}/10`);
              continue;
            }
            if (/permission[-_ ]denied/.test(s)){
              try{
                const again = await ref.get();
                if (again && again.exists){
                  _drawerShareSetCreateState("collision", `retry ${i+1}/10`);
                  continue;
                }
              }catch{}
            }
            throw err;
          }
        }
        const e = new Error("CODE_GEN_FAILED");
        e.kind = "CODE_GEN_FAILED";
        throw e;
      }
      function _drawerShareTsToMs(v){
        if (!v) return 0;
        if (typeof v.toMillis === "function") return Number(v.toMillis()) || 0;
        if (typeof v.seconds === "number"){
          const ns = Number(v.nanoseconds || 0);
          return (Number(v.seconds) * 1000) + Math.floor(ns / 1e6);
        }
        return Number(v) || 0;
      }
      async function _drawerShareFetchByCode(codeRaw){
        const code = _drawerShareSanitizeCode(codeRaw);
        if (!/^[A-Z0-9]{6}$/.test(code)){
          const e = new Error("INVALID_CODE");
          e.kind = "INVALID_CODE";
          throw e;
        }
        const db = _drawerShareGetDb();
        const snap = await db.collection("shares").doc(code).get();
        if (!snap.exists){
          const e = new Error("NOT_FOUND");
          e.kind = "NOT_FOUND";
          throw e;
        }
        const body = snap.data() || {};
        const expMs = _drawerShareTsToMs(body.expiresAt);
        if (!expMs || expMs <= Date.now()){
          const e = new Error("EXPIRED");
          e.kind = "EXPIRED";
          throw e;
        }
        const appVersion = (typeof APP_VERSION === "string" && APP_VERSION) ? APP_VERSION : "v26";
        if (String(body.appVersion || "") !== String(appVersion) || Number(body.schemaVersion || 0) !== 1){
          const e = new Error("VERSION_MISMATCH");
          e.kind = "VERSION_MISMATCH";
          throw e;
        }
        return { code, expMs, body };
      }
      function _drawerShareImportErrorText(err){
        const k = String(err?.kind || err?.message || "");
        if (k === "INVALID_CODE") return "6";
        if (k === "NOT_FOUND") return "NOT_FOUND: ";
        if (k === "EXPIRED") return "EXPIRED: ";
        if (k === "VERSION_MISMATCH") return "VERSION_MISMATCH: ";
        return "";
      }
      function _drawerShareImportPreset(body){
        const src = body && body.preset;
        if (!src || typeof src !== "object"){
          throw new Error("");
        }
        const srcSubject = src.subject && typeof src.subject === "object" ? src.subject : null;
        if (srcSubject && /^subc:[a-z0-9_-]{4,}$/i.test(String(srcSubject.id || "")) && String(srcSubject.name || "").trim()){
          const custom = loadCustomSubjects();
          if (!custom.some((s) => s.id === srcSubject.id)){
            custom.unshift({
              id: String(srcSubject.id),
              name: String(srcSubject.name || "").trim(),
              color: _normalizeMetaColor(srcSubject.color || ""),
              builtin: false
            });
            saveCustomSubjects(custom);
          }
        }
        const srcTags = Array.isArray(src.tags) ? src.tags : [];
        if (srcTags.length){
          const customTags = loadCustomTags();
          let changed = false;
          for (const row of srcTags){
            const n = _normalizeTagItem(row);
            if (!n) continue;
            if (!customTags.some((t) => t.id === n.id)){
              customTags.unshift(n);
              changed = true;
            }
          }
          if (changed) saveCustomTags(customTags);
        }
        const list = loadPresets();
        const baseName = String(src.name || "Shared Preset");
        const name = _uniquePresetName(baseName, list);
        const subjectId = _resolveSubjectId(src.subjectId, { fallback: "sub:english", allowMissingCustom: false });
        const isEnglish = _isEnglishSubjectId(subjectId);
        const isMath = _isMathSubjectId(subjectId);
        let words = _normalizeWordList(src.words);
        if (!words.length){
          words = _cardsToWordList(_normalizeCardList(src.cards, { allowLatex: isMath }));
        }
        let cards = _normalizeCardList(src.cards, { allowLatex: isMath });
        if (!cards.length && !isEnglish){
          cards = _wordsToCardList(words, { allowLatex: false });
        }

        const m = (src.modes && typeof src.modes === "object")
          ? src.modes
          : { SEQ:true, RND:true, HAND:true, CHOICE:true };
        const preset = {
          id: newId(),
          name,
          builtin: false,
          modes: {
            SEQ: !!m.SEQ,
            RND: !!m.RND,
            HAND: !!m.HAND,
            CHOICE: !!m.CHOICE
          },
          words,
          cards,
          subjectId,
          tagIds: _normalizeTagIds(src.tagIds, { allowUnknown: false })
        };
        list.unshift(preset);
        savePresets(list);
        setActivePreset(preset.id);
        try{ refreshPresetList(); }catch{}
        return preset;
      }
      function _drawerShareApplyTab(tab){
        const t = (tab === "import") ? "import" : "share";
        _menuState.presetShare.tab = t;
        const sendTab = document.getElementById("drawerShareTabSend");
        const importTab = document.getElementById("drawerShareTabImport");
        const sendPanel = document.getElementById("drawerShareSendPanel");
        const importPanel = document.getElementById("drawerShareImportPanel");
        if (sendTab) sendTab.classList.toggle("active", t === "share");
        if (importTab) importTab.classList.toggle("active", t === "import");
        if (sendPanel) sendPanel.classList.toggle("hidden", t !== "share");
        if (importPanel) importPanel.classList.toggle("hidden", t !== "import");
      }
      function _drawerShareRenderPresetOptions(){
        const sel = document.getElementById("drawerSharePresetSelect");
        const createBtn = document.getElementById("drawerShareCreateBtn");
        if (!sel) return;
        const list = loadPresets();
        const prev = String(_menuState.presetShare.selectedPresetId || "");
        sel.innerHTML = "";
        if (!list.length){
          const o = document.createElement("option");
          o.value = "";
          o.textContent = "My Preset ";
          sel.appendChild(o);
          sel.disabled = true;
          if (createBtn) createBtn.disabled = true;
          _menuState.presetShare.selectedPresetId = "";
          _customSelectEnhance(document.getElementById("menuContent") || document);
          return;
        }
        sel.disabled = false;
        if (createBtn) createBtn.disabled = false;
        for (const p of list){
          const o = document.createElement("option");
          const count = _presetEntryCount(p);
          const unit = _isEnglishSubjectId(p.subjectId || "sub:english") ? "" : "";
          o.value = p.id;
          o.textContent = `${p.name || "My Preset"} (${count}${unit})`;
          sel.appendChild(o);
        }
        if (prev && list.some(p => p.id === prev)) sel.value = prev;
        else sel.value = list[0].id;
        _menuState.presetShare.selectedPresetId = sel.value;
        _customSelectEnhance(document.getElementById("menuContent") || document);
      }
      function _drawerShareRenderQROnce(shareLink){
        const img = document.getElementById("drawerShareQrImg");
        const status = document.getElementById("drawerShareQrStatus");
        if (!img || !status){
          return;
        }
        img.style.display = "none";
        status.textContent = "QR";
        const src = `https://api.qrserver.com/v1/create-qr-code/?size=240x240&data=${encodeURIComponent(String(shareLink || ""))}`;
        let done = false;
        const timeoutId = setTimeout(() => {
          if (done) return;
          done = true;
          img.style.display = "none";
          status.textContent = "QR";
        }, 5000);
        img.onload = () => {
          if (done) return;
          done = true;
          clearTimeout(timeoutId);
          img.style.display = "block";
          status.textContent = "";
        };
        img.onerror = () => {
          if (done) return;
          done = true;
          clearTimeout(timeoutId);
          img.style.display = "none";
          status.textContent = "QR";
        };
        img.src = src;
      }
      function _drawerShareRenderCountdown(){
        const expEl = document.getElementById("drawerShareExpires");
        if (!expEl) return;
        const exp = Number(_menuState.presetShare.entry?.expiresAt || 0);
        if (!exp){
          expEl.textContent = "Expires in --:--";
          return;
        }
        const ms = exp - Date.now();
        const sec = Math.max(0, Math.floor(ms / 1000));
        const mm = String(Math.floor(sec / 60)).padStart(2, "0");
        const ss = String(sec % 60).padStart(2, "0");
        expEl.textContent = `Expires in ${mm}:${ss}`;
      }
      function _drawerShareStopTimer(){
        const id = _menuState.presetShare.timerId;
        if (id){
          clearInterval(id);
          _menuState.presetShare.timerId = null;
        }
      }
      function _drawerShareStartTimer(){
        _drawerShareStopTimer();
        _drawerShareRenderCountdown();
        _menuState.presetShare.timerId = setInterval(() => {
          if (_menuState.view !== "presetShare"){
            _drawerShareStopTimer();
            return;
          }
          _drawerShareRenderCountdown();
          const entry = _menuState.presetShare.entry;
          if (!entry || !entry.expiresAt) return;
          if (entry.expiresAt <= Date.now() && !_menuState.presetShare.creating){
            _drawerShareCreateNow(true);
          }
        }, 1000);
      }
      function _drawerShareRenderEntry(entry){
        const codeEl = document.getElementById("drawerShareCode");
        const linkEl = document.getElementById("drawerShareLinkText");
        const qrImg = document.getElementById("drawerShareQrImg");
        const qrStatus = document.getElementById("drawerShareQrStatus");
        const copyCodeBtn = document.getElementById("drawerShareCopyCodeBtn");
        const copyLinkBtn = document.getElementById("drawerShareCopyLinkBtn");
        if (!entry){
          if (codeEl) codeEl.textContent = "---";
          if (linkEl) linkEl.textContent = "";
          if (qrImg) qrImg.style.display = "none";
          if (qrStatus) qrStatus.textContent = "QR";
          if (copyCodeBtn) copyCodeBtn.disabled = true;
          if (copyLinkBtn) copyLinkBtn.disabled = true;
          _drawerShareStopTimer();
          _drawerShareRenderCountdown();
          return;
        }
        const code = _drawerShareSanitizeCode(entry.code || "");
        if (codeEl) codeEl.textContent = `${code.slice(0,3)} ${code.slice(3)}`;
        if (linkEl) linkEl.textContent = String(entry.shareLink || "");
        if (copyCodeBtn) copyCodeBtn.disabled = false;
        if (copyLinkBtn) copyLinkBtn.disabled = false;
        _drawerShareRenderQROnce(entry.shareLink);
        _drawerShareRenderCountdown();
        _drawerShareStartTimer();
        _drawerShareSetCreateState("ui-updated");
      }
      async function _drawerShareCreateNow(silent){
        const select = document.getElementById("drawerSharePresetSelect");
        const pid = String((select && select.value) || _menuState.presetShare.selectedPresetId || "");
        if (!pid){
          _drawerShareSetStatus("drawerShareSendStatus", " My Preset ", "error");
          _drawerShareSetCreateState("failed", " My Preset ", true);
          return;
        }
        if (_menuState.presetShare.creating) return;
        _menuState.presetShare.creating = true;
        const btn = document.getElementById("drawerShareCreateBtn");
        if (btn) btn.disabled = true;
        showLoading("");
        _drawerShareSetStatus("drawerShareSendStatus", "");
        _drawerShareSetCreateState("started");
        try{
          const entry = await _drawerShareCreateEntry(pid);
          _menuState.presetShare.selectedPresetId = pid;
          _menuState.presetShare.entry = entry;
          _drawerShareRenderEntry(entry);
          if (!silent){
            const msg = entry.reused ? "" : "";
            _drawerShareSetStatus("drawerShareSendStatus", msg, "ok");
          }
        }catch(err){
          console.warn("[DrawerShare] create failed:", err);
          const msgRaw = String(err?.message || "");
          const msg = (msgRaw === "CODE_GEN_FAILED")
            ? ""
            : `: ${msgRaw || "unknown error"}`;
          _drawerShareSetStatus("drawerShareSendStatus", msg, "error");
          _drawerShareSetCreateState("failed", msgRaw || "unknown error", true);
          _drawerShareRenderEntry(null);
          const qrStatus = document.getElementById("drawerShareQrStatus");
          if (qrStatus) qrStatus.textContent = "QR";
        }finally{
          _menuState.presetShare.creating = false;
          if (btn) btn.disabled = false;
          hideLoading();
        }
      }
      async function _drawerShareImportByCode(codeRaw, fromHash){
        const code = _drawerShareSanitizeCode(codeRaw);
        const input = document.getElementById("drawerShareImportCode");
        if (input) input.value = code;
        if (_menuState.presetShare.importing) return;
        _menuState.presetShare.importing = true;
        const btn = document.getElementById("drawerShareImportBtn");
        if (btn) btn.disabled = true;
        showLoading("");
        _drawerShareSetStatus("drawerShareImportStatus", "");
        try{
          const got = await _drawerShareFetchByCode(code);
          const preset = _drawerShareImportPreset(got.body);
          _drawerShareSetStatus("drawerShareImportStatus", `: ${preset.name}`, "ok");
          _drawerShareRenderPresetOptions();
          if (fromHash){
            _drawerShareClearHash();
            _menuState.presetShare.hashCode = "";
          }
        }catch(err){
          _drawerShareSetStatus("drawerShareImportStatus", _drawerShareImportErrorText(err), "error");
        }finally{
          _menuState.presetShare.importing = false;
          if (btn) btn.disabled = false;
          hideLoading();
        }
      }
      function _drawerShareRefreshBySelection(){
        const sel = document.getElementById("drawerSharePresetSelect");
        const pid = String(sel?.value || "");
        _menuState.presetShare.selectedPresetId = pid;
        if (!pid){
          _menuState.presetShare.entry = null;
          _drawerShareRenderEntry(null);
          _drawerShareSetCreateState("idle");
          return;
        }
        const cached = _drawerShareCacheGet(pid);
        if (cached && cached.expiresAt > Date.now() + 1000){
          _menuState.presetShare.entry = cached;
          _drawerShareRenderEntry(cached);
          _drawerShareSetStatus("drawerShareSendStatus", "", "ok");
          _drawerShareSetCreateState("ui-updated", "cached");
        } else {
          _menuState.presetShare.entry = null;
          _drawerShareRenderEntry(null);
          _drawerShareSetStatus("drawerShareSendStatus", "", "");
          _drawerShareSetCreateState("idle");
        }
      }
      function _drawerShareInitView(){
        if (_menuState.view !== "presetShare") return;
        _drawerShareRenderPresetOptions();
        _drawerShareApplyTab(_menuState.presetShare.tab || "share");
        _drawerShareRefreshBySelection();

        const importInput = document.getElementById("drawerShareImportCode");
        if (importInput){
          const pre = _drawerShareSanitizeCode(importInput.value || "");
          if (pre !== importInput.value) importInput.value = pre;
        }

        const hashCode = _menuState.presetShare.hashCode || _drawerShareCodeFromHash();
        if (hashCode){
          _menuState.presetShare.tab = "import";
          _drawerShareApplyTab("import");
          if (importInput) importInput.value = hashCode;
          if (!_menuState.presetShare.hashTried){
            _menuState.presetShare.hashTried = true;
            _drawerShareImportByCode(hashCode, true);
          }
        }
      }
      function _memoInitView(){
        if (_menuState.view === "memoCheck"){
          _insightsBuildPresetOptions();
          const src = document.getElementById("insightsPresetSelect");
          const dst = document.getElementById("memoInsightsPresetSelect");
          if (src && dst){
            dst.innerHTML = src.innerHTML;
            dst.value = insights.preset || "CURRENT";
          }
          const m = document.getElementById("memoInsightsModeSelect");
          const r = document.getElementById("memoInsightsRangeSelect");
          if (m) m.value = insights.mode || "ALL";
          if (r) r.value = insights.range || "30D";
          _customSelectEnhance(document.getElementById("menuContent") || document);
          _memoRenderInsightsTop();
          _memoRenderCalendar();
        } else if (_menuState.view === "memoDay"){
          _memoRenderRecoList(_menuState.memoCheck.currentDate);
          const all = _memoLoadAll();
          const recMode = all[_menuState.memoCheck.currentDate]?.recommended?.mode || "CHOICE";
          const modeEl = document.getElementById("memoRecommendedMode");
          if (modeEl) modeEl.value = recMode;
          _customSelectEnhance(document.getElementById("menuContent") || document);
        } else if (_menuState.view === "presetShare"){
          _drawerShareInitView();
          _customSelectEnhance(document.getElementById("menuContent") || document);
        } else if (_menuState.view === "onlineBattle"){
          _battleInitView();
          _customSelectEnhance(document.getElementById("menuContent") || document);
        } else if (_menuState.view === "onlineBattleRealtime"){
          _rtBattleInitView();
          _customSelectEnhance(document.getElementById("menuContent") || document);
        }
      }

      function _setMenuView(view){
        const { overlay, panel, title, content } = _menuEls();
        if(!panel || !title || !content) return;
        _customSelectClose();

        if(!_menuState.rootHtml){
          _menuState.rootHtml = content.innerHTML || "";
        }

        _menuState.view = view;

        let ttl = "MENU";
        let html = _menuState.rootHtml;

        if(view === "root"){
          panel.classList.remove("has-back");
          ttl = "MENU";
          html = _menuState.rootHtml;
        } else {
          panel.classList.add("has-back");
          if(view === "help"){ ttl = "Help"; html = _renderHelpHTML(); }
          else if(view === "terms"){ ttl = "Terms"; html = _renderTermsHTML(); }
          else if(view === "report"){ ttl = "Report"; html = _renderReportFormHTML(); }
          else if(view === "reportConfirm"){ ttl = "Report"; html = _renderReportConfirmHTML(); }
          else if(view === "reportDone"){ ttl = "Report"; html = _renderReportDoneHTML(); }
          else if(view === "memoCheck"){ ttl = ""; html = _renderMemoCheckHTML(); }
          else if(view === "memoDay"){ ttl = ""; html = _renderMemoDayHTML(_menuState.memoCheck.currentDate || _memoToYmd(Date.now())); }
          else if(view === "presetShare"){ ttl = ""; html = _renderPresetShareHTML(); }
          else if(view === "onlineBattle"){ ttl = ""; html = _renderOnlineBattleHTML(); }
          else if(view === "onlineBattleRealtime"){ ttl = ""; html = _renderOnlineBattleRealtimeHTML(); }
          else { ttl = "MENU"; html = _menuState.rootHtml; panel.classList.remove("has-back"); _menuState.view = "root"; }
        }

        if (view !== "presetShare") _drawerShareStopTimer();
        if (view !== "onlineBattle"){ try{ _battleStopPolling(); }catch(_){} }
        if (view !== "onlineBattleRealtime"){
          try{
            const st = (_menuState && _menuState.rtBattle && typeof _menuState.rtBattle === "object") ? _menuState.rtBattle : null;
            if (!(st && st.overlayOpen)) _rtBattleDisconnect(true);
          }catch(_){}
        }

        const isMemoFull = (view === "memoCheck" || view === "memoDay");
        panel.classList.toggle("memo-full", isMemoFull);
        if (overlay) overlay.classList.toggle("memo-full", isMemoFull);

        title.textContent = ttl;
        content.innerHTML = html;
        _customSelectEnhance(content);

        // Always show the top of the content
        try{ content.scrollTop = 0; }catch(_){}
        requestAnimationFrame(()=>{
          try{ content.focus({ preventScroll: true }); }catch(_){}
        });
        if (view === "help"){
          _faqInitHelpTools();
        }
        _memoInitView();
      }

      const MENU_CLOSE_FALLBACK_MS = 360;
      const FAQ_TOGGLE_MS = 220;
      let _menuCloseTimerId = null;
      let _menuCloseToken = 0;

      function _menuReducedMotion(){
        return _isMotionReduced();
      }

      function _menuNotifyNotFound(){
        try{ uiToast("drawer not found"); }catch{}
      }

      function _menuFinalizeClose(overlay, panel){
        if (!overlay || !panel) return;
        _customSelectClose();
        overlay.classList.remove("open", "is-open", "is-closing", "memo-full");
        panel.classList.remove("open", "is-open", "is-closing", "has-back", "memo-full");
        overlay.hidden = true;
        panel.hidden = true;
        overlay.setAttribute("aria-hidden", "true");
        panel.setAttribute("aria-hidden", "true");
        _menuState.view = "root";
      }

      function _menuCancelCloseWait(){
        _menuCloseToken += 1;
        if (_menuCloseTimerId){
          clearTimeout(_menuCloseTimerId);
          _menuCloseTimerId = null;
        }
      }

      function _faqReducedMotion(){
        return _menuReducedMotion();
      }

      const FAQ_SEARCH_DEBOUNCE_MS = 100;
      const _faqFilterState = {
        timer: null,
        query: "",
        category: "ALL"
      };
      function _faqNormalizeText(text){
        return String(text || "").toLowerCase().replace(/\s+/g, " ").trim();
      }
      function _faqInferCategory(summaryText, bodyText){
        const s = _faqNormalizeText(`${summaryText} ${bodyText}`);
        if (!s) return "";
        if (/|qr|6||import|export|share/.test(s)) return "";
        if (/||video||/.test(s)) return "";
        if (/my preset|preset|||/.test(s)) return "";
        if (/|theme|bgm|||display|theme|admin login|chat|instant|deep|vq ai|token|max_tokens|quota|/.test(s)) return "";
        if (/permission-denied|unauthorized-domain|firebaseconfig|||||||404|400|api\/ai\/chat|workers ai|origin null/.test(s)) return "";
        return "";
      }
      function _faqApplyFilter(){
        const panel = document.getElementById("menuPanel");
        if (!panel || _menuState.view !== "help") return;
        const list = panel.querySelector(".faq-list");
        if (!list) return;

        const details = Array.from(list.querySelectorAll("details.faq"));
        const q = _faqNormalizeText(_faqFilterState.query);
        const cat = _faqFilterState.category || "ALL";
        let hit = 0;

        details.forEach((item) => {
          const hay = _faqNormalizeText(item.dataset.faqSearch || "");
          const itemCat = item.dataset.faqCategory || "";
          const okCat = (cat === "ALL") || (itemCat === cat);
          const okQ = !q || hay.includes(q);
          const show = okCat && okQ;
          item.classList.toggle("is-hidden", !show);
          if (show) hit += 1;
        });

        const countEl = panel.querySelector("#faqResultCount");
        if (countEl) countEl.textContent = `${hit}`;
        const emptyEl = panel.querySelector("#faqNoResult");
        if (emptyEl) emptyEl.classList.toggle("hidden", hit > 0);
      }
      function _faqScheduleFilter(){
        if (_faqFilterState.timer){
          clearTimeout(_faqFilterState.timer);
          _faqFilterState.timer = null;
        }
        _faqFilterState.timer = setTimeout(() => {
          _faqFilterState.timer = null;
          _faqApplyFilter();
        }, FAQ_SEARCH_DEBOUNCE_MS);
      }
      function _faqInitHelpTools(){
        const panel = document.getElementById("menuPanel");
        if (!panel || _menuState.view !== "help") return;
        const list = panel.querySelector(".faq-list");
        if (!list) return;
        const details = Array.from(list.querySelectorAll("details.faq"));
        details.forEach((item) => {
          const summaryText = item.querySelector("summary")?.textContent || "";
          const bodyText = item.querySelector(".faq-body")?.textContent || "";
          const presetCat = item.dataset.faqCat || "";
          const cat = presetCat || _faqInferCategory(summaryText, bodyText);
          item.dataset.faqCategory = cat;
          item.dataset.faqSearch = _faqNormalizeText(`${summaryText} ${bodyText}`);
        });

        const input = panel.querySelector("#faqSearchInput");
        if (input){
          _faqFilterState.query = String(input.value || "");
        } else {
          _faqFilterState.query = "";
        }
        _faqFilterState.category = "ALL";

        const chips = Array.from(panel.querySelectorAll(".faq-chip[data-faq-cat]"));
        chips.forEach((chip) => {
          const on = String(chip.getAttribute("data-faq-cat") || "ALL") === "ALL";
          chip.classList.toggle("is-active", on);
          chip.setAttribute("aria-pressed", on ? "true" : "false");
        });

        _faqApplyFilter();
      }

      function _faqAnimateToggle(details){
        if (!(details instanceof HTMLElement)) return;
        const body = details.querySelector(":scope > .faq-body") || details.querySelector(".faq-body");
        if (!(body instanceof HTMLElement)){
          details.open = !details.open;
          return;
        }
        if (details.dataset.animating === "1") return;

        const opening = !details.open;
        if (_faqReducedMotion()){
          details.open = opening;
          body.style.height = "";
          body.style.opacity = "";
          body.style.overflow = "";
          body.style.transition = "";
          body.style.willChange = "";
          details.dataset.animating = "";
          return;
        }

        details.dataset.animating = "1";
        const ease = "cubic-bezier(.22,1,.36,1)";
        const finish = (fn) => {
          details.dataset.animating = "";
          body.style.height = "";
          body.style.opacity = "";
          body.style.overflow = "";
          body.style.transition = "";
          body.style.willChange = "";
          if (typeof fn === "function") fn();
        };

        if (opening){
          details.open = true;
          body.style.overflow = "hidden";
          body.style.willChange = "height, opacity";
          body.style.transition = "none";
          body.style.height = "0px";
          body.style.opacity = "0";
          void body.offsetHeight;
          const target = Math.max(0, Math.ceil(body.scrollHeight));
          body.style.transition = `height ${FAQ_TOGGLE_MS}ms ${ease}, opacity ${FAQ_TOGGLE_MS}ms ${ease}`;
          requestAnimationFrame(() => {
            body.style.height = `${target}px`;
            body.style.opacity = "1";
          });

          let done = false;
          const clear = () => {
            if (done) return;
            done = true;
            body.removeEventListener("transitionend", onEnd);
            finish();
          };
          const onEnd = (ev) => {
            if (ev.target !== body) return;
            if (ev.propertyName !== "height" && ev.propertyName !== "opacity") return;
            clear();
          };
          body.addEventListener("transitionend", onEnd);
          setTimeout(clear, FAQ_TOGGLE_MS + 120);
          return;
        }

        const startHeight = Math.max(0, Math.ceil(body.getBoundingClientRect().height || body.scrollHeight));
        body.style.overflow = "hidden";
        body.style.willChange = "height, opacity";
        body.style.transition = "none";
        body.style.height = `${startHeight}px`;
        body.style.opacity = "1";
        void body.offsetHeight;
        body.style.transition = `height ${FAQ_TOGGLE_MS}ms ${ease}, opacity ${FAQ_TOGGLE_MS}ms ${ease}`;
        requestAnimationFrame(() => {
          body.style.height = "0px";
          body.style.opacity = "0";
        });

        let done = false;
        const clear = () => {
          if (done) return;
          done = true;
          body.removeEventListener("transitionend", onEnd);
          finish(() => { details.open = false; });
        };
        const onEnd = (ev) => {
          if (ev.target !== body) return;
          if (ev.propertyName !== "height" && ev.propertyName !== "opacity") return;
          clear();
        };
        body.addEventListener("transitionend", onEnd);
        setTimeout(clear, FAQ_TOGGLE_MS + 120);
      }

      function openMenu(){
        const { overlay, panel } = _menuEls();
        if(!overlay || !panel){
          _menuNotifyNotFound();
          return;
        }

        _menuCancelCloseWait();

        overlay.hidden = false;
        panel.hidden = false;
        overlay.setAttribute("aria-hidden", "false");
        panel.setAttribute("aria-hidden", "false");
        overlay.classList.remove("is-closing");
        panel.classList.remove("is-closing");

        // Reset to root each time (no scroll position carry-over)
        _setMenuView("root");

        const applyOpen = () => {
          overlay.classList.add("open", "is-open");
          panel.classList.add("open", "is-open");
        };
        if (_menuReducedMotion()) applyOpen();
        else requestAnimationFrame(applyOpen);
      }

      function closeMenu(){
        const { overlay, panel } = _menuEls();
        if(!overlay || !panel){
          _menuNotifyNotFound();
          return;
        }
        if (overlay.hidden && panel.hidden && !panel.classList.contains("is-open") && !panel.classList.contains("open")){
          return;
        }

        _drawerShareStopTimer();
        try{ _battleStopPolling(); }catch(_){}
        try{ _rtBattleDisconnect(true); }catch(_){}

        // Stop "sending" state when drawer is closed to avoid stuck UI on next open
        _menuState.sending = false;
        _menuCancelCloseWait();

        overlay.hidden = false;
        panel.hidden = false;
        overlay.setAttribute("aria-hidden", "false");
        panel.setAttribute("aria-hidden", "false");
        overlay.classList.add("open", "is-open");
        panel.classList.add("open", "is-open");
        overlay.classList.remove("memo-full");
        panel.classList.remove("has-back", "memo-full");

        const token = _menuCloseToken;
        const finalize = () => {
          if (token !== _menuCloseToken) return;
          _menuFinalizeClose(overlay, panel);
        };

        overlay.classList.add("is-closing");
        panel.classList.add("is-closing");
        if (_menuReducedMotion()){
          finalize();
          return;
        }

        let done = false;
        const complete = () => {
          if (done) return;
          done = true;
          panel.removeEventListener("transitionend", onEnd);
          if (_menuCloseTimerId){
            clearTimeout(_menuCloseTimerId);
            _menuCloseTimerId = null;
          }
          finalize();
        };
        const onEnd = (ev) => {
          if (ev.target !== panel) return;
          if (ev.propertyName !== "transform" && ev.propertyName !== "opacity") return;
          complete();
        };
        panel.addEventListener("transitionend", onEnd);
        _menuCloseTimerId = setTimeout(complete, MENU_CLOSE_FALLBACK_MS);
      }

      function toggleMenu(){
        const { panel } = _menuEls();
        if(panel && !panel.hidden && panel.classList.contains("is-open") && !panel.classList.contains("is-closing")) closeMenu();
        else openMenu();
      }

      function _menuBack(){
        if(_menuState.view === "reportConfirm"){
          _setMenuView("report");
          return;
        }
        if(_menuState.view === "reportDone"){
          _setMenuView("root");
          return;
        }
        if(_menuState.view === "memoDay"){
          _setMenuView("memoCheck");
          return;
        }
        if(_menuState.view !== "root"){
          _setMenuView("root");
          return;
        }
        closeMenu();
      }

      function _handleMenuAction(action){
        if(!action) return;
        if(action === "help"){ _setMenuView("help"); return; }
        if(action === "terms"){ _setMenuView("terms"); return; }
        if(action === "report"){ _setMenuView("report"); return; }
        if(action === "memoCheck"){ _setMenuView("memoCheck"); return; }
        if(action === "presetShare"){ _setMenuView("presetShare"); return; }
        if(action === "onlineBattle"){ _setMenuView("onlineBattle"); return; }
        if(action === "onlineBattleRealtime"){
          try{ closeMenu(); }catch(_){}
          try{
            if (typeof _rtBattleOverlayOpen === "function") _rtBattleOverlayOpen("top");
            else _setMenuView("onlineBattleRealtime");
          }catch(err){
            try{ uiToast(": " + (err?.message || err)); }catch(_){}
          }
          return;
        }

        if(action === "settings"){
          closeMenu();
          try{
            if(typeof openSettings === "function") openSettings({ fromMenu: true });
            else if(typeof openSettingsPanel === "function") openSettingsPanel();
            else if(typeof openSettingsModal === "function") openSettingsModal();
            else uiToast("Settings UI");
          }catch(err){
            uiToast("Settings: " + (err && err.message ? err.message : err));
          }
        }
      }

      function _readReportDraftFromDOM(){
        const email = (document.getElementById("reportEmail")?.value || "").trim();
        const subject = (document.getElementById("reportSubject")?.value || "").trim();
        const message = (document.getElementById("reportMessage")?.value || "").trim();
        return { email, subject, message };
      }

      async function _sendReportViaEmailJS(draft){
        if(!EMAILJS_PUBLIC_KEY || !EMAILJS_SERVICE_ID || !EMAILJS_TEMPLATE_ID){
          throw new Error("EmailJS config.public.js  meta ");
        }
        if(!_ensureEmailJSInit()){
          throw new Error("EmailJS /");
        }

        const appVersion = (typeof APP_VERSION === "string" && APP_VERSION) ? APP_VERSION : "v26";
        const params = {
          reply_to: draft.email,
          subject: draft.subject,
          message: draft.message,
          app_version: appVersion,
          page: location.href,
          user_agent: navigator.userAgent,
          sent_at: _fmtLocalSentAt(),
        };

        return window.emailjs.send(EMAILJS_SERVICE_ID, EMAILJS_TEMPLATE_ID, params);
      }

      function initMenu(){
        if(_menuState.inited) return;
        _menuState.inited = true;

        const { btn, overlay, panel, content } = _menuEls();

        // Cache the root list HTML once
        if(content && !_menuState.rootHtml){
          _menuState.rootHtml = content.innerHTML || "";
        }

        // Init EmailJS once after DOMContentLoaded
        _ensureEmailJSInit();

        // Delegation click handler (prevents "click does nothing" bugs)
        document.addEventListener("click", async (e)=>{
          // Menu button
          const menuBtn = e.target.closest("#menuBtn");
          if(menuBtn){
            e.preventDefault();
            try{
              toggleMenu();
            }catch(err){
              console.warn("[Menu] toggle failed:", err);
              try{ uiToast(""); }catch(_){}
            }
            return;
          }

          // Overlay click closes
          const ov = e.target.closest("#menuOverlay");
          if(ov){
            e.preventDefault();
            closeMenu();
            return;
          }

          const faqChip = e.target.closest(".faq-chip[data-faq-cat]");
          if (faqChip && faqChip.closest("#menuPanel")){
            e.preventDefault();
            const panel = faqChip.closest("#menuPanel");
            const cat = String(faqChip.getAttribute("data-faq-cat") || "ALL");
            _faqFilterState.category = cat;
            panel.querySelectorAll(".faq-chip[data-faq-cat]").forEach((chip) => {
              const on = chip === faqChip;
              chip.classList.toggle("is-active", on);
              chip.setAttribute("aria-pressed", on ? "true" : "false");
            });
            _faqApplyFilter();
            return;
          }

          // FAQ open/close animation
          const summaryEl = e.target.closest("summary");
          if (summaryEl && summaryEl.closest("#menuPanel")){
            const detailsEl = summaryEl.parentElement;
            if (detailsEl && detailsEl.tagName === "DETAILS" && detailsEl.classList.contains("faq")){
              e.preventDefault();
              _faqAnimateToggle(detailsEl);
              return;
            }
          }

          // Close / Back
          const closeBtn = e.target.closest('[data-menu-action="close"]');
          if(closeBtn && closeBtn.closest("#menuPanel")){
            e.preventDefault();
            closeMenu();
            return;
          }
          const backBtn = e.target.closest('[data-menu-action="back"]');
          if(backBtn && backBtn.closest("#menuPanel")){
            e.preventDefault();
            _menuBack();
            return;
          }

          // Menu items
          const item = e.target.closest('.menu-item[data-menu-action]');
          if(item && item.closest("#menuPanel")){
            e.preventDefault();
            _handleMenuAction(item.getAttribute("data-menu-action"));
            return;
          }

          // Memo check actions
          const memoBtn = e.target.closest("[data-memo-action]");
          if (memoBtn && memoBtn.closest("#menuPanel")){
            e.preventDefault();
            const act = memoBtn.getAttribute("data-memo-action");
            if (act === "monthPrev"){
              const d = new Date(_menuState.memoCheck.monthBaseTs || Date.now());
              d.setMonth(d.getMonth()-1, 1);
              _menuState.memoCheck.monthBaseTs = d.getTime();
              _memoRenderCalendar();
              return;
            }
            if (act === "monthNext"){
              const d = new Date(_menuState.memoCheck.monthBaseTs || Date.now());
              d.setMonth(d.getMonth()+1, 1);
              _menuState.memoCheck.monthBaseTs = d.getTime();
              _memoRenderCalendar();
              return;
            }
            if (act === "backCalendar"){
              _setMenuView("memoCheck");
              return;
            }
            if (act === "addCustomBlock"){
              const ip = document.getElementById("memoCustomBlockInput");
              const t = (ip?.value || "").trim();
              if (t){
                _memoAddPickedBlock(t);
                if (ip) ip.value = "";
              }
              return;
            }
            if (act === "saveDay"){
              const dateYmd = _menuState.memoCheck.currentDate || _memoToYmd(Date.now());
              const all = _memoLoadAll();
              const existing = all[dateYmd] || {};
              all[dateYmd] = {
                blocks: _menuState.memoCheck.draftBlocks.slice(),
                slots: _memoCollectDayDraft(),
                recommended: existing.recommended || null,
                updatedAt: Date.now()
              };
              _memoSaveAll(all);
              uiToast("");
              return;
            }
            if (act === "clearDay"){
              ["memoRangeText","memoWeakText","memoReasonText","memoMemoText"].forEach(id => {
                const elx = document.getElementById(id);
                if (elx) elx.value = "";
              });
              _menuState.memoCheck.draftBlocks = [];
              const picked = document.getElementById("memoPickedBlocks");
              if (picked) picked.innerHTML = "";
              return;
            }
            if (act === "analyzeDay"){
              const dateYmd = _menuState.memoCheck.currentDate || _memoToYmd(Date.now());
              _memoAnalyze(dateYmd);
              return;
            }
            if (act === "startRecommended"){
              const dateYmd = _menuState.memoCheck.currentDate || _memoToYmd(Date.now());
              _memoStartRecommended(dateYmd);
              return;
            }
          }

          const shareTabBtn = e.target.closest("[data-share-tab]");
          if (shareTabBtn && shareTabBtn.closest("#menuPanel")){
            e.preventDefault();
            const tab = shareTabBtn.getAttribute("data-share-tab");
            _drawerShareApplyTab(tab === "import" ? "import" : "share");
            return;
          }

          const shareBtn = e.target.closest("[data-share-action]");
          if (shareBtn && shareBtn.closest("#menuPanel")){
            e.preventDefault();
            const act = shareBtn.getAttribute("data-share-action");
            if (act === "create"){
              _drawerShareCreateNow(false);
              return;
            }
            if (act === "copyCode"){
              const code = _menuState.presetShare.entry?.code || "";
              if (!code) return;
              const ok = await _copyText(code);
              uiToast(ok ? "" : "");
              return;
            }
            if (act === "copyLink"){
              const link = _menuState.presetShare.entry?.shareLink || "";
              if (!link) return;
              const ok = await _copyText(link);
              uiToast(ok ? "" : "");
              return;
            }
            if (act === "import"){
              const code = document.getElementById("drawerShareImportCode")?.value || "";
              _drawerShareImportByCode(code, false);
              return;
            }
          }

          const battleBtn = e.target.closest("[data-battle-action]");
          if (battleBtn && battleBtn.closest("#menuPanel")){
            e.preventDefault();
            const act = String(battleBtn.getAttribute("data-battle-action") || "");
            if (act === "startQueue"){
              _battleQueueStart();
              return;
            }
            if (act === "cancelQueue"){
              _battleCancelQueue();
              return;
            }
            if (act === "refreshMatch"){
              if (_battleState().matchId) _battleLoadMatch();
              else if (_battleState().queueId) _battlePollStatusOnce();
              return;
            }
            if (act === "showResult"){
              _battleFetchResult();
              return;
            }
            if (act === "leaveBattle"){
              _battleLeave();
              return;
            }
            if (act === "submitWrite"){
              const input = document.getElementById("battleWriteInput");
              _battleSubmitAnswer(input ? input.value : "");
              return;
            }
            if (act === "chooseAnswer"){
              _battleSubmitAnswer(String(battleBtn.getAttribute("data-battle-answer") || ""));
              return;
            }
          }

          const rtBattleBtn = e.target.closest("[data-rt-battle-action]");
          if (rtBattleBtn && rtBattleBtn.closest("#menuPanel, #onlineOverlay")){
            e.preventDefault();
            const act = String(rtBattleBtn.getAttribute("data-rt-battle-action") || "");
          if (typeof _rtBattleOverlayHandleAction === "function" && _rtBattleOverlayHandleAction(act, rtBattleBtn)) return;
            if (act === "start"){ _rtBattleStart(); return; }
            if (act === "disconnect"){ _rtBattleLeave(); return; }
            if (act === "reconnect"){ _rtBattleReconnect(); return; }
            if (act === "readyToggle"){
              const me = (typeof _rtBattleMePlayer === "function") ? _rtBattleMePlayer() : null;
              _rtBattleSetReady(!(me && me.ready));
              return;
            }
            if (act === "gameStart"){ _rtBattleStartGame(); return; }
            if (act === "backLobby"){ _rtBattleRematch(); return; }
            if (act === "rematch"){ _rtBattleRematch(); return; }
            if (act === "submitWrite"){
              const input = document.getElementById("rtBattleWriteInput");
              _rtBattleSubmitAnswer(input ? input.value : "");
              return;
            }
            if (act === "chooseAnswer"){
              _rtBattleSubmitChoice(String(rtBattleBtn.getAttribute("data-rt-battle-answer") || ""));
              return;
            }
          }

          const calDay = e.target.closest("[data-memo-date]");
          if (calDay && calDay.closest("#menuPanel")){
            e.preventDefault();
            const ymd = calDay.getAttribute("data-memo-date");
            _menuState.memoCheck.currentDate = ymd || _memoToYmd(Date.now());
            _setMenuView("memoDay");
            return;
          }

          const memoBlock = e.target.closest("[data-memo-block]");
          if (memoBlock && memoBlock.closest("#menuPanel")){
            e.preventDefault();
            const txt = memoBlock.getAttribute("data-memo-block") || "";
            _menuState.memoCheck.selectedBlock = txt;
            document.querySelectorAll("#menuPanel [data-memo-block]").forEach(x => x.classList.toggle("is-selected", x === memoBlock));
            _memoAddPickedBlock(txt);
            return;
          }

          const memoSlot = e.target.closest(".memo-slot[data-memo-slot]");
          if (memoSlot && memoSlot.closest("#menuPanel")){
            const selected = _menuState.memoCheck.selectedBlock;
            if (selected){
              _memoInsertToSlot(memoSlot.getAttribute("data-memo-slot"), selected);
            }
            return;
          }

          // Report actions
          const rbtn = e.target.closest('[data-report-action]');
          if(rbtn && rbtn.closest("#menuPanel")){
            e.preventDefault();

            const act = rbtn.getAttribute("data-report-action");

            if(act === "goConfirm"){
              const draft = _readReportDraftFromDOM();
              _menuState.reportDraft = draft;

              if(!draft.email || !_isValidEmail(draft.email)){
                _setReportStatus("", true);
                return;
              }
              if(!draft.subject){
                _setReportStatus("", true);
                return;
              }
              if(!draft.message){
                _setReportStatus("", true);
                return;
              }

              _setMenuView("reportConfirm");
              return;
            }

            if(act === "backEdit"){
              _setMenuView("report");
              return;
            }

            if(act === "sendConfirm"){
              if(_menuState.sending) return;

              const draft = _menuState.reportDraft || _readReportDraftFromDOM();

              if(!draft.email || !_isValidEmail(draft.email)){
                _setReportStatus("", true);
                return;
              }
              if(!draft.subject){
                _setReportStatus("", true);
                return;
              }
              if(!draft.message){
                _setReportStatus("", true);
                return;
              }

              _menuState.sending = true;
              _setReportStatus("", false);

              // Disable button & show progress
              const btnEl = rbtn;
              const prevText = btnEl.textContent;
              btnEl.disabled = true;
              btnEl.textContent = "";

              try{
                await _sendReportViaEmailJS(draft);
                _menuState.sending = false;

                // Clear draft after success
                _menuState.reportDraft = { email:"", subject:"", message:"" };

                _setMenuView("reportDone");
              }catch(err){
                _menuState.sending = false;
                console.warn("[Report] send failed:", err);

                btnEl.disabled = false;
                btnEl.textContent = prevText || "";

                _setReportStatus((err && err.message) ? err.message : "", true);
              }
              return;
            }

            if(act === "doneClose"){
              closeMenu();
              return;
            }
          }
        }, true);

        document.addEventListener("change", (e)=>{
          const t = e.target;
          if (!(t instanceof Element)) return;
          if (!t.closest("#menuPanel") && !t.closest("#onlineOverlay")) return;
          if (t.id === "battleModeSelect" || t.id === "battlePresetSelect" || t.id === "battleCountSelect"){
            _battleApplyFormFromDom();
            return;
          }
          if (t.id === "rtBattleModeSelect" || t.id === "rtBattleCountSelect"){
            _rtBattleApplyFormFromDom();
            return;
          }
          if (t.id === "rtBattlePresetSelect"){
            if (typeof _rtBattleSendPresetSelection === "function") _rtBattleSendPresetSelection();
            return;
          }
          if (t.id === "rtBattleQuestionCountSelect"){
            if (typeof _rtBattleSendRoomSettings === "function") _rtBattleSendRoomSettings();
            return;
          }
          if (t.id === "memoInsightsPresetSelect" || t.id === "memoInsightsModeSelect" || t.id === "memoInsightsRangeSelect"){
            _memoRenderInsightsTop();
            return;
          }
          if (t.id === "drawerSharePresetSelect"){
            _menuState.presetShare.selectedPresetId = t.value || "";
            _drawerShareRefreshBySelection();
          }
        }, true);

        document.addEventListener("input", (e)=>{
          const t = e.target;
          if (!(t instanceof HTMLElement)) return;
          if (!t.closest("#menuPanel") && !t.closest("#onlineOverlay")) return;
          if (t instanceof HTMLInputElement && t.id === "drawerShareImportCode"){
            const code = _drawerShareSanitizeCode(t.value);
            if (code !== t.value) t.value = code;
            return;
          }
          if ((t instanceof HTMLInputElement || t instanceof HTMLTextAreaElement) && t.id === "faqSearchInput"){
            _faqFilterState.query = t.value || "";
            _faqScheduleFilter();
            return;
          }
          if (t instanceof HTMLInputElement && t.id === "battleWriteInput"){
            _battleState().writeDraft = t.value || "";
            return;
          }
          if (t instanceof HTMLInputElement && t.id === "rtBattleWriteInput"){
            _rtBattleState().writeDraft = t.value || "";
            return;
          }
          if (t instanceof HTMLInputElement && t.id === "rtRoomCreatePasswordInput"){
            const v = String(t.value || "").toUpperCase().replace(/[^A-Z0-9]/g, "").slice(0, 6);
            _rtBattleState().roomPassword = v;
            if (t.value !== v) t.value = v;
            return;
          }
          if (t instanceof HTMLInputElement && t.id === "rtRoomJoinIdInput"){
            const v = String(t.value || "").toUpperCase().replace(/[^A-Z0-9]/g, "").slice(0, 6);
            _rtBattleState().joinRoomId = v;
            if (t.value !== v) t.value = v;
            return;
          }
          if (t instanceof HTMLInputElement && t.id === "rtRoomJoinPasswordInput"){
            const v = String(t.value || "").toUpperCase().replace(/[^A-Z0-9]/g, "").slice(0, 6);
            _rtBattleState().joinPassword = v;
            if (t.value !== v) t.value = v;
            return;
          }
          if (t instanceof HTMLInputElement && t.id === "rtRoomNickInput"){
            _rtBattleState().nickname = String(t.value || "").trim().slice(0, 32);
            return;
          }
        }, true);

        document.addEventListener("dragstart", (e)=>{
          const block = e.target && e.target.closest ? e.target.closest("[data-memo-block]") : null;
          if (!block || !block.closest("#menuPanel")) return;
          const text = block.getAttribute("data-memo-block") || "";
          if (!e.dataTransfer) return;
          e.dataTransfer.setData("text/plain", text);
          e.dataTransfer.effectAllowed = "copy";
        }, true);
        document.addEventListener("dragover", (e)=>{
          const slot = e.target && e.target.closest ? e.target.closest(".memo-slot[data-memo-slot]") : null;
          if (!slot || !slot.closest("#menuPanel")) return;
          e.preventDefault();
          if (e.dataTransfer) e.dataTransfer.dropEffect = "copy";
        }, true);
        document.addEventListener("drop", (e)=>{
          const slot = e.target && e.target.closest ? e.target.closest(".memo-slot[data-memo-slot]") : null;
          if (!slot || !slot.closest("#menuPanel")) return;
          e.preventDefault();
          const text = e.dataTransfer ? e.dataTransfer.getData("text/plain") : "";
          if (!text) return;
          _memoAddPickedBlock(text);
          _memoInsertToSlot(slot.getAttribute("data-memo-slot"), text);
        }, true);

        document.addEventListener("keydown", (e)=>{
          const t = e.target;
          if (!(t instanceof HTMLElement)) return;
          if (!t.closest("#menuPanel") && !t.closest("#onlineOverlay")) return;
          if (t.id === "battleWriteInput" && e.key === "Enter" && !e.shiftKey){
            e.preventDefault();
            _battleSubmitAnswer((t instanceof HTMLInputElement) ? (t.value || "") : "");
            return;
          }
          if (t.id === "rtBattleWriteInput" && e.key === "Enter" && !e.shiftKey){
            e.preventDefault();
            _rtBattleSubmitAnswer((t instanceof HTMLInputElement) ? (t.value || "") : "");
            return;
          }
          if (t.id !== "drawerShareImportCode") return;
          if (e.key !== "Enter") return;
          e.preventDefault();
          _drawerShareImportByCode(t.value || "", false);
        }, true);

        // Esc closes drawer (but never steals keys while typing)
        document.addEventListener("keydown", (e)=>{
          if(e.key !== "Escape") return;
          if(typeof _isTyping === "function" && _isTyping()) return;
          if (typeof _rtBattleOverlayIsOpen === "function" && _rtBattleOverlayIsOpen()){
            e.preventDefault();
            try{ _rtBattleOverlayClose(); }catch(_){}
            return;
          }

          const { panel } = _menuEls();
          if(panel && !panel.hidden){
            e.preventDefault();
            closeMenu();
          }
        }, true);

        // Safety: if critical DOM is missing, show a toast so it's never "silent"
        if(!btn || !overlay || !panel){
          try{ uiToast("UI"); }catch(_){}
        }

        const hashCode = _drawerShareCodeFromHash();
        if (hashCode){
          _menuState.presetShare.tab = "import";
          _menuState.presetShare.hashCode = hashCode;
          _menuState.presetShare.hashTried = false;
          setTimeout(() => {
            openMenu();
            _setMenuView("presetShare");
          }, 0);
        }
      }
      // ROOM_DO_UI_V2_GAME: room-based WebSocket chat + realtime vocab battle (MVP 3 questions)
      const asArray = (v)=>Array.isArray(v)?v:[];
      const asStr = (v)=>(typeof v==="string")?v:"";
      function _rtBattleState(){
        if (!_menuState.rtBattle || typeof _menuState.rtBattle !== "object") _menuState.rtBattle = {};
        const st = _menuState.rtBattle;
        if (typeof st.roomId !== "string") st.roomId = "";
        if (typeof st.roomPassword !== "string") st.roomPassword = "";
        if (typeof st.joinRoomId !== "string") st.joinRoomId = "";
        if (typeof st.joinPassword !== "string") st.joinPassword = "";
        if (typeof st.nickname !== "string") st.nickname = "";
        if (typeof st.wsUrl !== "string") st.wsUrl = "";
        if (!(st.socket instanceof WebSocket)) st.socket = null;
        if (typeof st.connecting !== "boolean") st.connecting = false;
        if (typeof st.connected !== "boolean") st.connected = false;
        if (typeof st.phase !== "string") st.phase = "lobby";
        if (typeof st.statusMsg !== "string") st.statusMsg = "";
        if (typeof st.errorMsg !== "string") st.errorMsg = "";
        if (typeof st.writeDraft !== "string") st.writeDraft = "";
        if (!Array.isArray(st.chatLogs)) st.chatLogs = [];
        if (!Array.isArray(st.players)) st.players = [];
        if (!Array.isArray(st.messages)) st.messages = [];
        if (!Array.isArray(st.participants)) st.participants = [];
        if (!st.room || typeof st.room !== "object") st.room = null;
        if (!st.you || typeof st.you !== "object") st.you = null;
        if (!st.game || typeof st.game !== "object") st.game = null;
        if (!st.currentQuestion || typeof st.currentQuestion !== "object") st.currentQuestion = null;
        if (!st.lastRoundResult || typeof st.lastRoundResult !== "object") st.lastRoundResult = null;
        if (!st.finalResult || typeof st.finalResult !== "object") st.finalResult = null;
        if (!Array.isArray(st.roundLogs)) st.roundLogs = [];
        if (typeof st.busy !== "boolean") st.busy = false;
        if (typeof st.pingTimerId !== "number" && st.pingTimerId !== null) st.pingTimerId = null;
        if (typeof st.uiTimerId !== "number" && st.uiTimerId !== null) st.uiTimerId = null;
        return st;
      }
      function _rtBattlePushLog(kind, text, extra = {}){
        const st = _rtBattleState();
        const msg = {
          kind: String(kind || "system"),
          text: String(text || ""),
          ts: Date.now(),
          ...((extra && typeof extra === "object") ? extra : {})
        };
        st.chatLogs = asArray(st.chatLogs);
        st.chatLogs.push(msg);
        if (asArray(st.chatLogs).length > 120) st.chatLogs = asArray(st.chatLogs).slice(-120);
      }
      function _rtBattleStopPing(){
        const st = _rtBattleState();
        if (st.pingTimerId){
          clearInterval(st.pingTimerId);
          st.pingTimerId = null;
        }
      }
      function _rtBattleStopUiTimer(){
        const st = _rtBattleState();
        if (st.uiTimerId){
          clearInterval(st.uiTimerId);
          st.uiTimerId = null;
        }
      }
      function _rtBattleEnsureUiTimer(){
        const st = _rtBattleState();
        if (st.uiTimerId) return;
        st.uiTimerId = setInterval(() => {
          if (_menuState.view !== "onlineBattleRealtime") return;
          const elx = document.getElementById("rtBattleCountdownText");
          if (!elx) return;
          const remain = _rtBattleRemainingMs();
          elx.textContent = `${Math.max(0, Math.ceil(remain / 1000))}`;
        }, 250);
      }
      function _rtBattleSafeCloseSocket(){
        const st = _rtBattleState();
        const ws = st.socket;
        st.socket = null;
        if (ws){
          try{ ws.onopen = ws.onclose = ws.onerror = ws.onmessage = null; }catch(_){}
          try{ ws.close(); }catch(_){}
        }
      }
      function _rtBattleDisconnect(silent = false){
        const st = _rtBattleState();
        _rtBattleStopPing();
        _rtBattleStopUiTimer();
        _rtBattleSafeCloseSocket();
        st.connecting = false;
        st.connected = false;
        if (!silent){
          st.statusMsg = "";
          _rtBattlePushLog("system", "");
        }
      }
      function _rtBattleReset(keepInputs = true){
        const st = _rtBattleState();
        const keep = keepInputs ? {
          roomPassword: st.roomPassword,
          joinRoomId: st.joinRoomId,
          joinPassword: st.joinPassword,
          nickname: st.nickname
        } : null;
        _rtBattleDisconnect(true);
        st.roomId = "";
        st.wsUrl = "";
        st.phase = "lobby";
        st.statusMsg = "";
        st.errorMsg = "";
        st.players = [];
        st.room = null;
        st.you = null;
        st.game = null;
        st.currentQuestion = null;
        st.lastRoundResult = null;
        st.finalResult = null;
        st.writeDraft = "";
        st.chatLogs = [];
        st.busy = false;
        if (keep){
          st.roomPassword = keep.roomPassword;
          st.joinRoomId = keep.joinRoomId;
          st.joinPassword = keep.joinPassword;
          st.nickname = keep.nickname;
        }
      }
      function _rtBattleAuthTokenRequired(){
        const token = _authGetToken();
        if (!token){
          const err = new Error("");
          err.code = "UNAUTHORIZED";
          throw err;
        }
        return token;
      }
      function _rtBattleMyUserId(){
        const raw = authState?.user?.id ?? authState?.user?.userId ?? 0;
        return Math.max(0, Number(raw || 0));
      }
      function _rtBattleMePlayer(){
        const uid = _rtBattleMyUserId();
        return (_rtBattleState().players || []).find((p) => Math.max(0, Number(p?.userId || 0)) === uid) || null;
      }
      function _rtBattleIsHost(){
        const st = _rtBattleState();
        const hostUid = Math.max(0, Number(st.room?.hostUserId || 0));
        return !!hostUid && hostUid === _rtBattleMyUserId();
      }
      function _rtBattleAllReady(){
        const players = asArray(_rtBattleState().players).filter((p) => !!p?.connected);
        return asArray(players).length >= 2 && players.every((p) => !!p.ready);
      }
      function _rtBattleRemainingMs(){
        const endsAt = Math.max(0, Number(_rtBattleState().game?.questionEndsAtMs || 0));
        if (!endsAt) return 0;
        return Math.max(0, endsAt - Date.now());
      }
      function _rtBattleApplyFormFromDom(){
        const st = _rtBattleState();
        const createPwEl = document.getElementById("rtRoomCreatePasswordInput");
        const createCountEl = document.getElementById("rtRoomCreateQuestionCountSelect");
        const joinIdEl = document.getElementById("rtRoomJoinIdInput");
        const joinPwEl = document.getElementById("rtRoomJoinPasswordInput");
        const nickEl = document.getElementById("rtRoomNickInput");
        if (createPwEl) st.roomPassword = String(createPwEl.value || "").toUpperCase().replace(/[^A-Z0-9]/g, "").slice(0, 6);
        if (createCountEl) st.questionCount = _rtBattleNormalizeQuestionCountValue(createCountEl.value);
        if (joinIdEl) st.joinRoomId = String(joinIdEl.value || "").toUpperCase().replace(/[^A-Z0-9]/g, "").slice(0, 6);
        if (joinPwEl) st.joinPassword = String(joinPwEl.value || "").toUpperCase().replace(/[^A-Z0-9]/g, "").slice(0, 6);
        if (nickEl) st.nickname = String(nickEl.value || "").trim().slice(0, 32);
      }
      function _rtBattleStatusLabel(){
        const st = _rtBattleState();
        if (st.errorMsg) return st.errorMsg;
        if (st.statusMsg) return st.statusMsg;
        if (st.connecting) return "";
        if (st.connected) return ` (${String(st.phase || "lobby")})`;
        return "";
      }
      function _rtBattleSafeSend(payload){
        const st = _rtBattleState();
        const ws = st.socket;
        if (!ws || ws.readyState !== WebSocket.OPEN) return false;
        try{
          ws.send(JSON.stringify(payload || {}));
          return true;
        }catch{
          return false;
        }
      }
      function _rtBattleRerender(){
        if (_menuState.view !== "onlineBattleRealtime") return;
        const content = document.getElementById("menuContent");
        if (!content) return;
        content.innerHTML = _renderOnlineBattleRealtimeHTML();
        _rtBattleInitView();
      }
      function _rtBattleApplySnapshot(snapshot){
        const st = _rtBattleState();
        if (!snapshot || typeof snapshot !== "object") return;
        st.room = (snapshot.room && typeof snapshot.room === "object") ? snapshot.room : st.room;
        st.players = Array.isArray(snapshot.players) ? snapshot.players : st.players;
        if (typeof snapshot.lastEventId !== "undefined" || Array.isArray(snapshot.events)){
          _rtBattleConsumeRoomEvents(snapshot);
        }
        st.phase = String(snapshot.phase || st.phase || "lobby").toLowerCase();
        st.game = (snapshot.game && typeof snapshot.game === "object") ? snapshot.game : st.game;
        if (Math.max(0, Number(st.game?.questionIds?.length || 0)) > 0){
          st.game.totalRounds = Math.max(1, Number(st.game.questionIds.length));
        }
        if (typeof st.room?.settings?.questionCount !== "undefined"){
          st.questionCount = _rtBattleNormalizeQuestionCountValue(st.room.settings.questionCount);
        }
        if (st.game?.currentQuestion) {
          st.currentQuestion = st.game.currentQuestion;
        } else if (st.phase !== "playing") {
          st.currentQuestion = null;
        }
        try{
          const dbg = st.room?.debug || {};
          console.log("[rtBattle:debug]", {
            questionCount: (typeof dbg.questionCount !== "undefined") ? dbg.questionCount : st.room?.settings?.questionCount,
            questionIdsLength: Math.max(0, Number(dbg.questionIdsLength || st.game?.questionIds?.length || 0)),
            presetWordsLength: Math.max(0, Number(dbg.presetWordsLength || st.game?.presetWordsLength || 0))
          });
        }catch(_){}
      }
      function _rtBattleHandleMessage(msg){
        const st = _rtBattleState();
        const type = String(msg?.type || "").toLowerCase();
        if (!type) return;
        if (type === "room:snapshot"){
          _rtBattleApplySnapshot(msg);
          if (st.connected) st.statusMsg = `: ${st.phase}`;
          if (st.phase === "playing") _rtBattleEnsureUiTimer();
          else _rtBattleStopUiTimer();
          _rtBattleRerender();
          return;
        }
        if (type === "state"){
          if (msg?.state && typeof msg.state === "object") {
            _rtBattleApplySnapshot(msg.state);
          } else {
            _rtBattleApplySnapshot(msg);
          }
          if (st.phase === "playing") _rtBattleEnsureUiTimer();
          else _rtBattleStopUiTimer();
          _rtBattleRerender();
          return;
        }
        if (type === "joined"){
          st.you = (msg && typeof msg.you === "object") ? msg.you : st.you;
          st.room = (msg && typeof msg.room === "object") ? msg.room : st.room;
          st.statusMsg = "";
          _rtBattlePushLog("system", `${st.you?.nick || "you"}`);
          _rtBattleRerender();
          return;
        }
        if (type === "chat"){
          const fromNick = String(msg?.from?.nick || "unknown");
          const fromId = Number(msg?.from?.id || 0);
          const text = String(msg?.text || "");
          _rtBattlePushLog("chat", text, { fromNick, fromId, ts: Number(msg?.ts || Date.now()) });
          _rtBattleRerender();
          return;
        }
        if (type === "game:question"){
          st.phase = "playing";
          st.currentQuestion = {
            qid: String(msg?.qid || ""),
            no: Math.max(0, Number(msg?.no || 0)),
            prompt: String(msg?.prompt || ""),
            choices: Array.isArray(msg?.choices) ? msg.choices.map((x)=>String(x || "")) : [],
            round: Math.max(1, Number(msg?.round || 1)),
            totalRounds: _rtBattleResolvedTotalRounds(msg?.totalRounds || st.game?.totalRounds || 1)
          };
          st.lastRoundResult = null;
          st.finalResult = null;
          st.game = st.game && typeof st.game === "object" ? st.game : {};
          st.game.round = Math.max(0, Number(msg?.round || 1) - 1);
          st.game.totalRounds = _rtBattleResolvedTotalRounds(msg?.totalRounds || st.game?.totalRounds || 1);
          st.game.questionEndsAtMs = Math.max(0, Number(msg?.endsAtMs || 0));
          st.game.questionStartedAtMs = Math.max(0, Number(st.game.questionStartedAtMs || (st.game.questionEndsAtMs ? (st.game.questionEndsAtMs - 10000) : 0)));
          _rtBattleEnsureUiTimer();
          st.statusMsg = ` ${st.currentQuestion.round}/${st.currentQuestion.totalRounds}`;
          _rtBattleRerender();
          return;
        }
        if (type === "game:result"){
          st.lastRoundResult = msg && typeof msg === "object" ? msg : null;
          st.statusMsg = ` ${Math.max(1, Number(msg?.round || 1))} `;
          _rtBattleRerender();
          return;
        }
        if (type === "game:final"){
          st.phase = "result";
          st.finalResult = msg && typeof msg === "object" ? msg : null;
          st.statusMsg = "";
          _rtBattleStopUiTimer();
          _rtBattleRerender();
          return;
        }
        if (type === "error"){
          st.errorMsg = String(msg?.message || msg?.code || "");
          _rtBattlePushLog("system", `: ${st.errorMsg}`);
          try{ uiToast(st.errorMsg); }catch(_){}
          _rtBattleRerender();
          return;
        }
        if (type === "pong"){
          return;
        }
      }
      function _rtBattleConnect(wsUrlRaw){
        const st = _rtBattleState();
        const token = _rtBattleAuthTokenRequired();
        const wsUrlSafe = String(wsUrlRaw || st.wsUrl || "").trim();
        if (!wsUrlSafe){
          st.errorMsg = "WebSocket URL";
          try{ uiToast(st.errorMsg); }catch(_){}
          _rtBattleRerender();
          return;
        }
        if (typeof WebSocket !== "function"){
          st.errorMsg = "WebSocket";
          try{ uiToast(st.errorMsg); }catch(_){}
          _rtBattleRerender();
          return;
        }
        _rtBattleApplyFormFromDom();
        _rtBattleDisconnect(true);
        st.connecting = true;
        st.connected = false;
        st.errorMsg = "";
        st.statusMsg = "";
        st.wsUrl = wsUrlSafe;
        _rtBattleRerender();
        let finalUrl = wsUrlSafe;
        try{
          const u = new URL(wsUrlSafe, location.href);
          if (st.joinPassword || st.roomPassword) u.searchParams.set("pw", st.joinPassword || st.roomPassword);
          if (st.nickname) u.searchParams.set("nick", st.nickname);
          u.searchParams.set("token", token);
          finalUrl = u.toString();
        }catch{
          const qp = [];
          if (st.joinPassword || st.roomPassword) qp.push(`pw=${encodeURIComponent(st.joinPassword || st.roomPassword)}`);
          if (st.nickname) qp.push(`nick=${encodeURIComponent(st.nickname)}`);
          qp.push(`token=${encodeURIComponent(token)}`);
          finalUrl = wsUrlSafe + (wsUrlSafe.includes("?") ? "&" : "?") + qp.join("&");
        }
        let ws = null;
        try{
          ws = new WebSocket(finalUrl);
        }catch(err){
          st.connecting = false;
          st.connected = false;
          st.errorMsg = String(err?.message || "WebSocket");
          _rtBattlePushLog("system", `: ${st.errorMsg}`);
          _rtBattleRerender();
          return;
        }
        st.socket = ws;
        ws.onopen = () => {
          if (_rtBattleState().socket !== ws) return;
          st.connecting = false;
          st.connected = true;
          st.statusMsg = "";
          st.errorMsg = "";
          _rtBattleSafeSend({ type: "hello", pw: st.joinPassword || st.roomPassword || "", nick: st.nickname || "" });
          _rtBattleStopPing();
          st.pingTimerId = setInterval(() => { _rtBattleSafeSend({ type: "ping" }); }, 15000);
          _rtBattleRerender();
        };
        ws.onmessage = (ev) => {
          let msg = null;
          try{ msg = JSON.parse(String(ev?.data || "")); }catch{ msg = null; }
          if (msg) _rtBattleHandleMessage(msg);
        };
        ws.onerror = () => {
          if (_rtBattleState().socket !== ws) return;
          st.connecting = false;
          st.connected = false;
          st.errorMsg = "WebSocket";
          _rtBattlePushLog("system", st.errorMsg);
          _rtBattleRerender();
        };
        ws.onclose = () => {
          if (_rtBattleState().socket === ws) st.socket = null;
          _rtBattleStopPing();
          _rtBattleStopUiTimer();
          st.connecting = false;
          const wasConnected = st.connected;
          st.connected = false;
          if (wasConnected) _rtBattlePushLog("system", "");
          if (!st.errorMsg) st.statusMsg = "";
          _rtBattleRerender();
        };
      }
      async function _rtBattleStart(){
        const st = _rtBattleState();
        if (st.busy || st.connecting) return;
        try{
          _rtBattleApplyFormFromDom();
          st.busy = true;
          st.errorMsg = "";
          st.statusMsg = "";
          _rtBattleRerender();
          const token = _rtBattleAuthTokenRequired();
          const body = await _authFetch("/api/room/create", {
            method: "POST",
            headers: { Authorization: `Bearer ${token}` },
            body: JSON.stringify({ password: st.roomPassword || undefined, questionCount: st.questionCount || 20 })
          });
          st.roomId = String(body?.roomId || "").toUpperCase();
          st.roomPassword = String(body?.password || st.roomPassword || "").toUpperCase();
          st.joinRoomId = st.roomId;
          st.joinPassword = st.roomPassword;
          st.wsUrl = String(body?.wsUrl || "");
          if (!st.wsUrl || !st.roomId) throw new Error("");
          st.chatLogs = [];
          st.currentQuestion = null;
          st.lastRoundResult = null;
          st.finalResult = null;
          _rtBattlePushLog("system", `: ${st.roomId} / PW: ${st.roomPassword}`);
          st.statusMsg = "";
          _rtBattleConnect(st.wsUrl);
        }catch(err){
          st.errorMsg = String(err?.message || "");
          try{ uiToast(st.errorMsg); }catch(_){}
          _rtBattleRerender();
        }finally{
          st.busy = false;
          _rtBattleRerender();
        }
      }
      async function _rtBattleReconnect(){
        const st = _rtBattleState();
        if (st.busy || st.connecting) return;
        try{
          _rtBattleApplyFormFromDom();
          const roomId = asStr(st.joinRoomId).toUpperCase();
          const password = asStr(st.joinPassword).toUpperCase();
          const nick = String(st.nickname || "").trim();
          if (!roomId || asStr(roomId).length !== 6) throw new Error("ID6");
          if (!password || asStr(password).length !== 6) throw new Error("6");
          st.busy = true;
          st.errorMsg = "";
          st.statusMsg = "";
          _rtBattleRerender();
          const token = _rtBattleAuthTokenRequired();
          const body = await _authFetch("/api/room/join", {
            method: "POST",
            headers: { Authorization: `Bearer ${token}` },
            body: JSON.stringify({ roomId, password, nickname: nick || undefined })
          });
          st.roomId = roomId;
          st.roomPassword = password;
          st.wsUrl = String(body?.wsUrl || "");
          if (!st.wsUrl) throw new Error("wsUrl ");
          if (!asArray(st.chatLogs).length) _rtBattlePushLog("system", `: ${roomId}`);
          st.statusMsg = "OK";
          _rtBattleConnect(st.wsUrl);
        }catch(err){
          st.errorMsg = String(err?.message || "");
          try{ uiToast(st.errorMsg); }catch(_){}
          _rtBattleRerender();
        }finally{
          st.busy = false;
          _rtBattleRerender();
        }
      }
      function _rtBattleLeave(){
        const st = _rtBattleState();
        _rtBattleSafeSend({ type: "leave" });
        _rtBattleDisconnect(true);
        st.statusMsg = "";
        st.phase = "lobby";
        st.players = [];
        st.room = null;
        st.you = null;
        st.game = null;
        st.currentQuestion = null;
        st.lastRoundResult = null;
        st.finalResult = null;
        _rtBattlePushLog("system", "");
        _rtBattleRerender();
      }
      function _rtBattleSubmitAnswer(text){
        const st = _rtBattleState();
        const msg = String((text ?? st.writeDraft) || "").trim();
        if (!msg){
          try{ uiToast(""); }catch(_){}
          return;
        }
        if (!st.connected){
          try{ uiToast(""); }catch(_){}
          return;
        }
        const ok = _rtBattleSafeSend({ type: "chat", text: msg });
        if (!ok){
          try{ uiToast(""); }catch(_){}
          return;
        }
        st.writeDraft = "";
        _rtBattleRerender();
      }
      function _rtBattleSubmitChoice(choiceIndexRaw){
        const st = _rtBattleState();
        const me = _rtBattleMePlayer();
        if (!st.connected || String(st.phase || "") !== "playing"){
          try{ uiToast(""); }catch(_){}
          return;
        }
        if (me && me.answeredCurrent){
          try{ uiToast(""); }catch(_){}
          return;
        }
        if (_rtBattleRemainingMs() <= 0){
          try{ uiToast(""); }catch(_){}
          return;
        }
        const choiceIndex = Math.trunc(Number(choiceIndexRaw));
        if (!(choiceIndex >= 0 && choiceIndex <= 3)) return;
        const ok = _rtBattleSafeSend({ type: "answer:submit", choiceIndex });
        if (!ok){
          try{ uiToast(""); }catch(_){}
          return;
        }
        st.statusMsg = "";
      }
      function _rtBattleSetReady(ready){
        const st = _rtBattleState();
        if (!st.connected){
          try{ uiToast(""); }catch(_){}
          return;
        }
        const ok = _rtBattleSafeSend({ type: "ready:set", ready: !!ready });
        if (!ok) try{ uiToast("Ready"); }catch(_){}
      }
      function _rtBattleStartGame(){
        const st = _rtBattleState();
        if (!st.connected){
          try{ uiToast(""); }catch(_){}
          return;
        }
        if (!_rtBattleIsHost()){
          try{ uiToast(""); }catch(_){}
          return;
        }
        const ok = _rtBattleSafeSend({ type: "game:start" });
        if (!ok) try{ uiToast(""); }catch(_){}
      }
      function _rtBattleRematch(){
        const st = _rtBattleState();
        if (!st.connected){
          try{ uiToast(""); }catch(_){}
          return;
        }
        if (!_rtBattleIsHost()){
          try{ uiToast(""); }catch(_){}
          return;
        }
        const ok = _rtBattleSafeSend({ type: "game:rematch" });
        if (!ok) try{ uiToast(""); }catch(_){}
      }
      function _rtBattleRenderPlayerList(){
        const st = _rtBattleState();
        const players = asArray(st.players);
        if (!asArray(players).length) return `<div class="mini"></div>`;
        return players.map((p) => {
          const isYou = Math.max(0, Number(p?.userId || 0)) === _rtBattleMyUserId();
          return `<div class="insight-card" style="padding:10px; margin-top:8px;">
            <div style="display:flex; justify-content:space-between; gap:8px;">
              <div><strong>${_escapeHtml(String(p?.nick || "Guest"))}</strong>${isYou ? ' <span class="mini">()</span>' : ''}</div>
              <div class="mini">${!p?.connected ? "" : (p?.ready ? "READY" : "")}</div>
            </div>
            <div class="mini" style="margin-top:4px;">score ${Math.max(0, Number(p?.score || 0))} / time ${Math.round(Math.max(0, Number(p?.answeredAtMsTotal || 0))/100)/10}s ${p?.answeredCurrent ? " / " : ""}</div>
          </div>`;
        }).join("");
      }
      function _rtBattleRenderChatLogs(){
        const st = _rtBattleState();
        const rows = asArray(st.chatLogs);
        const list = asArray(rows).slice(-40);
        if (!asArray(list).length) return `<div class="ov-chat-empty"></div>`;
        if (typeof _rtBattleChatRowHtml === "function"){
          return list.map((row, i) => _rtBattleChatRowHtml(row, i)).join("");
        }
        return list.map((row) => `<div class="ov-chat-row">${_escapeHtml(String(row?.text || ""))}</div>`).join("");
      }
      function _rtBattleRenderGameCard(){
        const st = _rtBattleState();
        const phase = String(st.phase || "lobby");
        const me = _rtBattleMePlayer();
        if (phase === "lobby"){
          const ready = !!me?.ready;
          const hasPreset = !!(_rtBattleState().room?.presetRef);
          const canStart = _rtBattleIsHost() && _rtBattleAllReady() && hasPreset;
          return `<section class="insight-card" style="padding:12px; margin-top:10px;">
            <div class="insight-head"><div class="insight-title"></div><div class="insight-note">${_escapeHtml(String(st.room?.roomId || ""))}</div></div>
            <div class="mini" style="margin-top:6px;">Ready</div>
            <div class="row-actions" style="margin-top:10px; gap:8px; flex-wrap:wrap;">
              <button class="btn" type="button" data-rt-battle-action="readyToggle"${!st.connected ? " disabled" : ""}>${ready ? "Ready" : "Ready"}</button>
              ${_rtBattleIsHost() ? `<button class="btn" type="button" data-rt-battle-action="gameStart"${(!st.connected || !canStart) ? " disabled" : ""}>Start</button>` : ""}
              <button class="textbtn" type="button" data-rt-battle-action="disconnect"${!st.connected && !st.connecting ? " disabled" : ""}></button>
            </div>
            ${_rtBattleIsHost() ? `<div class="mini" style="margin-top:8px;">${!hasPreset ? "" : (canStart ? "Ready" : "2Ready")}</div>` : ``}
          </section>`;
        }
        if (phase === "playing"){
          const q = st.currentQuestion || st.game?.currentQuestion || null;
          if (!q){
            return `<section class="insight-card" style="padding:12px; margin-top:10px;"><div class="mini"></div></section>`;
          }
          const answered = !!me?.answeredCurrent;
          const roundNo = Math.max(1, Number(q.round || (Number(st.game?.round || 0) + 1)));
          const totalRounds = _rtBattleResolvedTotalRounds(q.totalRounds || st.game?.totalRounds || 1);
          const remainSec = Math.max(0, Math.ceil(_rtBattleRemainingMs()/1000));
          const myScore = Math.max(0, Number(me?.score || 0));
          const remainQuestions = Math.max(0, totalRounds - roundNo);
          const roomId = String(st.room?.roomId || st.roomId || "");
          return `<section class="ov-playing-shell" aria-label=" ">
            <div class="ov-playing-top">
              <div class="ov-playing-hud">
                <div class="ov-hud-left">
                  <div class="ov-hud-line"><span class="ov-mini">ROOM</span> <code>${_escapeHtml(roomId || "------")}</code></div>
                  <div class="ov-hud-line"><span class="ov-mini"></span> Q ${roundNo}/${totalRounds}   ${remainQuestions}</div>
                </div>
                <div class="ov-hud-center">
                  <div class="ov-hud-timer" id="rtBattleCountdownText">${remainSec}</div>
                  <div class="ov-mini">sec</div>
                </div>
                <div class="ov-hud-right">
                  <div class="ov-hud-line"><span class="ov-mini">SCORE</span> ${myScore}</div>
                  <div class="ov-actions" style="justify-content:flex-end; margin-top:6px;">
                    <button class="textbtn" type="button" data-rt-battle-action="disconnect"${(!st.connected && !st.connecting) ? " disabled" : ""}></button>
                  </div>
                </div>
              </div>
              ${_rtBattleRenderScoreboardBars()}
            </div>
            <div class="card ov-play-card ov-question-stage ${st.feedbackKind || ""}">
              <div class="meta">
                <div class="no">No.${Math.max(0, Number(q.no || 0))}</div>
                <div class="dir"><span>ONLINE BATTLE</span><span class="judge">${answered ? "" : ""}</span></div>
              </div>
              <div class="prompt">${_escapeHtml(String(q.prompt || ""))}</div>
              <div class="ov-mini" style="margin-top:6px;">${_escapeHtml(String(st.room?.presetName || _rtBattlePresetDisplayName(st.room?.presetRef, "") || ""))}</div>
              <div class="choice-wrap" aria-label="4">
                <div class="choice-label">CHOICES</div>
                <div class="choices ov-choice-grid">
                  ${(Array.isArray(q.choices) ? q.choices : []).slice(0,4).map((c, idx) => `<button class="choice-btn" type="button" data-rt-battle-action="chooseAnswer" data-rt-battle-answer="${idx}"${(!st.connected || answered || _rtBattleRemainingMs()<=0) ? " disabled" : ""}><span class="k">${String.fromCharCode(65+idx)}</span>${_escapeHtml(String(c || ""))}</button>`).join("")}
                </div>
              </div>
              <div class="ov-play-foot">
                <div class="mini">${answered ? "" : ""}</div>
                <div class="mini">1</div>
              </div>
            </div>
          </section>`;
        }
        if (phase === "result"){
          const leaderboard = Array.isArray(st.finalResult?.leaderboard) ? st.finalResult.leaderboard : (Array.isArray(st.game?.finalLeaderboard) ? st.game.finalLeaderboard : []);
          const totalRounds = _rtBattleResolvedTotalRounds(st.game?.totalRounds || st.finalResult?.scores?.[0]?.totalRounds || 1);
          return `<section class="ov-result-shell">
            <div class="quiz-header">
              <div class="progress"><span>RESULT</span></div>
              <div class="pill">${_escapeHtml(_rtBattleQuestionCountLabel(totalRounds))}</div>
              <div class="pill">${asArray(leaderboard).length}</div>
            </div>
            ${_rtBattleRenderResultSummaryCard()}
            <section class="card ov-result-card">
              <div class="ov-result-title"></div>
              <div class="ov-result-table-wrap">
                <table class="ov-result-table">
                  <thead><tr><th>#</th><th></th><th></th><th></th></tr></thead>
                  <tbody>
                  ${asArray(leaderboard).length ? asArray(leaderboard).map((row, i)=>`<tr>
                    <td>${i+1}</td>
                    <td>${_escapeHtml(String(row?.nick || "Guest"))}</td>
                    <td>${Math.max(0, Number(row?.score || 0))}/${totalRounds}</td>
                    <td>${Math.round(Math.max(0, Number(row?.answeredAtMsTotal || 0))/100)/10}s</td>
                  </tr>`).join("") : `<tr><td colspan="4" class="ov-emptycell"></td></tr>`}
                  </tbody>
                </table>
              </div>
              <div class="row-actions" style="margin-top:12px;">
                ${_rtBattleIsHost() ? `<button class="btn" type="button" data-rt-battle-action="backLobby"${!st.connected ? " disabled" : ""}></button>` : `<button class="btn" type="button" disabled></button>`}
                ${_rtBattleIsHost() ? `<button class="textbtn" type="button" data-rt-battle-action="rematch"${!st.connected ? " disabled" : ""}></button>` : ``}
                <button class="textbtn" type="button" data-rt-battle-action="disconnect"${!st.connected && !st.connecting ? " disabled" : ""}></button>
                <button class="textbtn" type="button" data-rt-battle-action="overlayClose"></button>
              </div>
            </section>
            ${_rtBattleRenderRoundHistory()}
          </section>`;
        }
        return "";
      }
      function _rtBattleRenderRoundResult(){
        const r = _rtBattleState().lastRoundResult;
        if (!r || typeof r !== "object") return "";
        const totalRounds = _rtBattleResolvedTotalRounds(r.totalRounds || _rtBattleState().game?.totalRounds || 1);
        return `<section class="insight-card" style="padding:12px; margin-top:10px;">
          <div class="insight-head"><div class="insight-title"></div><div class="insight-note">${Math.max(1, Number(r.round || 1))}/${totalRounds}</div></div>
          <div class="mini">:  ${Math.max(0, Number(r.correctIndex || 0)) + 1}</div>
          <div style="margin-top:8px;">
            ${(Array.isArray(r.answersSummary) ? r.answersSummary : []).map((a)=>`<div class="mini">${_escapeHtml(String(a?.nick || "Guest"))}: ${a?.answered ? `${Math.max(0, Number(a.choiceIndex || 0))+1}` : ""} ${a?.correct ? "" : ""}</div>`).join("")}
          </div>
        </section>`;
      }
      function _renderOnlineBattleRealtimeHTML(){
        const st = _rtBattleState();
        const token = _authGetToken();
        const roomId = String(st.roomId || st.joinRoomId || "");
        const roomPw = String(st.roomPassword || st.joinPassword || "");
        return `
          <div class="menu-article">
            <h3></h3>
            <p class="mini">4Ready  Start  </p>
            ${!token ? `<div class="insight-empty"></div>` : `
              <section class="insight-card" style="padding:12px;">
                <div class="mini"></div>
                <input id="rtRoomNickInput" class="spell-input" type="text" maxlength="32" placeholder="Rinto" value="${_escapeHtml(String(st.nickname || ""))}" />
                <div class="row-actions" style="margin-top:10px; align-items:end;">
                  <div style="flex:1; min-width:0;">
                    <div class="mini">PW</div>
                    <input id="rtRoomCreatePasswordInput" class="spell-input" type="text" inputmode="latin" maxlength="6" placeholder="ABC123" value="${_escapeHtml(String(st.roomPassword || ""))}" />
                  </div>
                  <button class="btn" type="button" data-rt-battle-action="start"${st.busy || st.connecting ? " disabled" : ""}></button>
                </div>
              </section>

              <section class="insight-card" style="padding:12px; margin-top:10px;">
                <div class="row-actions" style="display:grid; grid-template-columns:1fr 1fr auto; gap:8px; align-items:end;">
                  <div style="min-width:0;">
                    <div class="mini">ID</div>
                    <input id="rtRoomJoinIdInput" class="spell-input" type="text" inputmode="latin" maxlength="6" placeholder="A1B2C3" value="${_escapeHtml(String(st.joinRoomId || ""))}" />
                  </div>
                  <div style="min-width:0;">
                    <div class="mini"></div>
                    <input id="rtRoomJoinPasswordInput" class="spell-input" type="text" inputmode="latin" maxlength="6" placeholder="ABC123" value="${_escapeHtml(String(st.joinPassword || ""))}" />
                  </div>
                  <button class="btn" type="button" data-rt-battle-action="reconnect"${st.busy || st.connecting ? " disabled" : ""}></button>
                </div>
                <div class="row-actions" style="margin-top:10px;">
                  <button class="textbtn" type="button" data-rt-battle-action="disconnect"${(!st.connected && !st.connecting) ? " disabled" : ""}></button>
                  ${roomId ? `<span class="mini">: <code>${_escapeHtml(roomId)}</code>${roomPw ? ` / PW <code>${_escapeHtml(roomPw)}</code>` : ""}</span>` : ""}
                </div>
                <div class="mini" id="rtBattleStatusLine" style="margin-top:8px;">${_escapeHtml(_rtBattleStatusLabel())}</div>
              </section>

              <section class="insight-card" style="padding:12px; margin-top:10px;">
                <div class="insight-head"><div class="insight-title"> / </div><div class="insight-note">${_escapeHtml(String(st.phase || "lobby"))}</div></div>
                <div class="mini">: ${Number(st.room?.count || asArray(st.players).length || 0)}/${Number(st.room?.max || 4)}${_rtBattleIsHost() ? " / Host" : ""}</div>
                <div style="margin-top:8px;">${_rtBattleRenderPlayerList()}</div>
              </section>

              ${_rtBattleRenderGameCard()}
              ${_rtBattleRenderRoundResult()}

              <section class="insight-card" style="padding:12px; margin-top:10px;">
                <div class="insight-head"><div class="insight-title"></div><div class="insight-note">${st.connected ? "" : ""}</div></div>
                <div style="max-height:220px; overflow:auto; border:1px solid var(--line); border-radius:10px; margin-top:8px; background:var(--card);">
                  ${_rtBattleRenderChatLogs()}
                </div>
                <div class="row-actions" style="margin-top:10px;">
                  <input id="rtBattleWriteInput" class="spell-input" type="text" placeholder="" value="${_escapeHtml(String(st.writeDraft || ""))}" />
                  <button class="btn" type="button" data-rt-battle-action="submitWrite"${!st.connected ? " disabled" : ""}></button>
                </div>
              </section>
            `}
          </div>
        `;
      }
      function _rtBattleInitView(){
        if (_menuState.view !== "onlineBattleRealtime") return;
        const st = _rtBattleState();
        const content = document.getElementById("menuContent") || document;
        _customSelectEnhance(content);
        const createPwEl = document.getElementById("rtRoomCreatePasswordInput");
        const joinIdEl = document.getElementById("rtRoomJoinIdInput");
        const joinPwEl = document.getElementById("rtRoomJoinPasswordInput");
        const nickEl = document.getElementById("rtRoomNickInput");
        const chatEl = document.getElementById("rtBattleWriteInput");
        if (createPwEl) createPwEl.value = String(st.roomPassword || "");
        if (joinIdEl) joinIdEl.value = String(st.joinRoomId || "");
        if (joinPwEl) joinPwEl.value = String(st.joinPassword || "");
        if (nickEl) nickEl.value = String(st.nickname || "");
        if (chatEl) chatEl.value = String(st.writeDraft || "");
        if (st.phase === "playing") _rtBattleEnsureUiTimer();
        else _rtBattleStopUiTimer();
      }
      // ROOM_DO_UI_V3_OVERLAY: fullscreen lobby/qr/preset/countdown/reconnect
      const RT_BATTLE_LAST_ROOM_KEY = "vq.lastRoom";
      const RT_QR_JS_URL = "https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js";
      function _rtBattleState(){
        if (!_menuState.rtBattle || typeof _menuState.rtBattle !== "object") _menuState.rtBattle = {};
        const st = _menuState.rtBattle;
        if (typeof st.overlayOpen !== "boolean") st.overlayOpen = false;
        if (typeof st.overlayScene !== "string") st.overlayScene = "top";
        if (typeof st.overlaySheet !== "string") st.overlaySheet = "";
        if (!Array.isArray(st.overlayHistory)) st.overlayHistory = [];
        if (typeof st.manualClose !== "boolean") st.manualClose = false;
        if (typeof st.reconnectAttempts !== "number") st.reconnectAttempts = 0;
        if (typeof st.reconnectTimerId !== "number" && st.reconnectTimerId !== null) st.reconnectTimerId = null;
        if (typeof st.reconnecting !== "boolean") st.reconnecting = false;
        if (!st.qr || typeof st.qr !== "object") st.qr = { status: "idle", url: "", error: "", timeoutId: null, reqId: 0 };
        if (!st.scanner || typeof st.scanner !== "object") st.scanner = {
          open: false, supported: null, status: "", error: "", stream: null, loopTimerId: null, videoReady: false, loadingLib: false
        };
        if (typeof st.feedbackKind !== "string") st.feedbackKind = "";
        if (typeof st.feedbackTimerId !== "number" && st.feedbackTimerId !== null) st.feedbackTimerId = null;
        if (typeof st.joinUrl !== "string") st.joinUrl = "";
        if (!st.presetRef || typeof st.presetRef !== "object") st.presetRef = null;
        if (typeof st.presetName !== "string") st.presetName = "";
        if (typeof st.questionCount === "undefined") st.questionCount = 20;
        if (!Array.isArray(st.presetOptionsCache)) st.presetOptionsCache = [];
        if (typeof st.lastSeenEventId !== "number") st.lastSeenEventId = 0;
        if (!Array.isArray(st.eventToastQueue)) st.eventToastQueue = [];
        if (!Array.isArray(st.eventHistory)) st.eventHistory = [];
        if (!st.eventToastActive || typeof st.eventToastActive !== "object") st.eventToastActive = null;
        if (typeof st.eventToastTimerId !== "number" && st.eventToastTimerId !== null) st.eventToastTimerId = null;
        if (typeof st.eventToastAnimTimerId !== "number" && st.eventToastAnimTimerId !== null) st.eventToastAnimTimerId = null;
        if (!st.b3d || typeof st.b3d !== "object") st.b3d = {};
        const b3 = st.b3d;
        if (typeof b3.open !== "boolean") b3.open = false;
        if (typeof b3.loading !== "boolean") b3.loading = false;
        if (typeof b3.error !== "string") b3.error = "";
        if (typeof b3.status !== "string") b3.status = "";
        if (typeof b3.connectedWeak !== "boolean") b3.connectedWeak = false;
        if (typeof b3.lastNetTs !== "number") b3.lastNetTs = 0;
        if (typeof b3.pingMs !== "number") b3.pingMs = 0;
        if (typeof b3.awaitingPingTs !== "number") b3.awaitingPingTs = 0;
        if (typeof b3.lastSendAt !== "number") b3.lastSendAt = 0;
        if (typeof b3.rafId !== "number" && b3.rafId !== null) b3.rafId = null;
        if (typeof b3.netTimerId !== "number" && b3.netTimerId !== null) b3.netTimerId = null;
        if (typeof b3.uiTimerId !== "number" && b3.uiTimerId !== null) b3.uiTimerId = null;
        if (typeof b3.resizeBound !== "boolean") b3.resizeBound = false;
        if (typeof b3.overlayScene !== "string") b3.overlayScene = "play";
        if (typeof b3.quizOpen !== "boolean") b3.quizOpen = false;
        if (typeof b3.quizAnswered !== "boolean") b3.quizAnswered = false;
        if (typeof b3.quizError !== "string") b3.quizError = "";
        if (typeof b3.gateOpen !== "boolean") b3.gateOpen = false;
        if (typeof b3.gateRaised !== "number") b3.gateRaised = 0;
        if (typeof b3.localFinished !== "boolean") b3.localFinished = false;
        if (!Array.isArray(b3.finishOrder)) b3.finishOrder = [];
        if (typeof b3.winnerUserId !== "number") b3.winnerUserId = 0;
        if (typeof b3.winnerNick !== "string") b3.winnerNick = "";
        if (!b3.remoteStates || typeof b3.remoteStates !== "object") b3.remoteStates = {};
        if (!b3.remoteMeshes || typeof b3.remoteMeshes !== "object") b3.remoteMeshes = {};
        if (!b3.input || typeof b3.input !== "object") b3.input = { fwd:false, back:false, left:false, right:false, jump:false };
        return st;
      }
      function _rtBattleOverlayIsOpen(){ return !!_rtBattleState().overlayOpen; }
      function _rtBattleStopReconnect(){
        const st = _rtBattleState();
        if (st.reconnectTimerId){
          clearTimeout(st.reconnectTimerId);
          st.reconnectTimerId = null;
        }
        st.reconnecting = false;
      }
      function _rtBattleClearFeedback(){
        const st = _rtBattleState();
        if (st.feedbackTimerId){ clearTimeout(st.feedbackTimerId); st.feedbackTimerId = null; }
        st.feedbackKind = "";
      }
      function _rtBattleFeedback(kind){
        const st = _rtBattleState();
        _rtBattleClearFeedback();
        st.feedbackKind = (kind === "ok") ? "ok" : "ng";
        try{ if (typeof playSfx === "function") playSfx(kind === "ok" ? "ok" : "ng"); }catch(_){}
        try{
          if (navigator && typeof navigator.vibrate === "function"){
            if (kind === "ok") navigator.vibrate(20);
            else navigator.vibrate([20,30,20]);
          }
        }catch(_){}
        st.feedbackTimerId = setTimeout(() => {
          st.feedbackTimerId = null;
          st.feedbackKind = "";
          _rtBattleOverlayRender();
        }, 260);
        _rtBattleOverlayRender();
      }
      function _rtBattleSaveLastRoom(){
        const st = _rtBattleState();
        const roomId = String(st.roomId || st.joinRoomId || "");
        const pw = String(st.roomPassword || st.joinPassword || "");
        if (!roomId || !pw) return;
        const payload = { roomId, pw, nickname: String(st.nickname || ""), ts: Date.now() };
        try{ window.localStorage.setItem(RT_BATTLE_LAST_ROOM_KEY, JSON.stringify(payload)); }catch(_){}
      }
      function _rtBattleLoadLastRoom(){
        try{
          const raw = window.localStorage.getItem(RT_BATTLE_LAST_ROOM_KEY);
          if (!raw) return null;
          const d = JSON.parse(raw);
          if (!d || typeof d !== "object") return null;
          if ((Date.now() - Math.max(0, Number(d.ts || 0))) > 10 * 60 * 1000) return null;
          return {
            roomId: String(d.roomId || "").toUpperCase().replace(/[^A-Z0-9]/g, "").slice(0,6),
            pw: String(d.pw || "").toUpperCase().replace(/[^A-Z0-9]/g, "").slice(0,6),
            nickname: String(d.nickname || "").slice(0,32),
            ts: Math.max(0, Number(d.ts || 0))
          };
        }catch(_){ return null; }
      }
      function _rtBattleJoinUrl(roomId, pw){
        const u = new URL(location.href);
        u.hash = `room=${encodeURIComponent(String(roomId || ""))}&pw=${encodeURIComponent(String(pw || ""))}`;
        return u.toString();
      }
      function _rtBattleParseRoomHash(hashRaw){
        const raw = String(hashRaw || location.hash || "").replace(/^#/, "");
        if (!raw) return null;
        const p = new URLSearchParams(raw);
        const roomId = String(p.get("room") || "").toUpperCase().replace(/[^A-Z0-9]/g, "").slice(0,6);
        const pw = String(p.get("pw") || "").toUpperCase().replace(/[^A-Z0-9]/g, "").slice(0,6);
        if (!roomId || !pw) return null;
        return { roomId, pw };
      }
      function _rtBattleHashAutofill(){
        const parsed = _rtBattleParseRoomHash(location.hash);
        if (!parsed) return;
        const st = _rtBattleState();
        st.joinRoomId = parsed.roomId;
        st.joinPassword = parsed.pw;
        _rtBattleOverlayOpen("join");
        _rtBattleOverlayRender();
      }
      let __rtQrScriptPromise = null;
      function _rtBattleLoadQrForJoinUrl(joinUrl){
        const st = _rtBattleState();
        const qr = st.qr || (st.qr = { status: "idle", url: "", error: "", timeoutId: null, reqId: 0 });
        qr.reqId = Math.max(0, Number(qr.reqId || 0)) + 1;
        const rid = qr.reqId;
        qr.status = "loading";
        qr.error = "";
        qr.url = "";
        if (qr.timeoutId){ clearTimeout(qr.timeoutId); qr.timeoutId = null; }
        _rtBattleOverlayRender();
        const imgUrl = `https://api.qrserver.com/v1/create-qr-code/?size=240x240&data=${encodeURIComponent(String(joinUrl || ""))}`;
        const img = new Image();
        let settled = false;
        const done = (ok, errMsg="") => {
          if (settled) return;
          settled = true;
          if (qr.timeoutId){ clearTimeout(qr.timeoutId); qr.timeoutId = null; }
          if (rid !== qr.reqId) return;
          if (ok){
            qr.status = "ok";
            qr.url = imgUrl;
            qr.error = "";
          } else {
            qr.status = "error";
            qr.url = "";
            qr.error = errMsg || "QR/URL";
          }
          _rtBattleOverlayRender();
        };
        img.onload = () => done(true);
        img.onerror = () => done(false, "QR/URL");
        qr.timeoutId = setTimeout(() => done(false, "QR/URL"), 5000);
        img.src = imgUrl;
      }
      function _rtBattleEnsureOverlayStyles(){
        if (document.getElementById("onlineOverlayStyles")) return;
        const style = document.createElement("style");
        style.id = "onlineOverlayStyles";
        style.textContent = `
          #onlineOverlay{position:fixed; inset:0; z-index:99990; display:none;}
          #onlineOverlay.is-open{display:block;}
          #onlineOverlay .ov-bg{position:absolute; inset:0; background:rgba(0,0,0,.28);}
          #onlineOverlay .ov-shell{position:absolute; inset:10px 10px calc(env(safe-area-inset-bottom,0px) + 10px) 10px; background:var(--bg,var(--panel,#fff)); color:var(--text,#111); border:1px solid var(--border,#ddd); border-radius:20px; box-shadow:var(--shadow,0 12px 30px rgba(0,0,0,.12)); display:flex; flex-direction:column; overflow:hidden;}
          #onlineOverlay .ov-head{display:flex; align-items:center; justify-content:space-between; gap:10px; padding:10px 12px; border-bottom:1px solid var(--bar-border,var(--line,var(--border,#ddd))); background:var(--bar-bg,var(--panel,#fff)); position:sticky; top:0; z-index:2;}
          #onlineOverlay .ov-title{font-weight:800; font-size:16px;}
          #onlineOverlay .ov-headbtn{min-height:40px; min-width:40px; border-radius:12px;}
          #onlineOverlay .ov-body{flex:1; overflow:auto; padding:14px; background:var(--bg,#f7f7f8);}
          #onlineOverlay .ov-scene{animation:ovFade .22s cubic-bezier(.22,1,.36,1);}
          #onlineOverlay .ov-grid{display:grid; gap:10px;}
          #onlineOverlay .ov-grid.cols2{grid-template-columns:repeat(2,minmax(0,1fr));}
          #onlineOverlay .ov-card{background:var(--panel,#fff); border:1px solid var(--border,#ddd); border-radius:14px; padding:12px; box-shadow:0 1px 0 rgba(17,18,20,.04);}
          #onlineOverlay .ov-card.is-click{cursor:pointer;}
          #onlineOverlay .ov-card h4{margin:0 0 6px; font-size:15px;}
          #onlineOverlay .ov-mini{font-size:12px; opacity:.8;}
          #onlineOverlay .ov-actions{display:flex; gap:8px; flex-wrap:wrap; margin-top:10px;}
          #onlineOverlay .ov-iconbtn{min-width:40px; min-height:40px; padding:0 10px; display:inline-flex; align-items:center; justify-content:center; border-radius:12px;}
          #onlineOverlay .ov-iconbtn .ms{font-size:20px; line-height:1;}
          #onlineOverlay .ov-banner{padding:10px 12px; border-radius:14px; background:var(--panel,#fff); border:1px solid var(--border,#ddd); margin-bottom:10px; box-shadow:0 1px 0 rgba(17,18,20,.04);}
          #onlineOverlay .ov-banner.err{background:rgba(255,0,0,.06);}
          #onlineOverlay .ov-countdown{display:grid; place-items:center; min-height:40vh; text-align:center;}
          #onlineOverlay .ov-countdown .n{font-size:clamp(48px,14vw,92px); font-weight:900; line-height:1; animation:ovPop .24s ease;}
          #onlineOverlay .ov-qr{display:grid; place-items:center; min-height:260px; border-radius:14px; border:1px dashed var(--line,var(--border,#ddd)); background:var(--panel,#fff);}
          #onlineOverlay .ov-qr img{max-width:240px; width:100%; height:auto; border-radius:12px;}
          #onlineOverlay .ov-entry-card{display:flex; align-items:center; gap:12px; text-align:left;}
          #onlineOverlay .ov-entry-icon{width:44px; height:44px; border-radius:12px; display:grid; place-items:center; flex-shrink:0; background:var(--panel2,#f3f4f6); border:1px solid var(--border,#ddd); color:var(--accent,#1f2a44);}
          #onlineOverlay .ov-entry-icon .ms{font-size:24px; line-height:1;}
          #onlineOverlay .ov-entry-copy{min-width:0;}
          #onlineOverlay .ov-entry-copy h4{margin:0 0 4px;}
          #onlineOverlay .ov-scene-lobby{display:grid; gap:10px;}
          #onlineOverlay .ov-lobby-head{position:sticky; top:0; z-index:3; background:rgba(255,255,255,.88); border:1px solid var(--border,#ddd); border-radius:14px; padding:10px 12px; box-shadow:0 1px 0 rgba(17,18,20,.04); display:grid; grid-template-columns:minmax(0,1fr) minmax(0,1.2fr) auto; gap:10px; align-items:center;}
          #onlineOverlay .ov-lobby-head-left,#onlineOverlay .ov-lobby-head-center{min-width:0;}
          #onlineOverlay .ov-lobby-head-center{text-align:center;}
          #onlineOverlay .ov-lobby-head-right{display:flex; gap:6px; align-items:center; justify-content:flex-end;}
          #onlineOverlay .ov-lobby-title{font-weight:800; font-size:15px; line-height:1.2;}
          #onlineOverlay .ov-lobby-room code{font-size:14px; font-weight:800; letter-spacing:.08em;}
          #onlineOverlay .ov-lobby-head-badges{grid-column:1/-1; display:flex; gap:6px; flex-wrap:wrap;}
          #onlineOverlay .ov-chat-main{padding:10px; display:flex; flex-direction:column; min-height:58vh; max-height:calc(100dvh - 180px);}
          #onlineOverlay .ov-chat-main-head{display:flex; align-items:center; justify-content:space-between; gap:8px; padding:2px 2px 8px;}
          #onlineOverlay .ov-chat-scroll.is-main{flex:1; max-height:none; min-height:220px; background:var(--panel2,#fbfbfc);}
          #onlineOverlay .ov-chat-composer{position:sticky; bottom:0; padding-top:10px; margin-top:10px; background:linear-gradient(180deg, rgba(255,255,255,0), rgba(255,255,255,.85) 24%, rgba(255,255,255,.95));}
          #onlineOverlay .ov-chat-composer-row{display:flex; gap:8px; align-items:center;}
          #onlineOverlay .ov-chat-composer-row.is-tools{margin-top:8px;}
          #onlineOverlay .ov-chat-composer-row .spell-input{flex:1; min-width:0;}
          #onlineOverlay .ov-chat-row.is-chat{padding:8px 10px 10px; border-bottom:0; display:flex; flex-direction:column; gap:4px;}
          #onlineOverlay .ov-chat-row.is-chat .ov-chat-bubble{display:inline-block; max-width:min(92%, 560px); border:1px solid var(--border,#ddd); border-radius:14px; background:var(--panel,#fff); padding:9px 11px; box-shadow:0 1px 0 rgba(17,18,20,.04);}
          #onlineOverlay .ov-chat-row.is-chat.is-me{align-items:flex-end;}
          #onlineOverlay .ov-chat-row.is-chat.is-me .ov-chat-bubble{background:rgba(31,42,68,.06); border-color:rgba(31,42,68,.14);}
          #onlineOverlay .ov-chat-row.is-chat.is-me .ov-chat-meta{text-align:right;}
          #onlineOverlay .ov-chat-text{white-space:pre-wrap; word-break:break-word; color:var(--text); line-height:1.45;}
          #onlineOverlay .ov-side-sheet{position:absolute; top:70px; right:12px; bottom:12px; width:min(420px, 92vw); background:var(--panel,#fff); border:1px solid var(--border,#ddd); border-radius:16px; box-shadow:0 14px 28px rgba(0,0,0,.12); transform:translateX(12px); opacity:0; pointer-events:none; transition:transform .22s cubic-bezier(.22,1,.36,1), opacity .22s cubic-bezier(.22,1,.36,1); z-index:6; display:flex; flex-direction:column; overflow:hidden;}
          #onlineOverlay .ov-side-sheet.is-open{transform:none; opacity:1; pointer-events:auto;}
          #onlineOverlay .ov-sheet-mask{position:absolute; inset:0; background:rgba(0,0,0,.12); z-index:5;}
          #onlineOverlay .ov-side-sheet-head{display:flex; align-items:center; justify-content:space-between; gap:8px; padding:10px 12px; border-bottom:1px solid var(--border,#ddd); background:var(--panel,#fff); position:sticky; top:0; z-index:1;}
          #onlineOverlay .ov-side-sheet-body{flex:1; overflow:auto; padding:12px; background:var(--bg,#f7f7f8);}
          #onlineOverlay .ov-sheet-stack{display:grid; gap:10px;}
          #onlineOverlay .ov-sheet-headline{font-weight:700; font-size:13px; margin-bottom:6px; color:var(--text);}
          #onlineOverlay .ov-mode-grid{display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:8px;}
          #onlineOverlay .ov-mode-chip{appearance:none; border:1px solid var(--border,#ddd); background:var(--panel2,#fbfbfc); color:var(--text); border-radius:12px; min-height:42px; padding:8px 10px; font-size:12px; font-weight:700; text-align:center; transition:transform .16s ease, box-shadow .16s ease, border-color .16s ease;}
          #onlineOverlay .ov-mode-chip.is-active{border-color:rgba(31,42,68,.24); background:rgba(31,42,68,.08); box-shadow:0 1px 0 rgba(17,18,20,.04);}
          #onlineOverlay .ov-mode-chip:not(:disabled):active{transform:scale(.98);}
          #onlineOverlay .ov-mode-chip:disabled{opacity:.55; cursor:not-allowed;}
          #onlineOverlay .ov-member-log{display:grid; gap:6px; margin-top:8px;}
          #onlineOverlay .ov-member-log-row{display:flex; align-items:center; gap:8px; min-height:34px; padding:6px 8px; border-radius:10px; border:1px solid var(--border,#ddd); background:var(--panel2,#fbfbfc); font-size:12px;}
          #onlineOverlay .ov-member-log-badge{display:inline-flex; align-items:center; justify-content:center; min-width:34px; height:20px; padding:0 6px; border-radius:999px; border:1px solid var(--border,#ddd); font-size:10px; font-weight:700; color:var(--muted);}
          #onlineOverlay .ov-member-log-row.is-ok .ov-member-log-badge{background:rgba(64,190,106,.10); color:#1e7a45;}
          #onlineOverlay .ov-member-log-row.is-ng .ov-member-log-badge{background:rgba(235,87,87,.10); color:#b03939;}
          #onlineOverlay .ov-stage-grid{display:grid; gap:10px;}
          #onlineOverlay .ov-stage-grid.is-lobby{grid-template-columns:minmax(0,1.05fr) minmax(0,.95fr);}
          #onlineOverlay .ov-stage-grid.is-game{grid-template-columns:minmax(0,1.1fr) minmax(0,.9fr);}
          #onlineOverlay .ov-scene-gameplay{display:grid; grid-template-rows:auto auto minmax(0,1fr); gap:10px; min-height:100%;}
          #onlineOverlay .ov-game-head{display:grid; grid-template-columns:minmax(0,1fr) auto auto; gap:10px; align-items:center; border:1px solid var(--border,#ddd); background:var(--panel,#fff); border-radius:14px; padding:10px 12px; box-shadow:0 1px 0 rgba(17,18,20,.04);}
          #onlineOverlay .ov-game-head-left{min-width:0;}
          #onlineOverlay .ov-game-title{font-weight:800; font-size:14px; color:var(--text); line-height:1.1;}
          #onlineOverlay .ov-game-head-center{display:grid; gap:2px; justify-items:center; min-width:90px;}
          #onlineOverlay .ov-game-head-progress{font-size:13px; font-weight:800; color:var(--text);}
          #onlineOverlay .ov-game-head-phase{font-size:11px; color:var(--muted); letter-spacing:.04em;}
          #onlineOverlay .ov-game-head-right{display:flex; align-items:center; gap:6px;}
          #onlineOverlay .ov-game-stage-wrap{min-height:0; display:grid;}
          #onlineOverlay .ov-game-shell-card{padding:10px; min-height:0; overflow:auto; background:var(--panel,#fff);}
          #onlineOverlay .ov-game-shell-card > .ov-playing-shell,
          #onlineOverlay .ov-game-shell-card > .ov-result-shell{max-width:920px; width:100%; margin:0 auto;}
          #onlineOverlay .ov-game-shell-card > .ov-result-shell{gap:12px;}
          #onlineOverlay .ov-countdown-stage{display:grid; gap:12px; max-width:860px; margin:0 auto;}
          #onlineOverlay .ov-countdown-shell{border:1px solid var(--border,#ddd); border-radius:14px; background:var(--panel2,#fbfbfc); padding:16px;}
          #onlineOverlay .ov-chat-scroll{max-height:240px; overflow:auto; border:1px solid var(--border,#ddd); border-radius:10px; background:var(--panel2,#fbfbfc);}
          #onlineOverlay .ov-chat-list{display:block;}
          #onlineOverlay .ov-chat-empty{padding:10px 12px; font-size:12px; color:var(--muted);}
          #onlineOverlay .ov-chat-row{padding:8px 10px; border-bottom:1px solid var(--border,#ddd);}
          #onlineOverlay .ov-chat-row:last-child{border-bottom:0;}
          #onlineOverlay .ov-chat-row.is-system{font-size:12px; color:var(--muted);}
          #onlineOverlay .ov-chat-meta{font-size:11px; color:var(--muted); margin-bottom:3px;}
          #onlineOverlay .ov-chat-meta span{opacity:.8;}
          #onlineOverlay .ov-card.settings-group{overflow:hidden;}
          #onlineOverlay .ov-card.settings-group .settings-row{background:transparent;}
          #onlineOverlay .ov-card.settings-group .settings-row.is-static{cursor:default;}
          #onlineOverlay .ov-scanner{position:absolute; inset:0; background:rgba(0,0,0,.45); display:none; z-index:4;}
          #onlineOverlay .ov-scanner.is-open{display:block;}
          #onlineOverlay .ov-scanner-panel{position:absolute; left:10px; right:10px; top:56px; bottom:10px; background:var(--panel,#fff); border-radius:18px; border:1px solid var(--border,#ddd); display:flex; flex-direction:column; overflow:hidden;}
          #onlineOverlay .ov-scanner-head{display:flex; justify-content:space-between; align-items:center; padding:10px 12px; border-bottom:1px solid var(--line,var(--border,#ddd));}
          #onlineOverlay .ov-scanner-view{position:relative; flex:1; background:#000; display:grid; place-items:center;}
          #onlineOverlay .ov-scanner-view video{width:100%; height:100%; object-fit:cover;}
          #onlineOverlay .ov-scanner-overlay{position:absolute; inset:0; pointer-events:none; border:2px solid rgba(255,255,255,.2);}
          #onlineOverlay .ov-qcard.ok{box-shadow:0 0 0 2px rgba(64,190,106,.35) inset;}
          #onlineOverlay .ov-qcard.ng{box-shadow:0 0 0 2px rgba(235,87,87,.35) inset;}
          #onlineOverlay .ov-playing-shell{display:grid; gap:10px;}
          #onlineOverlay .ov-playing-top{display:grid; grid-template-columns:minmax(0,1fr); gap:10px; position:sticky; top:0; z-index:2;}
          #onlineOverlay .ov-playing-hud{display:grid; grid-template-columns:minmax(0,1fr) auto minmax(0,1fr); gap:10px; align-items:center; background:var(--panel,#fff); border:1px solid var(--border,#ddd); border-radius:14px; padding:10px 12px; box-shadow:0 1px 0 rgba(17,18,20,.04);}
          #onlineOverlay .ov-hud-left,#onlineOverlay .ov-hud-right{display:grid; gap:4px; min-width:0;}
          #onlineOverlay .ov-hud-right{text-align:right; justify-items:end;}
          #onlineOverlay .ov-hud-center{display:grid; justify-items:center; align-content:center; min-width:64px;}
          #onlineOverlay .ov-hud-line{font-size:13px; color:var(--text); white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
          #onlineOverlay .ov-hud-line code{font-family:ui-monospace,SFMono-Regular,Menlo,monospace; font-size:12px;}
          #onlineOverlay .ov-hud-timer{font-size:clamp(26px,5vw,36px); line-height:1; font-weight:900; font-variant-numeric:tabular-nums; letter-spacing:.02em;}
          #onlineOverlay .ov-play-card{padding:14px;}
          #onlineOverlay .ov-play-card.card{border-radius:16px;}
          #onlineOverlay .ov-play-card.ov-question-stage{animation:ovQuestionIn .22s cubic-bezier(.22,1,.36,1);}
          #onlineOverlay .ov-play-card .prompt{font-size:18px; line-height:1.45; margin-top:10px;}
          #onlineOverlay .ov-play-card .choice-wrap{display:block; margin-top:12px;}
          #onlineOverlay .ov-play-card .choice-label{font-size:12px; color:var(--muted); margin-bottom:8px; letter-spacing:.08em;}
          #onlineOverlay .ov-play-card .ov-choice-grid{display:grid; grid-template-columns:1fr; gap:10px;}
          #onlineOverlay .ov-play-card .choice-btn{width:100%; justify-content:flex-start; text-align:left; min-height:48px;}
          #onlineOverlay .ov-play-foot{display:flex; justify-content:space-between; align-items:center; gap:10px; margin-top:12px;}
          #onlineOverlay .ov-scoreboard{background:var(--panel,#fff); border:1px solid var(--border,#ddd); border-radius:14px; padding:10px; box-shadow:0 1px 0 rgba(17,18,20,.04);}
          #onlineOverlay .ov-score-title{font-size:12px; font-weight:700; color:var(--muted); margin-bottom:8px;}
          #onlineOverlay .ov-score-list{display:grid; gap:8px; max-height:160px; overflow:auto;}
          #onlineOverlay .ov-score-row{display:grid; gap:4px;}
          #onlineOverlay .ov-score-row.is-me .ov-score-name{font-weight:800;}
          #onlineOverlay .ov-score-head{display:flex; justify-content:space-between; gap:8px; align-items:center;}
          #onlineOverlay .ov-score-name{font-size:12px; color:var(--text); overflow:hidden; text-overflow:ellipsis; white-space:nowrap;}
          #onlineOverlay .ov-score-val{font-size:11px; color:var(--muted); flex-shrink:0;}
          #onlineOverlay .ov-score-bar{height:8px; border-radius:999px; background:var(--panel2,#f3f4f6); border:1px solid var(--border,#ddd); overflow:hidden;}
          #onlineOverlay .ov-score-bar i{display:block; height:100%; border-radius:999px; background:linear-gradient(90deg, rgba(31,42,68,.88), rgba(31,42,68,.62));}
          #onlineOverlay .ov-event-toast{position:sticky; top:0; z-index:5; margin:0 auto 10px; width:fit-content; max-width:min(92%,520px); pointer-events:none; padding:10px 14px; border-radius:12px; border:1px solid var(--border,#ddd); background:rgba(255,255,255,.94); color:var(--text); box-shadow:0 10px 24px rgba(0,0,0,.10); animation:ovToastIn .24s cubic-bezier(.22,1,.36,1); display:flex; align-items:center; gap:8px;}
          #onlineOverlay .ov-event-badge{display:inline-flex; align-items:center; justify-content:center; min-width:44px; height:22px; padding:0 8px; border-radius:999px; border:1px solid var(--border,#ddd); background:var(--panel2,#f5f6f8); color:var(--muted); font-size:11px; font-weight:800; letter-spacing:.04em;}
          #onlineOverlay .ov-event-toast.is-ok .ov-event-badge{color:#1e7a45; background:rgba(64,190,106,.10);}
          #onlineOverlay .ov-event-toast.is-ng .ov-event-badge{color:#b03939; background:rgba(235,87,87,.10);}
          #onlineOverlay .ov-event-toast.is-info .ov-event-badge{color:var(--accent,#1f2a44);}
          #onlineOverlay .ov-event-toast.is-hide{animation:ovToastOut .22s cubic-bezier(.22,1,.36,1) forwards;}
          #onlineOverlay .ov-result-shell{display:grid; gap:10px;}
          #onlineOverlay .ov-result-summary{padding:14px;}
          #onlineOverlay .ov-result-summary-grid{display:grid; gap:10px; grid-template-columns:repeat(4,minmax(0,1fr));}
          #onlineOverlay .ov-result-stat{border:1px solid var(--border,#ddd); border-radius:12px; background:var(--panel2,#fbfbfc); padding:10px;}
          #onlineOverlay .ov-result-stat .k{display:block; font-size:11px; color:var(--muted); margin-bottom:4px;}
          #onlineOverlay .ov-result-stat strong{display:block; font-size:17px; line-height:1.2;}
          #onlineOverlay .ov-result-card{padding:14px;}
          #onlineOverlay .ov-result-title{font-weight:800; font-size:17px; margin-bottom:8px;}
          #onlineOverlay .ov-result-table-wrap{overflow:auto; border:1px solid var(--border,#ddd); border-radius:12px; background:var(--panel2,#fbfbfc);}
          #onlineOverlay .ov-result-table{width:100%; border-collapse:collapse; font-size:13px;}
          #onlineOverlay .ov-result-table th, #onlineOverlay .ov-result-table td{padding:10px 12px; border-bottom:1px solid var(--border,#ddd); text-align:left; white-space:nowrap;}
          #onlineOverlay .ov-result-table thead th{position:sticky; top:0; background:var(--panel,#fff); z-index:1;}
          #onlineOverlay .ov-result-table tbody tr:last-child td{border-bottom:0;}
          #onlineOverlay .ov-emptycell{color:var(--muted); text-align:center;}
          #onlineOverlay .ov-roundlog-card{padding:14px;}
          #onlineOverlay .ov-roundlog-list{display:grid; gap:8px; max-height:260px; overflow:auto;}
          #onlineOverlay .ov-roundlog-item{border:1px solid var(--border,#ddd); border-radius:12px; background:var(--panel2,#fbfbfc); padding:10px;}
          #onlineOverlay .ov-roundlog-item.is-ok{box-shadow:inset 0 0 0 1px rgba(64,190,106,.18);}
          #onlineOverlay .ov-roundlog-item.is-ng{box-shadow:inset 0 0 0 1px rgba(235,87,87,.16);}
          #onlineOverlay .ov-roundlog-top{display:flex; align-items:center; justify-content:space-between; gap:8px;}
          @keyframes ovFade{from{opacity:0; transform:translateY(8px)}to{opacity:1; transform:none}}
          @keyframes ovPop{from{opacity:.2; transform:scale(.9)}to{opacity:1; transform:scale(1)}}
          @keyframes ovQuestionIn{from{opacity:0; transform:translateY(8px)}to{opacity:1; transform:none}}
          @keyframes ovToastIn{from{opacity:0; transform:translateY(-8px)}to{opacity:1; transform:none}}
          @keyframes ovToastOut{from{opacity:1; transform:none}to{opacity:0; transform:translateY(-8px)}}
          @media (max-width: 760px){
            #onlineOverlay .ov-shell{inset:0 0 calc(env(safe-area-inset-bottom,0px)) 0; border-radius:0;}
            #onlineOverlay .ov-grid.cols2{grid-template-columns:1fr;}
            #onlineOverlay .ov-body{padding:12px;}
            #onlineOverlay .ov-scene-gameplay{grid-template-rows:auto auto minmax(0,1fr);}
            #onlineOverlay .ov-game-head{grid-template-columns:minmax(0,1fr) auto; align-items:start;}
            #onlineOverlay .ov-game-head-center{grid-column:1/-1; justify-items:start; order:3;}
            #onlineOverlay .ov-game-head-right{justify-content:flex-end;}
            #onlineOverlay .ov-lobby-head{grid-template-columns:minmax(0,1fr) auto; align-items:start;}
            #onlineOverlay .ov-lobby-head-center{grid-column:1 / -1; order:3; text-align:left;}
            #onlineOverlay .ov-lobby-head-badges{order:4;}
            #onlineOverlay .ov-chat-main{min-height:calc(100dvh - 230px); max-height:calc(100dvh - 230px);}
            #onlineOverlay .ov-side-sheet{top:60px; right:8px; bottom:8px; width:min(96vw, 420px);}
            #onlineOverlay .ov-stage-grid.is-lobby,
            #onlineOverlay .ov-stage-grid.is-game{grid-template-columns:1fr;}
            #onlineOverlay .ov-chat-scroll{max-height:200px;}
            #onlineOverlay .ov-playing-hud{grid-template-columns:1fr auto; align-items:start;}
            #onlineOverlay .ov-hud-left{grid-column:1/2;}
            #onlineOverlay .ov-hud-center{grid-column:2/3; grid-row:1 / span 2; align-self:center;}
            #onlineOverlay .ov-hud-right{grid-column:1/3; justify-items:start; text-align:left; margin-top:2px;}
            #onlineOverlay .ov-hud-right .ov-actions{justify-content:flex-start !important;}
            #onlineOverlay .ov-play-card .prompt{font-size:16px;}
            #onlineOverlay .ov-play-card .ov-choice-grid{grid-template-columns:repeat(2,minmax(0,1fr));}
            #onlineOverlay .ov-play-card .choice-btn{min-height:52px;}
            #onlineOverlay .ov-result-summary-grid{grid-template-columns:repeat(2,minmax(0,1fr));}
          }
        `;
        document.head.appendChild(style);
      }
      function _rtBattleOverlayEnsureDom(){
        _rtBattleEnsureOverlayStyles();
        let root = document.getElementById("onlineOverlay");
        if (root) return root;
        root = document.createElement("div");
        root.id = "onlineOverlay";
        root.setAttribute("aria-hidden", "true");
        root.innerHTML = `
          <div class="ov-bg" data-rt-battle-action="overlayClose"></div>
          <div class="ov-shell" role="dialog" aria-label="">
            <div class="ov-head">
              <button class="btn ov-headbtn" type="button" id="onlineOverlayBackBtn" data-rt-battle-action="overlayBack"></button>
              <div class="ov-title" id="onlineOverlayTitle"></div>
              <button class="btn ov-headbtn" type="button" data-rt-battle-action="overlayClose"></button>
            </div>
            <div class="ov-body" id="onlineOverlayBody"></div>
            <div class="ov-scanner" id="rtQrScannerWrap"></div>
          </div>`;
        document.body.appendChild(root);
        return root;
      }
      function _rtBattleOverlaySetBodyLock(on){
        try{
          document.documentElement.classList.toggle("rt-battle-overlay-open", !!on);
          document.body.classList.toggle("rt-battle-overlay-open", !!on);
          document.body.style.overflow = on ? "hidden" : "";
        }catch(_){}
      }
      function _rtBattleOverlayPush(scene){
        const st = _rtBattleState();
        const cur = String(st.overlayScene || "top");
        if (cur && cur !== scene) st.overlayHistory.push(cur);
        st.overlayScene = scene;
      }
      function _rtBattleOverlayBack(){
        const st = _rtBattleState();
        if (st.scanner?.open){ _rtBattleScannerClose(); return; }
        const prev = st.overlayHistory.pop();
        if (prev){ st.overlayScene = prev; _rtBattleOverlayRender(); return; }
        _rtBattleOverlayClose();
      }
      function _rtBattleOverlayOpen(scene = "top"){
        const st = _rtBattleState();
        st.overlayOpen = true;
        if (!st.overlayScene) st.overlayScene = "top";
        if (scene) st.overlayScene = String(scene);
        if (!Array.isArray(st.overlayHistory)) st.overlayHistory = [];
        _rtBattleOverlayEnsureDom();
        _rtBattleOverlaySetBodyLock(true);
        const root = document.getElementById("onlineOverlay");
        if (root){
          root.classList.add("is-open");
          root.hidden = false;
          root.setAttribute("aria-hidden", "false");
        }
        _rtBattleOverlayRender();
      }
      function _rtBattleOverlayClose(){
        const st = _rtBattleState();
        st.overlayOpen = false;
        st.overlayHistory = [];
        _rtBattleScannerClose(true);
        _rtBattleStopReconnect();
        _rtBattleDisconnect(true);
        _rtBattleClearFeedback();
        const root = document.getElementById("onlineOverlay");
        if (root){
          root.classList.remove("is-open");
          root.hidden = true;
          root.setAttribute("aria-hidden", "true");
        }
        _rtBattleOverlaySetBodyLock(false);
      }
      function _rtBattleSceneFromPhase(){
        const st = _rtBattleState();
        if (!st.connected) return String(st.overlayScene || "top");
        const phase = String(st.phase || "lobby");
        if (phase === "countdown") return "countdown";
        if (phase === "playing") return "game";
        if (phase === "result") return "result";
        return "lobby";
      }
      function _rtBattleOverlaySyncSceneFromState(){
        const st = _rtBattleState();
        if (!st.overlayOpen) return;
        const derived = _rtBattleSceneFromPhase();
        if (st.connected) st.overlayScene = derived;
      }
      function _rtBattlePresetOptions(){
        const builtins = [
          { value: "builtin:ALL", label: "ALL" },
          { value: "builtin:0-200", label: "0-200" },
          { value: "builtin:200-400", label: "200-400" },
          { value: "builtin:400-600", label: "400-600" }
        ];
        const out = builtins.slice();
        try{
          const raw = window.localStorage.getItem(PRESETS_KEY);
          const arr = raw ? JSON.parse(raw) : [];
          if (Array.isArray(arr)){
            for (const p of arr){
              if (!p || typeof p !== "object") continue;
              const id = String(p.id || "");
              const name = String(p.name || "");
              if (!id || !name) continue;
              out.push({ value: `custom:${id}`, label: `My: ${name}` });
            }
          }
        }catch(_){}
        return out.slice(0, 80);
      }
      function _rtBattlePresetDisplayName(ref, fallbackName = ""){
        if (fallbackName) return String(fallbackName);
        if (!ref || typeof ref !== "object") return "";
        const type = String(ref.type || "");
        if (type === "builtin") return String(ref.key || "builtin").replace(/^builtin:/, "");
        if (type === "custom") return `My Preset`;
        return "";
      }
      function _rtBattleNormalizeQuestionCountValue(v){
        const raw = String(v ?? "").trim().toUpperCase();
        if (raw === "ALL") return "ALL";
        const n = Math.trunc(Number(v));
        if ([10, 20, 30, 50].includes(n)) return n;
        return 20;
      }
      function _rtBattleQuestionCountValue(){
        const st = _rtBattleState();
        const roomVal = st.room?.settings?.questionCount;
        const localVal = typeof st.questionCount !== "undefined" ? st.questionCount : roomVal;
        return _rtBattleNormalizeQuestionCountValue(localVal);
      }
      function _rtBattleQuestionCountLabel(v){
        const q = _rtBattleNormalizeQuestionCountValue(v);
        return q === "ALL" ? "ALL" : String(q);
      }
      function _rtBattleQuestionCountOptions(){
        return ["10", "20", "30", "50", "ALL"].map((v) => ({ value: v, label: v === "ALL" ? "ALL" : `${v}` }));
      }
      function _rtBattleResolvedTotalRounds(inputTotal){
        const st = _rtBattleState();
        const idsLen = Math.max(0, Number(st?.game?.questionIds?.length || 0));
        if (idsLen > 0) return idsLen;
        const direct = Math.max(0, Number(inputTotal || 0));
        if (direct > 0) return direct;
        const currentQTotal = Math.max(0, Number(st?.currentQuestion?.totalRounds || 0));
        if (currentQTotal > 0) return currentQTotal;
        const gameTotal = Math.max(0, Number(st?.game?.totalRounds || 0));
        if (gameTotal > 0) return gameTotal;
        const roomQ = st?.room?.settings?.questionCount;
        if (String(roomQ || "").toUpperCase() === "ALL") {
          const pool = Math.max(0, Number(st?.game?.presetWordsLength || 0));
          if (pool > 0) return pool;
        }
        const qc = _rtBattleQuestionCountValue();
        return qc === "ALL" ? Math.max(1, Number(st?.game?.presetWordsLength || 1)) : Math.max(1, Number(qc || 20));
      }
      function _rtBattleSendRoomSettings(){
        const st = _rtBattleState();
        if (!_rtBattleIsHost() || !st.connected) return;
        const sel = document.getElementById("rtBattleQuestionCountSelect");
        const qVal = _rtBattleNormalizeQuestionCountValue(sel ? sel.value : st.questionCount);
        st.questionCount = qVal;
        if (!st.room || typeof st.room !== "object") st.room = {};
        if (!st.room.settings || typeof st.room.settings !== "object") st.room.settings = {};
        st.room.settings.questionCount = qVal;
        try{ console.log("[room:settings]", { questionCount: qVal }); }catch(_){}
        _rtBattleOverlayRender();
        const ok = _rtBattleSafeSend({ type: "settings:set", questionCount: qVal });
        if (!ok) try{ uiToast(""); }catch(_){}
      }
      function _rtBattleScoreRows(){
        const st = _rtBattleState();
        const players = asArray(st.players);
        const total = _rtBattleResolvedTotalRounds(st.game?.totalRounds || st.currentQuestion?.totalRounds);
        const maxCorrect = Math.max(1, ...players.map((p) => Math.max(0, Number(p?.score || 0))));
        return players
          .map((p) => {
            const correct = Math.max(0, Number(p?.score || 0));
            return {
              id: Math.max(0, Number(p?.id || 0)),
              userId: Math.max(0, Number(p?.userId || 0)),
              nick: String(p?.nick || "Guest"),
              correct,
              total,
              ratio: Math.max(6, Math.round((correct / maxCorrect) * 100)),
              answeredCurrent: !!p?.answeredCurrent
            };
          })
          .sort((a, b) => {
            if (b.correct !== a.correct) return b.correct - a.correct;
            return a.id - b.id;
          });
      }
      function _rtBattleRenderScoreboardBars(){
        const rows = _rtBattleScoreRows();
        if (!rows.length) return "";
        const meUid = _rtBattleMyUserId();
        return `<div class="ov-scoreboard" id="rtBattleScoreboard">
          <div class="ov-score-title"> / </div>
          <div class="ov-score-list">
            ${rows.map((r) => `<div class="ov-score-row${r.userId===meUid ? " is-me" : ""}">
              <div class="ov-score-head">
                <span class="ov-score-name">${_escapeHtml(r.nick)}${r.userId===meUid ? " ()" : ""}</span>
                <span class="ov-score-val">${r.correct}/${r.total}</span>
              </div>
              <div class="ov-score-bar"><i style="width:${Math.max(6, Math.min(100, r.ratio))}%"></i></div>
            </div>`).join("")}
          </div>
        </div>`;
      }
      function _rtBattleResultSummary(){
        const st = _rtBattleState();
        const leaderboard = asArray(st.finalResult?.leaderboard || st.game?.finalLeaderboard);
        const meUid = _rtBattleMyUserId();
        const totalRounds = _rtBattleResolvedTotalRounds(st.game?.totalRounds || 1);
        const rankIndex = leaderboard.findIndex((r) => Math.max(0, Number(r?.userId || 0)) === meUid);
        const me = rankIndex >= 0 ? leaderboard[rankIndex] : null;
        const correct = Math.max(0, Number(me?.score || 0));
        const accuracy = Math.round((correct / totalRounds) * 100);
        return {
          rank: rankIndex >= 0 ? (rankIndex + 1) : null,
          correct,
          totalRounds,
          accuracy,
          totalTimeSec: Math.round(Math.max(0, Number(me?.answeredAtMsTotal || 0)) / 100) / 10
        };
      }
      function _rtBattleRenderResultSummaryCard(){
        const st = _rtBattleState();
        const s = _rtBattleResultSummary();
        return `<section class="ov-card ov-result-summary">
          <div class="ov-result-title"></div>
          <div class="ov-result-summary-grid">
            <div class="ov-result-stat"><span class="k"></span><strong>${s.rank ? `${s.rank}` : ""}</strong></div>
            <div class="ov-result-stat"><span class="k"></span><strong>${s.correct}/${s.totalRounds}</strong></div>
            <div class="ov-result-stat"><span class="k"></span><strong>${Number.isFinite(s.accuracy) ? `${s.accuracy}%` : ""}</strong></div>
            <div class="ov-result-stat"><span class="k"></span><strong>${Number.isFinite(s.totalTimeSec) ? `${s.totalTimeSec}s` : ""}</strong></div>
          </div>
          <div style="margin-top:10px;">${_rtBattleRenderScoreboardBars()}</div>
        </section>`;
      }
      function _rtBattleRenderRoundHistory(){
        const rows = asArray(_rtBattleState().roundLogs);
        return `<section class="ov-card ov-roundlog-card">
          <div class="ov-result-title"></div>
          <div class="ov-roundlog-list">
            ${rows.length ? rows.map((r) => `<div class="ov-roundlog-item${r.correct ? " is-ok" : (r.answered ? " is-ng" : "")}">
              <div class="ov-roundlog-top">
                <div><strong>Q${Math.max(1, Number(r.round || 1))}</strong>${r.no ? ` / No.${Math.max(0, Number(r.no || 0))}` : ""}</div>
                <div class="ov-mini">${r.answered ? (r.correct ? "" : "") : ""}</div>
              </div>
              <div class="ov-mini" style="margin-top:4px; white-space:pre-wrap;">${_escapeHtml(String(r.prompt || ""))}</div>
              <div class="ov-mini" style="margin-top:6px;">:  ${Math.max(0, Number(r.correctIndex || 0)) + 1}${r.answered ? ` / :  ${Math.max(0, Number(r.yourChoiceIndex || 0)) + 1}` : ""}</div>
            </div>`).join("") : `<div class="ov-emptycell"></div>`}
          </div>
        </section>`;
      }
      function _rtBattleToastClear(){
        const st = _rtBattleState();
        if (st.eventToastTimerId){ clearTimeout(st.eventToastTimerId); st.eventToastTimerId = null; }
        if (st.eventToastAnimTimerId){ clearTimeout(st.eventToastAnimTimerId); st.eventToastAnimTimerId = null; }
        st.eventToastActive = null;
      }
      function _rtBattleToastPump(){
        const st = _rtBattleState();
        if (String(st.phase || "") !== "playing") {
          _rtBattleToastClear();
          st.eventToastQueue = [];
          _rtBattleOverlayRender();
          return;
        }
        if (st.eventToastActive || !asArray(st.eventToastQueue).length) return;
        st.eventToastActive = st.eventToastQueue.shift();
        _rtBattleOverlayRender();
        st.eventToastAnimTimerId = setTimeout(() => {
          if (st.eventToastActive) st.eventToastActive.hiding = true;
          _rtBattleOverlayRender();
        }, 1300);
        st.eventToastTimerId = setTimeout(() => {
          st.eventToastTimerId = null;
          st.eventToastAnimTimerId = null;
          st.eventToastActive = null;
          _rtBattleOverlayRender();
          _rtBattleToastPump();
        }, 1600);
      }
      function _rtBattleQueueAnswerToast(ev){
        const st = _rtBattleState();
        if (String(st.phase || "") !== "playing") return;
        if (!ev || String(ev.type || "").toUpperCase() !== "ANSWERED") return;
        const myUid = _rtBattleMyUserId();
        if (Math.max(0, Number(ev.userId || 0)) === myUid) return;
        const nickname = String(ev.nickname || "");
        const suffix = (typeof ev.correct === "boolean")
          ? (ev.correct ? "" : "")
          : "";
        st.eventToastQueue = asArray(st.eventToastQueue);
        st.eventToastQueue.push({
          id: Math.max(0, Number(ev.id || 0)),
          text: `${nickname}${suffix}`,
          ts: Date.now(),
          kind: (typeof ev.correct === "boolean") ? (ev.correct ? "ok" : "ng") : "info",
          hiding: false
        });
        st.eventHistory = asArray(st.eventHistory);
        st.eventHistory.push({
          id: Math.max(0, Number(ev.id || 0)),
          text: `${nickname}${suffix}`,
          ts: Math.max(0, Number(ev.ts || Date.now())),
          kind: (typeof ev.correct === "boolean") ? (ev.correct ? "ok" : "ng") : "info"
        });
        if (st.eventHistory.length > 20) st.eventHistory = st.eventHistory.slice(-20);
        while (st.eventToastQueue.length > 3) st.eventToastQueue.shift();
        _rtBattleToastPump();
      }
      function _rtBattleConsumeRoomEvents(packet){
        const st = _rtBattleState();
        const events = asArray(packet?.events);
        const lastId = Math.max(0, Number(packet?.lastEventId || 0));
        if (!events.length && !lastId) return;
        const seen = Math.max(0, Number(st.lastSeenEventId || 0));
        for (const ev of events){
          const eid = Math.max(0, Number(ev?.id || 0));
          if (!eid || eid <= seen) continue;
          _rtBattleQueueAnswerToast(ev);
        }
        st.lastSeenEventId = Math.max(seen, lastId, ...events.map((e) => Math.max(0, Number(e?.id || 0))));
      }
      function _rtBattleRenderEventToast(){
        const st = _rtBattleState();
        const t = st.eventToastActive;
        if (!t || String(st.phase || "") !== "playing") return "";
        const kind = String(t.kind || "info");
        const badge = kind === "ok" ? "OK" : (kind === "ng" ? "NG" : "INFO");
        return `<div class="ov-event-toast is-${_escapeHtml(kind)}${t.hiding ? " is-hide" : ""}" aria-live="polite"><span class="ov-event-badge">${badge}</span><span>${_escapeHtml(String(t.text || ""))}</span></div>`;
      }
      function _rtBattleSetPresetFromSelect(value){
        const st = _rtBattleState();
        const v = String(value || "");
        if (!v){ st.presetRef = null; st.presetName = ""; return; }
        if (v.startsWith("builtin:")){
          st.presetRef = { type: "builtin", key: v };
          st.presetName = v.replace(/^builtin:/, "");
        } else if (v.startsWith("custom:")){
          st.presetRef = { type: "custom", id: v.slice(7) };
          st.presetName = v;
          const opt = _rtBattlePresetOptions().find(o => o.value === v);
          if (opt) st.presetName = opt.label;
        }
      }
      function _rtBattleSendPresetSelection(){
        const st = _rtBattleState();
        if (!_rtBattleIsHost()) return;
        if (!st.connected) return;
        const sel = document.getElementById("rtBattlePresetSelect");
        if (sel) _rtBattleSetPresetFromSelect(sel.value);
        const ref = st.presetRef;
        if (!st.room || typeof st.room !== "object") st.room = {};
        st.room.presetRef = ref ? { ...ref } : null;
        st.room.presetName = st.presetName || _rtBattlePresetDisplayName(ref);
        try{ console.log("[preset:set]", ref); }catch(_){}
        _rtBattleOverlayRender();
        try{ uiToast(""); }catch(_){}
        const ok = _rtBattleSafeSend({ type: "preset:set", presetRef: ref, presetName: st.presetName || _rtBattlePresetDisplayName(ref) });
        if (!ok) try{ uiToast(""); }catch(_){}
      }
      function _rtBattleOverlayBanner(){
        const st = _rtBattleState();
        const parts = [];
        if (st.errorMsg) parts.push({ cls: "err", text: st.errorMsg });
        else if (st.reconnecting) parts.push({ cls: "", text: ` (${Math.max(1, Number(st.reconnectAttempts || 1))}/5)` });
        else if (st.statusMsg) parts.push({ cls: "", text: st.statusMsg });
        return parts.map(b => `<div class="ov-banner ${b.cls}">${_escapeHtml(String(b.text || ""))}</div>`).join("");
      }
      function _rtBattleShareCardHtml(){
        const st = _rtBattleState();
        const roomId = String(st.roomId || "");
        const pw = String(st.roomPassword || "");
        if (!roomId || !pw) return "";
        const joinUrl = String(st.joinUrl || _rtBattleJoinUrl(roomId, pw));
        const qr = st.qr || {};
        return `<section class="ov-card">
          <div class="ov-grid cols2">
            <div>
              <h4></h4>
              <div class="ov-mini">ID</div>
              <div style="font-size:24px; font-weight:900; letter-spacing:.08em; text-align:center; margin:8px 0;">${_escapeHtml(roomId)}</div>
              <div class="ov-mini">: <code>${_escapeHtml(pw)}</code></div>
              <div class="ov-actions">
                <button class="btn" type="button" data-rt-battle-action="copyRoomId">ID</button>
                <button class="btn" type="button" data-rt-battle-action="copyJoinUrl">URL</button>
              </div>
              <div class="ov-mini" style="margin-top:8px; word-break:break-all;">${_escapeHtml(joinUrl)}</div>
            </div>
            <div>
              <div class="ov-mini" style="margin-bottom:6px;">QR</div>
              <div class="ov-qr">
                ${qr.status === "ok" && qr.url ? `<img alt="room qr" src="${_escapeHtml(qr.url)}" />` : `<div class="ov-mini">${_escapeHtml(qr.status === "loading" ? "QR" : (qr.error || "QR"))}</div>`}
              </div>
            </div>
          </div>
        </section>`;
      }
      function _rtBattleRenderPresetSection(){
        const st = _rtBattleState();
        const host = _rtBattleIsHost();
        const opts = _rtBattlePresetOptions();
        const countOpts = _rtBattleQuestionCountOptions();
        const currentCount = _rtBattleQuestionCountLabel(_rtBattleQuestionCountValue());
        const roomPresetRef = st.room?.presetRef || st.presetRef || null;
        const currentVal = roomPresetRef?.type === "builtin"
          ? (String(roomPresetRef?.key || "").startsWith("builtin:") ? String(roomPresetRef?.key || "") : `builtin:${String(roomPresetRef?.key || "")}`)
          : (roomPresetRef?.type === "custom" ? `custom:${String(roomPresetRef?.id || "")}` : "");
        return `<section class="ov-card settings-group">
          <div class="settings-row is-static">
            <div class="label"></div>
            <div class="value">${host ? "" : ""}</div>
          </div>
          <div class="settings-row is-static" style="display:block; min-height:auto;">
          <div class="ov-mini" style="margin-bottom:6px;">: ${_escapeHtml(_rtBattlePresetDisplayName(st.room?.presetRef, st.room?.presetName) || "")}</div>
          <select id="rtBattlePresetSelect" class="select settings-select" data-native-ui="1"${host ? "" : " disabled"}>
            <option value=""></option>
            ${opts.map(o => `<option value="${_escapeHtml(o.value)}"${o.value===currentVal?" selected":""}>${_escapeHtml(o.label)}</option>`).join("")}
          </select>
          ${host ? "" : `<div class="ov-mini" style="margin-top:8px;"></div>`}
          </div>
          <div class="settings-row is-static" style="display:block; min-height:auto;">
            <div class="ov-mini" style="margin-bottom:6px;"></div>
            <select id="rtBattleQuestionCountSelect" class="select settings-select" data-native-ui="1"${host ? "" : " disabled"}>
              ${countOpts.map(o => `<option value="${_escapeHtml(o.value)}"${o.value===currentCount?" selected":""}>${_escapeHtml(o.label)}</option>`).join("")}
            </select>
            <div class="ov-mini" style="margin-top:8px;">: ${_escapeHtml(currentCount === "ALL" ? "ALL" : `${currentCount}`)}</div>
          </div>
        </section>`;
      }
      function _rtBattleRoomCountText(){
        const st = _rtBattleState();
        const count = Math.max(0, Number(st.room?.count || asArray(st.players).length || 0));
        const max = Math.max(1, Number(st.room?.max || 4));
        return `${count}/${max}`;
      }
      function _rtBattleRoomCodeCompact(){
        const code = String(_rtBattleState().room?.roomId || _rtBattleState().roomId || "");
        return code ? code : "------";
      }
      function _rtBattleOverlaySheetTitle(sheet){
        if (sheet === "preset") return "";
        if (sheet === "game") return "";
        if (sheet === "members") return "";
        return "";
      }
      function _rtBattleSetModeSegment(mode){
        const st = _rtBattleState();
        const m = String(mode || "").toUpperCase();
        const allow = ["TURN","RUNDOM","EXAM","WRITE"];
        if (!allow.includes(m)) return;
        st.mode = m;
        _rtBattleOverlayRender();
      }
      function _rtBattleRenderModeSegments(){
        const st = _rtBattleState();
        const current = String(st.mode || "EXAM").toUpperCase();
        const items = [
          { key:"TURN", label:"TURN MODE" },
          { key:"RUNDOM", label:"RUNDOM MODE" },
          { key:"EXAM", label:"EXAM MODE" },
          { key:"WRITE", label:"WRITE MODE" }
        ];
        return `<div class="ov-mode-grid">
          ${items.map((it) => {
            const active = current === it.key;
            const disabled = it.key !== "EXAM";
            return `<button type="button" class="ov-mode-chip${active ? " is-active" : ""}" data-rt-battle-action="setModeSegment" data-rt-battle-mode="${it.key}"${disabled ? " disabled" : ""}>${_escapeHtml(it.label)}</button>`;
          }).join("")}
        </div>`;
      }
      function _rtBattleRenderGameSheet(){
        const st = _rtBattleState();
        const me = _rtBattleMePlayer();
        const ready = !!me?.ready;
        const hasPreset = !!(st.room?.presetRef);
        const canStart = _rtBattleIsHost() && _rtBattleAllReady() && hasPreset && st.connected;
        const phase = String(st.phase || "lobby");
        return `<div class="ov-sheet-stack">
          <section class="ov-card settings-group">
            <div class="ov-sheet-headline"></div>
            ${_rtBattleRenderModeSegments()}
            <div class="ov-mini" style="margin-top:8px;">MVP EXAM MODE </div>
          </section>
          <section class="ov-card settings-group">
            <div class="ov-sheet-headline"></div>
            <div class="ov-mini">: ${_escapeHtml(phase)} / ${_escapeHtml(_rtBattleStatusLabel())}</div>
            <div class="ov-actions">
              <button class="btn" type="button" data-rt-battle-action="readyToggle"${!st.connected ? " disabled" : ""}>${ready ? "Ready" : "Ready"}</button>
              ${_rtBattleIsHost() ? `<button class="btn primary" type="button" data-rt-battle-action="gameStart"${canStart ? "" : " disabled"}></button>` : `<button class="btn" type="button" disabled></button>`}
            </div>
            <div class="ov-actions">
              <button class="textbtn" type="button" data-rt-battle-action="disconnect"${(!st.connected && !st.connecting) ? " disabled" : ""}></button>
              ${_rtBattleIsHost() ? `<button class="textbtn" type="button" data-rt-battle-action="backLobby"${!st.connected ? " disabled" : ""}></button>` : ``}
            </div>
            <div class="ov-mini" style="margin-top:8px;">${!hasPreset ? "" : (canStart ? "" : "Ready")}</div>
          </section>
          <section class="ov-card settings-group">
            <div class="ov-sheet-headline"></div>
            <select id="rtBattleQuestionCountSelect" class="select settings-select" data-native-ui="1"${_rtBattleIsHost() ? "" : " disabled"}>
              ${_rtBattleQuestionCountOptions().map(o => `<option value="${_escapeHtml(o.value)}"${o.value===_rtBattleQuestionCountLabel(_rtBattleQuestionCountValue())?" selected":""}>${_escapeHtml(o.label)}</option>`).join("")}
            </select>
            <div class="ov-mini" style="margin-top:8px;"></div>
          </section>
          <section class="ov-card settings-group">
            <div class="ov-sheet-headline">3DBETA</div>
            <div class="ov-mini">3D</div>
            <div class="ov-actions" style="margin-top:8px;">
              <button class="btn primary" type="button" data-rt-battle-action="open3dBeta"${!st.connected ? " disabled" : ""}>3D</button>
            </div>
          </section>
        </div>`;
      }
      function _rtBattleRenderMembersSheet(){
        const st = _rtBattleState();
        const evs = asArray(st.eventHistory).slice(-10).reverse();
        return `<div class="ov-sheet-stack">
          <section class="ov-card settings-group">
            <div class="ov-sheet-headline"></div>
            <div class="ov-mini">: ${_rtBattleRoomCountText()} / ${_rtBattleIsHost() ? "" : ""}</div>
            <div style="margin-top:8px;">${_rtBattleRenderPlayerList()}</div>
          </section>
          <section class="ov-card settings-group">
            <div class="ov-sheet-headline"></div>
            <div class="ov-mini">PLAYING10</div>
            <div class="ov-member-log">
              ${evs.length ? evs.map((e) => `<div class="ov-member-log-row is-${_escapeHtml(String(e.kind || "info"))}"><span class="ov-member-log-badge">${_escapeHtml(String((e.kind||"info").toUpperCase()))}</span><span>${_escapeHtml(String(e.text || ""))}</span></div>`).join("") : `<div class="ov-mini"></div>`}
            </div>
          </section>
        </div>`;
      }
      function _rtBattleRenderLobbyHeaderBar(){
        const st = _rtBattleState();
        const phase = String(st.phase || "lobby");
        const dbg = st.room?.debug || {};
        const dbgLine = `Q=${String((typeof dbg.questionCount !== "undefined") ? dbg.questionCount : (st.room?.settings?.questionCount ?? st.questionCount ?? 20))} / IDs=${Math.max(0, Number(dbg.questionIdsLength || st.game?.questionIds?.length || 0))} / Pool=${Math.max(0, Number(dbg.presetWordsLength || st.game?.presetWordsLength || 0))}`;
        return `<div class="ov-lobby-head" id="rtBattleLobbyHead">
          <div class="ov-lobby-head-left">
            <div class="ov-lobby-title">Online Battle</div>
            <div class="ov-mini"></div>
          </div>
          <div class="ov-lobby-head-center">
            <div class="ov-lobby-room"><code>${_escapeHtml(_rtBattleRoomCodeCompact())}</code></div>
            <div class="ov-mini">${_escapeHtml(_rtBattleStatusLabel())} / ${_escapeHtml(_rtBattleRoomCountText())}</div>
          </div>
          <div class="ov-lobby-head-right">
            <button class="btn ov-iconbtn" type="button" data-rt-battle-action="openSheetPreset" aria-label="Preset"><span class="ms">inventory_2</span></button>
            <button class="btn ov-iconbtn" type="button" data-rt-battle-action="openSheetGame" aria-label="Game"><span class="ms">sports_esports</span></button>
            <button class="btn ov-iconbtn" type="button" data-rt-battle-action="openSheetMembers" aria-label="Members"><span class="ms">groups</span></button>
          </div>
          <div class="ov-lobby-head-badges">
            <span class="pill">${_escapeHtml(phase.toUpperCase())}</span>
            <span class="pill">${_escapeHtml(_rtBattlePresetDisplayName(st.room?.presetRef, st.room?.presetName) || "Preset")}</span>
          </div>
          <div class="ov-mini">${_escapeHtml(dbgLine)}</div>
        </div>`;
      }
      function _rtBattleRenderGameHeaderBar(){
        const st = _rtBattleState();
        const phase = String(st.phase || "lobby");
        const roomId = String(st.room?.roomId || st.roomId || "");
        const total = _rtBattleResolvedTotalRounds(st.game?.totalRounds || st.currentQuestion?.totalRounds || _rtBattleQuestionCountValue() || 1);
        const currentRound = (phase === "result")
          ? total
          : Math.max(1, Number(st.currentQuestion?.round || (Number(st.game?.round || 0) + 1)));
        const remainSec = Math.max(0, Math.ceil(Math.max(0, Number(_rtBattleRemainingMs ? _rtBattleRemainingMs() : 0)) / 1000));
        const dbg = st.room?.debug || {};
        const dbgLine = `Q=${String((typeof dbg.questionCount !== "undefined") ? dbg.questionCount : (st.room?.settings?.questionCount ?? st.questionCount ?? 20))} / IDs=${Math.max(0, Number(dbg.questionIdsLength || st.game?.questionIds?.length || 0))} / Pool=${Math.max(0, Number(dbg.presetWordsLength || st.game?.presetWordsLength || 0))}`;
        return `<div class="ov-game-head" id="rtBattleGameHeaderBar">
          <div class="ov-game-head-left">
            <div class="ov-game-title">Online Battle</div>
            <div class="ov-mini">Room <code>${_escapeHtml(roomId || "------")}</code>  ${_escapeHtml(_rtBattleStatusLabel())}</div>
          </div>
          <div class="ov-game-head-center">
            <div class="ov-game-head-progress">Q ${Math.max(1, currentRound)}/${Math.max(1, total)}</div>
            <div class="ov-game-head-phase">${_escapeHtml(phase.toUpperCase())}${phase === "playing" ? `  ${remainSec}s` : ""}</div>
          </div>
          <div class="ov-game-head-right">
            <button class="btn ov-iconbtn" type="button" data-rt-battle-action="openSheetPreset" aria-label="Preset"><span class="ms">inventory_2</span></button>
            <button class="btn ov-iconbtn" type="button" data-rt-battle-action="openSheetGame" aria-label="Game"><span class="ms">sports_esports</span></button>
            <button class="btn ov-iconbtn" type="button" data-rt-battle-action="openSheetMembers" aria-label="Members"><span class="ms">groups</span></button>
          </div>
          <div class="ov-mini">${_escapeHtml(dbgLine)}</div>
        </div>`;
      }
      function _rtBattleRenderLobbySideSheet(){
        const st = _rtBattleState();
        const sheet = String(st.overlaySheet || "");
        if (!sheet) return `<div id="rtBattleSheetMount"></div>`;
        let bodyHtml = "";
        if (sheet === "preset") bodyHtml = _rtBattleRenderPresetSection();
        else if (sheet === "game") bodyHtml = _rtBattleRenderGameSheet();
        else if (sheet === "members") bodyHtml = _rtBattleRenderMembersSheet();
        return `<div id="rtBattleSheetMount">
          <div class="ov-sheet-mask" data-rt-battle-action="closeSheet"></div>
          <aside class="ov-side-sheet is-open" aria-label="${_escapeHtml(_rtBattleOverlaySheetTitle(sheet))}">
            <div class="ov-side-sheet-head">
              <div class="ov-title">${_escapeHtml(_rtBattleOverlaySheetTitle(sheet))}</div>
              <button class="btn ov-headbtn" type="button" data-rt-battle-action="closeSheet"></button>
            </div>
            <div class="ov-side-sheet-body">${bodyHtml}</div>
          </aside>
        </div>`;
      }
      function _rtBattleRenderLobbyChatScene(){
        const st = _rtBattleState();
        return `<div class="ov-scene ov-scene-lobby">
          <div id="rtBattleBannerWrap">${_rtBattleOverlayBanner()}</div>
          ${_rtBattleRenderLobbyHeaderBar()}
          <section class="ov-card ov-chat-main" id="rtBattleChatPanel">
            <div class="ov-chat-main-head">
              <div class="ov-result-title" style="font-size:15px; margin:0;"></div>
              <div class="ov-mini"></div>
            </div>
            <div id="rtBattleChatScroll" class="ov-chat-scroll is-main"><div id="rtBattleChatList" class="ov-chat-list">${_rtBattleRenderChatLogs()}</div></div>
            <div class="ov-chat-composer">
              <div class="ov-chat-composer-row">
                <input id="rtBattleWriteInput" class="spell-input" type="text" placeholder="" value="${_escapeHtml(String(st.writeDraft || ""))}">
                <button class="btn" type="button" data-rt-battle-action="submitWrite"${!st.connected ? " disabled" : ""}></button>
              </div>
              <div class="ov-chat-composer-row is-tools">
                <button class="btn ov-iconbtn" type="button" data-rt-battle-action="openSheetPreset" aria-label=""><span class="ms">inventory_2</span></button>
                <button class="btn ov-iconbtn" type="button" data-rt-battle-action="openSheetGame" aria-label=""><span class="ms">play_circle</span></button>
                <button class="btn ov-iconbtn" type="button" data-rt-battle-action="openSheetMembers" aria-label=""><span class="ms">groups</span></button>
                <div class="ov-mini" style="margin-left:auto;">${_rtBattleIsHost() ? "Host" : "Member"}</div>
              </div>
            </div>
          </section>
          ${_rtBattleRenderLobbySideSheet()}
        </div>`;
      }
      function _rtBattleRenderTopScene(){
        const last = _rtBattleLoadLastRoom();
        return `<div class="ov-scene">
          <div id="rtBattleBannerWrap">${_rtBattleOverlayBanner()}</div>
          <div class="ov-grid cols2 ov-entry-grid">
            <button class="ov-card ov-entry-card is-click" type="button" data-rt-battle-action="openCreate">
              <div class="ov-entry-icon"><span class="ms" aria-hidden="true">add_circle</span></div>
              <div class="ov-entry-copy">
              <h4></h4><div class="ov-mini">ID</div>
              </div>
            </button>
            <button class="ov-card ov-entry-card is-click" type="button" data-rt-battle-action="openJoin">
              <div class="ov-entry-icon"><span class="ms" aria-hidden="true">qr_code_scanner</span></div>
              <div class="ov-entry-copy">
              <h4></h4><div class="ov-mini">ID +  / QR</div>
              </div>
            </button>
          </div>
          ${last ? `<section class="ov-card settings-group" style="margin-top:10px;">
            <h4></h4>
            <div class="ov-mini">Room <code>${_escapeHtml(last.roomId)}</code> / PW <code>${_escapeHtml(last.pw)}</code></div>
            <div class="ov-actions"><button class="btn" type="button" data-rt-battle-action="joinLastRoom"></button></div>
          </section>` : ``}
        </div>`;
      }
      function _rtBattleRenderCreateScene(){
        const st = _rtBattleState();
        return `<div class="ov-scene">
          <div id="rtBattleBannerWrap">${_rtBattleOverlayBanner()}</div>
          <section class="ov-card settings-group">
            <h4></h4>
            <div class="ov-mini"></div>
            <input id="rtRoomNickInput" class="spell-input" type="text" maxlength="32" placeholder="Rinto" value="${_escapeHtml(String(st.nickname || ""))}">
            <div class="ov-mini" style="margin-top:8px;">6</div>
            <input id="rtRoomCreatePasswordInput" class="spell-input" type="text" inputmode="latin" maxlength="6" placeholder="ABC123" value="${_escapeHtml(String(st.roomPassword || ""))}">
            <div class="ov-mini" style="margin-top:8px;"></div>
            <select id="rtRoomCreateQuestionCountSelect" class="select settings-select" data-native-ui="1">
              ${_rtBattleQuestionCountOptions().map(o => {
                const selected = String(_rtBattleNormalizeQuestionCountValue(o.value)) === String(_rtBattleQuestionCountValue());
                return `<option value="${_escapeHtml(o.value)}"${selected ? " selected" : ""}>${_escapeHtml(o.label)}</option>`;
              }).join("")}
            </select>
            <div class="ov-actions">
              <button class="btn" type="button" data-rt-battle-action="start"${st.busy || st.connecting ? " disabled" : ""}></button>
              <button class="textbtn" type="button" data-rt-battle-action="overlayBack"></button>
            </div>
          </section>
        </div>`;
      }
      function _rtBattleRenderJoinScene(){
        const st = _rtBattleState();
        return `<div class="ov-scene">
          <div id="rtBattleBannerWrap">${_rtBattleOverlayBanner()}</div>
          <section class="ov-card settings-group">
            <h4></h4>
            <div class="ov-mini"></div>
            <input id="rtRoomNickInput" class="spell-input" type="text" maxlength="32" placeholder="Rinto" value="${_escapeHtml(String(st.nickname || ""))}">
            <div class="ov-grid cols2" style="margin-top:8px;">
              <div><div class="ov-mini">ID</div><input id="rtRoomJoinIdInput" class="spell-input" type="text" inputmode="latin" maxlength="6" placeholder="A1B2C3" value="${_escapeHtml(String(st.joinRoomId || ""))}"></div>
              <div><div class="ov-mini"></div><input id="rtRoomJoinPasswordInput" class="spell-input" type="text" inputmode="latin" maxlength="6" placeholder="ABC123" value="${_escapeHtml(String(st.joinPassword || ""))}"></div>
            </div>
            <div class="ov-actions">
              <button class="btn" type="button" data-rt-battle-action="reconnect"${st.busy || st.connecting ? " disabled" : ""}></button>
              <button class="btn" type="button" data-rt-battle-action="openScanner">QR</button>
              <button class="textbtn" type="button" data-rt-battle-action="overlayBack"></button>
            </div>
            <div class="ov-mini" style="margin-top:8px;">QR</div>
          </section>
        </div>`;
      }
      function _rtBattleRenderLobbyGameResultScene(){
        const st = _rtBattleState();
        const phase = String(st.phase || "lobby");
        if (phase === "lobby"){
          return _rtBattleRenderLobbyChatScene();
        }
        const gameInner = phase === "countdown" ? _rtBattleRenderCountdownStage() : (_rtBattleRenderGameCard() || `<div class="ov-mini"></div>`);
        return `<div class="ov-scene ov-scene-gameplay">
          ${_rtBattleRenderEventToast()}
          <div id="rtBattleBannerWrap">${_rtBattleOverlayBanner()}</div>
          ${_rtBattleRenderGameHeaderBar()}
          <div class="ov-game-stage-wrap">
            <section class="ov-card ov-qcard ov-game-shell-card ${phase === "playing" ? (st.feedbackKind || "") : ""}" id="rtBattleGameWrap">
              ${gameInner}
              <div id="rtBattleRoundResultWrap">${phase === "playing" ? _rtBattleRenderRoundResult() : ""}</div>
            </section>
          </div>
          ${_rtBattleRenderLobbySideSheet()}
        </div>`;
      }
      function _rtBattleCountdownNumber(){
        const st = _rtBattleState();
        const endsAt = Math.max(0, Number(st.game?.countdownEndsAtMs || 0));
        const now = Date.now();
        const remain = Math.max(0, endsAt - now);
        if (!endsAt) return "";
        const sec = Math.ceil(remain / 1000);
        return sec <= 0 ? "GO!" : String(sec);
      }
      function _rtBattleRenderCountdownInner(){
        return `<div class="ov-countdown">
          <div>
            <div class="ov-mini"></div>
            <div class="n" id="rtBattleCountdownBig">${_escapeHtml(_rtBattleCountdownNumber())}</div>
          </div>
        </div>`;
      }
      function _rtBattleRenderCountdownStage(){
        return `<section class="ov-countdown-stage">
          <div class="ov-countdown-shell">
            ${_rtBattleRenderCountdownInner()}
            <div class="ov-mini" style="margin-top:10px; text-align:center;"></div>
          </div>
          ${_rtBattleRenderScoreboardBars()}
        </section>`;
      }
      function _rtBattleOverlaySceneTitle(scene){
        if (scene === "create") return " / ";
        if (scene === "join") return " / ";
        if (scene === "countdown") return " / ";
        if (scene === "game") return " / ";
        if (scene === "result") return " / ";
        if (scene === "lobby") return " / ";
        return "";
      }
      function _rtBattleOverlayRenderScanner(){
        const st = _rtBattleState();
        const wrap = document.getElementById("rtQrScannerWrap");
        if (!wrap) return;
        const sc = st.scanner || {};
        wrap.className = `ov-scanner${sc.open ? " is-open" : ""}`;
        if (!sc.open){ wrap.innerHTML = ""; return; }
        wrap.innerHTML = `
          <div class="ov-scanner-panel">
            <div class="ov-scanner-head">
              <div class="ov-title">QR</div>
              <button class="btn ov-headbtn" type="button" data-rt-battle-action="closeScanner"></button>
            </div>
            <div class="ov-scanner-view">
              <video id="rtQrScannerVideo" playsinline autoplay muted></video>
              <canvas id="rtQrScannerCanvas" style="display:none;"></canvas>
              <div class="ov-scanner-overlay"></div>
            </div>
            <div style="padding:10px 12px;" class="ov-mini">${_escapeHtml(String(sc.error || sc.status || ""))}</div>
          </div>`;
      }
      function _rtBattleChatRowKey(row, idx){
        const r = row && typeof row === "object" ? row : {};
        return [
          String(r.kind || "system"),
          Math.max(0, Number(r.ts || 0)),
          Math.max(0, Number(r.fromId || 0)),
          String(r.fromNick || ""),
          String(r.text || "").slice(0, 120),
          Math.max(0, Number(idx || 0))
        ].join("|");
      }
      function _rtBattleChatRowHtml(row, idx){
        const r = row && typeof row === "object" ? row : {};
        const key = _rtBattleChatRowKey(r, idx);
        const ts = new Date(Math.max(0, Number(r.ts || Date.now())));
        const hh = String(ts.getHours()).padStart(2, "0");
        const mm = String(ts.getMinutes()).padStart(2, "0");
        if (String(r.kind || "") === "chat"){
          const mine = Math.max(0, Number(r.fromId || 0)) === _rtBattleMyUserId();
          return `<div class="ov-chat-row is-chat${mine ? " is-me" : ""}" data-chat-key="${_escapeHtml(key)}">
            <div class="ov-chat-meta">${_escapeHtml(String(r.fromNick || "user"))} <span>${hh}:${mm}</span></div>
            <div class="ov-chat-bubble"><div class="ov-chat-text">${_escapeHtml(String(r.text || ""))}</div></div>
          </div>`;
        }
        return `<div class="ov-chat-row is-system" data-chat-key="${_escapeHtml(key)}"><span class="ov-chat-meta">${hh}:${mm}</span> ${_escapeHtml(String(r.text || ""))}</div>`;
      }
      function _rtBattleChatShouldStick(scroller){
        if (!(scroller instanceof HTMLElement)) return true;
        const remain = scroller.scrollHeight - (scroller.scrollTop + scroller.clientHeight);
        return remain <= 28;
      }
      function _rtBattleOverlayPatchChat(force){
        const root = document.getElementById("onlineOverlay");
        if (!root || !root.classList.contains("is-open")) return false;
        const phase = String(_rtBattleState().phase || "");
        if (!force && (phase === "playing" || phase === "countdown")) return false;
        const listEl = root.querySelector("#rtBattleChatList");
        const scrollEl = root.querySelector("#rtBattleChatScroll");
        if (!(listEl instanceof HTMLElement)) return false;
        const rows = asArray(_rtBattleState().chatLogs).slice(-40);
        const shouldStick = _rtBattleChatShouldStick(scrollEl);
        if (force || !listEl.children.length){
          listEl.innerHTML = asArray(rows).length ? rows.map((r, i) => _rtBattleChatRowHtml(r, i)).join("") : `<div class="ov-chat-empty"></div>`;
          if (scrollEl && shouldStick) scrollEl.scrollTop = scrollEl.scrollHeight;
          return true;
        }
        const existingKeys = asArray(Array.from(listEl.children).map((el) => el.getAttribute("data-chat-key") || ""));
        const newKeys = asArray(rows.map((r, i) => _rtBattleChatRowKey(r, i)));
        let prefixOk = asArray(existingKeys).length <= asArray(newKeys).length;
        for (let i = 0; i < asArray(existingKeys).length && prefixOk; i++){
          if (existingKeys[i] !== newKeys[i]) prefixOk = false;
        }
        if (!prefixOk){
          listEl.innerHTML = asArray(rows).length ? rows.map((r, i) => _rtBattleChatRowHtml(r, i)).join("") : `<div class="ov-chat-empty"></div>`;
        } else {
          if (listEl.querySelector(".ov-chat-empty")) listEl.innerHTML = "";
          for (let i = asArray(existingKeys).length; i < asArray(rows).length; i++){
            listEl.insertAdjacentHTML("beforeend", _rtBattleChatRowHtml(rows[i], i));
          }
        }
        if (scrollEl && shouldStick) scrollEl.scrollTop = scrollEl.scrollHeight;
        return true;
      }
      function _rtBattleOverlayPatchDynamic(scene){
        const root = document.getElementById("onlineOverlay");
        if (!root) return false;
        const body = root.querySelector("#onlineOverlayBody");
        if (!(body instanceof HTMLElement)) return false;
        if (String(body.dataset.scene || "") !== String(scene || "")) return false;
        const st = _rtBattleState();
        const bannerWrap = body.querySelector("#rtBattleBannerWrap");
        if (bannerWrap) bannerWrap.innerHTML = _rtBattleOverlayBanner();
        const roomMeta = body.querySelector("#rtBattleRoomMetaWrap");
        if (roomMeta){
          roomMeta.innerHTML = `<div class="ov-mini"> <code>${_escapeHtml(String(st.room?.roomId || st.roomId || ""))}</code> / : ${_escapeHtml(_rtBattleStatusLabel())}</div>
            <div class="ov-mini">${_rtBattleIsHost() ? "" : ""} / : ${_escapeHtml(_rtBattleQuestionCountLabel(st.room?.settings?.questionCount || st.questionCount))}</div>`;
        }
        const presetWrap = body.querySelector("#rtBattlePresetWrap");
        if (presetWrap){
          const phase = String(st.phase || "lobby");
          presetWrap.innerHTML = phase === "lobby" ? _rtBattleRenderPresetSection() : "";
        }
        const playersWrap = body.querySelector("#rtBattlePlayersWrap");
        if (playersWrap){
          playersWrap.innerHTML = `<h4> / </h4>${_rtBattleRenderPlayerList()}`;
        }
        const gameWrap = body.querySelector("#rtBattleGameWrap");
        if (gameWrap){
          const phase = String(st.phase || "lobby");
          const gameInner = phase === "countdown" ? _rtBattleRenderCountdownStage() : (_rtBattleRenderGameCard() || `<div class="ov-mini"></div>`);
          gameWrap.className = `ov-card ov-qcard ov-game-shell-card ${phase === "playing" ? (st.feedbackKind || "") : ""}`.trim();
          gameWrap.innerHTML = `${gameInner}<div id="rtBattleRoundResultWrap">${phase !== "countdown" ? _rtBattleRenderRoundResult() : ""}</div>`;
        }
        const chatPanel = body.querySelector("#rtBattleChatPanel");
        const phaseNow = String(st.phase || "");
        const isPlayingLike = (phaseNow === "playing" || phaseNow === "countdown");
        const lobbyHead = body.querySelector("#rtBattleLobbyHead");
        if (lobbyHead && phaseNow === "lobby"){
          lobbyHead.outerHTML = _rtBattleRenderLobbyHeaderBar();
        }
        const gameHead = body.querySelector("#rtBattleGameHeaderBar");
        if (gameHead && phaseNow !== "lobby"){
          gameHead.outerHTML = _rtBattleRenderGameHeaderBar();
        }
        const sheetMount = body.querySelector("#rtBattleSheetMount");
        if (sheetMount){
          sheetMount.outerHTML = _rtBattleRenderLobbySideSheet();
        }
        if (chatPanel instanceof HTMLElement) chatPanel.style.display = (phaseNow === "lobby") ? "" : "none";
        if (phaseNow === "lobby") _rtBattleOverlayPatchChat(false);
        const toastHtml = _rtBattleRenderEventToast();
        const oldToast = body.querySelector(".ov-event-toast");
        if (toastHtml){
          if (oldToast) oldToast.outerHTML = toastHtml;
          else body.insertAdjacentHTML("afterbegin", toastHtml);
        } else if (oldToast) {
          oldToast.remove();
        }
        const presetEl = body.querySelector("#rtBattlePresetSelect");
        if (presetEl instanceof HTMLSelectElement){
          presetEl.dataset.nativeUi = "1";
          presetEl.disabled = !_rtBattleIsHost();
        }
        const countEl = body.querySelector("#rtBattleQuestionCountSelect");
        if (countEl instanceof HTMLSelectElement){
          countEl.dataset.nativeUi = "1";
          countEl.value = _rtBattleQuestionCountLabel(_rtBattleQuestionCountValue());
          countEl.disabled = !_rtBattleIsHost();
        }
        return true;
      }
      function _rtBattleOverlayRender(){
        const st = _rtBattleState();
        if (!st.overlayOpen) return;
        const root = _rtBattleOverlayEnsureDom();
        if (!root) return;
        _rtBattleOverlaySyncSceneFromState();
        const scene = _rtBattleSceneFromPhase();
        const body = root.querySelector("#onlineOverlayBody");
        const title = root.querySelector("#onlineOverlayTitle");
        const backBtn = root.querySelector("#onlineOverlayBackBtn");
        if (title) title.textContent = _rtBattleOverlaySceneTitle(scene);
        if (backBtn) {
          const showBack = (scene === "create" || scene === "join") || !!(_rtBattleState().scanner?.open) || !!_rtBattleState().overlaySheet;
          backBtn.style.visibility = showBack ? "visible" : "hidden";
          backBtn.disabled = !showBack;
        }
        const patched = _rtBattleOverlayPatchDynamic(scene);
        if (body){
          if (!patched){
            let html = "";
            if (scene === "top") html = _rtBattleRenderTopScene();
            else if (scene === "create") html = _rtBattleRenderCreateScene();
            else if (scene === "join") html = _rtBattleRenderJoinScene();
            else html = _rtBattleRenderLobbyGameResultScene();
            body.innerHTML = html;
            body.dataset.scene = scene;
            if (!(String(_rtBattleState().phase || "") === "playing" || String(_rtBattleState().phase || "") === "countdown")){
              _rtBattleOverlayPatchChat(true);
            }
          }
        }
        _rtBattleOverlayRenderScanner();
        _customSelectEnhance(root);
        const presetEl = root.querySelector("#rtBattlePresetSelect");
        if (presetEl instanceof HTMLSelectElement){
          presetEl.dataset.nativeUi = "1";
          presetEl.disabled = !_rtBattleIsHost();
        }
        const countEl = root.querySelector("#rtBattleQuestionCountSelect");
        if (countEl instanceof HTMLSelectElement){
          countEl.dataset.nativeUi = "1";
          countEl.value = _rtBattleQuestionCountLabel(_rtBattleQuestionCountValue());
          countEl.disabled = !_rtBattleIsHost();
        }
      }
      function _rtBattleRerender(){
        if (_rtBattleOverlayIsOpen()){
          _rtBattleOverlayRender();
          return;
        }
        if (_menuState.view !== "onlineBattleRealtime") return;
        const content = document.getElementById("menuContent");
        if (!content) return;
        content.innerHTML = _renderOnlineBattleRealtimeHTML();
        _rtBattleInitView();
      }
      function _rtBattleEnsureUiTimer(){
        const st = _rtBattleState();
        if (st.uiTimerId) return;
        st.uiTimerId = setInterval(() => {
          if (!_rtBattleOverlayIsOpen() && _menuState.view !== "onlineBattleRealtime") return;
          const qEl = document.getElementById("rtBattleCountdownText");
          if (qEl) qEl.textContent = `${Math.max(0, Math.ceil(_rtBattleRemainingMs() / 1000))}`;
          const cEl = document.getElementById("rtBattleCountdownBig");
          if (cEl) cEl.textContent = _rtBattleCountdownNumber();
        }, 250);
      }
      function _rtBattleStopQrLoadTimeout(){
        const qr = _rtBattleState().qr;
        if (qr && qr.timeoutId){ clearTimeout(qr.timeoutId); qr.timeoutId = null; }
      }
      function _rtBattleScannerStopLoop(){
        const sc = _rtBattleState().scanner;
        if (!sc) return;
        if (sc.loopTimerId){ clearTimeout(sc.loopTimerId); sc.loopTimerId = null; }
      }
      function _rtBattleScannerStopStream(){
        const sc = _rtBattleState().scanner;
        if (!sc || !sc.stream) return;
        try{ for (const tr of sc.stream.getTracks()) tr.stop(); }catch(_){}
        sc.stream = null;
      }
      function _rtBattleScannerClose(silent = false){
        const st = _rtBattleState();
        if (!st.scanner) return;
        _rtBattleScannerStopLoop();
        _rtBattleScannerStopStream();
        st.scanner.open = false;
        st.scanner.status = "";
        if (!silent) _rtBattleOverlayRender();
      }
      async function _rtBattleEnsureJsQr(){
        if (window.jsQR) return true;
        if (__rtQrScriptPromise) return __rtQrScriptPromise;
        __rtQrScriptPromise = new Promise((resolve) => {
          const s = document.createElement("script");
          s.src = RT_QR_JS_URL;
          s.async = true;
          s.onload = () => resolve(!!window.jsQR);
          s.onerror = () => resolve(false);
          document.head.appendChild(s);
        });
        return __rtQrScriptPromise;
      }
      function _rtBattleApplyScannedJoinText(raw){
        const txt = String(raw || "").trim();
        if (!txt) return false;
        let roomId = "", pw = "";
        try{
          const u = new URL(txt, location.href);
          const h = _rtBattleParseRoomHash(u.hash);
          if (h){ roomId = h.roomId; pw = h.pw; }
          if (!roomId){
            roomId = String(u.searchParams.get("room") || "").toUpperCase().replace(/[^A-Z0-9]/g, "").slice(0,6);
            pw = String(u.searchParams.get("pw") || "").toUpperCase().replace(/[^A-Z0-9]/g, "").slice(0,6);
          }
        }catch{
          const h = _rtBattleParseRoomHash(txt.startsWith("#") ? txt : ("#" + txt));
          if (h){ roomId = h.roomId; pw = h.pw; }
        }
        if (!roomId || !pw) return false;
        const st = _rtBattleState();
        st.joinRoomId = roomId;
        st.joinPassword = pw;
        st.overlayScene = "join";
        _rtBattleScannerClose(true);
        st.statusMsg = "QR";
        _rtBattleOverlayRender();
        return true;
      }
      async function _rtBattleScannerDecodeLoop(){
        const st = _rtBattleState();
        const sc = st.scanner;
        if (!sc || !sc.open) return;
        const video = document.getElementById("rtQrScannerVideo");
        const canvas = document.getElementById("rtQrScannerCanvas");
        if (!(video instanceof HTMLVideoElement) || !(canvas instanceof HTMLCanvasElement)){
          sc.loopTimerId = setTimeout(_rtBattleScannerDecodeLoop, 250);
          return;
        }
        try{
          if ("BarcodeDetector" in window){
            sc.supported = true;
            const detector = sc._detector || (sc._detector = new BarcodeDetector({ formats: ["qr_code"] }));
            const codes = await detector.detect(video).catch(() => []);
            if (codes && codes[0] && _rtBattleApplyScannedJoinText(codes[0].rawValue || "")) return;
          } else {
            sc.supported = false;
            const okLib = await _rtBattleEnsureJsQr();
            if (!okLib){
              sc.error = "QR";
              _rtBattleOverlayRender();
              return;
            }
            const w = Math.max(2, video.videoWidth || 0);
            const h = Math.max(2, video.videoHeight || 0);
            if (w > 1 && h > 1){
              canvas.width = w;
              canvas.height = h;
              const ctx = canvas.getContext("2d", { willReadFrequently: true });
              if (ctx){
                ctx.drawImage(video, 0, 0, w, h);
                const img = ctx.getImageData(0, 0, w, h);
                const r = window.jsQR ? window.jsQR(img.data, w, h) : null;
                if (r && _rtBattleApplyScannedJoinText(r.data || "")) return;
              }
            }
          }
          sc.status = "QR";
        }catch(err){
          sc.error = String(err?.message || "QR");
        }finally{
          if (sc.open){
            _rtBattleOverlayRender();
            sc.loopTimerId = setTimeout(_rtBattleScannerDecodeLoop, 180);
          }
        }
      }
      async function _rtBattleScannerOpen(){
        const st = _rtBattleState();
        const sc = st.scanner || (st.scanner = {});
        sc.open = true;
        sc.error = "";
        sc.status = "";
        _rtBattleOverlayRender();
        const video = document.getElementById("rtQrScannerVideo");
        if (!(video instanceof HTMLVideoElement)) return;
        try{
          const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio: false });
          sc.stream = stream;
          video.srcObject = stream;
          await video.play().catch(()=>{});
          sc.status = "QR";
          _rtBattleScannerDecodeLoop();
        }catch(err){
          sc.error = `: ${String(err?.message || err || "")}`;
          _rtBattleOverlayRender();
        }
      }
      function _rtBattleScheduleReconnect(){
        const st = _rtBattleState();
        if (st.manualClose) return;
        if (!st.overlayOpen) return;
        if (!st.roomId || !(st.roomPassword || st.joinPassword)) return;
        if (st.reconnectAttempts >= 5) return;
        _rtBattleStopReconnect();
        st.reconnectAttempts = Math.max(0, Number(st.reconnectAttempts || 0)) + 1;
        st.reconnecting = true;
        const delay = Math.min(8000, 600 * (2 ** (st.reconnectAttempts - 1)));
        st.reconnectTimerId = setTimeout(() => {
          st.reconnectTimerId = null;
          if (!st.overlayOpen || st.connected || st.connecting) return;
          _rtBattleReconnect();
        }, delay);
        _rtBattleOverlayRender();
      }
      function _rtBattleOverlayHandleAction(act){
        const st = _rtBattleState();
        if (act === "overlayClose"){ _rtBattleOverlayClose(); return true; }
        if (act === "overlayBack"){
          if (st.overlaySheet){ st.overlaySheet = ""; _rtBattleOverlayRender(); return true; }
          _rtBattleOverlayBack(); return true;
        }
        if (act === "openSheetPreset"){ st.overlaySheet = "preset"; _rtBattleOverlayRender(); return true; }
        if (act === "openSheetGame"){ st.overlaySheet = "game"; _rtBattleOverlayRender(); return true; }
        if (act === "openSheetMembers"){ st.overlaySheet = "members"; _rtBattleOverlayRender(); return true; }
        if (act === "closeSheet"){ st.overlaySheet = ""; _rtBattleOverlayRender(); return true; }
        if (act === "setModeSegment"){
          const mode = String(arguments[1]?.getAttribute?.("data-rt-battle-mode") || "");
          _rtBattleSetModeSegment(mode);
          return true;
        }
        if (act === "openCreate"){ _rtBattleOverlayPush("create"); _rtBattleOverlayRender(); return true; }
        if (act === "openJoin"){ _rtBattleOverlayPush("join"); _rtBattleOverlayRender(); return true; }
        if (act === "joinLastRoom"){
          const last = _rtBattleLoadLastRoom();
          if (!last){ try{ uiToast(""); }catch(_){} return true; }
          st.joinRoomId = last.roomId; st.joinPassword = last.pw; if (!st.nickname) st.nickname = last.nickname || "";
          _rtBattleOverlayPush("join");
          _rtBattleOverlayRender();
          return true;
        }
        if (act === "copyRoomId"){
          _copyText(String(st.roomId || st.joinRoomId || "")).then(ok => uiToast(ok ? "ID" : ""));
          return true;
        }
        if (act === "copyJoinUrl"){
          const url = String(st.joinUrl || _rtBattleJoinUrl(st.roomId || st.joinRoomId, st.roomPassword || st.joinPassword));
          _copyText(url).then(ok => uiToast(ok ? "URL" : ""));
          return true;
        }
        if (act === "openScanner"){ _rtBattleScannerOpen(); return true; }
        if (act === "closeScanner"){ _rtBattleScannerClose(); return true; }
        return false;
      }
      function _rtBattleOverlayInitHooks(){
        if (window.__rtBattleOverlayHooked) return;
        window.__rtBattleOverlayHooked = true;
        window.addEventListener("hashchange", () => {
          try{ _rtBattleHashAutofill(); }catch(_){}
        });
      }
      // wrap/override some existing functions for overlay behavior
      const __rtBattleHandleMessageBase = _rtBattleHandleMessage;
      _rtBattleHandleMessage = function(msg){
        const st = _rtBattleState();
        const type = String(msg?.type || "").toLowerCase();
        if (type === "countdown:start"){
          st.phase = "countdown";
          st.roundLogs = [];
          st.lastRoundResult = null;
          st.finalResult = null;
          st.game = st.game && typeof st.game === "object" ? st.game : {};
          st.game.countdownStartAtMs = Math.max(0, Number(msg?.startAtMs || Date.now()));
          st.game.countdownEndsAtMs = Math.max(0, Number(msg?.endsAtMs || (Date.now()+3000)));
          st.statusMsg = "";
          _rtBattleEnsureUiTimer();
          _rtBattleOverlaySyncSceneFromState();
          _rtBattleOverlayRender();
        }
        let restoreRerender = null;
        if (type === "chat" && _rtBattleOverlayIsOpen()){
          const _baseRerender = _rtBattleRerender;
          _rtBattleRerender = function(){
            if (!_rtBattleOverlayIsOpen()) return _baseRerender.apply(this, arguments);
          };
          restoreRerender = () => { _rtBattleRerender = _baseRerender; };
        }
        __rtBattleHandleMessageBase(msg);
        if (restoreRerender) restoreRerender();
        const st2 = _rtBattleState();
        if (type === "countdown:start" || type === "room:snapshot" || type === "state" || type === "game:question"){
          if (st2.phase === "playing" || st2.phase === "countdown") _rtBattleEnsureUiTimer();
          else _rtBattleStopUiTimer();
        }
        if (type === "room:snapshot" || type === "state" || type === "joined" || type === "game:question" || type === "game:final" || type === "game:result"){
          if (st2.connected) _rtBattleSaveLastRoom();
          _rtBattleOverlaySyncSceneFromState();
        }
        if (type === "joined"){
          st2.reconnectAttempts = 0;
          st2.reconnecting = false;
          st2.joinUrl = _rtBattleJoinUrl(st2.roomId || st2.joinRoomId, st2.roomPassword || st2.joinPassword);
          _rtBattleLoadQrForJoinUrl(st2.joinUrl);
        }
        if (type === "room:snapshot" || type === "state"){
          try{ console.log("[preset:state]", st2.room?.presetRef || null); }catch(_){}
        }
        if (type === "chat" && _rtBattleOverlayIsOpen()){
          if (String(st2.phase || "") !== "playing" && String(st2.phase || "") !== "countdown"){
            _rtBattleOverlayPatchChat(false);
          }
          return;
        }
        if (type === "game:result"){
          const me = _rtBattleMePlayer();
          const arr = Array.isArray(msg?.answersSummary) ? msg.answersSummary : [];
          const my = arr.find(x => Math.max(0, Number(x?.userId || 0)) === _rtBattleMyUserId());
          try{
            const roundNo = Math.max(1, Number(msg?.round || 1));
            const q = _rtBattleState().currentQuestion || {};
            const myRow = arr.find(x => Math.max(0, Number(x?.userId || 0)) === _rtBattleMyUserId()) || null;
            const entry = {
              round: roundNo,
              no: Math.max(0, Number(q?.no || 0)),
              prompt: String(q?.prompt || ""),
              correctIndex: Math.max(0, Number(msg?.correctIndex || 0)),
              answered: !!myRow?.answered,
              yourChoiceIndex: myRow && Number.isInteger(Number(myRow.choiceIndex)) ? Number(myRow.choiceIndex) : -1,
              correct: !!myRow?.correct
            };
            const stx = _rtBattleState();
            stx.roundLogs = asArray(stx.roundLogs).filter((x) => Math.max(0, Number(x?.round || 0)) !== roundNo);
            stx.roundLogs.push(entry);
            stx.roundLogs.sort((a,b) => Math.max(0, Number(a?.round||0)) - Math.max(0, Number(b?.round||0)));
          }catch(_){}
          if (my && my.answered) _rtBattleFeedback(my.correct ? "ok" : "ng");
        }
      };
      const __rtBattleConnectBase = _rtBattleConnect;
      _rtBattleConnect = function(wsUrlRaw){
        const st = _rtBattleState();
        st.manualClose = false;
        __rtBattleConnectBase(wsUrlRaw);
        st.manualClose = false;
        // onclose/onerror wrappers are set inside base; detect reconnect via polling state change hooks from messages/close
      };
      const __rtBattleDisconnectBase = _rtBattleDisconnect;
      _rtBattleDisconnect = function(silent = false){
        const st = _rtBattleState();
        st.manualClose = true;
        _rtBattleStopReconnect();
        _rtBattleScannerClose(true);
        _rtBattleStopQrLoadTimeout();
        __rtBattleDisconnectBase(silent);
      };
      const __rtBattleSafeCloseSocketBase = _rtBattleSafeCloseSocket;
      _rtBattleSafeCloseSocket = function(){
        __rtBattleSafeCloseSocketBase();
      };
      // hook reconnect on socket close via patched rerender/status path: periodic monitor
      setInterval(() => {
        const st = _rtBattleState();
        if (!st.overlayOpen) return;
        if (st.manualClose) return;
        if (st.connected || st.connecting) return;
        if (!st.roomId || !(st.roomPassword || st.joinPassword)) return;
        if (String(st.phase || "lobby") === "lobby" || String(st.phase || "countdown") === "countdown" || String(st.phase || "playing") === "playing" || String(st.phase || "result") === "result"){
          _rtBattleScheduleReconnect();
        }
      }, 1200);
      const __rtBattleStartBase = _rtBattleStart;
      _rtBattleStart = async function(){
        const st = _rtBattleState();
        await __rtBattleStartBase();
        st.overlayScene = "lobby";
        st.joinUrl = _rtBattleJoinUrl(st.roomId || st.joinRoomId, st.roomPassword || st.joinPassword);
        _rtBattleLoadQrForJoinUrl(st.joinUrl);
        _rtBattleSaveLastRoom();
        _rtBattleOverlayOpen("lobby");
      };
      const __rtBattleReconnectBase = _rtBattleReconnect;
      _rtBattleReconnect = async function(){
        const st = _rtBattleState();
        await __rtBattleReconnectBase();
        st.overlayScene = "lobby";
        st.joinUrl = _rtBattleJoinUrl(st.roomId || st.joinRoomId, st.roomPassword || st.joinPassword);
        _rtBattleSaveLastRoom();
        _rtBattleOverlayOpen("lobby");
      };
      const __rtBattleLeaveBase = _rtBattleLeave;
      _rtBattleLeave = function(){
        __rtBattleLeaveBase();
        const st = _rtBattleState();
        st.overlayScene = "top";
        st.overlayHistory = [];
        _rtBattleOverlayRender();
      };
      // overlay-specific actions are handled via click delegation extension below (existing handler calls this)
      const __rtBattleInitViewBase = _rtBattleInitView;
      _rtBattleInitView = function(){
        __rtBattleInitViewBase();
        _rtBattleOverlayInitHooks();
      };
      setTimeout(() => { try{ _rtBattleOverlayInitHooks(); _rtBattleHashAutofill(); }catch(_){} }, 0);

      // ROOM_DO_UI_V4_3D_BETA: minimal 3D realtime battle demo overlay using existing room WS
      const RT3D_THREE_URL = "https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js";
      let __rt3dThreePromise = null;
      function _rtBattle3dState(){
        const st = _rtBattleState();
        if (!st.b3d || typeof st.b3d !== "object") st.b3d = {};
        const b = st.b3d;
        if (typeof b.open !== "boolean") b.open = false;
        if (typeof b.loading !== "boolean") b.loading = false;
        if (typeof b.error !== "string") b.error = "";
        if (typeof b.status !== "string") b.status = "";
        if (typeof b.sceneMode !== "string") b.sceneMode = "play"; // play|result
        if (typeof b.pingMs !== "number") b.pingMs = 0;
        if (typeof b.lastNetTs !== "number") b.lastNetTs = 0;
        if (typeof b.awaitingPingTs !== "number") b.awaitingPingTs = 0;
        if (typeof b.pingTimerId !== "number" && b.pingTimerId !== null) b.pingTimerId = null;
        if (typeof b.uiTimerId !== "number" && b.uiTimerId !== null) b.uiTimerId = null;
        if (typeof b.rafId !== "number" && b.rafId !== null) b.rafId = null;
        if (typeof b.netSendTimerId !== "number" && b.netSendTimerId !== null) b.netSendTimerId = null;
        if (typeof b.resizeListenerBound !== "boolean") b.resizeListenerBound = false;
        if (typeof b.quizOpen !== "boolean") b.quizOpen = false;
        if (typeof b.quizAnswered !== "boolean") b.quizAnswered = false;
        if (typeof b.quizError !== "string") b.quizError = "";
        if (typeof b.gateOpen !== "boolean") b.gateOpen = false;
        if (typeof b.gateAnim !== "number") b.gateAnim = 0;
        if (typeof b.localFinished !== "boolean") b.localFinished = false;
        if (typeof b.resultOpen !== "boolean") b.resultOpen = false;
        if (typeof b.winnerUserId !== "number") b.winnerUserId = 0;
        if (typeof b.winnerNick !== "string") b.winnerNick = "";
        if (!Array.isArray(b.finishOrder)) b.finishOrder = [];
        if (!b.input || typeof b.input !== "object") b.input = { fwd:false, back:false, left:false, right:false, jump:false };
        if (typeof b.jumpQueued !== "boolean") b.jumpQueued = false;
        if (!b.local || typeof b.local !== "object"){
          b.local = { x:0, y:0.9, z:4, vx:0, vy:0, vz:0, rotY:0, grounded:true, action:"idle", ts:0 };
        }
        if (!b.remoteStates || typeof b.remoteStates !== "object") b.remoteStates = {};
        if (!b.remoteMeshes || typeof b.remoteMeshes !== "object") b.remoteMeshes = {};
        if (!b.runtime || typeof b.runtime !== "object") b.runtime = {};
        if (typeof b.runtime.inited !== "boolean") b.runtime.inited = false;
        if (typeof b.runtime.lastTickTs !== "number") b.runtime.lastTickTs = 0;
        if (typeof b.runtime.lastHudRenderTs !== "number") b.runtime.lastHudRenderTs = 0;
        if (typeof b.runtime.lastSyncSentTs !== "number") b.runtime.lastSyncSentTs = 0;
        if (typeof b.runtime.toastTimerId !== "number" && b.runtime.toastTimerId !== null) b.runtime.toastTimerId = null;
        if (!Array.isArray(b.runtime.toastQueue)) b.runtime.toastQueue = [];
        if (typeof b.runtime.toastActive !== "boolean") b.runtime.toastActive = false;
        if (typeof b.runtime.lastShownFinishCount !== "number") b.runtime.lastShownFinishCount = 0;
        if (typeof b.runtime.seenGatePrompt !== "boolean") b.runtime.seenGatePrompt = false;
        return b;
      }
      function _rtBattle3dEnsureStyles(){
        if (document.getElementById("rt3dOverlayStyles")) return;
        const s = document.createElement("style");
        s.id = "rt3dOverlayStyles";
        s.textContent = `
          #rt3dOverlay{position:fixed; inset:0; z-index:100040; display:none;}
          #rt3dOverlay.is-open{display:block;}
          #rt3dOverlay .b3d-bg{position:absolute; inset:0; background:rgba(8,10,14,.2);}
          #rt3dOverlay .b3d-shell{position:absolute; inset:0; display:flex; flex-direction:column; background:var(--bg,#f7f7f8);}
          #rt3dOverlay .b3d-head{position:sticky; top:0; z-index:5; display:grid; grid-template-columns:auto 1fr auto; gap:10px; align-items:center; padding:10px 12px; border-bottom:1px solid var(--border,#ddd); background:rgba(255,255,255,.9); backdrop-filter:saturate(1.1);}
          #rt3dOverlay .b3d-head-left,#rt3dOverlay .b3d-head-right{display:flex; align-items:center; gap:8px;}
          #rt3dOverlay .b3d-title{font-weight:800; font-size:15px; line-height:1.15;}
          #rt3dOverlay .b3d-sub{font-size:11px; color:var(--muted,#666);}
          #rt3dOverlay .b3d-pill{display:inline-flex; align-items:center; gap:6px; height:28px; padding:0 10px; border-radius:999px; border:1px solid var(--border,#ddd); background:var(--panel,#fff); font-size:12px;}
          #rt3dOverlay .b3d-main{position:relative; flex:1; min-height:0; overflow:hidden;}
          #rt3dOverlay #rt3dCanvasWrap{position:absolute; inset:0; background:linear-gradient(180deg,#edf2f7,#f7f7f8);}
          #rt3dOverlay #rt3dCanvasWrap canvas{display:block; width:100%; height:100%; touch-action:none;}
          #rt3dOverlay .b3d-hud{position:absolute; top:12px; left:12px; right:12px; z-index:4; display:grid; grid-template-columns:minmax(0,1fr) auto auto; gap:8px; align-items:start; pointer-events:none;}
          #rt3dOverlay .b3d-hud-card{pointer-events:auto; min-width:0; border:1px solid var(--border,#ddd); background:rgba(255,255,255,.9); border-radius:14px; padding:8px 10px; box-shadow:0 2px 8px rgba(0,0,0,.06);}
          #rt3dOverlay .b3d-hud-card .t{font-size:11px; color:var(--muted,#666);}
          #rt3dOverlay .b3d-hud-card .v{font-weight:700; font-size:13px; color:var(--text,#111);}
          #rt3dOverlay .b3d-score-panel{position:absolute; top:66px; right:12px; z-index:4; width:min(280px, calc(100vw - 24px)); max-height:180px; overflow:auto; border:1px solid var(--border,#ddd); background:rgba(255,255,255,.9); border-radius:14px; padding:8px; box-shadow:0 2px 8px rgba(0,0,0,.06);}
          #rt3dOverlay .b3d-score-row{display:grid; grid-template-columns:auto minmax(0,1fr) auto; gap:8px; align-items:center; margin:4px 0;}
          #rt3dOverlay .b3d-score-name{font-size:12px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:86px;}
          #rt3dOverlay .b3d-score-track{height:8px; border-radius:999px; background:var(--panel2,#f0f2f5); border:1px solid rgba(0,0,0,.04); overflow:hidden;}
          #rt3dOverlay .b3d-score-fill{height:100%; border-radius:999px; background:rgba(31,42,68,.18);}
          #rt3dOverlay .b3d-score-val{font-size:11px; color:var(--muted,#666);}
          #rt3dOverlay .b3d-toast-wrap{position:absolute; top:12px; left:50%; transform:translateX(-50%); z-index:6; pointer-events:none; display:grid; gap:8px; width:min(420px, calc(100vw - 28px));}
          #rt3dOverlay .b3d-toast{opacity:0; transform:translateY(-8px); transition:opacity .22s cubic-bezier(.22,1,.36,1), transform .22s cubic-bezier(.22,1,.36,1); border:1px solid var(--border,#ddd); background:rgba(255,255,255,.95); border-radius:12px; padding:8px 10px; box-shadow:0 2px 8px rgba(0,0,0,.06); display:flex; align-items:center; gap:8px; font-size:12px;}
          #rt3dOverlay .b3d-toast.is-show{opacity:1; transform:translateY(0);}
          #rt3dOverlay .b3d-toast .badge{min-width:38px; height:20px; border-radius:999px; display:inline-flex; align-items:center; justify-content:center; font-size:10px; font-weight:700; border:1px solid var(--border,#ddd); color:var(--muted,#666);}
          #rt3dOverlay .b3d-toast.ok .badge{background:rgba(64,190,106,.10); color:#1e7a45;}
          #rt3dOverlay .b3d-toast.ng .badge{background:rgba(235,87,87,.10); color:#b03939;}
          #rt3dOverlay .b3d-toast.info .badge{background:rgba(31,42,68,.08); color:#324a78;}
          #rt3dOverlay .b3d-quiz{position:absolute; inset:auto 12px calc(120px + env(safe-area-inset-bottom,0px)) 12px; z-index:7; max-width:680px; margin:0 auto; border:1px solid var(--border,#ddd); background:rgba(255,255,255,.98); border-radius:16px; padding:12px; box-shadow:0 8px 20px rgba(0,0,0,.10); display:none;}
          #rt3dOverlay .b3d-quiz.is-open{display:block; animation:b3dFadeIn .2s cubic-bezier(.22,1,.36,1);}
          #rt3dOverlay .b3d-quiz h4{margin:0 0 6px; font-size:14px;}
          #rt3dOverlay .b3d-quiz .q{font-size:16px; font-weight:800; line-height:1.35; margin-bottom:8px;}
          #rt3dOverlay .b3d-quiz .choices{display:grid; gap:8px;}
          #rt3dOverlay .b3d-quiz .choices button{min-height:44px;}
          #rt3dOverlay .b3d-quiz .err{font-size:12px; color:#b03939; min-height:16px; margin-top:8px;}
          #rt3dOverlay .b3d-bottom{position:absolute; left:0; right:0; bottom:0; z-index:5; padding:8px 10px calc(env(safe-area-inset-bottom,0px) + 8px); pointer-events:none;}
          #rt3dOverlay .b3d-controls{display:flex; justify-content:space-between; align-items:flex-end; gap:12px;}
          #rt3dOverlay .b3d-dpad,#rt3dOverlay .b3d-actions{pointer-events:auto; display:grid; gap:8px;}
          #rt3dOverlay .b3d-dpad{grid-template-columns:repeat(3,56px); grid-template-rows:repeat(2,56px);}
          #rt3dOverlay .b3d-dpad .sp{visibility:hidden;}
          #rt3dOverlay .b3d-mbtn{width:56px; height:56px; border-radius:16px; border:1px solid var(--border,#ddd); background:rgba(255,255,255,.92); box-shadow:0 2px 8px rgba(0,0,0,.06); font-weight:800; display:grid; place-items:center; touch-action:none; user-select:none;}
          #rt3dOverlay .b3d-mbtn:active,#rt3dOverlay .b3d-mbtn.is-active{transform:scale(.97); background:rgba(31,42,68,.08);}
          #rt3dOverlay .b3d-jump{width:76px; height:76px; border-radius:20px;}
          #rt3dOverlay .b3d-status-bar{position:absolute; left:12px; bottom:calc(env(safe-area-inset-bottom,0px) + 12px); z-index:5; max-width:min(52vw,420px); border:1px solid var(--border,#ddd); background:rgba(255,255,255,.92); border-radius:12px; padding:6px 10px; font-size:12px; color:var(--muted,#666); box-shadow:0 2px 8px rgba(0,0,0,.06);}
          #rt3dOverlay .b3d-result{position:absolute; inset:70px 12px 120px; z-index:8; display:none; align-items:center; justify-content:center; pointer-events:none;}
          #rt3dOverlay .b3d-result.is-open{display:flex;}
          #rt3dOverlay .b3d-result-card{pointer-events:auto; width:min(640px,100%); border:1px solid var(--border,#ddd); background:rgba(255,255,255,.98); border-radius:16px; padding:14px; box-shadow:0 10px 24px rgba(0,0,0,.12); display:grid; gap:10px;}
          #rt3dOverlay .b3d-result-title{font-size:16px; font-weight:800;}
          #rt3dOverlay .b3d-result-list{display:grid; gap:6px; max-height:220px; overflow:auto;}
          #rt3dOverlay .b3d-result-row{display:grid; grid-template-columns:auto minmax(0,1fr) auto; gap:8px; align-items:center; border:1px solid var(--border,#ddd); background:var(--panel2,#fbfbfc); border-radius:10px; padding:8px 10px; font-size:13px;}
          #rt3dOverlay .b3d-result-actions{display:flex; gap:8px; flex-wrap:wrap;}
          #rt3dOverlay .b3d-overlay-msg{position:absolute; inset:0; z-index:9; display:none; place-items:center; background:rgba(0,0,0,.12);}
          #rt3dOverlay .b3d-overlay-msg.is-open{display:grid;}
          #rt3dOverlay .b3d-overlay-card{width:min(480px, calc(100vw - 24px)); border:1px solid var(--border,#ddd); background:rgba(255,255,255,.98); border-radius:16px; padding:14px; box-shadow:0 10px 24px rgba(0,0,0,.12);}
          #rt3dOverlay .b3d-overlay-card h4{margin:0 0 6px;}
          #rt3dOverlay .b3d-overlay-card .mini{line-height:1.4;}
          @media (max-width: 768px){
            #rt3dOverlay .b3d-head{grid-template-columns:auto 1fr; grid-template-areas:"left right" "center center";}
            #rt3dOverlay .b3d-head-left{grid-area:left;}
            #rt3dOverlay .b3d-head-right{grid-area:right; justify-content:flex-end;}
            #rt3dOverlay .b3d-head-center{grid-area:center;}
            #rt3dOverlay .b3d-hud{grid-template-columns:minmax(0,1fr) auto; grid-template-areas:"a b" "c c";}
            #rt3dOverlay .b3d-hud .b3d-hud-card:nth-child(1){grid-area:a;}
            #rt3dOverlay .b3d-hud .b3d-hud-card:nth-child(2){grid-area:b;}
            #rt3dOverlay .b3d-hud .b3d-hud-card:nth-child(3){grid-area:c;}
            #rt3dOverlay .b3d-score-panel{top:auto; bottom:calc(env(safe-area-inset-bottom,0px) + 96px); left:12px; right:12px; width:auto; max-height:140px;}
            #rt3dOverlay .b3d-quiz{inset:auto 12px calc(env(safe-area-inset-bottom,0px) + 110px) 12px;}
            #rt3dOverlay .b3d-dpad{grid-template-columns:repeat(3,52px); grid-template-rows:repeat(2,52px);}
            #rt3dOverlay .b3d-mbtn{width:52px; height:52px;}
            #rt3dOverlay .b3d-jump{width:68px; height:68px;}
            #rt3dOverlay .b3d-status-bar{max-width:calc(100vw - 24px);}
          }
          @keyframes b3dFadeIn{from{opacity:0; transform:translateY(8px)} to{opacity:1; transform:none}}
        `;
        document.head.appendChild(s);
      }
      function _rtBattle3dEnsureRoot(){
        let root = document.getElementById("rt3dOverlay");
        if (root) return root;
        root = document.createElement("div");
        root.id = "rt3dOverlay";
        root.setAttribute("aria-hidden", "true");
        root.innerHTML = `
          <div class="b3d-bg" data-rt-battle-action="b3dClose"></div>
          <div class="b3d-shell">
            <div class="b3d-head">
              <div class="b3d-head-left">
                <button class="btn ov-headbtn" type="button" data-rt-battle-action="b3dClose"></button>
                <div>
                  <div class="b3d-title">3DBETA</div>
                  <div class="b3d-sub" id="rt3dSubLine"></div>
                </div>
              </div>
              <div class="b3d-head-center">
                <span class="b3d-pill" id="rt3dRoomPill">ROOM ------</span>
                <span class="b3d-pill" id="rt3dPingPill">PING --ms</span>
                <span class="b3d-pill" id="rt3dSyncPill">SYNC --</span>
              </div>
              <div class="b3d-head-right">
                <button class="btn ov-iconbtn" type="button" data-rt-battle-action="b3dRetry" aria-label=""><span class="ms">wifi</span></button>
                <button class="btn ov-iconbtn" type="button" data-rt-battle-action="b3dReset" aria-label=""><span class="ms">restart_alt</span></button>
              </div>
            </div>
            <div class="b3d-main">
              <div id="rt3dCanvasWrap"></div>
              <div class="b3d-hud">
                <div class="b3d-hud-card"><div class="t"></div><div class="v" id="rt3dHudPlayers">0 / 4</div></div>
                <div class="b3d-hud-card"><div class="t"></div><div class="v" id="rt3dHudMe">-</div></div>
                <div class="b3d-hud-card"><div class="t"></div><div class="v" id="rt3dHudStatus"></div></div>
              </div>
              <div class="b3d-score-panel" id="rt3dScorePanel"></div>
              <div class="b3d-toast-wrap" id="rt3dToastWrap"></div>
              <div class="b3d-quiz" id="rt3dQuizCard" aria-hidden="true">
                <h4></h4>
                <div class="q" id="rt3dQuizPrompt"></div>
                <div class="choices" id="rt3dQuizChoices"></div>
                <div class="err" id="rt3dQuizError"></div>
              </div>
              <div class="b3d-result" id="rt3dResultLayer" aria-hidden="true">
                <div class="b3d-result-card">
                  <div class="b3d-result-title"></div>
                  <div class="mini" id="rt3dResultSub"></div>
                  <div class="b3d-result-list" id="rt3dResultList"></div>
                  <div class="b3d-result-actions">
                    <button class="btn" type="button" data-rt-battle-action="b3dReset"></button>
                    <button class="textbtn" type="button" data-rt-battle-action="b3dClose"></button>
                  </div>
                </div>
              </div>
              <div class="b3d-overlay-msg" id="rt3dOverlayMsg" aria-hidden="true">
                <div class="b3d-overlay-card">
                  <h4 id="rt3dErrTitle">3D</h4>
                  <div class="mini" id="rt3dErrText"></div>
                  <div class="ov-actions">
                    <button class="btn" type="button" data-rt-battle-action="b3dRetry"></button>
                    <button class="textbtn" type="button" data-rt-battle-action="b3dClose"></button>
                  </div>
                </div>
              </div>
              <div class="b3d-status-bar" id="rt3dStatusBar"></div>
            </div>
            <div class="b3d-bottom">
              <div class="b3d-controls">
                <div class="b3d-dpad" id="rt3dDpad">
                  <button class="b3d-mbtn sp" type="button" tabindex="-1" aria-hidden="true"></button>
                  <button class="b3d-mbtn" type="button" data-rt-battle-action="b3dHoldUp"></button>
                  <button class="b3d-mbtn sp" type="button" tabindex="-1" aria-hidden="true"></button>
                  <button class="b3d-mbtn" type="button" data-rt-battle-action="b3dHoldLeft"></button>
                  <button class="b3d-mbtn" type="button" data-rt-battle-action="b3dHoldDown"></button>
                  <button class="b3d-mbtn" type="button" data-rt-battle-action="b3dHoldRight"></button>
                </div>
                <div class="b3d-actions">
                  <button class="b3d-mbtn b3d-jump" type="button" data-rt-battle-action="b3dHoldJump">JUMP</button>
                </div>
              </div>
            </div>
          </div>
        `;
        document.body.appendChild(root);
        return root;
      }
      function _rtBattle3dIsOpen(){ return !!_rtBattle3dState().open; }
      function _rtBattle3dEnsureThree(){
        if (window.THREE) return Promise.resolve(window.THREE);
        if (__rt3dThreePromise) return __rt3dThreePromise;
        __rt3dThreePromise = new Promise((resolve, reject) => {
          const s = document.createElement("script");
          s.src = RT3D_THREE_URL;
          s.async = true;
          s.onload = () => window.THREE ? resolve(window.THREE) : reject(new Error("Three.js "));
          s.onerror = () => reject(new Error("Three.js "));
          document.head.appendChild(s);
        });
        return __rt3dThreePromise;
      }
      function _rtBattle3dQuestionData(){
        return {
          id: "gate_q_001",
          prompt: "demand ",
          choices: ["", "", "", ""],
          correctIndex: 0
        };
      }
      function _rtBattle3dActiveInputIsEditable(){
        const ae = document.activeElement;
        if (!ae) return false;
        if (ae instanceof HTMLInputElement || ae instanceof HTMLTextAreaElement) return true;
        return !!ae.isContentEditable;
      }
      function _rtBattle3dShowError(msg){
        const b = _rtBattle3dState();
        b.error = String(msg || "3D");
        const layer = document.getElementById("rt3dOverlayMsg");
        const text = document.getElementById("rt3dErrText");
        if (text) text.textContent = b.error;
        if (layer){ layer.classList.add("is-open"); layer.setAttribute("aria-hidden", "false"); }
        const status = document.getElementById("rt3dStatusBar");
        if (status) status.textContent = b.error;
      }
      function _rtBattle3dHideError(){
        const b = _rtBattle3dState();
        b.error = "";
        const layer = document.getElementById("rt3dOverlayMsg");
        if (layer){ layer.classList.remove("is-open"); layer.setAttribute("aria-hidden", "true"); }
      }
      function _rtBattle3dPushToast(kind, text){
        const b = _rtBattle3dState();
        const q = Array.isArray(b.runtime?.toastQueue) ? b.runtime.toastQueue : (b.runtime.toastQueue = []);
        if (q.length >= 3) q.shift();
        q.push({ kind: kind || "info", text: String(text || "") });
        _rtBattle3dDrainToastQueue();
      }
      function _rtBattle3dDrainToastQueue(){
        const b = _rtBattle3dState();
        if (!b.open) return;
        const rt = b.runtime || (b.runtime = {});
        if (rt.toastActive) return;
        const q = Array.isArray(rt.toastQueue) ? rt.toastQueue : [];
        const next = q.shift();
        if (!next) return;
        const wrap = document.getElementById("rt3dToastWrap");
        if (!wrap) return;
        rt.toastActive = true;
        const el = document.createElement("div");
        el.className = `b3d-toast ${next.kind || "info"}`;
        el.innerHTML = `<span class="badge">${_escapeHtml(String((next.kind || "info").toUpperCase()).slice(0,3))}</span><span>${_escapeHtml(next.text)}</span>`;
        wrap.appendChild(el);
        requestAnimationFrame(() => el.classList.add("is-show"));
        if (rt.toastTimerId) clearTimeout(rt.toastTimerId);
        rt.toastTimerId = setTimeout(() => {
          el.classList.remove("is-show");
          setTimeout(() => {
            try{ el.remove(); }catch(_){}
            rt.toastActive = false;
            rt.toastTimerId = null;
            _rtBattle3dDrainToastQueue();
          }, 240);
        }, 1600);
      }
      function _rtBattle3dRenderQuizUi(){
        const b = _rtBattle3dState();
        const card = document.getElementById("rt3dQuizCard");
        const promptEl = document.getElementById("rt3dQuizPrompt");
        const choicesEl = document.getElementById("rt3dQuizChoices");
        const errEl = document.getElementById("rt3dQuizError");
        if (!card || !promptEl || !choicesEl || !errEl) return;
        const q = _rtBattle3dQuestionData();
        promptEl.textContent = q.prompt;
        errEl.textContent = String(b.quizError || "");
        choicesEl.innerHTML = q.choices.map((c, idx) =>
          `<button class="btn" type="button" data-rt-battle-action="b3dQuizChoice" data-b3d-choice="${idx}"${b.quizAnswered ? " disabled" : ""}>${_escapeHtml(String(c))}</button>`
        ).join("");
        if (b.quizOpen){
          card.classList.add("is-open");
          card.setAttribute("aria-hidden", "false");
        } else {
          card.classList.remove("is-open");
          card.setAttribute("aria-hidden", "true");
        }
      }
      function _rtBattle3dUpdateStatusUi(){
        const st = _rtBattleState();
        const b = _rtBattle3dState();
        const players = asArray(st.players);
        const roomId = String(st.room?.roomId || st.roomId || "");
        const me = _rtBattleMePlayer();
        const roomPill = document.getElementById("rt3dRoomPill");
        const pingPill = document.getElementById("rt3dPingPill");
        const syncPill = document.getElementById("rt3dSyncPill");
        const sub = document.getElementById("rt3dSubLine");
        const hudPlayers = document.getElementById("rt3dHudPlayers");
        const hudMe = document.getElementById("rt3dHudMe");
        const hudStatus = document.getElementById("rt3dHudStatus");
        const bar = document.getElementById("rt3dStatusBar");
        if (roomPill) roomPill.textContent = `ROOM ${roomId || "------"}`;
        if (pingPill) pingPill.textContent = `PING ${Math.max(0, Math.round(Number(b.pingMs || 0)))}ms`;
        const staleMs = b.lastNetTs ? (Date.now() - b.lastNetTs) : 999999;
        if (syncPill) syncPill.textContent = staleMs < 2500 ? "SYNC OK" : "SYNC WEAK";
        if (sub) sub.textContent = `${players.filter((p)=>!!p?.connected).length}/${Math.max(1, Number(st.room?.max || 4))}  ${_rtBattleIsHost() ? "HOST" : "GUEST"}`;
        if (hudPlayers) hudPlayers.textContent = `${players.filter((p)=>!!p?.connected).length} / ${Math.max(1, Number(st.room?.max || 4))}`;
        if (hudMe) hudMe.textContent = String(me?.nick || st.nickname || "You");
        const statusTxt = b.resultOpen ? "" : (b.quizOpen ? "" : (b.gateOpen ? "OPEN" : ""));
        if (hudStatus) hudStatus.textContent = statusTxt;
        if (bar) bar.textContent = b.error ? b.error : (b.status || (st.connected ? "" : ""));
      }
      function _rtBattle3dRenderScoreboard(){
        const st = _rtBattleState();
        const box = document.getElementById("rt3dScorePanel");
        if (!box) return;
        const players = asArray(st.players);
        const total = _rtBattleResolvedTotalRounds(st.room?.settings?.questionCount || st.game?.totalRounds || st.questionCount || 20);
        if (!players.length){
          box.innerHTML = `<div class="mini"></div>`;
          return;
        }
        const maxScore = Math.max(1, ...players.map((p)=>Math.max(0, Number(p?.score || 0))));
        const html = players.map((p)=>{
          const score = Math.max(0, Number(p?.score || 0));
          const width = Math.max(4, Math.round((score / maxScore) * 100));
          const you = Math.max(0, Number(p?.userId || 0)) === _rtBattleMyUserId();
          return `<div class="b3d-score-row${you ? " is-you" : ""}">
            <div class="b3d-score-name">${_escapeHtml(String(p?.nick || "Guest"))}${you ? " *" : ""}</div>
            <div class="b3d-score-track"><div class="b3d-score-fill" style="width:${width}%"></div></div>
            <div class="b3d-score-val">${score}/${total}</div>
          </div>`;
        }).join("");
        if (box.dataset.hash !== html){
          box.dataset.hash = html;
          box.innerHTML = html;
        }
      }
      function _rtBattle3dRenderResult(){
        const b = _rtBattle3dState();
        const layer = document.getElementById("rt3dResultLayer");
        const sub = document.getElementById("rt3dResultSub");
        const list = document.getElementById("rt3dResultList");
        if (!layer || !sub || !list) return;
        if (!b.resultOpen){
          layer.classList.remove("is-open");
          layer.setAttribute("aria-hidden", "true");
          return;
        }
        layer.classList.add("is-open");
        layer.setAttribute("aria-hidden", "false");
        const rows = asArray(b.finishOrder);
        const myUid = _rtBattleMyUserId();
        const myRow = rows.find((r)=>Math.max(0, Number(r?.userId||0))===myUid) || null;
        const winnerNick = String(b.winnerNick || rows[0]?.nick || "");
        sub.textContent = winnerNick ? `: ${winnerNick}${myRow ? ` / : ${myRow.rank}` : ""}` : "";
        const html = rows.length ? rows.map((r)=>`<div class="b3d-result-row"><div>#${Math.max(1,Number(r?.rank||0))}</div><div>${_escapeHtml(String(r?.nick || "Guest"))}</div><div class="mini">${new Date(Math.max(0,Number(r?.ts||0))).toLocaleTimeString()}</div></div>`).join("") : `<div class="mini"></div>`;
        if (list.dataset.hash !== html){
          list.dataset.hash = html;
          list.innerHTML = html;
        }
      }
      function _rtBattle3dSyncFromSnapshot(snapshotLike){
        const st = _rtBattleState();
        const b = _rtBattle3dState();
        const src = (snapshotLike && typeof snapshotLike === "object") ? snapshotLike : null;
        const g3 = (src?.game3d && typeof src.game3d === "object")
          ? src.game3d
          : ((src?.state?.game3d && typeof src.state.game3d === "object")
            ? src.state.game3d
            : ((st.room && st.room.game3d && typeof st.room.game3d === "object")
              ? st.room.game3d
              : ((st.game?.game3d && typeof st.game.game3d === "object") ? st.game.game3d : null)));
        if (!g3) return;
        b.lastNetTs = Date.now();
        b.gateOpen = !!g3.gateOpen;
        b.winnerUserId = Math.max(0, Number(g3.winnerUserId || 0));
        b.winnerNick = String(g3.winnerNick || "");
        b.finishOrder = asArray(g3.finishOrder).map((x)=>({ userId:Math.max(0,Number(x?.userId||0)), nick:String(x?.nick||""), rank:Math.max(1,Number(x?.rank||1)), ts:Math.max(0,Number(x?.ts||0)) }));
        const rs = {};
        const srcPlayers = (g3.players && typeof g3.players === "object") ? g3.players : {};
        for (const [k,v] of Object.entries(srcPlayers)){
          const uid = String(Math.max(0, Number(k)));
          rs[uid] = {
            x:Number(v?.x||0), y:Number(v?.y||0.9), z:Number(v?.z||0),
            vx:Number(v?.vx||0), vy:Number(v?.vy||0), vz:Number(v?.vz||0),
            rotY:Number(v?.rotY||0), action:String(v?.action||"idle"), ts:Number(v?.ts||0),
            lastSeen: Date.now()
          };
        }
        b.remoteStates = rs;
        if (b.gateOpen && b.quizOpen){
          b.quizOpen = false;
          b.quizAnswered = true;
          b.quizError = "";
          _rtBattle3dRenderQuizUi();
        }
        if (b.winnerUserId && !b.resultOpen){
          b.resultOpen = true;
          b.status = "";
          _rtBattle3dPushToast("ok", `${b.winnerNick || ""}`);
        }
        _rtBattle3dRenderScoreboard();
        _rtBattle3dRenderResult();
        _rtBattle3dUpdateStatusUi();
      }
      function _rtBattle3dEnsureScene(){
        const b = _rtBattle3dState();
        const rt = b.runtime || (b.runtime = {});
        if (rt.inited) return;
        const THREE = window.THREE;
        if (!THREE) throw new Error("THREE ");
        const wrap = document.getElementById("rt3dCanvasWrap");
        if (!wrap) throw new Error("3D");
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: "low-power" });
        renderer.setPixelRatio(Math.min(1.5, window.devicePixelRatio || 1));
        renderer.setSize(Math.max(1, wrap.clientWidth), Math.max(1, wrap.clientHeight), false);
        renderer.outputColorSpace = THREE.SRGBColorSpace || undefined;
        wrap.innerHTML = "";
        wrap.appendChild(renderer.domElement);
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf3f5f8);
        const camera = new THREE.PerspectiveCamera(60, Math.max(1, wrap.clientWidth) / Math.max(1, wrap.clientHeight), 0.1, 100);
        const hemi = new THREE.HemisphereLight(0xffffff, 0xd9dde5, 1.1);
        hemi.position.set(0, 10, 0);
        scene.add(hemi);
        const dir = new THREE.DirectionalLight(0xffffff, 0.35);
        dir.position.set(4, 8, 2);
        scene.add(dir);
        const ground = new THREE.Mesh(
          new THREE.BoxGeometry(12, 0.2, 26),
          new THREE.MeshStandardMaterial({ color: 0xe7ebf2, roughness: 0.95, metalness: 0.02 })
        );
        ground.position.set(0, -0.1, -6);
        scene.add(ground);
        const wallMat = new THREE.MeshStandardMaterial({ color: 0xd6dbe5, roughness: 0.92 });
        const walls = [];
        const mkWall = (x,y,z,w,h,d) => {
          const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), wallMat);
          m.position.set(x,y,z);
          scene.add(m);
          walls.push({ x:x, y:y, z:z, w:w, h:h, d:d });
          return m;
        };
        mkWall(-5.6, 1.2, -6, 0.3, 2.6, 25.5);
        mkWall(5.6, 1.2, -6, 0.3, 2.6, 25.5);
        mkWall(0, 1.2, 6.5, 11.5, 2.6, 0.3);
        mkWall(0, 1.2, -18.5, 11.5, 2.6, 0.3);
        const gatePostMat = new THREE.MeshStandardMaterial({ color: 0xc3cad8, roughness: 0.9 });
        const gateDoorMat = new THREE.MeshStandardMaterial({ color: 0x8794ad, roughness: 0.85 });
        const gateL = new THREE.Mesh(new THREE.BoxGeometry(0.4, 2.4, 0.6), gatePostMat);
        const gateR = new THREE.Mesh(new THREE.BoxGeometry(0.4, 2.4, 0.6), gatePostMat);
        gateL.position.set(-2.0, 1.2, -4.0); gateR.position.set(2.0, 1.2, -4.0);
        scene.add(gateL); scene.add(gateR);
        const gateDoor = new THREE.Mesh(new THREE.BoxGeometry(3.2, 2.0, 0.35), gateDoorMat);
        gateDoor.position.set(0, 1.0, -4.0);
        scene.add(gateDoor);
        const gateFrame = new THREE.Group(); gateFrame.add(gateL); gateFrame.add(gateR); gateFrame.add(gateDoor); scene.add(gateFrame);
        const goalRing = new THREE.Mesh(
          new THREE.TorusGeometry(0.9, 0.14, 10, 24),
          new THREE.MeshStandardMaterial({ color: 0x74b7ff, roughness: 0.55, metalness: 0.05 })
        );
        goalRing.position.set(0, 1.6, -14.6);
        goalRing.rotation.x = Math.PI / 2;
        scene.add(goalRing);
        const goalPole = new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.1,3.2,10), new THREE.MeshStandardMaterial({ color: 0xb8c2d6, roughness: 0.8 }));
        goalPole.position.set(0, 1.6, -14.6);
        scene.add(goalPole);
        const localColor = _rtBattle3dColorForUser(_rtBattleMyUserId());
        const localMesh = _rtBattle3dBuildPlayerMesh(localColor);
        scene.add(localMesh);
        rt.renderer = renderer;
        rt.scene = scene;
        rt.camera = camera;
        rt.wrap = wrap;
        rt.walls = walls;
        rt.gateDoor = gateDoor;
        rt.goalRing = goalRing;
        rt.localMesh = localMesh;
        rt.inited = true;
        rt.lastTickTs = performance.now();
        _rtBattle3dResize();
      }
      function _rtBattle3dBuildPlayerMesh(colorHex){
        const THREE = window.THREE;
        const g = new THREE.Group();
        const mat = new THREE.MeshStandardMaterial({ color: colorHex, roughness: 0.86, metalness: 0.02 });
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.26, 0.28, 0.62, 10), mat);
        body.position.y = 0.48;
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.28, 12, 10), mat);
        head.position.y = 0.88;
        g.add(body, head);
        const dir = new THREE.Mesh(new THREE.BoxGeometry(0.12,0.05,0.22), new THREE.MeshStandardMaterial({ color: 0x1f2a44, roughness: 0.7 }));
        dir.position.set(0,0.6,0.28);
        g.add(dir);
        g.position.set(0, 0, 0);
        return g;
      }
      function _rtBattle3dColorForUser(uid){
        const id = Math.max(1, Number(uid || 1));
        const palette = [0x4f8cff,0x56c27d,0xff9f43,0xff6b81,0x8e7dff,0x36b0b7];
        return palette[id % palette.length];
      }
      function _rtBattle3dResize(){
        const b = _rtBattle3dState();
        const rt = b.runtime || {};
        const renderer = rt.renderer, camera = rt.camera, wrap = rt.wrap;
        if (!renderer || !camera || !wrap) return;
        const w = Math.max(1, wrap.clientWidth);
        const h = Math.max(1, wrap.clientHeight);
        renderer.setPixelRatio(Math.min(1.5, window.devicePixelRatio || 1));
        renderer.setSize(w, h, false);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
      }
      function _rtBattle3dClampWorld(){
        const b = _rtBattle3dState();
        const p = b.local;
        const r = 0.32;
        p.x = Math.max(-5.15 + r, Math.min(5.15 - r, p.x));
        p.z = Math.max(-18.05 + r, Math.min(6.05 - r, p.z));
        if (!b.gateOpen){
          const gateZ = -4.0;
          const halfDepth = 0.26;
          const halfWidth = 1.65;
          if (Math.abs(p.x) < halfWidth && Math.abs(p.z - gateZ) < (halfDepth + r)){
            if (p.z < gateZ) p.z = gateZ - halfDepth - r;
            else p.z = gateZ + halfDepth + r;
          }
        }
      }
      function _rtBattle3dOpenQuiz(){
        const b = _rtBattle3dState();
        if (b.quizOpen || b.gateOpen) return;
        b.quizOpen = true;
        b.quizAnswered = false;
        b.quizError = "";
        b.status = "";
        _rtBattle3dRenderQuizUi();
        _rtBattle3dUpdateStatusUi();
      }
      function _rtBattle3dSubmitQuizChoice(idx){
        const b = _rtBattle3dState();
        const q = _rtBattle3dQuestionData();
        if (!b.quizOpen || b.quizAnswered) return;
        const choice = Math.trunc(Number(idx));
        if (!(choice >= 0 && choice < q.choices.length)) return;
        b.quizAnswered = true;
        if (choice === q.correctIndex){
          b.quizError = "";
          b.quizOpen = false;
          b.gateOpen = true;
          b.status = "";
          try{ if (typeof playSfx === "function") playSfx("ok"); }catch(_){}
          try{ if (navigator?.vibrate) navigator.vibrate(18); }catch(_){}
          _rtBattle3dPushToast("ok", "");
          _rtBattleSafeSend({ type: "game3d:gate", open: true });
        } else {
          b.quizError = "";
          b.quizAnswered = false;
          try{ if (typeof playSfx === "function") playSfx("ng"); }catch(_){}
          try{ if (navigator?.vibrate) navigator.vibrate([14,18,14]); }catch(_){}
          _rtBattle3dPushToast("ng", "");
        }
        _rtBattle3dRenderQuizUi();
        _rtBattle3dUpdateStatusUi();
      }
      function _rtBattle3dMaybeTriggerWorldEvents(){
        const b = _rtBattle3dState();
        const p = b.local;
        if (!b.gateOpen && !b.quizOpen && !b.localFinished){
          const inGateTrigger = Math.abs(p.x) < 2.1 && p.z < -2.3 && p.z > -3.8;
          if (inGateTrigger) _rtBattle3dOpenQuiz();
        }
        if (b.gateOpen && !b.localFinished){
          const inGoal = Math.abs(p.x) < 2.0 && p.z < -13.8;
          if (inGoal){
            b.localFinished = true;
            b.status = "";
            _rtBattleSafeSend({ type: "game3d:goal" });
            _rtBattle3dPushToast("ok", "");
          }
        }
      }
      function _rtBattle3dUpdateLocalMeshAndCamera(dt){
        const b = _rtBattle3dState();
        const rt = b.runtime || {};
        const m = rt.localMesh, cam = rt.camera;
        if (m){
          m.position.set(b.local.x, Math.max(0, Number(b.local.y || 0.9) - 0.9), b.local.z);
          m.rotation.y = b.local.rotY || 0;
        }
        if (cam){
          const target = new window.THREE.Vector3(b.local.x, 0.9, b.local.z);
          const desired = new window.THREE.Vector3(b.local.x + 4.0, 4.3, b.local.z + 6.2);
          cam.position.lerp(desired, Math.min(1, dt * 6));
          cam.lookAt(target);
        }
      }
      function _rtBattle3dSyncRemoteMeshes(dt){
        const b = _rtBattle3dState();
        const rt = b.runtime || {};
        const scene = rt.scene;
        if (!scene || !window.THREE) return;
        const myUid = _rtBattleMyUserId();
        const states = b.remoteStates && typeof b.remoteStates === "object" ? b.remoteStates : {};
        const keep = new Set();
        for (const [uidKey, rs] of Object.entries(states)){
          const uid = Math.max(0, Number(uidKey || 0));
          if (!uid || uid === myUid) continue;
          keep.add(String(uid));
          let mesh = b.remoteMeshes[String(uid)];
          if (!mesh){
            mesh = _rtBattle3dBuildPlayerMesh(_rtBattle3dColorForUser(uid));
            scene.add(mesh);
            b.remoteMeshes[String(uid)] = mesh;
          }
          const tx = Number(rs?.x || 0), tz = Number(rs?.z || 0);
          const targetY = 0;
          mesh.position.x += (tx - mesh.position.x) * Math.min(1, dt * 8);
          mesh.position.y += ((((Number(rs?.y || 0.9) - 0.9) || targetY)) - mesh.position.y) * Math.min(1, dt * 8);
          mesh.position.z += (tz - mesh.position.z) * Math.min(1, dt * 8);
          const tr = Number(rs?.rotY || 0);
          mesh.rotation.y += (tr - mesh.rotation.y) * Math.min(1, dt * 8);
        }
        for (const [uid, mesh] of Object.entries(b.remoteMeshes || {})){
          if (!keep.has(uid)){
            try{ mesh.parent && mesh.parent.remove(mesh); }catch(_){}
            delete b.remoteMeshes[uid];
          }
        }
      }
      function _rtBattle3dStepPhysics(dt){
        const b = _rtBattle3dState();
        const p = b.local;
        if (b.quizOpen || b.resultOpen){
          p.vx *= 0.85; p.vz *= 0.85;
          return;
        }
        const speed = 4.6;
        let ix = 0, iz = 0;
        if (b.input.left) ix -= 1;
        if (b.input.right) ix += 1;
        if (b.input.fwd) iz -= 1;
        if (b.input.back) iz += 1;
        const len = Math.hypot(ix, iz) || 1;
        ix /= len; iz /= len;
        p.vx = ix * speed;
        p.vz = iz * speed;
        if ((b.jumpQueued || b.input.jump) && p.grounded){
          p.vy = 7.2;
          p.grounded = false;
          b.jumpQueued = false;
        }
        if (Math.abs(ix) > 0.01 || Math.abs(iz) > 0.01){
          p.rotY = Math.atan2(ix, iz);
          p.action = "run";
        } else {
          p.action = "idle";
        }
        p.vy += -18 * dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.z += p.vz * dt;
        if (p.y <= 0.9){
          p.y = 0.9; p.vy = 0; p.grounded = true;
        }
        _rtBattle3dClampWorld();
      }
      function _rtBattle3dAnimateWorld(dt){
        const b = _rtBattle3dState();
        const rt = b.runtime || {};
        b.gateAnim += ((b.gateOpen ? 1 : 0) - Number(b.gateAnim || 0)) * Math.min(1, dt * 4.5);
        if (rt.gateDoor){
          rt.gateDoor.position.y = 1.0 + (b.gateAnim * 3.2);
        }
        if (rt.goalRing){
          rt.goalRing.rotation.z += dt * 0.8;
        }
      }
      function _rtBattle3dSendLocalState(force = false){
        const st = _rtBattleState();
        const b = _rtBattle3dState();
        if (!st.connected) return;
        const now = Date.now();
        if (!force && (now - Math.max(0, Number(b.runtime?.lastSyncSentTs || 0))) < 80) return;
        const p = b.local;
        const payload = {
          type: "player3d:update",
          state: {
            x: Math.round(p.x * 100) / 100,
            y: Math.round(p.y * 100) / 100,
            z: Math.round(p.z * 100) / 100,
            vx: Math.round(p.vx * 100) / 100,
            vy: Math.round(p.vy * 100) / 100,
            vz: Math.round(p.vz * 100) / 100,
            rotY: Math.round((p.rotY || 0) * 1000) / 1000,
            action: String(p.action || "idle"),
            ts: now
          }
        };
        if (_rtBattleSafeSend(payload)){
          b.runtime.lastSyncSentTs = now;
        }
      }
      function _rtBattle3dTick(tsNow){
        const b = _rtBattle3dState();
        const rt = b.runtime || {};
        if (!b.open || !rt.inited || !rt.renderer || !rt.scene || !rt.camera) return;
        const prev = Math.max(0, Number(rt.lastTickTs || tsNow));
        const dt = Math.min(0.05, Math.max(0.001, (tsNow - prev) / 1000));
        rt.lastTickTs = tsNow;
        _rtBattle3dStepPhysics(dt);
        _rtBattle3dMaybeTriggerWorldEvents();
        _rtBattle3dAnimateWorld(dt);
        _rtBattle3dUpdateLocalMeshAndCamera(dt);
        _rtBattle3dSyncRemoteMeshes(dt);
        rt.renderer.render(rt.scene, rt.camera);
        _rtBattle3dSendLocalState(false);
        if ((tsNow - Math.max(0, Number(rt.lastHudRenderTs || 0))) > 180){
          rt.lastHudRenderTs = tsNow;
          _rtBattle3dRenderScoreboard();
          _rtBattle3dRenderResult();
          _rtBattle3dUpdateStatusUi();
        }
        b.rafId = requestAnimationFrame(_rtBattle3dTick);
      }
      function _rtBattle3dStartLoops(){
        const b = _rtBattle3dState();
        if (!b.rafId) b.rafId = requestAnimationFrame(_rtBattle3dTick);
        if (!b.uiTimerId){
          b.uiTimerId = setInterval(() => {
            if (!_rtBattle3dIsOpen()) return;
            _rtBattle3dUpdateStatusUi();
          }, 500);
        }
        if (!b.pingTimerId){
          b.pingTimerId = setInterval(() => {
            if (!_rtBattle3dIsOpen()) return;
            const st = _rtBattleState();
            if (!st.connected) return;
            b.awaitingPingTs = Date.now();
            _rtBattleSafeSend({ type: "ping" });
          }, 5000);
        }
      }
      function _rtBattle3dStopLoops(){
        const b = _rtBattle3dState();
        if (b.rafId){ cancelAnimationFrame(b.rafId); b.rafId = null; }
        if (b.uiTimerId){ clearInterval(b.uiTimerId); b.uiTimerId = null; }
        if (b.pingTimerId){ clearInterval(b.pingTimerId); b.pingTimerId = null; }
      }
      function _rtBattle3dDestroyScene(){
        const b = _rtBattle3dState();
        const rt = b.runtime || {};
        _rtBattle3dStopLoops();
        if (rt.toastTimerId){ clearTimeout(rt.toastTimerId); rt.toastTimerId = null; }
        if (rt.scene && b.remoteMeshes){
          for (const mesh of Object.values(b.remoteMeshes)){ try{ mesh.parent && mesh.parent.remove(mesh); }catch(_){} }
        }
        b.remoteMeshes = {};
        try{
          if (rt.renderer){
            rt.renderer.dispose?.();
            const c = rt.renderer.domElement;
            c && c.parentNode && c.parentNode.removeChild(c);
          }
        }catch(_){}
        b.runtime = { inited:false, toastQueue:[], toastActive:false, lastShownFinishCount:0, seenGatePrompt:false };
      }
      function _rtBattle3dKeyboardHandler(e, down){
        if (!_rtBattle3dIsOpen()) return;
        if (_rtBattle3dActiveInputIsEditable()) return;
        const b = _rtBattle3dState();
        const k = String(e.key || "").toLowerCase();
        if (["w","arrowup"].includes(k)){ b.input.fwd = down; e.preventDefault(); }
        else if (["s","arrowdown"].includes(k)){ b.input.back = down; e.preventDefault(); }
        else if (["a","arrowleft"].includes(k)){ b.input.left = down; e.preventDefault(); }
        else if (["d","arrowright"].includes(k)){ b.input.right = down; e.preventDefault(); }
        else if (k === " " || k === "spacebar"){ b.input.jump = down; if (down) b.jumpQueued = true; e.preventDefault(); }
        else if (k === "escape" && down){ _rtBattle3dClose(); e.preventDefault(); }
      }
      function _rtBattle3dBindGlobalHandlers(){
        if (window.__rt3dGlobalBound) return;
        window.__rt3dGlobalBound = true;
        window.addEventListener("keydown", (e) => _rtBattle3dKeyboardHandler(e, true), true);
        window.addEventListener("keyup", (e) => _rtBattle3dKeyboardHandler(e, false), true);
        window.addEventListener("resize", () => { if (_rtBattle3dIsOpen()) _rtBattle3dResize(); }, { passive:true });
        document.addEventListener("click", (e) => {
          const btn = e.target && e.target.closest ? e.target.closest("[data-rt-battle-action]") : null;
          if (!btn) return;
          if (!btn.closest("#rt3dOverlay")) return;
          const act = String(btn.getAttribute("data-rt-battle-action") || "");
          if (_rtBattle3dHandleAction(act, btn)) return;
        }, true);
        const holdPointer = (down) => {
          document.addEventListener(down ? "pointerdown" : "pointerup", (e) => {
            const btn = e.target && e.target.closest ? e.target.closest("#rt3dOverlay [data-rt-battle-action^='b3dHold']") : null;
            if (!btn) return;
            const act = String(btn.getAttribute("data-rt-battle-action") || "");
            const map = { b3dHoldUp:"fwd", b3dHoldDown:"back", b3dHoldLeft:"left", b3dHoldRight:"right", b3dHoldJump:"jump" };
            const key = map[act];
            if (!key) return;
            const b = _rtBattle3dState();
            b.input[key] = down;
            if (key === "jump" && down) b.jumpQueued = true;
            btn.classList.toggle("is-active", down);
            if (down){
              try{ btn.setPointerCapture && btn.setPointerCapture(e.pointerId); }catch(_){}
            }
            e.preventDefault();
          }, true);
        };
        holdPointer(true);
        holdPointer(false);
        window.addEventListener("pointerup", () => {
          if (!_rtBattle3dIsOpen()) return;
          const b = _rtBattle3dState();
          b.input.fwd = b.input.back = b.input.left = b.input.right = false;
          b.input.jump = false;
          document.querySelectorAll("#rt3dOverlay .b3d-mbtn.is-active").forEach((el) => el.classList.remove("is-active"));
        }, true);
        document.addEventListener("pointercancel", (e) => {
          const btn = e.target && e.target.closest ? e.target.closest("#rt3dOverlay [data-rt-battle-action^='b3dHold']") : null;
          if (!btn) return;
          const act = String(btn.getAttribute("data-rt-battle-action") || "");
          const map = { b3dHoldUp:"fwd", b3dHoldDown:"back", b3dHoldLeft:"left", b3dHoldRight:"right", b3dHoldJump:"jump" };
          const key = map[act];
          if (!key) return;
          const b = _rtBattle3dState();
          b.input[key] = false;
          btn.classList.remove("is-active");
        }, true);
      }
      async function _rtBattle3dOpen(){
        const st = _rtBattleState();
        const b = _rtBattle3dState();
        if (!st.connected){
          try{ uiToast(""); }catch(_){}
          return;
        }
        _rtBattle3dEnsureStyles();
        _rtBattle3dBindGlobalHandlers();
        const root = _rtBattle3dEnsureRoot();
        b.open = true;
        b.loading = true;
        b.error = "";
        b.status = "3D";
        b.sceneMode = "play";
        b.resultOpen = false;
        b.localFinished = false;
        b.quizOpen = false;
        b.quizAnswered = false;
        b.quizError = "";
        b.runtime = { inited:false, toastQueue:[], toastActive:false, lastShownFinishCount:0, seenGatePrompt:false };
        b.local = { x:0, y:0.9, z:4, vx:0, vy:0, vz:0, rotY:0, grounded:true, action:"idle", ts:Date.now() };
        root.classList.add("is-open");
        root.hidden = false;
        root.setAttribute("aria-hidden", "false");
        b._prevBodyOverflow = document.body.style.overflow || "";
        document.body.style.overflow = "hidden";
        _rtBattle3dHideError();
        _rtBattle3dRenderQuizUi();
        _rtBattle3dRenderResult();
        _rtBattle3dUpdateStatusUi();
        try{
          await _rtBattle3dEnsureThree();
          _rtBattle3dEnsureScene();
          _rtBattle3dSyncFromSnapshot();
          _rtBattle3dSendLocalState(true);
          _rtBattle3dStartLoops();
          b.loading = false;
          b.status = "";
          _rtBattle3dUpdateStatusUi();
          _rtBattle3dPushToast("info", "");
        }catch(err){
          b.loading = false;
          _rtBattle3dShowError(String(err?.message || "3D"));
        }
      }
      function _rtBattle3dClose(){
        const b = _rtBattle3dState();
        if (!b.open) return;
        b.open = false;
        b.loading = false;
        b.quizOpen = false;
        _rtBattle3dStopLoops();
        _rtBattle3dDestroyScene();
        const root = document.getElementById("rt3dOverlay");
        if (root){
          root.classList.remove("is-open");
          root.setAttribute("aria-hidden", "true");
          root.hidden = true;
        }
        document.body.style.overflow = (typeof b._prevBodyOverflow === "string") ? b._prevBodyOverflow : "";
      }
      function _rtBattle3dHandleAction(act, el){
        const b = _rtBattle3dState();
        if (act === "open3dBeta"){ _rtBattle3dOpen(); return true; }
        if (!_rtBattle3dIsOpen()) return false;
        if (act === "b3dClose"){ _rtBattle3dClose(); return true; }
        if (act === "b3dRetry"){
          if (!_rtBattleState().connected) _rtBattleReconnect();
          else { _rtBattle3dClose(); setTimeout(() => { _rtBattle3dOpen(); }, 50); }
          return true;
        }
        if (act === "b3dReset"){
          if (_rtBattleIsHost()) _rtBattleSafeSend({ type: "game3d:reset" });
          b.resultOpen = false;
          b.localFinished = false;
          b.winnerUserId = 0;
          b.winnerNick = "";
          b.finishOrder = [];
          b.quizOpen = false;
          b.quizAnswered = false;
          b.quizError = "";
          b.gateOpen = false;
          b.local = { x:0, y:0.9, z:4, vx:0, vy:0, vz:0, rotY:0, grounded:true, action:"idle", ts:Date.now() };
          _rtBattle3dRenderQuizUi();
          _rtBattle3dRenderResult();
          _rtBattle3dUpdateStatusUi();
          _rtBattle3dSendLocalState(true);
          return true;
        }
        if (act === "b3dQuizChoice"){
          const idx = Number(el?.getAttribute?.("data-b3d-choice") || -1);
          _rtBattle3dSubmitQuizChoice(idx);
          return true;
        }
        return false;
      }
      // hook overlay actions so existing Game sheet button opens 3D demo
      const __rtBattleOverlayHandleActionV4Base = _rtBattleOverlayHandleAction;
      _rtBattleOverlayHandleAction = function(act, el){
        if (_rtBattle3dHandleAction(act, el)) return true;
        return __rtBattleOverlayHandleActionV4Base.apply(this, arguments);
      };
      // hook WS messages for 3D sync events/state
      const __rtBattleHandleMessageV4Base = _rtBattleHandleMessage;
      _rtBattleHandleMessage = function(msg){
        __rtBattleHandleMessageV4Base.apply(this, arguments);
        const type = String(msg?.type || "").toLowerCase();
        const st = _rtBattleState();
        const b = _rtBattle3dState();
        if (type === "pong"){
          if (b.awaitingPingTs > 0){
            b.pingMs = Math.max(0, Date.now() - b.awaitingPingTs);
            b.awaitingPingTs = 0;
          }
          b.lastNetTs = Date.now();
          if (_rtBattle3dIsOpen()) _rtBattle3dUpdateStatusUi();
          return;
        }
        if (type === "room:snapshot" || type === "state"){
          _rtBattle3dSyncFromSnapshot(msg);
          return;
        }
        if (type === "game3d:player"){
          const uid = Math.max(0, Number(msg?.userId || msg?.id || 0));
          if (uid && uid !== _rtBattleMyUserId()){
            const rs = (msg?.state && typeof msg.state === "object") ? msg.state : {};
            b.remoteStates[String(uid)] = {
              x:Number(rs.x||0), y:Number(rs.y||0.9), z:Number(rs.z||0),
              vx:Number(rs.vx||0), vy:Number(rs.vy||0), vz:Number(rs.vz||0),
              rotY:Number(rs.rotY||0), action:String(rs.action||"idle"),
              ts:Number(rs.ts||Date.now()), lastSeen: Date.now(), nick:String(msg?.nick || "")
            };
          }
          b.lastNetTs = Date.now();
          return;
        }
        if (type === "game3d:world"){
          if (msg?.game3d && typeof msg.game3d === "object"){
            if (typeof msg.game3d.gateOpen !== "undefined") b.gateOpen = !!msg.game3d.gateOpen;
            if (typeof msg.game3d.winnerUserId !== "undefined") b.winnerUserId = Math.max(0, Number(msg.game3d.winnerUserId || 0));
            if (typeof msg.game3d.winnerNick !== "undefined") b.winnerNick = String(msg.game3d.winnerNick || "");
            if (Array.isArray(msg.game3d.finishOrder)) b.finishOrder = msg.game3d.finishOrder.map((x)=>({ userId:Math.max(0,Number(x?.userId||0)), nick:String(x?.nick||""), rank:Math.max(1,Number(x?.rank||1)), ts:Math.max(0,Number(x?.ts||0)) }));
          }
          if (b.gateOpen && b.quizOpen){ b.quizOpen = false; b.quizAnswered = true; b.quizError = ""; _rtBattle3dRenderQuizUi(); }
          if (!b.gateOpen && !b.winnerUserId && asArray(b.finishOrder).length === 0){
            b.resultOpen = false;
            b.localFinished = false;
            b.quizOpen = false;
            b.quizAnswered = false;
            b.quizError = "";
            b.local = { x:0, y:0.9, z:4, vx:0, vy:0, vz:0, rotY:0, grounded:true, action:"idle", ts:Date.now() };
          }
          _rtBattle3dRenderResult();
          _rtBattle3dUpdateStatusUi();
          b.lastNetTs = Date.now();
          return;
        }
        if (type === "game3d:finish"){
          const g3 = (msg?.game3d && typeof msg.game3d === "object") ? msg.game3d : {};
          b.winnerUserId = Math.max(0, Number(g3.winnerUserId || msg?.winner?.userId || 0));
          b.winnerNick = String(g3.winnerNick || msg?.winner?.nick || "");
          b.finishOrder = Array.isArray(g3.finishOrder) ? g3.finishOrder : (Array.isArray(msg?.leaderboard) ? msg.leaderboard : []);
          b.resultOpen = true;
          b.lastNetTs = Date.now();
          _rtBattle3dPushToast("ok", `${b.winnerNick || ""}`);
          _rtBattle3dRenderResult();
          _rtBattle3dUpdateStatusUi();
          return;
        }
      };
      // ensure close/leave disconnect also closes 3D overlay and frees resources
      const __rtBattleDisconnectV4Base = _rtBattleDisconnect;
      _rtBattleDisconnect = function(silent = false){
        try{ _rtBattle3dClose(); }catch(_){}
        return __rtBattleDisconnectV4Base.apply(this, arguments);
      };
      const __rtBattleLeaveV4Base = _rtBattleLeave;
      _rtBattleLeave = function(){
        try{ _rtBattle3dClose(); }catch(_){}
        return __rtBattleLeaveV4Base.apply(this, arguments);
      };

      // ROOM_DO_UI_V5_3D_PHASE1: lobby/ready/start/countdown + synchronized room quiz + round effects
      function _rtBattle3dPhase1State(){
        const b = _rtBattle3dState();
        if (typeof b.roomPhase !== "string") b.roomPhase = "lobby";
        if (typeof b.quizRoundIndex !== "number") b.quizRoundIndex = -1;
        if (typeof b.quizSubmittedRound !== "number") b.quizSubmittedRound = -1;
        if (typeof b.effectKind !== "string") b.effectKind = "";
        if (typeof b.effectEndsAtMs !== "number") b.effectEndsAtMs = 0;
        if (typeof b.countdownEndsAtMs !== "number") b.countdownEndsAtMs = 0;
        if (typeof b.countdownStartAtMs !== "number") b.countdownStartAtMs = 0;
        if (typeof b.lastFinalHash !== "string") b.lastFinalHash = "";
        if (typeof b.lastRoundResultHash !== "string") b.lastRoundResultHash = "";
        if (typeof b._phase1Bound !== "boolean") b._phase1Bound = false;
        if (!b.phase1 || typeof b.phase1 !== "object") b.phase1 = {};
        if (typeof b.phase1.showLobbySheet !== "string") b.phase1.showLobbySheet = "";
        return b;
      }
      function _rtBattle3dPhase1EnsureStyles(){
        if (document.getElementById("rt3dPhase1Styles")) return;
        const s = document.createElement("style");
        s.id = "rt3dPhase1Styles";
        s.textContent = `
          #rt3dOverlay .b3d-hud{grid-template-columns:minmax(0,1.3fr) auto auto auto; align-items:start;}
          #rt3dOverlay .b3d-hud .b3d-hud-card.is-timer .v{font-size:22px; font-weight:900; font-variant-numeric:tabular-nums; line-height:1;}
          #rt3dOverlay .b3d-hud .b3d-hud-card.is-round .v{font-size:14px;}
          #rt3dOverlay .b3d-scene-layer{position:absolute; inset:0; z-index:7; pointer-events:none;}
          #rt3dOverlay .b3d-center-stack{position:absolute; inset:74px 12px calc(env(safe-area-inset-bottom,0px) + 100px); display:grid; align-items:center; justify-items:center; pointer-events:none;}
          #rt3dOverlay .b3d-lobby-card,
          #rt3dOverlay .b3d-countdown-card{pointer-events:auto; width:min(760px, calc(100vw - 24px)); border:1px solid var(--border,#ddd); background:rgba(255,255,255,.96); border-radius:16px; box-shadow:0 12px 24px rgba(0,0,0,.10);}
          #rt3dOverlay .b3d-lobby-card{padding:14px; display:none; grid-template-columns:minmax(0,1.05fr) minmax(0,.95fr); gap:12px;}
          #rt3dOverlay .b3d-lobby-card.is-open{display:grid; animation:b3dFadeIn .22s cubic-bezier(.22,1,.36,1);}
          #rt3dOverlay .b3d-countdown-card{padding:18px; display:none; text-align:center;}
          #rt3dOverlay .b3d-countdown-card.is-open{display:block; animation:b3dFadeIn .18s cubic-bezier(.22,1,.36,1);}
          #rt3dOverlay .b3d-countdown-num{font-size:clamp(44px, 12vw, 84px); font-weight:900; line-height:1; letter-spacing:.02em;}
          #rt3dOverlay .b3d-countdown-sub{font-size:13px; color:var(--muted,#666); margin-top:6px;}
          #rt3dOverlay .b3d-panel{border:1px solid var(--border,#ddd); background:var(--panel2,#fbfbfc); border-radius:14px; padding:10px;}
          #rt3dOverlay .b3d-panel h4{margin:0 0 8px; font-size:13px; font-weight:800;}
          #rt3dOverlay .b3d-mini{font-size:12px; color:var(--muted,#666); line-height:1.45;}
          #rt3dOverlay .b3d-grid{display:grid; gap:10px;}
          #rt3dOverlay .b3d-player-list{display:grid; gap:6px; max-height:180px; overflow:auto;}
          #rt3dOverlay .b3d-player-row{display:grid; grid-template-columns:minmax(0,1fr) auto auto; gap:8px; align-items:center; border:1px solid var(--border,#ddd); background:var(--panel,#fff); border-radius:10px; padding:8px 10px;}
          #rt3dOverlay .b3d-player-row .name{font-size:12px; font-weight:700; min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;}
          #rt3dOverlay .b3d-player-row .pill{height:20px; padding:0 8px; border-radius:999px; border:1px solid var(--border,#ddd); display:inline-flex; align-items:center; font-size:10px; font-weight:700;}
          #rt3dOverlay .b3d-player-row .pill.is-ready{background:rgba(64,190,106,.10); color:#1e7a45;}
          #rt3dOverlay .b3d-player-row .pill.is-host{background:rgba(31,42,68,.08); color:var(--accent,#1f2a44);}
          #rt3dOverlay .b3d-actions-row{display:flex; gap:8px; flex-wrap:wrap; align-items:center;}
          #rt3dOverlay .b3d-actions-row .btn{min-height:40px;}
          #rt3dOverlay .b3d-inline-grid{display:grid; grid-template-columns:1fr 1fr; gap:8px;}
          #rt3dOverlay .b3d-select{width:100%; min-height:40px; border-radius:12px; border:1px solid var(--border,#ddd); background:var(--panel,#fff); color:var(--text,#111); padding:0 12px; font:inherit;}
          #rt3dOverlay .b3d-seg-grid{display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:8px;}
          #rt3dOverlay .b3d-seg-btn{border:1px solid var(--border,#ddd); border-radius:12px; min-height:42px; background:var(--panel,#fff); color:var(--text,#111); font-weight:700; font-size:12px; padding:6px 10px;}
          #rt3dOverlay .b3d-seg-btn.is-active{border-color:rgba(31,42,68,.26); background:rgba(31,42,68,.08);}
          #rt3dOverlay .b3d-seg-btn:disabled{opacity:.55; cursor:not-allowed;}
          #rt3dOverlay .b3d-round-track{height:8px; border-radius:999px; background:var(--panel2,#f1f3f5); border:1px solid var(--border,#ddd); overflow:hidden; margin-top:8px;}
          #rt3dOverlay .b3d-round-track i{display:block; height:100%; background:rgba(31,42,68,.18); border-radius:999px; width:0%;}
          #rt3dOverlay .b3d-quiz .mini-line{font-size:12px; color:var(--muted,#666); margin-bottom:6px;}
          #rt3dOverlay .b3d-quiz .state-line{font-size:12px; color:var(--muted,#666); margin-top:8px; min-height:16px;}
          #rt3dOverlay .b3d-result-card .b3d-final-grid{display:grid; grid-template-columns:repeat(3,minmax(0,1fr)); gap:8px;}
          #rt3dOverlay .b3d-stat{border:1px solid var(--border,#ddd); background:var(--panel2,#fbfbfc); border-radius:10px; padding:8px;}
          #rt3dOverlay .b3d-stat .k{font-size:11px; color:var(--muted,#666);}
          #rt3dOverlay .b3d-stat .v{font-size:16px; font-weight:800; margin-top:2px;}
          #rt3dOverlay .b3d-roundlog{display:grid; gap:6px; max-height:160px; overflow:auto;}
          #rt3dOverlay .b3d-roundlog-item{border:1px solid var(--border,#ddd); background:var(--panel2,#fbfbfc); border-radius:10px; padding:8px;}
          #rt3dOverlay .b3d-roundlog-item.ok{box-shadow:inset 0 0 0 1px rgba(64,190,106,.14);}
          #rt3dOverlay .b3d-roundlog-item.ng{box-shadow:inset 0 0 0 1px rgba(235,87,87,.12);}
          @media (max-width: 840px){
            #rt3dOverlay .b3d-hud{grid-template-columns:minmax(0,1fr) auto auto; grid-template-areas:"a b c" "d d d";}
            #rt3dOverlay .b3d-hud .b3d-hud-card:nth-child(1){grid-area:a;}
            #rt3dOverlay .b3d-hud .b3d-hud-card:nth-child(2){grid-area:b;}
            #rt3dOverlay .b3d-hud .b3d-hud-card:nth-child(3){grid-area:c;}
            #rt3dOverlay .b3d-hud .b3d-hud-card:nth-child(4){grid-area:d;}
            #rt3dOverlay .b3d-lobby-card{grid-template-columns:1fr; max-height:min(72vh, 640px); overflow:auto;}
            #rt3dOverlay .b3d-final-grid{grid-template-columns:1fr 1fr;}
          }
        `;
        document.head.appendChild(s);
      }
      function _rtBattle3dQuestionData(){
        const st = _rtBattleState();
        const q = (st.game && st.game.currentQuestion && typeof st.game.currentQuestion === "object") ? st.game.currentQuestion : null;
        if (q) {
          return {
            id: String(q.qid || ""),
            no: Math.max(0, Number(q.no || 0)),
            round: Math.max(1, Number(st.game?.round || 0) + 1),
            totalRounds: _rtBattleResolvedTotalRounds(st.game?.totalRounds || st.room?.settings?.questionCount || 1),
            prompt: String(q.prompt || ""),
            choices: asArray(q.choices).slice(0, 4).map((x) => String(x || "")),
            correctIndex: Number.isInteger(Number(q.correctIndex)) ? Number(q.correctIndex) : -1
          };
        }
        return {
          id: "",
          no: 0,
          round: Math.max(1, Number(st.game?.round || 0) + 1),
          totalRounds: _rtBattleResolvedTotalRounds(st.game?.totalRounds || st.room?.settings?.questionCount || 1),
          prompt: "",
          choices: [],
          correctIndex: -1
        };
      }
      function _rtBattle3dEnsurePhase1Dom(){
        const root = _rtBattle3dEnsureRoot();
        _rtBattle3dPhase1EnsureStyles();
        const main = root.querySelector(".b3d-main");
        if (!(main instanceof HTMLElement)) return root;
        if (!document.getElementById("rt3dSceneLayer")){
          const layer = document.createElement("div");
          layer.id = "rt3dSceneLayer";
          layer.className = "b3d-scene-layer";
          layer.innerHTML = `
            <div class="b3d-center-stack">
              <section class="b3d-lobby-card" id="rt3dLobbyLayer" aria-hidden="true"></section>
              <section class="b3d-countdown-card" id="rt3dCountdownLayer" aria-hidden="true">
                <div class="b3d-countdown-num" id="rt3dCountdownNum">3</div>
                <div class="b3d-countdown-sub" id="rt3dCountdownSub"></div>
              </section>
            </div>`;
          main.appendChild(layer);
        }
        return root;
      }
      function _rtBattle3dRoundProgressPct(){
        const st = _rtBattleState();
        const total = _rtBattleResolvedTotalRounds(st.game?.totalRounds || st.room?.settings?.questionCount || 1);
        const phase = String(st.phase || "lobby");
        const currentRound = (phase === "playing" || phase === "countdown")
          ? Math.max(1, Number(st.game?.round || 0) + 1)
          : (phase === "result" ? total : 0);
        if (!currentRound) return 0;
        return Math.max(0, Math.min(100, Math.round((currentRound / total) * 100)));
      }
      function _rtBattle3dPresetValueFromRef(ref){
        if (!ref || typeof ref !== "object") return "";
        const type = String(ref.type || "").toLowerCase();
        if (type === "builtin"){
          const key = String(ref.key || "").replace(/^builtin:/i, "");
          return `builtin:${key || "ALL"}`;
        }
        if (type === "custom"){
          const id = String(ref.id || "");
          return id ? `custom:${id}` : "";
        }
        return "";
      }
      function _rtBattle3dPresetRefFromValue(raw){
        const v = String(raw || "").trim();
        if (!v) return null;
        if (v.startsWith("builtin:")){
          const key = v.replace(/^builtin:/, "") || "ALL";
          return { type: "builtin", key };
        }
        if (v.startsWith("custom:")){
          const id = v.slice("custom:".length);
          if (!id) return null;
          return { type: "custom", id };
        }
        return null;
      }
      function _rtBattle3dRenderLobbyPanel(){
        const st = _rtBattleState();
        const b = _rtBattle3dPhase1State();
        const layer = document.getElementById("rt3dLobbyLayer");
        if (!(layer instanceof HTMLElement)) return;
        const phase = String(st.phase || "lobby");
        const show = (phase === "lobby");
        layer.classList.toggle("is-open", show);
        layer.setAttribute("aria-hidden", show ? "false" : "true");
        if (!show) return;
        const players = asArray(st.players).filter((p) => !!p);
        const isHost = _rtBattleIsHost();
        const currentPresetLabel = _rtBattlePresetDisplayName(st.room?.presetRef, st.room?.presetName) || "";
        const roomId = String(st.room?.roomId || st.roomId || "------");
        const countVal = _rtBattleQuestionCountLabel(st.room?.settings?.questionCount || st.questionCount || 20);
        const dbg = st.room?.debug || {};
        const dbgLine = `Q=${String((typeof dbg.questionCount !== "undefined") ? dbg.questionCount : (st.room?.settings?.questionCount ?? st.questionCount ?? 20))} / IDs=${Math.max(0, Number(dbg.questionIdsLength || st.game?.questionIds?.length || 0))} / Pool=${Math.max(0, Number(dbg.presetWordsLength || st.game?.presetWordsLength || 0))}`;
        const qOpts = asArray(_rtBattleQuestionCountOptions()).map((o) => `<option value="${_escapeHtml(o.value)}"${String(o.value)===String(countVal) ? " selected" : ""}>${_escapeHtml(o.label)}</option>`).join("");
        const pOpts = asArray(_rtBattlePresetOptions()).map((o) => {
          const selected = String(o.value) === String(_rtBattle3dPresetValueFromRef(st.room?.presetRef));
          return `<option value="${_escapeHtml(String(o.value||""))}"${selected ? " selected" : ""}>${_escapeHtml(String(o.label||""))}</option>`;
        }).join("");
        const rowsHtml = players.length ? players.map((p) => {
          const isMe = Math.max(0, Number(p?.userId || 0)) === _rtBattleMyUserId();
          const ready = !!p?.ready;
          const connected = !!p?.connected;
          const isHostRow = Math.max(0, Number(p?.userId || 0)) === Math.max(0, Number(st.room?.hostUserId || 0));
          return `<div class="b3d-player-row${isMe ? " is-me" : ""}">
            <div class="name">${_escapeHtml(String(p?.nick || "Guest"))}${isMe ? " *" : ""}</div>
            <span class="pill${ready ? " is-ready" : ""}">${ready ? "READY" : "WAIT"}</span>
            ${isHostRow ? `<span class="pill is-host">HOST</span>` : `<span class="pill">${connected ? "ON" : "OFF"}</span>`}
          </div>`;
        }).join("") : `<div class="b3d-mini"></div>`;
        layer.innerHTML = `
          <div class="b3d-grid">
            <div class="b3d-panel">
              <h4></h4>
              <div class="b3d-mini">Room <code>${_escapeHtml(roomId)}</code>  ${players.filter((p)=>!!p.connected).length}/${Math.max(1, Number(st.room?.max || 4))}</div>
              <div class="b3d-mini" style="margin-top:4px;">${_escapeHtml(dbgLine)}</div>
              <div class="b3d-round-track"><i style="width:${_rtBattle3dRoundProgressPct()}%"></i></div>
              <div class="b3d-mini" style="margin-top:8px;">Ready</div>
              <div class="b3d-actions-row" style="margin-top:10px;">
                <button class="btn${_rtBattleMePlayer()?.ready ? "" : " primary"}" type="button" data-rt-battle-action="b3dToggleReady">${_rtBattleMePlayer()?.ready ? "Ready" : "Ready"}</button>
                <button class="btn primary" type="button" data-rt-battle-action="b3dStartGame"${!isHost ? " disabled" : ""}></button>
                <button class="textbtn" type="button" data-rt-battle-action="b3dClose"></button>
              </div>
              ${!isHost ? `<div class="b3d-mini" style="margin-top:8px;"></div>` : ``}
            </div>
            <div class="b3d-grid">
              <div class="b3d-panel">
                <h4></h4>
                <div class="b3d-player-list">${rowsHtml}</div>
              </div>
              <div class="b3d-panel">
                <h4> / </h4>
                <div class="b3d-mini">: ${_escapeHtml(currentPresetLabel)}</div>
                <div class="b3d-inline-grid" style="margin-top:8px;">
                  <div>
                    <div class="b3d-mini" style="margin-bottom:4px;"></div>
                    <select id="rt3dLobbyPresetSelect" class="b3d-select" ${isHost ? "" : "disabled"}>${pOpts}</select>
                  </div>
                  <div>
                    <div class="b3d-mini" style="margin-bottom:4px;"></div>
                    <select id="rt3dLobbyQuestionCountSelect" class="b3d-select" ${isHost ? "" : "disabled"}>${qOpts}</select>
                  </div>
                </div>
                <div class="b3d-mini" style="margin-top:8px;">${isHost ? "" : ""}</div>
              </div>
            </div>
          </div>`;
      }
      function _rtBattle3dCountdownText(){
        const st = _rtBattleState();
        const endsAt = Math.max(0, Number(st.game?.countdownEndsAtMs || _rtBattle3dPhase1State().countdownEndsAtMs || 0));
        if (!endsAt) return "";
        const ms = Math.max(0, endsAt - Date.now());
        const sec = Math.ceil(ms / 1000);
        return sec <= 0 ? "GO!" : String(sec);
      }
      function _rtBattle3dRenderCountdownLayer(){
        const st = _rtBattleState();
        const layer = document.getElementById("rt3dCountdownLayer");
        if (!(layer instanceof HTMLElement)) return;
        const show = String(st.phase || "") === "countdown";
        layer.classList.toggle("is-open", show);
        layer.setAttribute("aria-hidden", show ? "false" : "true");
        if (!show) return;
        const num = document.getElementById("rt3dCountdownNum");
        const sub = document.getElementById("rt3dCountdownSub");
        if (num) num.textContent = _rtBattle3dCountdownText();
        if (sub) sub.textContent = "";
      }
      function _rtBattle3dRenderQuizUi(){
        const b = _rtBattle3dPhase1State();
        const st = _rtBattleState();
        const card = document.getElementById("rt3dQuizCard");
        const promptEl = document.getElementById("rt3dQuizPrompt");
        const choicesEl = document.getElementById("rt3dQuizChoices");
        const errEl = document.getElementById("rt3dQuizError");
        if (!card || !promptEl || !choicesEl || !errEl) return;
        const q = _rtBattle3dQuestionData();
        const hasChoices = asArray(q.choices).length > 0;
        const me = _rtBattleMePlayer();
        const alreadyAnswered = !!me?.answeredCurrent || b.quizSubmittedRound === Math.max(0, Number(st.game?.round || 0));
        promptEl.textContent = q.prompt || "";
        errEl.textContent = String(b.quizError || "");
        let miniEl = card.querySelector(".mini-line");
        if (!miniEl){
          miniEl = document.createElement("div");
          miniEl.className = "mini-line";
          card.insertBefore(miniEl, promptEl);
        }
        miniEl.textContent = `Q ${Math.max(1, Number(q.round || 1))}/${_rtBattleResolvedTotalRounds(q.totalRounds || st.game?.totalRounds || 1)}${q.no ? `  No.${q.no}` : ""}`;
        let stateLine = card.querySelector(".state-line");
        if (!stateLine){
          stateLine = document.createElement("div");
          stateLine.className = "state-line";
          card.appendChild(stateLine);
        }
        stateLine.textContent = alreadyAnswered ? "" : (hasChoices ? "" : "");
        choicesEl.innerHTML = hasChoices ? asArray(q.choices).map((c, idx) =>
          `<button class="btn" type="button" data-rt-battle-action="b3dQuizChoice" data-b3d-choice="${idx}"${(alreadyAnswered || !b.quizOpen) ? " disabled" : ""}>${_escapeHtml(String(c))}</button>`
        ).join("") : `<div class="b3d-mini"></div>`;
        const shouldShow = !!b.quizOpen && String(st.phase || "") === "playing" && hasChoices;
        if (shouldShow){
          card.classList.add("is-open");
          card.setAttribute("aria-hidden", "false");
        } else {
          card.classList.remove("is-open");
          card.setAttribute("aria-hidden", "true");
        }
      }
      function _rtBattle3dUpdateStatusUi(){
        const st = _rtBattleState();
        const b = _rtBattle3dPhase1State();
        const players = asArray(st.players);
        const roomId = String(st.room?.roomId || st.roomId || "");
        const me = _rtBattleMePlayer();
        const roomPill = document.getElementById("rt3dRoomPill");
        const pingPill = document.getElementById("rt3dPingPill");
        const syncPill = document.getElementById("rt3dSyncPill");
        const sub = document.getElementById("rt3dSubLine");
        const hudPlayers = document.getElementById("rt3dHudPlayers");
        const hudMe = document.getElementById("rt3dHudMe");
        const hudStatus = document.getElementById("rt3dHudStatus");
        const bar = document.getElementById("rt3dStatusBar");
        if (roomPill) roomPill.textContent = `ROOM ${roomId || "------"}`;
        if (pingPill) pingPill.textContent = `PING ${Math.max(0, Math.round(Number(b.pingMs || 0)))}ms`;
        const staleMs = b.lastNetTs ? (Date.now() - b.lastNetTs) : 999999;
        if (syncPill) syncPill.textContent = staleMs < 2500 ? "SYNC OK" : "SYNC WEAK";
        const phase = String(st.phase || "lobby");
        const totalRounds = _rtBattleResolvedTotalRounds(st.game?.totalRounds || st.room?.settings?.questionCount || 1);
        const roundNo = phase === "result" ? totalRounds : Math.max(1, Number(st.game?.round || 0) + 1);
        const qEndsAt = Math.max(0, Number(st.game?.questionEndsAtMs || 0));
        const remainSec = (phase === "playing" && qEndsAt) ? Math.max(0, Math.ceil((qEndsAt - Date.now()) / 1000)) : 0;
        if (sub) sub.textContent = `${players.filter((p)=>!!p?.connected).length}/${Math.max(1, Number(st.room?.max || 4))}  ${_rtBattleIsHost() ? "HOST" : "GUEST"}  ${phase.toUpperCase()}`;
        if (hudPlayers) hudPlayers.textContent = `${players.filter((p)=>!!p?.connected).length} / ${Math.max(1, Number(st.room?.max || 4))}`;
        if (hudMe) hudMe.textContent = `${String(me?.nick || st.nickname || "You")} / ${Math.max(0, Number(me?.score || 0))}pt`;
        let statusTxt = "";
        if (phase === "lobby") statusTxt = `Ready ${players.filter((p)=>!!p?.ready && !!p?.connected).length}/${players.filter((p)=>!!p?.connected).length}`;
        else if (phase === "countdown") statusTxt = ` ${_rtBattle3dCountdownText()}`;
        else if (phase === "playing") statusTxt = `Q ${roundNo}/${totalRounds}  ${remainSec}s`;
        else if (phase === "result") statusTxt = ` ${totalRounds}`;
        if (b.effectEndsAtMs > Date.now()){
          const effRemain = Math.max(0, Math.ceil((b.effectEndsAtMs - Date.now()) / 1000));
          statusTxt += b.effectKind === "boost" ? `  BOOST ${effRemain}s` : `  SLOW ${effRemain}s`;
        }
        if (hudStatus) hudStatus.textContent = statusTxt;
        if (bar) bar.textContent = b.error ? b.error : (b.status || (st.connected ? "" : ""));
        const scorePanel = document.getElementById("rt3dScorePanel");
        if (scorePanel) scorePanel.style.display = (phase === "playing" || phase === "countdown" || phase === "result") ? "" : "none";
        _rtBattle3dRenderLobbyPanel();
        _rtBattle3dRenderCountdownLayer();
      }
      function _rtBattle3dRenderScoreboard(){
        const st = _rtBattleState();
        const box = document.getElementById("rt3dScorePanel");
        if (!box) return;
        const phase = String(st.phase || "lobby");
        if (phase !== "playing" && phase !== "countdown" && phase !== "result"){
          box.innerHTML = "";
          box.dataset.hash = "";
          return;
        }
        const players = asArray(st.players);
        const total = Math.max(1, Number(st.game?.questionIds?.length || st.game?.totalRounds || st.room?.settings?.questionCount || 20));
        if (!players.length){
          box.innerHTML = `<div class="mini"></div>`;
          box.dataset.hash = "empty";
          return;
        }
        const maxScore = Math.max(1, ...players.map((p)=>Math.max(0, Number(p?.score || 0))));
        const html = players.map((p)=>{
          const score = Math.max(0, Number(p?.score || 0));
          const width = Math.max(4, Math.round((score / maxScore) * 100));
          const you = Math.max(0, Number(p?.userId || 0)) === _rtBattleMyUserId();
          return `<div class="b3d-score-row${you ? " is-you" : ""}">
            <div class="b3d-score-name">${_escapeHtml(String(p?.nick || "Guest"))}${you ? " *" : ""}</div>
            <div class="b3d-score-track"><div class="b3d-score-fill" style="width:${width}%"></div></div>
            <div class="b3d-score-val">${score}pt / ${Math.max(0, Number(p?.answeredAtMsTotal || 0))}ms</div>
          </div>`;
        }).join("");
        if (box.dataset.hash !== html){
          box.dataset.hash = html;
          box.innerHTML = `<div class="b3d-mini" style="margin-bottom:6px;"></div>${html}`;
        }
      }
      function _rtBattle3dRenderResult(){
        const st = _rtBattleState();
        const b = _rtBattle3dPhase1State();
        const layer = document.getElementById("rt3dResultLayer");
        const sub = document.getElementById("rt3dResultSub");
        const list = document.getElementById("rt3dResultList");
        if (!layer || !sub || !list) return;
        const phase = String(st.phase || "lobby");
        const finalRows = (phase === "result")
          ? asArray(st.game?.finalLeaderboard)
          : [];
        const show = phase === "result" && finalRows.length > 0;
        b.resultOpen = !!show;
        if (!show){
          layer.classList.remove("is-open");
          layer.setAttribute("aria-hidden", "true");
          return;
        }
        layer.classList.add("is-open");
        layer.setAttribute("aria-hidden", "false");
        const myUid = _rtBattleMyUserId();
        const myRow = finalRows.find((r)=>Math.max(0, Number(r?.userId||0))===myUid) || null;
        const winner = finalRows[0] || null;
        const totalRounds = Math.max(1, Number(st.game?.questionIds?.length || st.game?.totalRounds || st.room?.settings?.questionCount || 20));
        let finals = layer.querySelector(".b3d-final-grid");
        if (!finals){
          finals = document.createElement("div");
          finals.className = "b3d-final-grid";
          const title = layer.querySelector(".b3d-result-title");
          title && title.insertAdjacentElement("afterend", finals);
        }
        finals.innerHTML = `
          <div class="b3d-stat"><div class="k"></div><div class="v">${_escapeHtml(String(winner?.nick || "-"))}</div></div>
          <div class="b3d-stat"><div class="k"></div><div class="v">${myRow ? `${Math.max(1, Number(finalRows.findIndex((r)=>Math.max(0, Number(r?.userId||0))===myUid)+1))}` : "-"}</div></div>
          <div class="b3d-stat"><div class="k"></div><div class="v">${totalRounds}</div></div>`;
        sub.textContent = winner ? `${winner.nick} ` : "";
        const rowsHtml = finalRows.map((r, idx)=>`<div class="b3d-result-row">
            <div>#${idx+1}</div>
            <div>${_escapeHtml(String(r?.nick || "Guest"))}</div>
            <div class="mini">${Math.max(0, Number(r?.score || 0))}pt / ${Math.max(0, Number(r?.answeredAtMsTotal || 0))}ms</div>
          </div>`).join("");
        if (list.dataset.hash !== rowsHtml){
          list.dataset.hash = rowsHtml;
          list.innerHTML = rowsHtml;
        }
        let roundLog = layer.querySelector("#rt3dRoundLog");
        if (!roundLog){
          roundLog = document.createElement("div");
          roundLog.id = "rt3dRoundLog";
          roundLog.className = "b3d-roundlog";
          const actions = layer.querySelector(".b3d-result-actions");
          actions && actions.insertAdjacentElement("beforebegin", roundLog);
        }
        const logs = [];
        const resultByRound = (st.room?.state?.game?.resultByRound && typeof st.room.state.game.resultByRound === "object") ? st.room.state.game.resultByRound : (st.game?.resultByRound || {});
        if (resultByRound && typeof resultByRound === "object"){
          for (const [rk, rv] of Object.entries(resultByRound)){
            const roundNo = Math.max(1, Number(rk) + 1);
            const myAns = asArray(rv?.answersSummary).find((a)=>Math.max(0, Number(a?.userId||0))===myUid) || null;
            logs.push({ roundNo, correctIndex: rv?.correctIndex, myAns });
          }
        } else if (st.game?.lastResult) {
          const rv = st.game.lastResult;
          logs.push({ roundNo: Math.max(1, Number(rv.round || 1)), correctIndex: rv.correctIndex, myAns: asArray(rv.answersSummary).find((a)=>Math.max(0, Number(a?.userId||0))===myUid)||null });
        }
        const logHtml = logs.sort((a,b)=>a.roundNo-b.roundNo).map((x)=>{
          const ok = !!x.myAns?.correct;
          const ansTxt = x.myAns ? (x.myAns.answered ? `: ${ok ? "" : ""}` : ": ") : ": -";
          return `<div class="b3d-roundlog-item ${ok ? "ok" : "ng"}"><div class="b3d-mini">Q${x.roundNo}</div><div>${_escapeHtml(ansTxt)}</div></div>`;
        }).join("");
        if (roundLog.dataset.hash !== logHtml){
          roundLog.dataset.hash = logHtml;
          roundLog.innerHTML = logHtml || `<div class="b3d-mini"></div>`;
        }
      }
      const __rtBattle3dSyncFromSnapshotV4Base = _rtBattle3dSyncFromSnapshot;
      _rtBattle3dSyncFromSnapshot = function(snapshotLike){
        __rtBattle3dSyncFromSnapshotV4Base(snapshotLike);
        const st = _rtBattleState();
        const b = _rtBattle3dPhase1State();
        b.roomPhase = String(st.phase || "lobby");
        b.countdownStartAtMs = Math.max(0, Number(st.game?.countdownStartAtMs || 0));
        b.countdownEndsAtMs = Math.max(0, Number(st.game?.countdownEndsAtMs || 0));
        const curRound = Math.max(0, Number(st.game?.round || 0));
        if (b.roomPhase === "playing"){
          if (b.quizRoundIndex !== curRound){
            b.quizRoundIndex = curRound;
            b.quizSubmittedRound = -1;
            b.quizError = "";
            b.quizAnswered = false;
            b.quizOpen = false;
            b.gateOpen = false;
            b.localFinished = false;
            b.resultOpen = false;
          }
          const me = _rtBattleMePlayer();
          if (!!me?.answeredCurrent) {
            b.quizSubmittedRound = curRound;
          }
        }
        if (b.roomPhase !== "playing"){
          b.quizOpen = false;
          b.quizAnswered = false;
          b.quizError = "";
        }
        if (b.roomPhase !== "result"){
          b.resultOpen = false;
        }
        _rtBattle3dRenderQuizUi();
        _rtBattle3dRenderScoreboard();
        _rtBattle3dRenderResult();
        _rtBattle3dUpdateStatusUi();
      };
      function _rtBattle3dOpenQuiz(){
        const st = _rtBattleState();
        const b = _rtBattle3dPhase1State();
        if (String(st.phase || "") !== "playing") return;
        const q = _rtBattle3dQuestionData();
        if (!q || !asArray(q.choices).length) return;
        const curRound = Math.max(0, Number(st.game?.round || 0));
        if (b.quizSubmittedRound === curRound) return;
        if (b.quizOpen) return;
        b.quizOpen = true;
        b.quizAnswered = false;
        b.quizError = "";
        b.status = "";
        _rtBattle3dRenderQuizUi();
        _rtBattle3dUpdateStatusUi();
      }
      function _rtBattle3dSubmitQuizChoice(idx){
        const st = _rtBattleState();
        const b = _rtBattle3dPhase1State();
        const q = _rtBattle3dQuestionData();
        if (!b.quizOpen) return;
        const choice = Math.trunc(Number(idx));
        if (!(choice >= 0 && choice < asArray(q.choices).length)) return;
        if (String(st.phase || "") !== "playing"){
          b.quizError = "";
          _rtBattle3dRenderQuizUi();
          return;
        }
        const me = _rtBattleMePlayer();
        if (!!me?.answeredCurrent){
          b.quizSubmittedRound = Math.max(0, Number(st.game?.round || 0));
          b.quizOpen = false;
          b.quizAnswered = true;
          b.quizError = "";
          _rtBattle3dRenderQuizUi();
          return;
        }
        const ok = _rtBattleSafeSend({ type: "answer:submit", choiceIndex: choice });
        if (!ok){
          b.quizError = "";
          _rtBattle3dRenderQuizUi();
          return;
        }
        b.quizSubmittedRound = Math.max(0, Number(st.game?.round || 0));
        b.quizAnswered = true;
        b.quizOpen = false;
        b.quizError = "";
        b.status = "";
        _rtBattle3dRenderQuizUi();
        _rtBattle3dUpdateStatusUi();
      }
      function _rtBattle3dMaybeTriggerWorldEvents(){
        const st = _rtBattleState();
        const b = _rtBattle3dPhase1State();
        const p = b.local;
        const phase = String(st.phase || "lobby");
        if (phase === "playing"){
          if (!b.quizOpen){
            const inGateTrigger = Math.abs(p.x) < 2.1 && p.z < -2.3 && p.z > -3.8;
            if (inGateTrigger) _rtBattle3dOpenQuiz();
          }
          return;
        }
        // fallback demo behavior when room quiz isn't running
        if (!b.gateOpen && !b.quizOpen && !b.localFinished){
          const inGateTrigger = Math.abs(p.x) < 2.1 && p.z < -2.3 && p.z > -3.8;
          if (inGateTrigger) _rtBattle3dOpenQuiz();
        }
        if (b.gateOpen && !b.localFinished && phase !== "result"){
          const inGoal = Math.abs(p.x) < 2.0 && p.z < -13.8;
          if (inGoal){
            b.localFinished = true;
            b.status = "";
            _rtBattleSafeSend({ type: "game3d:goal" });
            _rtBattle3dPushToast("ok", "");
          }
        }
      }
      const __rtBattle3dStepPhysicsV4Base = _rtBattle3dStepPhysics;
      _rtBattle3dStepPhysics = function(dt){
        const b = _rtBattle3dPhase1State();
        const st = _rtBattleState();
        const p = b.local;
        const phase = String(st.phase || "lobby");
        if (b.quizOpen || b.resultOpen || phase === "countdown"){
          p.vx *= 0.85; p.vz *= 0.85;
          return;
        }
        if (phase !== "playing"){
          // lobby/result: allow camera scene idle only (very slow drift stop)
          p.vx *= 0.82; p.vz *= 0.82;
          if (Math.abs(p.vx) < 0.01) p.vx = 0;
          if (Math.abs(p.vz) < 0.01) p.vz = 0;
          return;
        }
        const now = Date.now();
        let mult = 1;
        if (b.effectEndsAtMs > now) {
          if (b.effectKind === "boost") mult = 1.45;
          else if (b.effectKind === "debuff") mult = 0.55;
        }
        // copy of v4 physics with configurable speed multiplier
        let ix = 0, iz = 0;
        if (b.input.left) ix -= 1;
        if (b.input.right) ix += 1;
        if (b.input.fwd) iz -= 1;
        if (b.input.back) iz += 1;
        const len = Math.hypot(ix, iz) || 1;
        ix /= len; iz /= len;
        const speed = 4.6 * mult;
        p.vx = ix * speed;
        p.vz = iz * speed;
        if ((b.jumpQueued || b.input.jump) && p.grounded){
          p.vy = 7.2;
          p.grounded = false;
          b.jumpQueued = false;
        }
        if (Math.abs(ix) > 0.01 || Math.abs(iz) > 0.01){
          p.rotY = Math.atan2(ix, iz);
          p.action = (mult > 1.1 ? "boost" : (mult < 0.9 ? "slow" : "run"));
        } else {
          p.action = "idle";
        }
        p.vy += -18 * dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.z += p.vz * dt;
        if (p.y <= 0.9){
          p.y = 0.9; p.vy = 0; p.grounded = true;
        }
        _rtBattle3dClampWorld();
      };
      const __rtBattle3dBindGlobalHandlersV4Base = _rtBattle3dBindGlobalHandlers;
      _rtBattle3dBindGlobalHandlers = function(){
        __rtBattle3dBindGlobalHandlersV4Base();
        const b = _rtBattle3dPhase1State();
        if (b._phase1Bound) return;
        b._phase1Bound = true;
        document.addEventListener("change", (e) => {
          const target = e.target;
          if (!(target instanceof HTMLElement)) return;
          if (!target.closest("#rt3dOverlay")) return;
          if (target.id === "rt3dLobbyPresetSelect"){
            try {
              const raw = String(target.value || "");
              const ref = _rtBattle3dPresetRefFromValue(raw);
              if (!ref) { try{ uiToast(""); }catch(_){} return; }
              console.log("[preset:set]", ref);
              const st = _rtBattleState();
              st.room = st.room || {};
              st.room.presetRef = ref;
              st.room.presetName = _rtBattlePresetDisplayName(ref);
              _rtBattleSafeSend({ type: "preset:set", presetRef: ref, presetName: st.room.presetName });
              try{ uiToast(""); }catch(_){}
              _rtBattle3dRenderLobbyPanel();
              _rtBattle3dUpdateStatusUi();
            } catch (err) {
              try{ uiToast(String(err?.message || "")); }catch(_){}
            }
          }
          if (target.id === "rt3dLobbyQuestionCountSelect"){
            const raw = String(target.value || "10");
            const qv = (raw === "ALL") ? "ALL" : Math.max(1, Number(raw || 10));
            const st = _rtBattleState();
            st.room = st.room || {};
            st.room.settings = st.room.settings || {};
            st.room.settings.questionCount = qv;
            _rtBattleSafeSend({ type: "settings:set", questionCount: qv });
            _rtBattle3dRenderLobbyPanel();
            _rtBattle3dRenderScoreboard();
          }
        }, true);
      };
      const __rtBattle3dOpenV4Base = _rtBattle3dOpen;
      _rtBattle3dOpen = async function(){
        _rtBattle3dEnsurePhase1Dom();
        await __rtBattle3dOpenV4Base.apply(this, arguments);
        _rtBattle3dEnsurePhase1Dom();
        _rtBattle3dRenderLobbyPanel();
        _rtBattle3dRenderCountdownLayer();
        _rtBattle3dRenderQuizUi();
        _rtBattle3dRenderScoreboard();
        _rtBattle3dRenderResult();
        _rtBattle3dUpdateStatusUi();
      };
      const __rtBattle3dCloseV4Base = _rtBattle3dClose;
      _rtBattle3dClose = function(){
        const b = _rtBattle3dPhase1State();
        b.quizOpen = false;
        b.quizAnswered = false;
        b.quizSubmittedRound = -1;
        b.effectKind = "";
        b.effectEndsAtMs = 0;
        return __rtBattle3dCloseV4Base.apply(this, arguments);
      };
      const __rtBattle3dHandleActionV4Base = _rtBattle3dHandleAction;
      _rtBattle3dHandleAction = function(act, el){
        const st = _rtBattleState();
        const b = _rtBattle3dPhase1State();
        if (act === "b3dToggleReady"){
          const me = _rtBattleMePlayer();
          const nextReady = !me?.ready;
          _rtBattleSafeSend({ type: "ready:set", ready: !!nextReady });
          return true;
        }
        if (act === "b3dStartGame"){
          const ok = _rtBattleSafeSend({ type: "game:start" });
          if (!ok) { try{ uiToast(""); }catch(_){} }
          return true;
        }
        if (act === "b3dReset"){
          if (String(st.phase || "") === "result"){
            if (_rtBattleIsHost()) _rtBattleSafeSend({ type: "game:rematch" });
            else try{ uiToast(""); }catch(_){}
            return true;
          }
        }
        return __rtBattle3dHandleActionV4Base.apply(this, arguments);
      };
      const __rtBattleHandleMessageV5Base = _rtBattleHandleMessage;
      _rtBattleHandleMessage = function(msg){
        __rtBattleHandleMessageV5Base.apply(this, arguments);
        const type = String(msg?.type || "").toLowerCase();
        const st = _rtBattleState();
        const b = _rtBattle3dPhase1State();
        if (type === "countdown:start"){
          b.countdownStartAtMs = Math.max(0, Number(msg?.startAtMs || 0));
          b.countdownEndsAtMs = Math.max(0, Number(msg?.endsAtMs || 0));
          b.quizOpen = false;
          b.quizAnswered = false;
          b.quizError = "";
          b.gateOpen = false;
          if (_rtBattle3dIsOpen()){
            _rtBattle3dRenderCountdownLayer();
            _rtBattle3dUpdateStatusUi();
          }
          return;
        }
        if (type === "game:question"){
          b.quizRoundIndex = Math.max(0, Number((msg?.round || 1) - 1));
          b.quizSubmittedRound = -1;
          b.quizOpen = false;
          b.quizAnswered = false;
          b.quizError = "";
          b.gateOpen = false;
          b.localFinished = false;
          b.resultOpen = false;
          b.effectKind = "";
          b.effectEndsAtMs = 0;
          if (_rtBattle3dIsOpen()){
            _rtBattle3dRenderQuizUi();
            _rtBattle3dUpdateStatusUi();
          }
          return;
        }
        if (type === "game:result"){
          const roundNo = Math.max(1, Number(msg?.round || 1));
          const hash = JSON.stringify([roundNo, msg?.correctIndex, asArray(msg?.answersSummary).map((a)=>[a?.userId,a?.choiceIndex,a?.correct,a?.answeredAtMs])]);
          if (hash === b.lastRoundResultHash) return;
          b.lastRoundResultHash = hash;
          const myUid = _rtBattleMyUserId();
          const myAns = asArray(msg?.answersSummary).find((a)=>Math.max(0, Number(a?.userId||0))===myUid) || null;
          if (myAns && typeof myAns.correct === "boolean"){
            if (myAns.correct){
              b.effectKind = "boost";
              b.effectEndsAtMs = Date.now() + 3000;
              b.gateOpen = true;
              try{ if (typeof playSfx === "function") playSfx("ok"); }catch(_){}
              try{ if (navigator?.vibrate) navigator.vibrate(20); }catch(_){}
            } else {
              b.effectKind = "debuff";
              b.effectEndsAtMs = Date.now() + 2000;
              b.gateOpen = true;
              try{ if (typeof playSfx === "function") playSfx("ng"); }catch(_){}
              try{ if (navigator?.vibrate) navigator.vibrate([20,30,20]); }catch(_){}
            }
          }
          const fastestKey = String(msg?.fastestCorrectUserKey || "");
          const fastestMine = fastestKey && String(myUid) === fastestKey;
          const toastTxt = myAns?.correct
            ? (fastestMine ? " +3" : "")
            : "";
          _rtBattle3dPushToast(myAns?.correct ? "ok" : "ng", toastTxt);
          if (_rtBattle3dIsOpen()){
            _rtBattle3dRenderQuizUi();
            _rtBattle3dRenderScoreboard();
            _rtBattle3dUpdateStatusUi();
          }
          return;
        }
        if (type === "game:final"){
          b.resultOpen = true;
          b.quizOpen = false;
          b.quizAnswered = true;
          b.quizError = "";
          if (_rtBattle3dIsOpen()){
            _rtBattle3dRenderResult();
            _rtBattle3dRenderScoreboard();
            _rtBattle3dUpdateStatusUi();
          }
          return;
        }
      };

      // ROOM_DO_UI_V6_3D_PHASE2: full game-like scene polish, joystick, gimmicks, state machine UI
      function _rtBattle3dPhase2State(){
        const b = _rtBattle3dPhase1State();
        if (!b.p2 || typeof b.p2 !== "object") b.p2 = {};
        const p2 = b.p2;
        if (typeof p2.scene !== "string") p2.scene = "BOOT"; // BOOT/TITLE/LOBBY/MATCH_INTRO/PLAYING/ROUND_CARD/RESULTS/POST_MATCH
        if (typeof p2.chatOpen !== "boolean") p2.chatOpen = false;
        if (typeof p2.goText !== "string") p2.goText = "";
        if (typeof p2.goHideAt !== "number") p2.goHideAt = 0;
        if (typeof p2.roundCardHideAt !== "number") p2.roundCardHideAt = 0;
        if (typeof p2.lastQuestionQid !== "string") p2.lastQuestionQid = "";
        if (typeof p2.lastFinalHash !== "string") p2.lastFinalHash = "";
        if (typeof p2.lastRoundResultToastHash !== "string") p2.lastRoundResultToastHash = "";
        if (typeof p2.camYaw !== "number") p2.camYaw = 0;
        if (typeof p2.camPitch !== "number") p2.camPitch = 0.35;
        if (typeof p2.dragCam !== "boolean") p2.dragCam = false;
        if (typeof p2.dragPointerId !== "number") p2.dragPointerId = -1;
        if (!p2.dragStart || typeof p2.dragStart !== "object") p2.dragStart = { x:0, y:0, yaw:0, pitch:0 };
        if (!p2.joy || typeof p2.joy !== "object") p2.joy = { active:false, pointerId:-1, x:0, y:0, nx:0, ny:0 };
        if (!p2.gimmicks || typeof p2.gimmicks !== "object") p2.gimmicks = {};
        if (!Array.isArray(p2.answerFeed)) p2.answerFeed = [];
        if (typeof p2.answerFeedHash !== "string") p2.answerFeedHash = "";
        if (typeof p2.lastChatPatchedLen !== "number") p2.lastChatPatchedLen = 0;
        return b;
      }
      function _rtBattle3dPhase2SceneName(){
        const st = _rtBattleState();
        const b = _rtBattle3dPhase2State();
        if (!b.open) return "BOOT";
        if (b.loading) return "BOOT";
        if (!st.connected) return "TITLE";
        const phase = String(st.phase || "lobby");
        if (phase === "lobby") return "LOBBY";
        if (phase === "countdown") return "MATCH_INTRO";
        if (phase === "playing") return b.quizOpen ? "ROUND_CARD" : "PLAYING";
        if (phase === "result") return "RESULTS";
        return "TITLE";
      }
      function _rtBattle3dPhase2EnsureStyles(){
        if (document.getElementById("rt3dPhase2Styles")) return;
        const s = document.createElement("style");
        s.id = "rt3dPhase2Styles";
        s.textContent = `
          #rt3dOverlay .b3d-shell{background:radial-gradient(1200px 600px at 50% -10%, rgba(31,42,68,.06), transparent 60%), var(--bg,#f7f7f8);}
          #rt3dOverlay .b3d-head{background:rgba(255,255,255,.82); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); border-bottom-color:rgba(17,17,17,.08);}
          #rt3dOverlay .b3d-head .b3d-title{font-size:14px; letter-spacing:.02em;}
          #rt3dOverlay .b3d-head-center{display:flex; align-items:center; justify-content:center; gap:6px; flex-wrap:wrap;}
          #rt3dOverlay .b3d-pill{background:rgba(255,255,255,.76); border-color:rgba(17,17,17,.08); box-shadow:0 1px 0 rgba(17,17,17,.03);}
          #rt3dOverlay .b3d-hud{top:10px; left:10px; right:10px;}
          #rt3dOverlay .b3d-hud-card{background:rgba(255,255,255,.78); border-color:rgba(17,17,17,.08); box-shadow:0 6px 18px rgba(0,0,0,.06);}
          #rt3dOverlay .b3d-hud-card.is-timer .v{font-size:28px;}
          #rt3dOverlay .b3d-hud-card.is-compact .t{font-size:10px;}
          #rt3dOverlay .b3d-hud-card.is-compact .v{font-size:12px;}
          #rt3dOverlay .b3d-score-panel{top:58px; background:rgba(255,255,255,.78); border-color:rgba(17,17,17,.08); box-shadow:0 6px 18px rgba(0,0,0,.06);}
          #rt3dOverlay .b3d-score-fill{background:linear-gradient(90deg, rgba(31,42,68,.88), rgba(76,130,210,.66));}
          #rt3dOverlay .b3d-score-row.is-me .b3d-score-fill{background:linear-gradient(90deg, rgba(31,42,68,.92), rgba(64,190,106,.72));}
          #rt3dOverlay .b3d-quiz{inset:auto 12px calc(124px + env(safe-area-inset-bottom,0px)) 12px; border-radius:20px; background:rgba(255,255,255,.97); border-color:rgba(17,17,17,.08); box-shadow:0 18px 36px rgba(0,0,0,.14);}
          #rt3dOverlay .b3d-quiz h4{font-size:13px; color:var(--muted,#666); letter-spacing:.05em;}
          #rt3dOverlay .b3d-quiz .q{font-size:20px; line-height:1.4; margin-bottom:10px;}
          #rt3dOverlay .b3d-quiz .choices{gap:10px;}
          #rt3dOverlay .b3d-quiz .choices .btn{min-height:50px; border-radius:14px; justify-content:flex-start; text-align:left; box-shadow:0 4px 10px rgba(0,0,0,.04);}
          #rt3dOverlay .b3d-quiz .choices .btn:active{transform:scale(.98);}
          #rt3dOverlay .b3d-quiz-timer{height:6px; border-radius:999px; background:var(--panel2,#f2f4f7); border:1px solid rgba(17,17,17,.06); overflow:hidden; margin-top:10px;}
          #rt3dOverlay .b3d-quiz-timer i{display:block; height:100%; width:100%; background:rgba(31,42,68,.22); transform-origin:left center;}
          #rt3dOverlay .b3d-round-card{position:absolute; inset:88px 12px auto 12px; z-index:8; display:none; justify-content:center; pointer-events:none;}
          #rt3dOverlay .b3d-round-card.is-open{display:flex;}
          #rt3dOverlay .b3d-round-card-inner{pointer-events:auto; width:min(720px, 100%); border:1px solid rgba(17,17,17,.08); background:rgba(255,255,255,.93); border-radius:18px; box-shadow:0 14px 30px rgba(0,0,0,.10); padding:12px 14px; animation:b3dRoundCardIn .22s cubic-bezier(.22,1,.36,1);}
          #rt3dOverlay .b3d-round-card .top{display:flex; justify-content:space-between; gap:8px; align-items:center; margin-bottom:6px;}
          #rt3dOverlay .b3d-round-card .title{font-weight:800; font-size:14px;}
          #rt3dOverlay .b3d-round-card .meta{font-size:12px; color:var(--muted,#666);}
          #rt3dOverlay .b3d-round-card .prompt{font-size:16px; font-weight:700; line-height:1.4; margin-top:4px;}
          #rt3dOverlay .b3d-go-pop{position:absolute; inset:0; z-index:9; display:none; place-items:center; pointer-events:none;}
          #rt3dOverlay .b3d-go-pop.is-open{display:grid;}
          #rt3dOverlay .b3d-go-pop span{font-weight:900; font-size:clamp(40px, 14vw, 96px); line-height:1; color:#1f2a44; background:rgba(255,255,255,.88); border:1px solid rgba(17,17,17,.08); border-radius:18px; padding:10px 18px; box-shadow:0 18px 36px rgba(0,0,0,.12); animation:b3dGoPop .28s cubic-bezier(.22,1,.36,1);}
          #rt3dOverlay .b3d-chatdock{position:absolute; right:12px; bottom:calc(env(safe-area-inset-bottom,0px) + 92px); z-index:6; width:min(360px, calc(100vw - 24px)); border:1px solid rgba(17,17,17,.08); background:rgba(255,255,255,.88); border-radius:16px; box-shadow:0 12px 24px rgba(0,0,0,.10); overflow:hidden; display:grid; grid-template-rows:auto 1fr auto;}
          #rt3dOverlay .b3d-chatdock.is-collapsed{grid-template-rows:auto; width:auto; min-width:120px;}
          #rt3dOverlay .b3d-chatdock-head{display:flex; align-items:center; justify-content:space-between; gap:8px; padding:8px 10px; border-bottom:1px solid rgba(17,17,17,.08); background:rgba(255,255,255,.7);}
          #rt3dOverlay .b3d-chatdock.is-collapsed .b3d-chatdock-head{border-bottom:0;}
          #rt3dOverlay .b3d-chatdock-title{font-size:12px; font-weight:700;}
          #rt3dOverlay .b3d-chatdock-body{max-height:180px; overflow:auto; padding:8px; display:grid; gap:6px; background:rgba(255,255,255,.5);}
          #rt3dOverlay .b3d-chatdock.is-collapsed .b3d-chatdock-body,
          #rt3dOverlay .b3d-chatdock.is-collapsed .b3d-chatdock-foot{display:none;}
          #rt3dOverlay .b3d-chat-item{padding:6px 8px; border-radius:10px; border:1px solid rgba(17,17,17,.06); background:rgba(255,255,255,.8);}
          #rt3dOverlay .b3d-chat-item .m{font-size:11px; color:var(--muted,#666); margin-bottom:2px;}
          #rt3dOverlay .b3d-chat-item .t{font-size:12px; line-height:1.35; white-space:pre-wrap; word-break:break-word;}
          #rt3dOverlay .b3d-chatdock-foot{padding:8px; border-top:1px solid rgba(17,17,17,.08); display:flex; gap:8px; align-items:center; background:rgba(255,255,255,.66);}
          #rt3dOverlay .b3d-chatdock-foot input{flex:1; min-width:0; min-height:40px; border-radius:12px; border:1px solid rgba(17,17,17,.10); background:rgba(255,255,255,.96); padding:0 12px; font:inherit;}
          #rt3dOverlay .b3d-chatdock-foot .btn{min-height:40px;}
          #rt3dOverlay .b3d-joystick{position:absolute; left:12px; bottom:calc(env(safe-area-inset-bottom,0px) + 90px); z-index:6; width:112px; height:112px; border-radius:999px; border:1px solid rgba(17,17,17,.08); background:rgba(255,255,255,.72); box-shadow:0 12px 22px rgba(0,0,0,.08); touch-action:none; display:grid; place-items:center;}
          #rt3dOverlay .b3d-joystick-base{width:84px; height:84px; border-radius:999px; border:1px dashed rgba(31,42,68,.18); background:rgba(255,255,255,.32); position:relative;}
          #rt3dOverlay .b3d-joystick-knob{position:absolute; left:50%; top:50%; width:40px; height:40px; margin:-20px 0 0 -20px; border-radius:999px; border:1px solid rgba(17,17,17,.10); background:rgba(255,255,255,.95); box-shadow:0 6px 12px rgba(0,0,0,.08); transform:translate(0,0);}
          #rt3dOverlay .b3d-jump2{position:absolute; right:12px; bottom:calc(env(safe-area-inset-bottom,0px) + 92px); z-index:6; width:74px; height:74px; border-radius:20px;}
          #rt3dOverlay .b3d-camreset{position:absolute; right:12px; top:120px; z-index:6; width:42px; height:42px; border-radius:14px; border:1px solid rgba(17,17,17,.08); background:rgba(255,255,255,.84); display:grid; place-items:center; box-shadow:0 10px 18px rgba(0,0,0,.08);}
          #rt3dOverlay .b3d-chat-toggle{position:absolute; right:12px; bottom:calc(env(safe-area-inset-bottom,0px) + 46px); z-index:6; min-height:36px; padding:0 12px; border-radius:999px; border:1px solid rgba(17,17,17,.08); background:rgba(255,255,255,.88); display:inline-flex; align-items:center; gap:6px; box-shadow:0 10px 18px rgba(0,0,0,.08);}
          #rt3dOverlay .b3d-gfx-badge{position:absolute; left:12px; top:120px; z-index:6; border-radius:12px; border:1px solid rgba(17,17,17,.08); background:rgba(255,255,255,.84); padding:7px 10px; font-size:11px; color:var(--muted,#666);}
          #rt3dOverlay .b3d-gimmick-hit{position:absolute; inset:0; z-index:7; pointer-events:none; opacity:0; background:radial-gradient(circle at center, rgba(255,255,255,.0) 20%, rgba(235,87,87,.10) 100%);}
          #rt3dOverlay .b3d-gimmick-hit.is-show{animation:b3dHitFlash .22s ease-out;}
          @keyframes b3dGoPop{from{opacity:0; transform:scale(.88)}to{opacity:1; transform:scale(1)}}
          @keyframes b3dRoundCardIn{from{opacity:0; transform:translateY(10px) scale(.98)}to{opacity:1; transform:none}}
          @keyframes b3dHitFlash{0%{opacity:0}15%{opacity:1}100%{opacity:0}}
          @media (max-width: 768px){
            #rt3dOverlay .b3d-chatdock{width:min(92vw, 360px); right:8px; bottom:calc(env(safe-area-inset-bottom,0px) + 84px);}
            #rt3dOverlay .b3d-joystick{left:8px; width:104px; height:104px; bottom:calc(env(safe-area-inset-bottom,0px) + 82px);}
            #rt3dOverlay .b3d-joystick-base{width:78px; height:78px;}
            #rt3dOverlay .b3d-jump2{right:8px; bottom:calc(env(safe-area-inset-bottom,0px) + 84px);}
            #rt3dOverlay .b3d-camreset{top:112px; right:8px;}
            #rt3dOverlay .b3d-gfx-badge{left:8px; top:112px;}
          }
        `;
        document.head.appendChild(s);
      }
      function _rtBattle3dPhase2EnsureDom(){
        const root = _rtBattle3dEnsureRoot();
        _rtBattle3dPhase2EnsureStyles();
        const main = root.querySelector(".b3d-main");
        if (!(main instanceof HTMLElement)) return root;
        if (!document.getElementById("rt3dRoundCard")){
          main.insertAdjacentHTML("beforeend", `
            <div class="b3d-round-card" id="rt3dRoundCard" aria-hidden="true">
              <div class="b3d-round-card-inner">
                <div class="top"><div class="title" id="rt3dRoundCardTitle">ROUND</div><div class="meta" id="rt3dRoundCardMeta"></div></div>
                <div class="prompt" id="rt3dRoundCardPrompt"></div>
              </div>
            </div>
            <div class="b3d-go-pop" id="rt3dGoPop" aria-hidden="true"><span id="rt3dGoPopText">GO!</span></div>
            <button class="b3d-camreset" type="button" data-rt-battle-action="b3dCamReset" aria-label=""><span class="ms">center_focus_strong</span></button>
            <div class="b3d-gfx-badge" id="rt3dGfxBadge">3D Sync</div>
            <div class="b3d-gimmick-hit" id="rt3dHitFx"></div>
            <div class="b3d-chatdock is-collapsed" id="rt3dChatDock">
              <div class="b3d-chatdock-head">
                <div class="b3d-chatdock-title">Room Chat</div>
                <button class="btn ov-iconbtn" type="button" data-rt-battle-action="b3dChatToggle" aria-label=""><span class="ms">chat</span></button>
              </div>
              <div class="b3d-chatdock-body" id="rt3dChatList"></div>
              <div class="b3d-chatdock-foot">
                <input id="rt3dChatInput" type="text" maxlength="400" placeholder="">
                <button class="btn" type="button" data-rt-battle-action="b3dChatSend"></button>
              </div>
            </div>
            <button class="b3d-chat-toggle" type="button" data-rt-battle-action="b3dChatToggle" id="rt3dChatToggleMini"><span class="ms">chat</span><span>Chat</span></button>
            <div class="b3d-joystick" id="rt3dJoyPad" aria-label="">
              <div class="b3d-joystick-base"><div class="b3d-joystick-knob" id="rt3dJoyKnob"></div></div>
            </div>
            <button class="b3d-mbtn b3d-jump2" type="button" data-rt-battle-action="b3dHoldJump">JUMP</button>`);
        }
        // reduce old dpad visual clutter but keep fallback controls in DOM
        const dpad = root.querySelector("#rt3dDpad");
        if (dpad instanceof HTMLElement) dpad.style.display = "none";
        const oldActions = root.querySelector(".b3d-actions");
        if (oldActions instanceof HTMLElement) oldActions.style.display = "none";
        return root;
      }
      function _rtBattle3dPhase2SceneApply(){
        const b = _rtBattle3dPhase2State();
        const scene = _rtBattle3dPhase2SceneName();
        b.p2.scene = scene;
        const root = document.getElementById("rt3dOverlay");
        if (root) root.setAttribute("data-b3d-scene", scene);
        const badge = document.getElementById("rt3dGfxBadge");
        if (badge) badge.textContent = `3D  ${scene}`;
      }
      function _rtBattle3dPhase2CountdownTick(){
        const layer = document.getElementById("rt3dCountdownLayer");
        const num = document.getElementById("rt3dCountdownNum");
        const sub = document.getElementById("rt3dCountdownSub");
        if (!(layer instanceof HTMLElement) || !(num instanceof HTMLElement) || !(sub instanceof HTMLElement)) return;
        const st = _rtBattleState();
        const show = String(st.phase || "") === "countdown";
        layer.classList.toggle("is-open", show);
        if (!show) { layer.setAttribute("aria-hidden","true"); return; }
        layer.setAttribute("aria-hidden","false");
        const endsAt = Math.max(0, Number(st.game?.countdownEndsAtMs || 0));
        const remain = Math.max(0, endsAt - Date.now());
        const sec = Math.ceil(remain / 1000);
        const label = sec <= 0 ? "GO!" : String(sec);
        if (num.textContent !== label) num.textContent = label;
        sub.textContent = "";
      }
      function _rtBattle3dPhase2ShowGo(text = "GO!"){
        const b = _rtBattle3dPhase2State();
        b.p2.goText = String(text || "GO!");
        b.p2.goHideAt = Date.now() + 900;
        const pop = document.getElementById("rt3dGoPop");
        const txt = document.getElementById("rt3dGoPopText");
        if (txt) txt.textContent = b.p2.goText;
        if (pop){
          pop.classList.add("is-open");
          pop.setAttribute("aria-hidden","false");
        }
      }
      function _rtBattle3dPhase2UpdateTransientOverlays(){
        const b = _rtBattle3dPhase2State();
        const now = Date.now();
        const pop = document.getElementById("rt3dGoPop");
        if (pop && b.p2.goHideAt && now > b.p2.goHideAt){
          b.p2.goHideAt = 0;
          pop.classList.remove("is-open");
          pop.setAttribute("aria-hidden","true");
        }
        const rc = document.getElementById("rt3dRoundCard");
        if (rc && b.p2.roundCardHideAt && now > b.p2.roundCardHideAt){
          b.p2.roundCardHideAt = 0;
          rc.classList.remove("is-open");
          rc.setAttribute("aria-hidden","true");
        }
      }
      function _rtBattle3dPhase2ShowRoundCard(){
        const st = _rtBattleState();
        const b = _rtBattle3dPhase2State();
        const q = _rtBattle3dQuestionData();
        if (!q || !q.id) return;
        const rc = document.getElementById("rt3dRoundCard");
        const title = document.getElementById("rt3dRoundCardTitle");
        const meta = document.getElementById("rt3dRoundCardMeta");
        const prompt = document.getElementById("rt3dRoundCardPrompt");
        if (!(rc instanceof HTMLElement) || !(title instanceof HTMLElement) || !(meta instanceof HTMLElement) || !(prompt instanceof HTMLElement)) return;
        title.textContent = `ROUND ${Math.max(1, Number(q.round || 1))}/${_rtBattleResolvedTotalRounds(q.totalRounds || st.game?.totalRounds || 1)}`;
        meta.textContent = q.no ? `No.${q.no}` : "Quiz Gate";
        prompt.textContent = String(q.prompt || "");
        rc.classList.add("is-open");
        rc.setAttribute("aria-hidden","false");
        b.p2.roundCardHideAt = Date.now() + 1200;
      }
      function _rtBattle3dPhase2PatchQuizTimer(){
        const st = _rtBattleState();
        const card = document.getElementById("rt3dQuizCard");
        if (!(card instanceof HTMLElement)) return;
        let timerWrap = card.querySelector(".b3d-quiz-timer");
        if (!timerWrap){
          timerWrap = document.createElement("div");
          timerWrap.className = "b3d-quiz-timer";
          timerWrap.innerHTML = "<i></i>";
          card.appendChild(timerWrap);
        }
        const bar = timerWrap.querySelector("i");
        if (!(bar instanceof HTMLElement)) return;
        const endsAt = Math.max(0, Number(st.game?.questionEndsAtMs || 0));
        const phase = String(st.phase || "");
        if (phase !== "playing" || !endsAt){
          bar.style.transform = "scaleX(1)";
          return;
        }
        const startedAt = Math.max(0, Number(st.game?.questionStartedAtMs || (endsAt - 10000)));
        const total = Math.max(1, endsAt - startedAt);
        const remain = Math.max(0, endsAt - Date.now());
        const ratio = Math.max(0, Math.min(1, remain / total));
        bar.style.transform = `scaleX(${ratio})`;
      }
      function _rtBattle3dPhase2PatchChatDock(){
        const b = _rtBattle3dPhase2State();
        const st = _rtBattleState();
        const dock = document.getElementById("rt3dChatDock");
        const miniBtn = document.getElementById("rt3dChatToggleMini");
        const listEl = document.getElementById("rt3dChatList");
        if (!(dock instanceof HTMLElement) || !(listEl instanceof HTMLElement)) return;
        dock.classList.toggle("is-collapsed", !b.p2.chatOpen);
        if (miniBtn instanceof HTMLElement) miniBtn.style.display = b.p2.chatOpen ? "none" : "";
        const rows = asArray(st.chatLogs).slice(-30);
        const listHash = rows.map((r, i) => _rtBattleChatRowKey ? _rtBattleChatRowKey(r, i) : `${r?.ts||0}|${r?.text||""}`).join("||");
        if (listEl.dataset.hash === listHash) return;
        const shouldStick = (listEl.scrollHeight - (listEl.scrollTop + listEl.clientHeight)) < 24;
        listEl.dataset.hash = listHash;
        listEl.innerHTML = rows.length ? rows.map((r) => {
          const isChat = String(r?.kind||"") === "chat";
          const dt = new Date(Math.max(0, Number(r?.ts || Date.now())));
          const hh = String(dt.getHours()).padStart(2,"0");
          const mm = String(dt.getMinutes()).padStart(2,"0");
          return `<div class="b3d-chat-item">
            <div class="m">${_escapeHtml(isChat ? String(r?.fromNick || "user") : "system")}  ${hh}:${mm}</div>
            <div class="t">${_escapeHtml(String(r?.text || ""))}</div>
          </div>`;
        }).join("") : `<div class="b3d-mini"></div>`;
        if (shouldStick) listEl.scrollTop = listEl.scrollHeight;
      }
      function _rtBattle3dPhase2AddAnswerFeed(text){
        const b = _rtBattle3dPhase2State();
        const feed = asArray(b.p2.answerFeed);
        feed.push({ text: String(text || ""), ts: Date.now() });
        b.p2.answerFeed = feed.slice(-8);
      }
      function _rtBattle3dPhase2PatchMembersLogToasts(){
        const st = _rtBattleState();
        const b = _rtBattle3dPhase2State();
        const evs = asArray(st.eventHistory).slice(-6);
        const hash = evs.map((e)=>`${e?.kind||""}|${e?.text||""}|${e?.ts||0}`).join("||");
        if (hash === b.p2.answerFeedHash) return;
        b.p2.answerFeedHash = hash;
        if (evs.length){
          const last = evs[evs.length - 1];
          if (last && last.text) _rtBattle3dPhase2AddAnswerFeed(String(last.text));
        }
      }
      function _rtBattle3dPhase2PatchGimmicksMeshes(){
        const b = _rtBattle3dPhase2State();
        const rt = b.runtime || {};
        if (!rt.inited || !rt.scene || !window.THREE) return;
        const THREE = window.THREE;
        const g = b.p2.gimmicks || (b.p2.gimmicks = {});
        if (g._built) return;
        const seed = Math.max(1, Number(_rtBattleState().game?.quizSeed || 12345));
        g.seed = seed;
        const mkMat = (c) => new THREE.MeshStandardMaterial({ color: c, roughness: .86, metalness: .02 });
        // swing hammer
        const hammerPivot = new THREE.Group();
        hammerPivot.position.set(-2.8, 2.7, -9.2);
        const hammerRod = new THREE.Mesh(new THREE.BoxGeometry(0.14, 2.3, 0.14), mkMat(0xb8c1d4));
        hammerRod.position.y = -1.15;
        const hammerHead = new THREE.Mesh(new THREE.BoxGeometry(0.95, 0.28, 0.28), mkMat(0x8896b2));
        hammerHead.position.set(0, -2.2, 0);
        hammerPivot.add(hammerRod, hammerHead);
        rt.scene.add(hammerPivot);
        g.hammer = { pivot: hammerPivot, rangeX:[-3.8,-1.8], z:-9.2, hitR:1.0 };
        // rotating bar
        const rotor = new THREE.Group();
        rotor.position.set(2.2, 0.95, -11.1);
        const axis = new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,1.9,10), mkMat(0xbfc7d8));
        axis.position.y = 0.95;
        const bar = new THREE.Mesh(new THREE.BoxGeometry(2.8, 0.12, 0.22), mkMat(0x70839f));
        bar.position.y = 0.5;
        rotor.add(axis, bar);
        rt.scene.add(rotor);
        g.rotor = { root: rotor, len:1.5, center:{x:2.2,z:-11.1}, hitR:1.65 };
        // moving platform
        const plat = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.24,2.2), mkMat(0xd8deea));
        plat.position.set(0, 0.12, -7.6);
        rt.scene.add(plat);
        g.platform = { mesh: plat, base:{x:0,z:-7.6}, amp:1.5, speed:0.7 };
        g._built = true;
      }
      function _rtBattle3dPhase2WorldTimeSec(){
        const st = _rtBattleState();
        const seed = Math.max(1, Number(st.game?.quizSeed || 1));
        const t0 = Math.max(0, Number(st.game?.countdownStartAtMs || st.room?.createdAt || Date.now()));
        return Math.max(0, (Date.now() - t0) / 1000 + (seed % 17) * 0.013);
      }
      function _rtBattle3dPhase2AnimateGimmicks(dt){
        const b = _rtBattle3dPhase2State();
        const g = b.p2.gimmicks || {};
        const t = _rtBattle3dPhase2WorldTimeSec();
        if (g.hammer?.pivot){
          g.hammer.pivot.rotation.z = Math.sin(t * 1.35) * 0.95;
        }
        if (g.rotor?.root){
          g.rotor.root.rotation.y = t * 1.8;
        }
        if (g.platform?.mesh){
          g.platform.mesh.position.x = g.platform.base.x + Math.sin(t * g.platform.speed) * g.platform.amp;
        }
      }
      function _rtBattle3dPhase2HitEffect(){
        const fx = document.getElementById("rt3dHitFx");
        if (!(fx instanceof HTMLElement)) return;
        fx.classList.remove("is-show");
        void fx.offsetWidth;
        fx.classList.add("is-show");
        setTimeout(() => { try{ fx.classList.remove("is-show"); }catch(_){ } }, 240);
      }
      function _rtBattle3dPhase2ApplyGimmickCollision(dt){
        const st = _rtBattleState();
        if (String(st.phase || "") !== "playing") return;
        const b = _rtBattle3dPhase2State();
        const g = b.p2.gimmicks || {};
        const p = b.local;
        let hit = false;
        if (g.hammer){
          const dx = p.x - (-2.8);
          const dz = p.z - g.hammer.z;
          const d = Math.hypot(dx, dz);
          if (d < g.hammer.hitR && p.y < 1.8){
            p.vx += (dx || 0.2) * 2.2;
            p.vz += ((dz || 0.2) > 0 ? 1 : -1) * 2.2;
            b.effectKind = "debuff";
            b.effectEndsAtMs = Math.max(Date.now() + 900, b.effectEndsAtMs);
            hit = true;
          }
        }
        if (g.rotor){
          const dx = p.x - g.rotor.center.x;
          const dz = p.z - g.rotor.center.z;
          const d = Math.hypot(dx, dz);
          if (d < g.rotor.hitR && p.y < 1.4){
            p.vx += (dx / (d || 1)) * 2.8;
            p.vz += (dz / (d || 1)) * 2.8;
            hit = true;
          }
        }
        if (g.platform?.mesh){
          const px = Number(g.platform.mesh.position.x || 0);
          const pz = Number(g.platform.mesh.position.z || 0);
          const onPlat = Math.abs(p.x - px) < 1.1 && Math.abs(p.z - pz) < 1.1 && p.y <= 1.05;
          if (onPlat) {
            p.x += Math.cos(_rtBattle3dPhase2WorldTimeSec() * g.platform.speed) * g.platform.amp * g.platform.speed * dt;
          }
        }
        if (hit){
          _rtBattle3dPhase2HitEffect();
          _rtBattle3dPushToast("ng", "");
        }
      }
      const __rtBattle3dEnsureSceneV6Base = _rtBattle3dEnsureScene;
      _rtBattle3dEnsureScene = function(){
        _rtBattle3dPhase2EnsureDom();
        __rtBattle3dEnsureSceneV6Base.apply(this, arguments);
        _rtBattle3dPhase2PatchGimmicksMeshes();
      };
      const __rtBattle3dAnimateWorldV6Base = _rtBattle3dAnimateWorld;
      _rtBattle3dAnimateWorld = function(dt){
        __rtBattle3dAnimateWorldV6Base.apply(this, arguments);
        _rtBattle3dPhase2AnimateGimmicks(dt);
      };
      const __rtBattle3dStepPhysicsV6Base = _rtBattle3dStepPhysics;
      _rtBattle3dStepPhysics = function(dt){
        __rtBattle3dStepPhysicsV6Base.apply(this, arguments);
        _rtBattle3dPhase2ApplyGimmickCollision(dt);
      };
      const __rtBattle3dUpdateLocalMeshAndCameraV6Base = _rtBattle3dUpdateLocalMeshAndCamera;
      _rtBattle3dUpdateLocalMeshAndCamera = function(dt){
        const b = _rtBattle3dPhase2State();
        const st = _rtBattleState();
        const rt = b.runtime || {};
        if (rt.camera && rt.localMesh && window.THREE){
          const THREE = window.THREE;
          const target = new THREE.Vector3(b.local.x, 0.95, b.local.z);
          const yaw = Number(b.p2.camYaw || 0);
          const pitch = Math.max(0.15, Math.min(0.85, Number(b.p2.camPitch || 0.35)));
          const dist = 6.2;
          const side = Math.sin(yaw) * dist;
          const back = Math.cos(yaw) * dist;
          const desired = new THREE.Vector3(target.x + side, target.y + (2.1 + pitch * 4.0), target.z + back);
          rt.camera.position.lerp(desired, Math.min(1, dt * 5.5));
          rt.camera.lookAt(target);
          if (b.local.action === "boost") {
            rt.localMesh.scale.lerp(new THREE.Vector3(1.03, 1.03, 1.03), Math.min(1, dt * 8));
          } else if (b.local.action === "slow") {
            rt.localMesh.scale.lerp(new THREE.Vector3(0.96, 0.96, 0.96), Math.min(1, dt * 8));
          } else {
            rt.localMesh.scale.lerp(new THREE.Vector3(1, 1, 1), Math.min(1, dt * 8));
          }
        } else {
          __rtBattle3dUpdateLocalMeshAndCameraV6Base.apply(this, arguments);
          return;
        }
      };
      const __rtBattle3dTickV6Base = _rtBattle3dTick;
      _rtBattle3dTick = function(tsNow){
        __rtBattle3dTickV6Base.apply(this, arguments);
        if (!_rtBattle3dIsOpen()) return;
        _rtBattle3dPhase2SceneApply();
        _rtBattle3dPhase2CountdownTick();
        _rtBattle3dPhase2UpdateTransientOverlays();
        _rtBattle3dPhase2PatchQuizTimer();
        _rtBattle3dPhase2PatchChatDock();
        _rtBattle3dPhase2PatchMembersLogToasts();
      };
      const __rtBattle3dBindGlobalHandlersV6Base = _rtBattle3dBindGlobalHandlers;
      _rtBattle3dBindGlobalHandlers = function(){
        __rtBattle3dBindGlobalHandlersV6Base.apply(this, arguments);
        if (window.__rt3dPhase2GlobalBound) return;
        window.__rt3dPhase2GlobalBound = true;
        document.addEventListener("pointerdown", (e) => {
          const target = e.target instanceof Element ? e.target : null;
          if (!target || !target.closest("#rt3dOverlay")) return;
          const b = _rtBattle3dPhase2State();
          const joyPad = document.getElementById("rt3dJoyPad");
          if (joyPad && target.closest("#rt3dJoyPad")){
            const r = joyPad.getBoundingClientRect();
            b.p2.joy.active = true;
            b.p2.joy.pointerId = e.pointerId;
            b.p2.joy.x = (r.left + r.width/2);
            b.p2.joy.y = (r.top + r.height/2);
            try{ joyPad.setPointerCapture && joyPad.setPointerCapture(e.pointerId); }catch(_){}
            e.preventDefault();
            return;
          }
          const canvasWrap = document.getElementById("rt3dCanvasWrap");
          if (canvasWrap && target.closest("#rt3dCanvasWrap")){
            if (_rtBattle3dActiveInputIsEditable()) return;
            b.p2.dragCam = true;
            b.p2.dragPointerId = e.pointerId;
            b.p2.dragStart = { x:e.clientX, y:e.clientY, yaw:b.p2.camYaw||0, pitch:b.p2.camPitch||0.35 };
            try{ canvasWrap.setPointerCapture && canvasWrap.setPointerCapture(e.pointerId); }catch(_){}
          }
        }, true);
        document.addEventListener("pointermove", (e) => {
          if (!_rtBattle3dIsOpen()) return;
          const b = _rtBattle3dPhase2State();
          if (b.p2.joy.active && e.pointerId === b.p2.joy.pointerId){
            const dx = e.clientX - b.p2.joy.x;
            const dy = e.clientY - b.p2.joy.y;
            const max = 30;
            const clx = Math.max(-max, Math.min(max, dx));
            const cly = Math.max(-max, Math.min(max, dy));
            const nx = clx / max;
            const ny = cly / max;
            b.p2.joy.nx = nx; b.p2.joy.ny = ny;
            b.input.left = nx < -0.25; b.input.right = nx > 0.25;
            b.input.fwd = ny < -0.25; b.input.back = ny > 0.25;
            const knob = document.getElementById("rt3dJoyKnob");
            if (knob) knob.style.transform = `translate(${Math.round(clx)}px, ${Math.round(cly)}px)`;
            e.preventDefault();
            return;
          }
          if (b.p2.dragCam && e.pointerId === b.p2.dragPointerId){
            const dx = e.clientX - Number(b.p2.dragStart?.x || 0);
            const dy = e.clientY - Number(b.p2.dragStart?.y || 0);
            b.p2.camYaw = Number(b.p2.dragStart?.yaw || 0) - dx * 0.008;
            b.p2.camPitch = Math.max(0.15, Math.min(0.85, Number(b.p2.dragStart?.pitch || 0.35) + dy * 0.0035));
            e.preventDefault();
          }
        }, true);
        const resetJoy = () => {
          const b = _rtBattle3dPhase2State();
          b.p2.joy.active = false;
          b.p2.joy.pointerId = -1;
          b.p2.joy.nx = 0; b.p2.joy.ny = 0;
          b.input.left = b.input.right = b.input.fwd = b.input.back = false;
          const knob = document.getElementById("rt3dJoyKnob");
          if (knob) knob.style.transform = "translate(0px, 0px)";
        };
        document.addEventListener("pointerup", (e) => {
          const b = _rtBattle3dPhase2State();
          if (b.p2.joy.active && e.pointerId === b.p2.joy.pointerId) resetJoy();
          if (b.p2.dragCam && e.pointerId === b.p2.dragPointerId){
            b.p2.dragCam = false;
            b.p2.dragPointerId = -1;
          }
        }, true);
        document.addEventListener("pointercancel", (e) => {
          const b = _rtBattle3dPhase2State();
          if (b.p2.joy.active && e.pointerId === b.p2.joy.pointerId) resetJoy();
          if (b.p2.dragCam && e.pointerId === b.p2.dragPointerId){
            b.p2.dragCam = false;
            b.p2.dragPointerId = -1;
          }
        }, true);
      };
      const __rtBattle3dHandleActionV6Base = _rtBattle3dHandleAction;
      _rtBattle3dHandleAction = function(act, el){
        const b = _rtBattle3dPhase2State();
        if (act === "b3dCamReset"){
          b.p2.camYaw = 0; b.p2.camPitch = 0.35;
          return true;
        }
        if (act === "b3dChatToggle"){
          b.p2.chatOpen = !b.p2.chatOpen;
          _rtBattle3dPhase2PatchChatDock();
          return true;
        }
        if (act === "b3dChatSend"){
          const st = _rtBattleState();
          const inp = document.getElementById("rt3dChatInput");
          const text = asStr(inp && "value" in inp ? inp.value : "").trim();
          if (!text){
            try{ uiToast(""); }catch(_){}
            return true;
          }
          if (!_rtBattleSafeSend({ type:"chat", text })){
            try{ uiToast(""); }catch(_){}
            return true;
          }
          if (inp && "value" in inp) inp.value = "";
          _rtBattle3dPhase2PatchChatDock();
          return true;
        }
        return __rtBattle3dHandleActionV6Base.apply(this, arguments);
      };
      const __rtBattle3dOpenV6Base = _rtBattle3dOpen;
      _rtBattle3dOpen = async function(){
        _rtBattle3dPhase2EnsureDom();
        const b = _rtBattle3dPhase2State();
        b.p2.chatOpen = false;
        b.p2.camYaw = 0; b.p2.camPitch = 0.35;
        await __rtBattle3dOpenV6Base.apply(this, arguments);
        _rtBattle3dPhase2EnsureDom();
        _rtBattle3dPhase2SceneApply();
        _rtBattle3dPhase2PatchQuizTimer();
        _rtBattle3dPhase2PatchChatDock();
        _rtBattle3dUpdateStatusUi();
      };
      const __rtBattle3dCloseV6Base = _rtBattle3dClose;
      _rtBattle3dClose = function(){
        const b = _rtBattle3dPhase2State();
        b.p2.dragCam = false;
        b.p2.dragPointerId = -1;
        b.p2.joy.active = false;
        return __rtBattle3dCloseV6Base.apply(this, arguments);
      };
      const __rtBattleHandleMessageV6Base = _rtBattleHandleMessage;
      _rtBattleHandleMessage = function(msg){
        __rtBattleHandleMessageV6Base.apply(this, arguments);
        const type = String(msg?.type || "").toLowerCase();
        const b = _rtBattle3dPhase2State();
        const st = _rtBattleState();
        if (type === "countdown:start"){
          _rtBattle3dPhase2ShowGo("3");
          return;
        }
        if (type === "game:question"){
          const qid = asStr(msg?.qid);
          if (qid && qid !== b.p2.lastQuestionQid){
            b.p2.lastQuestionQid = qid;
            _rtBattle3dPhase2ShowRoundCard();
          }
          return;
        }
        if (type === "game:result"){
          const myUid = _rtBattleMyUserId();
          const myAns = asArray(msg?.answersSummary).find((a)=>Math.max(0, Number(a?.userId||0))===myUid) || null;
          const fastestMine = asStr(msg?.fastestCorrectUserKey) && asStr(msg.fastestCorrectUserKey) === String(myUid);
          if (myAns && typeof myAns.correct === "boolean"){
            const txt = myAns.correct ? (fastestMine ? "FAST! +3 " : " +10") : "";
            _rtBattle3dPushToast(myAns.correct ? "ok" : "ng", txt);
          }
          _rtBattle3dPhase2PatchMembersLogToasts();
          return;
        }
        if (type === "game:final"){
          const hash = JSON.stringify(asArray(st.game?.finalLeaderboard).map((r)=>[r?.userId,r?.score,r?.answeredAtMsTotal]));
          if (hash && hash !== b.p2.lastFinalHash){
            b.p2.lastFinalHash = hash;
            const leader = asArray(st.game?.finalLeaderboard)[0];
            if (leader) _rtBattle3dPushToast("ok", `${asStr(leader.nick) || ""} `);
          }
          return;
        }
      };
      const __rtBattle3dUpdateStatusUiV6Base = _rtBattle3dUpdateStatusUi;
      _rtBattle3dUpdateStatusUi = function(){
        __rtBattle3dUpdateStatusUiV6Base.apply(this, arguments);
        const root = document.getElementById("rt3dOverlay");
        if (!root) return;
        _rtBattle3dPhase2SceneApply();
        _rtBattle3dPhase2CountdownTick();
        _rtBattle3dPhase2PatchQuizTimer();
        _rtBattle3dPhase2PatchChatDock();
      };

      // ROOM_DO_UI_V7_PHASE2_NOFLASH_CHAT: patch 3D chat dock to diff-update (no innerHTML full replace)
      function _rtBattle3dPhase2ChatRowKey(row, idx){
        const r = row || {};
        const ts = Math.max(0, Number(r.ts || 0));
        const kind = asStr(r.kind || "chat");
        const from = asStr(r.fromNick || r.from || "");
        const text = asStr(r.text || "");
        return `${ts}|${kind}|${from}|${text}|${idx}`;
      }
      function _rtBattle3dPhase2RenderChatRowHtml(r){
        const isChat = asStr(r?.kind || "") === "chat";
        const dt = new Date(Math.max(0, Number(r?.ts || Date.now())));
        const hh = String(dt.getHours()).padStart(2, "0");
        const mm = String(dt.getMinutes()).padStart(2, "0");
        return `<div class="m">${_escapeHtml(isChat ? asStr(r?.fromNick || "user") : "system")}  ${hh}:${mm}</div><div class="t">${_escapeHtml(asStr(r?.text || ""))}</div>`;
      }
      function _rtBattle3dPhase2PatchChatDockDiff(){
        const b = _rtBattle3dPhase2State();
        const st = _rtBattleState();
        const dock = document.getElementById("rt3dChatDock");
        const miniBtn = document.getElementById("rt3dChatToggleMini");
        const listEl = document.getElementById("rt3dChatList");
        if (!(dock instanceof HTMLElement) || !(listEl instanceof HTMLElement)) return;
        dock.classList.toggle("is-collapsed", !b.p2.chatOpen);
        if (miniBtn instanceof HTMLElement) miniBtn.style.display = b.p2.chatOpen ? "none" : "";
        const rows = asArray(st.chatLogs).slice(-30);
        const shouldStick = (listEl.scrollHeight - (listEl.scrollTop + listEl.clientHeight)) < 24;
        if (!rows.length){
          if (listEl.dataset.mode !== "empty"){
            listEl.dataset.mode = "empty";
            listEl.replaceChildren();
            const empty = document.createElement("div");
            empty.className = "b3d-mini";
            empty.textContent = "";
            listEl.appendChild(empty);
          }
          return;
        }
        if (listEl.dataset.mode !== "rows"){
          listEl.dataset.mode = "rows";
          listEl.replaceChildren();
        }
        const curNodes = Array.from(listEl.children).filter((n)=>n instanceof HTMLElement);
        const curKeys = curNodes.map((n)=>n.dataset.key || "");
        const nextKeys = rows.map((row, idx)=>_rtBattle3dPhase2ChatRowKey(row, idx));
        const appendOnly = curKeys.length <= nextKeys.length && curKeys.every((k, i)=>k === nextKeys[i]);
        if (appendOnly){
          for (let i = curKeys.length; i < rows.length; i++){
            const row = rows[i];
            const key = nextKeys[i];
            const item = document.createElement("div");
            item.className = "b3d-chat-item";
            item.dataset.key = key;
            item.innerHTML = _rtBattle3dPhase2RenderChatRowHtml(row);
            listEl.appendChild(item);
          }
        } else {
          const frag = document.createDocumentFragment();
          rows.forEach((row, idx) => {
            const item = document.createElement("div");
            item.className = "b3d-chat-item";
            item.dataset.key = nextKeys[idx];
            item.innerHTML = _rtBattle3dPhase2RenderChatRowHtml(row);
            frag.appendChild(item);
          });
          listEl.replaceChildren(frag);
        }
        if (shouldStick) listEl.scrollTop = listEl.scrollHeight;
      }
      const __rtBattle3dPhase2PatchChatDockV7Base = _rtBattle3dPhase2PatchChatDock;
      _rtBattle3dPhase2PatchChatDock = function(){
        try{
          _rtBattle3dPhase2PatchChatDockDiff();
        }catch(err){
          try{ console.warn("[b3dChatDockDiff] fallback", err); }catch(_){}
          return __rtBattle3dPhase2PatchChatDockV7Base.apply(this, arguments);
        }
      };

      // ROOM_DO_UI_V8_3D_MAPS_INPUT_FIX: map system + UI input gating + player visibility safeguards
      function _rtBattle3dV8State(){
        const b = _rtBattle3dPhase2State();
        if (!b.p3 || typeof b.p3 !== "object") b.p3 = {};
        const p3 = b.p3;
        if (typeof p3.inputMode !== "string") p3.inputMode = "";
        if (typeof p3.uiModeUntil !== "number") p3.uiModeUntil = 0;
        if (typeof p3.lastUiHitMsgTs !== "number") p3.lastUiHitMsgTs = 0;
        if (typeof p3.mapId !== "string") p3.mapId = "bridge";
        if (typeof p3.mapSeed !== "number") p3.mapSeed = 1;
        if (typeof p3.lastMapHash !== "string") p3.lastMapHash = "";
        if (typeof p3.viewMode !== "string") p3.viewMode = "third";
        if (!p3.map || typeof p3.map !== "object") p3.map = {};
        if (!Array.isArray(p3.toastsQueue)) p3.toastsQueue = [];
        return b;
      }
      const RT3D_MAP_IDS = ["bridge","city","snow","factory","jungle","lab","sky","volcano","aqua","ice","desert","rail"];
      const RT3D_MAP_LABELS = {
        bridge:"Bridge", city:"City", snow:"Snow", factory:"Factory", jungle:"Jungle", lab:"Lab",
        sky:"Sky", volcano:"Volcano", aqua:"Aqua", ice:"Ice", desert:"Desert", rail:"Rail"
      };
      function _rtBattle3dV8Mulberry(seed){
        let t = (Math.max(1, Number(seed || 1)) >>> 0);
        return function(){
          t += 0x6D2B79F5;
          let x = Math.imul(t ^ (t >>> 15), 1 | t);
          x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
          return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
        };
      }
      function _rtBattle3dV8BuildMapPresets(){
        const base = {
          bounds:{ minX:-5.15, maxX:5.15, minZ:-18.05, maxZ:6.05 },
          gate:{ x:0, z:-4.0, halfW:1.65, halfD:0.26, trigger:{x:0,z:-3.05,halfW:2.1,halfD:0.75} },
          goal:{ x:0, z:-14.6, halfW:2.0, halfD:0.9 },
          checkpoints:[{x:0,z:4.0,r:1.4},{x:0,z:-8.4,r:1.7}],
          floors:[],
          hazards:[],
          decorations:[]
        };
        const mk = (id, partial) => ({ ...base, ...partial, id });
        return {
          bridge: mk("bridge", {
            theme:{ bg:0xeef4fb, floor:0xdfe8f5, edge:0xaab8cf, accent:0x7cb6ff },
            floors:[
              {type:"box", pos:[0,-0.05,-6], size:[4.4,0.12,23.8], material:"bridge"},
              {type:"box", pos:[-3.8,0.35,-6], size:[0.25,0.8,23.4], material:"rope"},
              {type:"box", pos:[3.8,0.35,-6], size:[0.25,0.8,23.4], material:"rope"}
            ],
            hazards:[
              {type:"WindZone", pos:[0,0.7,-10.5], size:[7.4,2.0,6.0], params:{force:[0.75,0,0], pulse:0.9}},
              {type:"MovingPlatform", pos:[0,0.15,-7.4], size:[2.3,0.24,2.2], params:{axis:"x", amp:1.8, speed:0.7}},
              {type:"Pusher", pos:[0,0.9,-12.6], size:[7.0,1.8,0.7], params:{axis:"x", amp:2.4, speed:1.1, push:3.2}}
            ],
            decorations:[{type:"ring", pos:[0,1.9,-14.6], size:[1.1,0.14,1.1], material:"goal"}]
          }),
          city: mk("city", {
            theme:{ bg:0xf4f6fa, floor:0xe6ebf3, edge:0xb3c0d3, accent:0x89a6ff },
            floors:[
              {type:"box", pos:[0,-0.05,-6], size:[10.8,0.12,25.0], material:"road"},
              {type:"box", pos:[-2.9,0.6,-9.6], size:[1.8,1.2,2.0], material:"roof"},
              {type:"box", pos:[2.8,1.0,-12.5], size:[2.2,2.0,2.2], material:"roof"},
              {type:"box", pos:[0,0.45,-15.4], size:[3.0,0.9,2.4], material:"roof"}
            ],
            hazards:[
              {type:"Laser", pos:[0,1.0,-8.7], size:[8.2,1.8,0.5], params:{period:2.2, on:1.1}},
              {type:"MovingPlatform", pos:[2.8,0.14,-10.1], size:[1.8,0.24,1.8], params:{axis:"y", amp:1.4, speed:0.8}},
              {type:"Rotator", pos:[-0.6,0.9,-13.1], size:[3.1,0.16,0.24], params:{speed:1.6}}
            ],
            decorations:[
              {type:"tower", pos:[-4.1,1.2,-9.2], size:[1.8,2.4,1.8], material:"building"},
              {type:"tower", pos:[4.0,1.6,-12.1], size:[1.6,3.2,1.6], material:"building"}
            ]
          }),
          snow: mk("snow", {
            theme:{ bg:0xf5f9fd, floor:0xe9f3fb, edge:0xb7c9db, accent:0x9fd7ff },
            floors:[
              {type:"box", pos:[0,-0.05,-6], size:[11.0,0.12,25.0], material:"snow"},
              {type:"ramp", pos:[0,0.55,-9.4], size:[4.2,1.1,4.5], rot:[-0.22,0,0], material:"ice"},
              {type:"box", pos:[0,1.1,-13.8], size:[3.4,0.16,3.0], material:"ice"}
            ],
            hazards:[
              {type:"IceFriction", pos:[0,0.6,-9.4], size:[4.6,1.6,5.0], params:{factor:0.25}},
              {type:"FallingFloor", pos:[-2.6,0.16,-12.0], size:[1.8,0.22,1.8], params:{delay:900, down:3.0, recover:2600}},
              {type:"WindZone", pos:[0,1.0,-14.0], size:[8.0,2.6,5.0], params:{force:[-0.5,0,0.2], pulse:1.25}}
            ],
            decorations:[
              {type:"column", pos:[-4.0,0.8,-10.8], size:[0.6,1.6,0.6], material:"snowRock"},
              {type:"column", pos:[4.0,1.0,-15.2], size:[0.7,2.0,0.7], material:"snowRock"}
            ]
          }),
          factory: mk("factory", { theme:{ bg:0xf5f5f6, floor:0xe5e7ea, edge:0xb7bcc6, accent:0xffb36b },
            hazards:[{type:"Conveyor", pos:[0,0.5,-9.5], size:[5.5,1.4,4.0], params:{dir:[1,0], speed:2.2}},
                     {type:"Rotator", pos:[0,0.9,-13.4], size:[3.3,0.16,0.22], params:{speed:2.1}}],
            decorations:[{type:"tower", pos:[-4.1,1.2,-11.0], size:[1.3,2.4,1.3], material:"metal"}]}),
          jungle: mk("jungle", { theme:{ bg:0xf1f8f2, floor:0xe2f0e1, edge:0xb8cdb6, accent:0x69c27b },
            hazards:[{type:"Quicksand", pos:[0,0.4,-10.8], size:[4.8,1.0,3.8], params:{slow:0.45}},
                     {type:"Pusher", pos:[0,1.0,-13.8], size:[7.4,1.8,0.7], params:{axis:"z", amp:1.2, speed:1.0, push:2.4}}]}),
          lab: mk("lab", { theme:{ bg:0xf7f8fe, floor:0xe7ebff, edge:0xb9c4ef, accent:0x8c9dff },
            hazards:[{type:"Laser", pos:[0,1.0,-9.0], size:[8.5,1.8,0.5], params:{period:1.6, on:0.8}},
                     {type:"Laser", pos:[0,1.0,-12.8], size:[8.5,1.8,0.5], params:{period:2.0, on:1.0, phase:0.7}}]}),
          sky: mk("sky", { theme:{ bg:0xeef5ff, floor:0xe6edf7, edge:0xbecfe5, accent:0x88c3ff },
            hazards:[{type:"MovingPlatform", pos:[-1.5,0.15,-9.3], size:[2.0,0.24,2.0], params:{axis:"z", amp:1.3, speed:0.9}},
                     {type:"MovingPlatform", pos:[1.6,0.15,-12.7], size:[2.0,0.24,2.0], params:{axis:"x", amp:1.4, speed:1.0}}]}),
          volcano: mk("volcano", { theme:{ bg:0x1a1514, floor:0x3b2f2d, edge:0x5b4440, accent:0xff7a59 },
            hazards:[{type:"RisingLava", pos:[0,0.1,-11.2], size:[8.5,0.3,8.5], params:{amp:0.65, speed:0.45}},
                     {type:"Rotator", pos:[0,1.0,-14.1], size:[3.4,0.16,0.24], params:{speed:2.4}}]}),
          aqua: mk("aqua", { theme:{ bg:0xeefaff, floor:0xdff1f8, edge:0xb7d7e3, accent:0x5dc4ff },
            hazards:[{type:"WaterSlide", pos:[0,0.4,-10.4], size:[5.8,1.1,5.5], params:{dir:[0,-1], speed:2.1}},
                     {type:"WindZone", pos:[0,0.9,-14.5], size:[7.0,1.8,4.0], params:{force:[0.3,0,-0.6], pulse:1.0}}]}),
          ice: mk("ice", { theme:{ bg:0xf6fbff, floor:0xe7f5ff, edge:0xc3deef, accent:0x9de0ff },
            hazards:[{type:"IceFriction", pos:[0,0.5,-9.0], size:[9.0,1.6,11.0], params:{factor:0.18}},
                     {type:"Rotator", pos:[0,0.9,-13.0], size:[3.0,0.16,0.22], params:{speed:1.5}}]}),
          desert: mk("desert", { theme:{ bg:0xfcf6e8, floor:0xf0e1bf, edge:0xd0b98a, accent:0xe9b25d },
            hazards:[{type:"Quicksand", pos:[0,0.45,-11.0], size:[5.6,1.0,4.2], params:{slow:0.38}},
                     {type:"WindZone", pos:[0,1.0,-14.2], size:[8.0,2.0,4.4], params:{force:[0.6,0,0], pulse:1.4}}]}),
          rail: mk("rail", { theme:{ bg:0xf4f5f7, floor:0xe2e5eb, edge:0xb4bbca, accent:0x7aa1ff },
            hazards:[{type:"TrainCar", pos:[0,0.2,-10.5], size:[2.2,0.35,2.8], params:{axis:"x", amp:2.3, speed:0.85}},
                     {type:"Conveyor", pos:[0,0.45,-14.2], size:[5.8,1.0,3.2], params:{dir:[1,0], speed:1.7}}]})
        };
      }
      const RT3D_MAPS = _rtBattle3dV8BuildMapPresets();
      function _rtBattle3dV8MapConfigById(mapId){
        return RT3D_MAPS[String(mapId || "bridge").toLowerCase()] || RT3D_MAPS.bridge;
      }
      function _rtBattle3dV8MarkUiMode(ms){
        const b = _rtBattle3dV8State();
        b.p3.inputMode = "ui";
        b.p3.uiModeUntil = Date.now() + Math.max(250, Number(ms || 1000));
      }
      function _rtBattle3dV8UiModeActive(){
        const b = _rtBattle3dV8State();
        return String(b.p3.inputMode || "") === "ui" && Number(b.p3.uiModeUntil || 0) > Date.now();
      }
      function _rtBattle3dV8UiSelector(){
        return "#uiRoot, #rt3dOverlay .b3d-head, #rt3dOverlay .b3d-bottom, #rt3dOverlay .b3d-chatdock, #rt3dOverlay .b3d-lobby-card, #rt3dOverlay .b3d-countdown-card, #rt3dOverlay .b3d-result, #rt3dOverlay .b3d-quiz";
      }
      function _rtBattle3dV8RewireRoot(root){
        if (!(root instanceof HTMLElement)) return root;
        const shell = root.querySelector(".b3d-shell");
        const main = root.querySelector(".b3d-main");
        if (!(shell instanceof HTMLElement) || !(main instanceof HTMLElement)) return root;
        let uiRoot = root.querySelector("#uiRoot");
        if (!(uiRoot instanceof HTMLElement)){
          uiRoot = document.createElement("div");
          uiRoot.id = "uiRoot";
          uiRoot.style.position = "absolute";
          uiRoot.style.inset = "0";
          uiRoot.style.zIndex = "10";
          uiRoot.style.pointerEvents = "none";
          uiRoot.style.overflow = "hidden";
          uiRoot.style.touchAction = "pan-y pan-x";
          main.appendChild(uiRoot);
        }
        Array.from(main.children).forEach((child) => {
          if (!(child instanceof HTMLElement)) return;
          if (child.id === "rt3dCanvasWrap" || child.id === "uiRoot") return;
          uiRoot.appendChild(child);
        });
        const canvasWrap = root.querySelector("#rt3dCanvasWrap");
        if (canvasWrap instanceof HTMLElement){
          canvasWrap.style.zIndex = "0";
          canvasWrap.style.pointerEvents = "auto";
          canvasWrap.style.touchAction = "none";
        }
        const peAuto = [
          ".b3d-hud-card",".b3d-score-panel",".b3d-toast-wrap",".b3d-quiz",".b3d-result",".b3d-overlay-msg",
          ".b3d-status-bar",".b3d-lobby-card",".b3d-countdown-card",".b3d-round-card",".b3d-chatdock",".b3d-joystick",".b3d-jump2",
          ".b3d-camreset",".b3d-chat-toggle",".b3d-gfx-badge"
        ];
        peAuto.forEach((sel)=> root.querySelectorAll(sel).forEach((el)=>{ if (el instanceof HTMLElement) el.style.pointerEvents = "auto"; }));
        root.querySelectorAll(".b3d-player-list,.b3d-chatdock-body,.b3d-score-panel,.b3d-result-list,.b3d-roundlog").forEach((el) => {
          if (!(el instanceof HTMLElement)) return;
          el.style.overflow = "auto";
          el.style.webkitOverflowScrolling = "touch";
          if (!el.style.touchAction) el.style.touchAction = "pan-y";
        });
        shell.style.overscrollBehavior = "contain";
        if (document.documentElement) document.documentElement.style.overscrollBehavior = "none";
        return root;
      }
      const __rtBattle3dEnsureRootV8Base = _rtBattle3dEnsureRoot;
      _rtBattle3dEnsureRoot = function(){
        const root = __rtBattle3dEnsureRootV8Base.apply(this, arguments);
        return _rtBattle3dV8RewireRoot(root);
      };
      function _rtBattle3dV8DisposeNode3d(node){
        if (!node) return;
        try{
          node.traverse?.((obj)=>{
            try{ obj.geometry && obj.geometry.dispose && obj.geometry.dispose(); }catch(_){}
            try{
              if (Array.isArray(obj.material)) obj.material.forEach((m)=>m && m.dispose && m.dispose());
              else if (obj.material && obj.material.dispose) obj.material.dispose();
            }catch(_){}
          });
        }catch(_){}
      }
      function _rtBattle3dV8Mat(THREE, color, rough=0.9){
        return new THREE.MeshStandardMaterial({ color, roughness: rough, metalness: 0.02 });
      }
      function _rtBattle3dV8MakeBox(THREE, spec, mat){
        const rot = asArray(spec.rot);
        const size = asArray(spec.size);
        const pos = asArray(spec.pos);
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(Number(size[0]||1), Number(size[1]||1), Number(size[2]||1)), mat);
        mesh.position.set(Number(pos[0]||0), Number(pos[1]||0), Number(pos[2]||0));
        mesh.rotation.set(Number(rot[0]||0), Number(rot[1]||0), Number(rot[2]||0));
        return mesh;
      }
      function _rtBattle3dV8HazardMesh(THREE, hz, theme){
        const t = String(hz.type || "");
        const size = asArray(hz.size);
        const pos = asArray(hz.pos);
        const g = new THREE.Group();
        g.position.set(Number(pos[0]||0), Number(pos[1]||0), Number(pos[2]||0));
        let mesh = null;
        if (t === "Rotator" || t === "Pusher"){
          mesh = new THREE.Mesh(new THREE.BoxGeometry(Number(size[0]||2), Number(size[1]||0.14), Number(size[2]||0.2)), _rtBattle3dV8Mat(THREE, theme.accent || 0x88a0ff, .82));
          g.add(mesh);
        } else if (t === "Laser"){
          mesh = new THREE.Mesh(new THREE.BoxGeometry(Number(size[0]||3), 0.06, 0.06), _rtBattle3dV8Mat(THREE, 0xff6d6d, .4));
          mesh.position.y = Math.max(0.2, Number(size[1]||1.1) * 0.5);
          g.add(mesh);
        } else if (t === "MovingPlatform" || t === "TrainCar" || t === "FallingFloor"){
          mesh = new THREE.Mesh(new THREE.BoxGeometry(Number(size[0]||2), Number(size[1]||0.24), Number(size[2]||2)), _rtBattle3dV8Mat(THREE, 0xd9dee8, .92));
          g.add(mesh);
        } else if (t === "RisingLava"){
          mesh = new THREE.Mesh(new THREE.BoxGeometry(Number(size[0]||5), Number(size[1]||0.2), Number(size[2]||5)), _rtBattle3dV8Mat(THREE, 0xff7448, .55));
          g.add(mesh);
        } else {
          mesh = new THREE.Mesh(new THREE.BoxGeometry(Number(size[0]||2), Number(size[1]||0.15), Number(size[2]||2)), _rtBattle3dV8Mat(THREE, 0xc8d0df, .9));
          g.add(mesh);
        }
        return { root:g, mesh };
      }
      function _rtBattle3dV8BuildMap(mapId, mapSeed){
        const b = _rtBattle3dV8State();
        const rt = b.runtime || {};
        const scene = rt.scene;
        const THREE = window.THREE;
        if (!scene || !THREE) return;
        const cfg = _rtBattle3dV8MapConfigById(mapId);
        const hash = `${cfg.id}|${Math.max(1, Number(mapSeed||1))}`;
        if (b.p3.lastMapHash === hash && b.p3.map?.group) return;
        if (b.p3.map?.group){
          try{ scene.remove(b.p3.map.group); }catch(_){}
          _rtBattle3dV8DisposeNode3d(b.p3.map.group);
        }
        const group = new THREE.Group();
        group.name = `rt3d-map-${cfg.id}`;
        const theme = cfg.theme || {};
        scene.background = new THREE.Color(Number(theme.bg || 0xf3f5f8));
        const colliders = [];
        const hazards = [];
        const moving = [];
        const rng = _rtBattle3dV8Mulberry(mapSeed);
        const floorMat = _rtBattle3dV8Mat(THREE, Number(theme.floor || 0xe7ebf2), .95);
        const edgeMat = _rtBattle3dV8Mat(THREE, Number(theme.edge || 0xbcc8da), .9);
        // thematic main runway replacement (keeps legacy bounds/gate/goal positions)
        const runway = new THREE.Mesh(new THREE.BoxGeometry(10.8, 0.12, 25.0), floorMat);
        runway.position.set(0, -0.05, -6.0);
        group.add(runway);
        colliders.push({ kind:"floor", x:0, y:-0.05, z:-6, sx:10.8, sy:0.12, sz:25.0 });
        asArray(cfg.floors).forEach((f)=>{
          const type = String(f.type || "box");
          const mesh = _rtBattle3dV8MakeBox(THREE, f, _rtBattle3dV8Mat(THREE, type === "ramp" ? Number(theme.accent || 0x89c0ff) : Number(theme.floor || 0xe7ebf2), type === "ramp" ? .75 : .95));
          group.add(mesh);
          const size = asArray(f.size);
          colliders.push({ kind:type, mesh, x:mesh.position.x, y:mesh.position.y, z:mesh.position.z, sx:Number(size[0]||1), sy:Number(size[1]||1), sz:Number(size[2]||1) });
        });
        // side rails/decor edges for visibility
        const railL = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.85, 24.0), edgeMat);
        railL.position.set(-5.25, 0.33, -6.0);
        const railR = railL.clone();
        railR.position.x = 5.25;
        group.add(railL, railR);
        asArray(cfg.decorations).forEach((d)=>{
          const type = String(d.type || "box");
          const matColor = type === "ring" ? Number(theme.accent || 0x74b7ff) : (type === "tower" ? 0xb8c1d4 : Number(theme.edge || 0xbcc8da));
          let mesh;
          if (type === "ring"){
            const size = asArray(d.size);
            mesh = new THREE.Mesh(new THREE.TorusGeometry(Number(size[0]||1), Number(size[1]||0.12), 8, 18), _rtBattle3dV8Mat(THREE, matColor, .55));
            mesh.rotation.x = Math.PI/2;
            const pos = asArray(d.pos); mesh.position.set(Number(pos[0]||0), Number(pos[1]||1.5), Number(pos[2]||0));
          } else if (type === "column" || type === "tower"){
            const size = asArray(d.size), pos = asArray(d.pos);
            mesh = new THREE.Mesh(new THREE.BoxGeometry(Number(size[0]||1), Number(size[1]||2), Number(size[2]||1)), _rtBattle3dV8Mat(THREE, matColor, .88));
            mesh.position.set(Number(pos[0]||0), Number(pos[1]||1), Number(pos[2]||0));
          } else {
            mesh = _rtBattle3dV8MakeBox(THREE, d, _rtBattle3dV8Mat(THREE, matColor, .88));
          }
          group.add(mesh);
        });
        // hazards (componentized)
        asArray(cfg.hazards).forEach((hz, idx)=>{
          const built = _rtBattle3dV8HazardMesh(THREE, hz, theme);
          if (!built || !built.root) return;
          group.add(built.root);
          const pos = asArray(hz.pos), size = asArray(hz.size), params = (hz.params && typeof hz.params==="object") ? hz.params : {};
          const item = {
            id:`${cfg.id}:${String(hz.type||"hz").toLowerCase()}:${idx}`,
            type:String(hz.type||""),
            root:built.root,
            mesh:built.mesh || null,
            basePos:{ x:Number(pos[0]||0), y:Number(pos[1]||0), z:Number(pos[2]||0) },
            size:{ x:Number(size[0]||1), y:Number(size[1]||1), z:Number(size[2]||1) },
            params,
            state:{ active:true, startedAt:0, fallen:false, hitCooldownUntil:0, phase:Number(params.phase||rng()*2) }
          };
          hazards.push(item);
          if (["MovingPlatform","Rotator","Pusher","Conveyor","Laser","FallingFloor","WindZone","IceFriction","Quicksand","WaterSlide","TrainCar","RisingLava"].includes(item.type)){
            moving.push(item);
          }
        });
        b.p3.map = {
          id: cfg.id,
          cfg,
          group,
          colliders,
          hazards,
          moving,
          bounds: cfg.bounds || null,
          gate: cfg.gate || null,
          goal: cfg.goal || null,
          checkpoints: asArray(cfg.checkpoints)
        };
        b.p3.mapId = cfg.id;
        b.p3.mapSeed = Math.max(1, Number(mapSeed||1));
        b.p3.lastMapHash = hash;
        scene.add(group);
      }
      function _rtBattle3dV8ApplyMapNow(){
        const b = _rtBattle3dV8State();
        const st = _rtBattleState();
        const mapId = asStr(st.game3d?.mapId || b.p3.mapId || "bridge").toLowerCase() || "bridge";
        const mapSeed = Math.max(1, Number(st.game3d?.mapSeed || b.p3.mapSeed || 1));
        _rtBattle3dV8BuildMap(mapId, mapSeed);
      }
      function _rtBattle3dV8WorldTimeSec(){
        const st = _rtBattleState();
        const seed = Math.max(1, Number(st.game3d?.mapSeed || st.game?.quizSeed || 1));
        const t0 = Math.max(0, Number(st.game?.countdownStartAtMs || st.room?.createdAt || Date.now()));
        return Math.max(0, (Date.now() - t0) / 1000 + (seed % 31) * 0.011);
      }
      function _rtBattle3dV8AnimateMapGimmicks(dt){
        const b = _rtBattle3dV8State();
        const t = _rtBattle3dV8WorldTimeSec();
        const hazards = asArray(b.p3.map?.moving);
        for (const hz of hazards){
          const type = String(hz.type || "");
          const p = hz.params || {};
          if (!hz.root) continue;
          if (type === "MovingPlatform"){
            const axis = String(p.axis||"x");
            const amp = Number(p.amp || 1.2), speed = Number(p.speed || 1);
            hz.root.position[axis] = hz.basePos[axis] + Math.sin(t * speed) * amp;
          } else if (type === "TrainCar"){
            const axis = String(p.axis||"x");
            const amp = Number(p.amp || 2), speed = Number(p.speed || .9);
            hz.root.position[axis] = hz.basePos[axis] + Math.sin(t * speed) * amp;
          } else if (type === "Rotator"){
            hz.root.rotation.y = t * Number(p.speed || 1.5) + Number(hz.state.phase || 0);
          } else if (type === "Pusher"){
            const axis = String(p.axis||"x");
            const amp = Number(p.amp || 1.6), speed = Number(p.speed || 1.1);
            hz.root.position[axis] = hz.basePos[axis] + Math.sin(t * speed) * amp;
          } else if (type === "Laser"){
            const period = Math.max(0.4, Number(p.period || 2));
            const on = Math.max(0.1, Math.min(period, Number(p.on || period * 0.5)));
            const phase = (t + Number(hz.state.phase || 0)) % period;
            hz.state.active = phase < on;
            if (hz.mesh) hz.mesh.visible = hz.state.active;
          } else if (type === "FallingFloor"){
            const down = Number(p.down || 2.4);
            const recover = Math.max(400, Number(p.recover || 2400));
            if (hz.state.fallen){
              const elapsed = Date.now() - Number(hz.state.startedAt || 0);
              hz.root.position.y = hz.basePos.y - down;
              if (elapsed > recover){
                hz.state.fallen = false;
                hz.state.startedAt = 0;
                hz.root.position.y = hz.basePos.y;
              }
            }
          } else if (type === "RisingLava"){
            const amp = Number(p.amp || 0.5), speed = Number(p.speed || 0.5);
            hz.root.position.y = hz.basePos.y + (Math.sin(t * speed) * 0.5 + 0.5) * amp;
          }
        }
      }
      function _rtBattle3dV8RectHit(p, hz, extra=0){
        const sx = Number(hz.size?.x || 1), sz = Number(hz.size?.z || 1), sy = Number(hz.size?.y || 1);
        const hx = sx * 0.5 + extra, hz2 = sz * 0.5 + extra;
        const dx = p.x - Number(hz.root?.position?.x ?? hz.basePos?.x ?? 0);
        const dz = p.z - Number(hz.root?.position?.z ?? hz.basePos?.z ?? 0);
        return (Math.abs(dx) <= hx && Math.abs(dz) <= hz2 && p.y <= (Number(hz.root?.position?.y ?? hz.basePos?.y ?? 0) + sy + 1.5));
      }
      function _rtBattle3dV8ApplyMapHazardCollision(dt){
        const st = _rtBattleState();
        if (String(st.phase || "") !== "playing") return;
        const b = _rtBattle3dV8State();
        const p = b.local;
        const tnow = Date.now();
        let gotHit = false;
        const hazards = asArray(b.p3.map?.hazards);
        for (const hz of hazards){
          if (!hz || !hz.root) continue;
          const type = String(hz.type || "");
          if (Number(hz.state?.hitCooldownUntil || 0) > tnow) continue;
          const hit = _rtBattle3dV8RectHit(p, hz, 0.22);
          if (!hit && type !== "FallingFloor") continue;
          if (type === "WindZone"){
            const f = asArray(hz.params?.force);
            p.vx += Number(f[0] || 0) * dt * 5;
            p.vz += Number(f[2] || 0) * dt * 5;
          } else if (type === "Conveyor"){
            const dir = asArray(hz.params?.dir);
            if (p.y <= 1.15){ p.x += Number(dir[0]||0) * Number(hz.params?.speed || 1.4) * dt; p.z += Number(dir[1]||0) * Number(hz.params?.speed || 1.4) * dt; }
          } else if (type === "WaterSlide"){
            const dir = asArray(hz.params?.dir);
            p.x += Number(dir[0]||0) * Number(hz.params?.speed || 1.8) * dt;
            p.z += Number(dir[1]||0) * Number(hz.params?.speed || 1.8) * dt;
            p.vx *= 0.99; p.vz *= 0.99;
          } else if (type === "IceFriction"){
            p.vx *= 1.01; p.vz *= 1.01;
            b.effectKind = "boost"; b.effectEndsAtMs = Math.max(tnow + 250, b.effectEndsAtMs);
          } else if (type === "Quicksand"){
            p.vx *= 0.78; p.vz *= 0.78;
            b.effectKind = "debuff"; b.effectEndsAtMs = Math.max(tnow + 350, b.effectEndsAtMs);
          } else if (type === "Laser"){
            if (!hz.state.active) continue;
            p.vx *= 0.4; p.vz *= 0.4;
            b.effectKind = "debuff"; b.effectEndsAtMs = Math.max(tnow + 900, b.effectEndsAtMs);
            gotHit = true;
          } else if (type === "Rotator" || type === "Pusher"){
            const cx = Number(hz.root.position.x || 0), cz = Number(hz.root.position.z || 0);
            const dx = p.x - cx, dz = p.z - cz;
            const d = Math.hypot(dx, dz) || 1;
            const force = Number(hz.params?.push || 2.8);
            p.vx += (dx / d) * force;
            p.vz += (dz / d) * force;
            b.effectKind = "debuff"; b.effectEndsAtMs = Math.max(tnow + 700, b.effectEndsAtMs);
            gotHit = true;
          } else if (type === "MovingPlatform" || type === "TrainCar"){
            if (p.y <= 1.2){
              const axis = String(hz.params?.axis || "x");
              const amp = Number(hz.params?.amp || 1.2), speed = Number(hz.params?.speed || 1);
              const v = Math.cos(_rtBattle3dV8WorldTimeSec() * speed) * amp * speed;
              if (axis === "x") p.x += v * dt;
              else if (axis === "z") p.z += v * dt;
              else p.y += Math.abs(v) * dt * 0.4;
            }
          } else if (type === "FallingFloor"){
            if (hit && !hz.state.fallen && p.y <= 1.2){
              const delay = Math.max(120, Number(hz.params?.delay || 850));
              if (!hz.state.startedAt) hz.state.startedAt = tnow;
              if ((tnow - hz.state.startedAt) > delay){
                hz.state.fallen = true;
                hz.state.hitCooldownUntil = tnow + 300;
              }
            } else if (!hit && !hz.state.fallen){
              hz.state.startedAt = 0;
            }
          } else if (type === "RisingLava"){
            const topY = Number(hz.root.position.y || 0) + (Number(hz.size?.y || 0.3) * 0.5) + 0.9;
            if (p.y <= topY){
              p.vx *= 0.6; p.vz *= 0.6;
              p.x = 0; p.z = 4; p.y = 0.9;
              b.effectKind = "debuff"; b.effectEndsAtMs = Math.max(tnow + 1200, b.effectEndsAtMs);
              gotHit = true;
            }
          }
          hz.state.hitCooldownUntil = tnow + 110;
        }
        if (gotHit){
          try{ _rtBattle3dPhase2HitEffect(); }catch(_){}
          _rtBattle3dPushToast("ng", "");
        }
      }
      function _rtBattle3dV8ClampWorld(){
        const b = _rtBattle3dV8State();
        const p = b.local;
        const r = 0.32;
        const bounds = b.p3.map?.bounds || { minX:-5.15, maxX:5.15, minZ:-18.05, maxZ:6.05 };
        p.x = Math.max(Number(bounds.minX || -5.15) + r, Math.min(Number(bounds.maxX || 5.15) - r, p.x));
        p.z = Math.max(Number(bounds.minZ || -18.05) + r, Math.min(Number(bounds.maxZ || 6.05) - r, p.z));
        const gate = b.p3.map?.gate;
        if (gate && !b.gateOpen){
          const gateZ = Number(gate.z || -4.0), halfDepth = Number(gate.halfD || 0.26), halfWidth = Number(gate.halfW || 1.65);
          if (Math.abs(p.x - Number(gate.x || 0)) < halfWidth && Math.abs(p.z - gateZ) < (halfDepth + r)){
            if (p.z < gateZ) p.z = gateZ - halfDepth - r;
            else p.z = gateZ + halfDepth + r;
          }
        }
      }
      function _rtBattle3dV8MaybeTriggerWorldEvents(){
        const b = _rtBattle3dV8State();
        const p = b.local;
        const gateTrigger = b.p3.map?.gate?.trigger || { x:0, z:-3.05, halfW:2.1, halfD:0.75 };
        if (!b.gateOpen && !b.quizOpen && !b.localFinished){
          const inGateTrigger = Math.abs(p.x - Number(gateTrigger.x || 0)) < Number(gateTrigger.halfW || 2.1)
            && Math.abs(p.z - Number(gateTrigger.z || -3.05)) < Number(gateTrigger.halfD || 0.75);
          if (inGateTrigger) _rtBattle3dOpenQuiz();
        }
        const goal = b.p3.map?.goal || { x:0, z:-14.6, halfW:2.0, halfD:0.9 };
        if (b.gateOpen && !b.localFinished){
          const inGoal = Math.abs(p.x - Number(goal.x || 0)) < Number(goal.halfW || 2.0)
            && Math.abs(p.z - Number(goal.z || -14.6)) < Number(goal.halfD || 0.9);
          if (inGoal){
            b.localFinished = true;
            b.status = "";
            _rtBattleSafeSend({ type: "game3d:goal" });
            _rtBattle3dPushToast("ok", "");
          }
        }
        // checkpoints (soft respawn memory)
        for (const cp of asArray(b.p3.map?.checkpoints)){
          const dx = p.x - Number(cp?.x || 0), dz = p.z - Number(cp?.z || 0), rr = Number(cp?.r || cp?.radius || 1.2);
          if ((dx*dx + dz*dz) <= rr*rr){
            b.p3.lastCheckpoint = { x:Number(cp?.x||0), y:0.9, z:Number(cp?.z||0) };
          }
        }
      }
      function _rtBattle3dV8EnsureUiAddons(){
        const root = _rtBattle3dEnsureRoot();
        const headRight = root.querySelector(".b3d-head-right");
        if (headRight instanceof HTMLElement && !root.querySelector("[data-rt-battle-action='b3dViewToggle']")){
          headRight.insertAdjacentHTML("afterbegin", `<button class="btn ov-iconbtn" type="button" data-rt-battle-action="b3dViewToggle" aria-label=""><span class="ms">videocam</span></button>
            <button class="btn ov-iconbtn" type="button" data-rt-battle-action="b3dLocatePlayers" aria-label=""><span class="ms">my_location</span></button>`);
        }
        const hud = root.querySelector(".b3d-hud");
        if (hud instanceof HTMLElement && !document.getElementById("rt3dHudDebug")){
          const card = document.createElement("div");
          card.className = "b3d-hud-card is-compact";
          card.innerHTML = `<div class="t">MAP / DEBUG</div><div class="v" id="rt3dHudDebug">-</div>`;
          hud.appendChild(card);
        }
        const main = root.querySelector(".b3d-main");
        if (main instanceof HTMLElement && !document.getElementById("rt3dUiHitDebug")){
          const dbg = document.createElement("div");
          dbg.id = "rt3dUiHitDebug";
          dbg.style.cssText = "position:absolute;left:10px;top:10px;z-index:30;pointer-events:none;font-size:11px;background:rgba(0,0,0,.55);color:#fff;padding:4px 8px;border-radius:8px;opacity:0;transition:opacity .18s;";
          main.appendChild(dbg);
        }
      }
      function _rtBattle3dV8PatchLobbyMapUi(){
        const layer = document.getElementById("rt3dLobbyLayer");
        if (!(layer instanceof HTMLElement)) return;
        const presetPanel = Array.from(layer.querySelectorAll(".b3d-panel")).find((el)=>/|/.test(asStr(el.querySelector("h4")?.textContent)));
        if (!(presetPanel instanceof HTMLElement)) return;
        let row = document.getElementById("rt3dLobbyMapRow");
        if (!row){
          row = document.createElement("div");
          row.id = "rt3dLobbyMapRow";
          row.style.marginTop = "8px";
          row.innerHTML = `
            <div class="b3d-mini" style="margin-bottom:4px;">3D</div>
            <select id="rt3dLobbyMapSelect" class="b3d-select"></select>
            <div class="b3d-mini" id="rt3dLobbyMapHint" style="margin-top:6px;"></div>`;
          presetPanel.appendChild(row);
        }
        const st = _rtBattleState();
        const isHost = _rtBattleIsHost();
        const sel = document.getElementById("rt3dLobbyMapSelect");
        const hint = document.getElementById("rt3dLobbyMapHint");
        if (!(sel instanceof HTMLSelectElement)) return;
        const current = asStr(st.game3d?.mapId || _rtBattle3dV8State().p3.mapId || "bridge").toLowerCase() || "bridge";
        const html = RT3D_MAP_IDS.map((id)=>`<option value="${_escapeHtml(id)}"${id===current?" selected":""}>${_escapeHtml(RT3D_MAP_LABELS[id]||id)}</option>`).join("");
        if (sel.dataset.optionsHash !== html){
          sel.dataset.optionsHash = html;
          sel.innerHTML = html;
        }
        sel.disabled = !isHost;
        if (hint) hint.textContent = isHost ? "" : "";
      }
      function _rtBattle3dV8UpdateDebugHud(){
        const st = _rtBattleState();
        const b = _rtBattle3dV8State();
        const el = document.getElementById("rt3dHudDebug");
        if (!(el instanceof HTMLElement)) return;
        const mapId = asStr(st.game3d?.mapId || b.p3.mapId || "bridge") || "bridge";
        const qLen = Math.max(0, Number(asArray(st.game?.questionIds).length || 0));
        const qCount = st.room?.settings?.questionCount ?? st.questionCount ?? 20;
        const pool = Math.max(0, Number(st.game?.presetWordsLength || 0));
        const txt = `${mapId.toUpperCase()}  Q=${String(qCount)}  IDs=${qLen}  Pool=${pool}`;
        if (el.textContent !== txt) el.textContent = txt;
      }
      function _rtBattle3dV8ShowHitTarget(e){
        if (!window.__rt3dUiDebug) return;
        const label = document.getElementById("rt3dUiHitDebug");
        if (!(label instanceof HTMLElement)) return;
        const x = Math.max(0, Number(e?.clientX || 0));
        const y = Math.max(0, Number(e?.clientY || 0));
        const hit = document.elementFromPoint(x, y);
        if (!(hit instanceof Element)) return;
        const txt = `${hit.tagName.toLowerCase()}${hit.id ? `#${hit.id}` : ""}${hit.className ? `.${String(hit.className).trim().replace(/\s+/g,'.')}` : ""}`;
        label.textContent = txt.slice(0, 140);
        label.style.opacity = "1";
        clearTimeout(label._hideTid);
        label._hideTid = setTimeout(()=>{ try{ label.style.opacity = "0"; }catch(_){} }, 900);
      }
      const __rtBattle3dRenderLobbyPanelV8Base = _rtBattle3dRenderLobbyPanel;
      _rtBattle3dRenderLobbyPanel = function(){
        __rtBattle3dRenderLobbyPanelV8Base.apply(this, arguments);
        _rtBattle3dV8PatchLobbyMapUi();
      };
      const __rtBattle3dEnsureSceneV8Base = _rtBattle3dEnsureScene;
      _rtBattle3dEnsureScene = function(){
        _rtBattle3dV8EnsureUiAddons();
        __rtBattle3dEnsureSceneV8Base.apply(this, arguments);
        const b = _rtBattle3dV8State();
        const rt = b.runtime || {};
        if (rt.renderer?.domElement) {
          rt.renderer.domElement.id = "glCanvas";
          rt.renderer.domElement.style.zIndex = "0";
        }
        if (rt.camera){
          rt.camera.near = 0.05;
          rt.camera.far = 180;
          rt.camera.updateProjectionMatrix?.();
        }
        _rtBattle3dV8ApplyMapNow();
      };
      const __rtBattle3dDestroySceneV8Base = _rtBattle3dDestroyScene;
      _rtBattle3dDestroyScene = function(){
        const b = _rtBattle3dV8State();
        try{
          const grp = b.p3?.map?.group;
          if (grp && b.runtime?.scene) b.runtime.scene.remove(grp);
          _rtBattle3dV8DisposeNode3d(grp);
        }catch(_){}
        b.p3.map = {};
        b.p3.lastMapHash = "";
        return __rtBattle3dDestroySceneV8Base.apply(this, arguments);
      };
      // Replace phase2 gimmick functions with componentized map-driven versions
      _rtBattle3dPhase2PatchGimmicksMeshes = function(){ _rtBattle3dV8ApplyMapNow(); };
      _rtBattle3dPhase2AnimateGimmicks = function(dt){ _rtBattle3dV8AnimateMapGimmicks(dt); };
      _rtBattle3dPhase2ApplyGimmickCollision = function(dt){ _rtBattle3dV8ApplyMapHazardCollision(dt); };
      const __rtBattle3dClampWorldV8Base = _rtBattle3dClampWorld;
      _rtBattle3dClampWorld = function(){
        try{ _rtBattle3dV8ClampWorld(); }catch(_){ __rtBattle3dClampWorldV8Base.apply(this, arguments); }
      };
      const __rtBattle3dMaybeTriggerWorldEventsV8Base = _rtBattle3dMaybeTriggerWorldEvents;
      _rtBattle3dMaybeTriggerWorldEvents = function(){
        try{ _rtBattle3dV8MaybeTriggerWorldEvents(); }catch(_){ __rtBattle3dMaybeTriggerWorldEventsV8Base.apply(this, arguments); }
      };
      const __rtBattle3dBuildPlayerMeshV8Base = _rtBattle3dBuildPlayerMesh;
      _rtBattle3dBuildPlayerMesh = function(colorHex){
        try{
          const mesh = __rtBattle3dBuildPlayerMeshV8Base.apply(this, arguments);
          if (mesh && mesh.scale) {
            mesh.visible = true;
            mesh.scale.set(Math.max(0.0001, Number(mesh.scale.x||1)), Math.max(0.0001, Number(mesh.scale.y||1)), Math.max(0.0001, Number(mesh.scale.z||1)));
          }
          return mesh;
        }catch(err){
          try{ console.error("[rt3d] player mesh fallback", err); }catch(_){}
          const THREE = window.THREE;
          if (!THREE) throw err;
          const g = new THREE.Group();
          const body = new THREE.Mesh(new THREE.BoxGeometry(0.55, 1.1, 0.45), new THREE.MeshStandardMaterial({ color: colorHex || 0x4f8cff, roughness:0.88, metalness:0.02 }));
          body.position.y = 0.55;
          g.add(body);
          g.visible = true;
          return g;
        }
      };
      const __rtBattle3dSyncRemoteMeshesV8Base = _rtBattle3dSyncRemoteMeshes;
      _rtBattle3dSyncRemoteMeshes = function(dt){
        __rtBattle3dSyncRemoteMeshesV8Base.apply(this, arguments);
        const b = _rtBattle3dV8State();
        for (const mesh of Object.values(b.remoteMeshes || {})){
          if (!mesh) continue;
          try{
            mesh.visible = true;
            if (mesh.scale){
              mesh.scale.x = Math.max(0.0001, Number(mesh.scale.x||1));
              mesh.scale.y = Math.max(0.0001, Number(mesh.scale.y||1));
              mesh.scale.z = Math.max(0.0001, Number(mesh.scale.z||1));
            }
          }catch(_){}
        }
      };
      const __rtBattle3dUpdateLocalMeshAndCameraV8Base = _rtBattle3dUpdateLocalMeshAndCamera;
      _rtBattle3dUpdateLocalMeshAndCamera = function(dt){
        const b = _rtBattle3dV8State();
        const rt = b.runtime || {};
        if (rt.camera && rt.localMesh && window.THREE){
          const THREE = window.THREE;
          const target = new THREE.Vector3(b.local.x, 0.95, b.local.z);
          const yaw = Number(b.p2.camYaw || 0);
          const pitch = Math.max(0.12, Math.min(0.9, Number(b.p2.camPitch || 0.35)));
          const first = String(b.p3.viewMode || "third") === "first";
          const dist = first ? 0.18 : 6.2;
          const side = Math.sin(yaw) * dist;
          const back = Math.cos(yaw) * dist;
          const desired = new THREE.Vector3(target.x + side, target.y + (first ? 0.6 : (2.1 + pitch * 4.0)), target.z + back);
          rt.camera.position.lerp(desired, Math.min(1, dt * 5.5));
          rt.camera.lookAt(first ? new THREE.Vector3(target.x + Math.sin(yaw) * 4, target.y + 0.6, target.z + Math.cos(yaw) * 4) : target);
          if (rt.localMesh) rt.localMesh.visible = !first;
          return;
        }
        return __rtBattle3dUpdateLocalMeshAndCameraV8Base.apply(this, arguments);
      };
      const __rtBattle3dBindGlobalHandlersV8Base = _rtBattle3dBindGlobalHandlers;
      _rtBattle3dBindGlobalHandlers = function(){
        if (!window.__rt3dV8InputGateBound){
          window.__rt3dV8InputGateBound = true;
          const markUi = (e) => {
            const t = e.target instanceof Element ? e.target : null;
            if (!t) return false;
            if (!t.closest || !t.closest("#rt3dOverlay")) return false;
            if (t.closest(_rtBattle3dV8UiSelector())){
              _rtBattle3dV8MarkUiMode(1200);
              return true;
            }
            return false;
          };
          const stopForUi = (e) => {
            if (!markUi(e)) return;
            try{ e.stopImmediatePropagation(); }catch(_){}
            try{ e.stopPropagation(); }catch(_){}
            _rtBattle3dV8ShowHitTarget(e);
          };
          ["pointerdown","pointermove","pointerup","touchstart","touchmove","touchend","wheel","click"].forEach((ev)=>{
            document.addEventListener(ev, stopForUi, { capture:true, passive: (ev === "wheel" ? false : true) });
          });
          // block WebGL drag/zoom temporarily while UI mode active
          const blockCanvasWhileUiMode = (e) => {
            if (!_rtBattle3dIsOpen()) return;
            const t = e.target instanceof Element ? e.target : null;
            if (!t || !t.closest || !t.closest("#rt3dCanvasWrap")) return;
            if (!_rtBattle3dV8UiModeActive()) return;
            try{ e.stopImmediatePropagation(); }catch(_){}
            try{ e.stopPropagation(); }catch(_){}
            if (e.cancelable) try{ e.preventDefault(); }catch(_){}
          };
          ["pointerdown","pointermove","wheel","touchstart","touchmove"].forEach((ev)=>{
            document.addEventListener(ev, blockCanvasWhileUiMode, { capture:true, passive:false });
          });
        }
        __rtBattle3dBindGlobalHandlersV8Base.apply(this, arguments);
        if (!window.__rt3dV8LobbyChangeBound){
          window.__rt3dV8LobbyChangeBound = true;
          document.addEventListener("change", (e) => {
            const t = e.target instanceof Element ? e.target : null;
            if (!t || !t.closest || !t.closest("#rt3dOverlay")) return;
            if (t.id === "rt3dLobbyMapSelect"){
              _rtBattle3dV8MarkUiMode(1000);
              const isHost = _rtBattleIsHost();
              if (!isHost){
                try{ uiToast(""); }catch(_){}
                return;
              }
              const mapId = asStr(t.value || "").toLowerCase();
              const safeMap = RT3D_MAP_IDS.includes(mapId) ? mapId : "bridge";
              const b = _rtBattle3dV8State();
              b.p3.mapId = safeMap;
              b.p3.mapSeed = Math.max(1, Date.now() % 2147483647);
              try{ console.log("[rt3d:map:set]", safeMap); }catch(_){}
              _rtBattleSafeSend({ type:"game3d:map", mapId:safeMap, mapSeed:b.p3.mapSeed });
              _rtBattle3dV8ApplyMapNow();
              try{ uiToast(""); }catch(_){}
              return;
            }
          }, true);
        }
      };
      const __rtBattle3dHandleActionV8Base = _rtBattle3dHandleAction;
      _rtBattle3dHandleAction = function(act, el){
        const b = _rtBattle3dV8State();
        if (act === "b3dViewToggle"){
          b.p3.viewMode = (String(b.p3.viewMode||"third")==="third") ? "first" : "third";
          try{ uiToast(b.p3.viewMode === "first" ? "" : ""); }catch(_){}
          return true;
        }
        if (act === "b3dLocatePlayers"){
          const rs = b.remoteStates && typeof b.remoteStates === "object" ? Object.values(b.remoteStates) : [];
          const first = rs[0];
          if (first){
            b.local.x = Number(first.x || 0) + 1.2;
            b.local.z = Number(first.z || 0) + 1.2;
            b.local.y = 0.9;
            _rtBattle3dPushToast("info", "");
            _rtBattle3dSendLocalState(true);
          } else {
            _rtBattle3dPushToast("info", "");
          }
          return true;
        }
        return __rtBattle3dHandleActionV8Base.apply(this, arguments);
      };
      const __rtBattle3dOpenV8Base = _rtBattle3dOpen;
      _rtBattle3dOpen = async function(){
        await __rtBattle3dOpenV8Base.apply(this, arguments);
        const b = _rtBattle3dV8State();
        b.p3.inputMode = "";
        b.p3.uiModeUntil = 0;
        _rtBattle3dV8EnsureUiAddons();
        _rtBattle3dV8PatchLobbyMapUi();
        _rtBattle3dV8ApplyMapNow();
      };
      const __rtBattleHandleMessageV8Base = _rtBattleHandleMessage;
      _rtBattleHandleMessage = function(msg){
        __rtBattleHandleMessageV8Base.apply(this, arguments);
        const type = String(msg?.type || "").toLowerCase();
        const b = _rtBattle3dV8State();
        if (type === "room:snapshot" || type === "state" || type === "game3d:world"){
          const g3 = (msg?.game3d && typeof msg.game3d === "object") ? msg.game3d : (msg?.state?.game3d && typeof msg.state.game3d === "object" ? msg.state.game3d : null);
          if (g3){
            const nextMapId = asStr(g3.mapId || b.p3.mapId || "bridge").toLowerCase() || "bridge";
            const nextMapSeed = Math.max(1, Number(g3.mapSeed || b.p3.mapSeed || 1));
            const changed = (nextMapId !== b.p3.mapId) || (nextMapSeed !== b.p3.mapSeed);
            b.p3.mapId = nextMapId;
            b.p3.mapSeed = nextMapSeed;
            if (changed && _rtBattle3dIsOpen()){
              _rtBattle3dV8ApplyMapNow();
              _rtBattle3dPushToast("info", `: ${RT3D_MAP_LABELS[nextMapId] || nextMapId}`);
            }
          }
          _rtBattle3dV8PatchLobbyMapUi();
          _rtBattle3dV8UpdateDebugHud();
        }
      };
      const __rtBattle3dTickV8Base = _rtBattle3dTick;
      _rtBattle3dTick = function(tsNow){
        __rtBattle3dTickV8Base.apply(this, arguments);
        if (!_rtBattle3dIsOpen()) return;
        const b = _rtBattle3dV8State();
        if (b.p3.inputMode === "ui" && Number(b.p3.uiModeUntil || 0) <= Date.now()){
          b.p3.inputMode = "";
          b.p3.uiModeUntil = 0;
        }
        _rtBattle3dV8UpdateDebugHud();
      };
      // extra style adjustments for touch/hover stability and unified controls
      (function _rtBattle3dV8ExtraStyles(){
        if (document.getElementById("rt3dV8Styles")) return;
        const s = document.createElement("style");
        s.id = "rt3dV8Styles";
        s.textContent = `
          #rt3dOverlay #uiRoot{pointer-events:none;}
          #rt3dOverlay #uiRoot .btn,
          #rt3dOverlay #uiRoot button,
          #rt3dOverlay #uiRoot input,
          #rt3dOverlay #uiRoot select,
          #rt3dOverlay #uiRoot .b3d-lobby-card,
          #rt3dOverlay #uiRoot .b3d-quiz,
          #rt3dOverlay #uiRoot .b3d-result-card,
          #rt3dOverlay #uiRoot .b3d-chatdock,
          #rt3dOverlay #uiRoot .b3d-score-panel{pointer-events:auto;}
          #rt3dOverlay #glCanvas{position:absolute; inset:0; z-index:0; touch-action:none;}
          #rt3dOverlay #uiRoot .b3d-player-list,
          #rt3dOverlay #uiRoot .b3d-chatdock-body,
          #rt3dOverlay #uiRoot .b3d-score-panel,
          #rt3dOverlay #uiRoot .b3d-result-list{max-height:220px; overflow:auto; -webkit-overflow-scrolling:touch; touch-action:pan-y;}
          #rt3dOverlay .b3d-select{appearance:none; background-image:linear-gradient(45deg,transparent 50%, currentColor 50%),linear-gradient(135deg,currentColor 50%, transparent 50%); background-position:calc(100% - 18px) 48%, calc(100% - 12px) 48%; background-size:6px 6px, 6px 6px; background-repeat:no-repeat; padding-right:30px;}
          @media (hover:hover){
            #rt3dOverlay .btn:hover,
            #rt3dOverlay .b3d-seg-btn:hover,
            #rt3dOverlay .b3d-mbtn:hover,
            #rt3dOverlay .b3d-chat-toggle:hover,
            #rt3dOverlay .b3d-camreset:hover{transform:none !important; filter:brightness(1.02); box-shadow:0 8px 16px rgba(0,0,0,.08);}
          }
        `;
        document.head.appendChild(s);
      })();

      function _lockViewportZoom(){
        if (window.__vqZoomLocked) return;
        window.__vqZoomLocked = true;
        const prevent = (e) => {
          try{ e.preventDefault(); }catch{}
        };
        document.addEventListener("touchstart", (e) => {
          if (e.touches && e.touches.length > 1) prevent(e);
        }, { passive: false });
        document.addEventListener("gesturestart", prevent, { passive: false });
        document.addEventListener("gesturechange", prevent, { passive: false });
        document.addEventListener("gestureend", prevent, { passive: false });
        document.addEventListener("wheel", (e) => {
          if (e.ctrlKey) prevent(e);
        }, { passive: false });
        document.addEventListener("touchmove", (e) => {
          if (e.touches && e.touches.length > 1) prevent(e);
        }, { passive: false });
        document.addEventListener("dblclick", prevent, { passive: false });
      }
window.addEventListener("DOMContentLoaded", () => {
  _lockViewportZoom();
  initMenu();
});
      if (document.readyState === "complete" || document.readyState === "interactive"){
        setTimeout(() => {
          _lockViewportZoom();
          initMenu();
        }, 0);
      }

})();
  
/* ============================================================
   SERVER (Cloudflare Workers + KV) - reference implementation
   ------------------------------------------------------------
   This client expects:
     POST  /api/share/create
     GET   /api/share/get?code=ABC123
     GET   /s/ABC123
   and CORS: Access-Control-Allow-Origin: *

   1) wrangler.toml (example)
   ------------------------------------------------------------
   name = "word-practice-share"
   main = "src/worker.js"
   compatibility_date = "2026-02-10"

   [[kv_namespaces]]
   binding = "SHAREKV"
   id = "YOUR_KV_ID"

   2) src/worker.js (example)
   ------------------------------------------------------------
   export default {
     async fetch(request, env) {
       const url = new URL(request.url);
       const path = url.pathname;

       // CORS
       if (request.method === "OPTIONS") {
         return new Response(null, {
           status: 204,
           headers: {
             "Access-Control-Allow-Origin": "*",
             "Access-Control-Allow-Methods": "GET,POST,OPTIONS",
             "Access-Control-Allow-Headers": "Content-Type",
             "Access-Control-Max-Age": "86400",
           },
         });
       }
       const cors = { "Access-Control-Allow-Origin": "*" };

       const json = (obj, status=200) => new Response(JSON.stringify(obj), {
         status,
         headers: { "Content-Type":"application/json; charset=utf-8", ...cors }
       });

       const html = (body, status=200) => new Response(body, {
         status,
         headers: { "Content-Type":"text/html; charset=utf-8", ...cors }
       });

       const randomCode = () => {
         const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
         let out = "";
         for (let i=0;i<6;i++) out += chars[Math.floor(Math.random()*chars.length)];
         return out;
       };

       if (path === "/api/share/create" && request.method === "POST") {
         const ct = request.headers.get("content-type") || "";
         if (!ct.includes("application/json")) return json({message:"JSON only"}, 400);
         const body = await request.json().catch(()=>null);
         if (!body || body.schemaVersion !== 1 || !body.preset) return json({message:"bad payload"}, 400);

         const payload = JSON.stringify({
           schemaVersion: 1,
           createdAt: Date.now(),
           expiresAt: Date.now() + 7*24*60*60*1000,
           preset: body.preset
         });

         if (payload.length > 200*1024) return json({message:"payload too large"}, 413);

         // generate non-colliding code
         let code = "";
         for (let i=0;i<12;i++){
           code = randomCode();
           const k = "SHARE:" + code;
           const exists = await env.SHAREKV.get(k);
           if (!exists){
             await env.SHAREKV.put(k, payload, { expirationTtl: 7*24*60*60 });
             break;
           }
           code = "";
         }
         if (!code) return json({message:"failed to allocate code"}, 500);

         const shareUrl = `${url.origin}/s/${code}`;
         return json({ code, shareUrl, expiresAt: Date.now() + 7*24*60*60*1000 }, 200);
       }

       if (path === "/api/share/get" && request.method === "GET") {
         const code = (url.searchParams.get("code") || "").toUpperCase();
         if (!/^[A-Z0-9]{6}$/.test(code)) return json({message:"bad code"}, 400);
         const k = "SHARE:" + code;
         const raw = await env.SHAREKV.get(k);
         if (!raw) return json({message:"not found or expired"}, 404);
         const data = JSON.parse(raw);
         return json({ preset: data.preset, schemaVersion: 1, createdAt: data.createdAt, expiresAt: data.expiresAt }, 200);
       }

       const sMatch = path.match(/^\/s\/([A-Z0-9]{6})$/i);
       if (sMatch){
         const code = sMatch[1].toUpperCase();
         const page = `<!doctype html>
<html lang="ja"><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>Preset Share</title>
<style>
  body{font-family:system-ui,-apple-system,BlinkMacSystemFont,sans-serif;background:#f5f5f7;color:#1d1d1f;margin:0;display:grid;place-items:center;min-height:100vh}
  .card{background:#f4f5f9;border-radius:18px;box-shadow:0 18px 45px rgba(0,0,0,.12);padding:24px 22px;max-width:420px;width:calc(100% - 40px);text-align:center}
  .code{font-weight:800;font-size:44px;letter-spacing:.14em;font-variant-numeric:tabular-nums;margin:10px 0 6px}
  .btn{appearance:none;border:0;background:#1f2a44;color:#f5f5f7;border-radius:12px;padding:10px 14px;font-weight:650;cursor:pointer}
  .note{color:#6e6e73;font-size:12px;line-height:1.6}
</style>
<div class="card">
  <div class="note"></div>
  <div class="code" id="c">${code}</div>
  <button class="btn" id="copy"></button>
  <div class="note" style="margin-top:12px"> </div>
</div>
<script>
  const c = document.getElementById('c').textContent;
  document.getElementById('copy').onclick = async () => {
    try{ await navigator.clipboard.writeText(c); }catch{
      const ta=document.createElement('textarea');ta.value=c;document.body.appendChild(ta);ta.select();document.execCommand('copy');ta.remove();
    }
  };
<\/script>`;
         return html(page, 200);
       }

       return new Response("Not found", { status:404, headers:cors });
     }
   };
   ============================================================ */

</script>
</body>
</html>
